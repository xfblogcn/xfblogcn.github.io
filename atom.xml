<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep</title>
  
  <subtitle>Hexo theme keep quick starter</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-01-17T06:25:19.170Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/01/17/Untitled/"/>
    <id>http://example.com/2025/01/17/Untitled/</id>
    <published>2025-01-17T06:24:54.469Z</published>
    <updated>2025-01-17T06:25:19.170Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://drive.google.com/file/d/1M04QjhvYSs8AYrN7EZQ47l6kjtIEpjG6/view?usp=drive_link" >https://drive.google.com/file/d/1M04QjhvYSs8AYrN7EZQ47l6kjtIEpjG6/view?usp=drive_link<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://drive.google.com/file/d/1GNcs9dPR8bp1Cg5y-f3m7lfdyFYjWIwU/view?usp=drive_link" >https://drive.google.com/file/d/1GNcs9dPR8bp1Cg5y-f3m7lfdyFYjWIwU/view?usp=drive_link<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://drive.google.com/file/d/1M04QjhvYSs8AYrN7EZQ47l6kjtIEpjG6/view?usp=drive_link&quot; &gt;https://drive.google.com/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS逆向_5_AST解混淆</title>
    <link href="http://example.com/2024/09/01/JS%E9%80%86%E5%90%91_5_AST%E8%A7%A3%E6%B7%B7%E6%B7%86/"/>
    <id>http://example.com/2024/09/01/JS%E9%80%86%E5%90%91_5_AST%E8%A7%A3%E6%B7%B7%E6%B7%86/</id>
    <published>2024-08-31T16:00:00.000Z</published>
    <updated>2024-12-09T05:43:55.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、AST技术专题"><a href="#一、AST技术专题" class="headerlink" title="一、AST技术专题"></a>一、AST技术专题</h2><blockquote><p><strong>AST 抽象语法树（Abstract Syntax Tree）：</strong>AST 是一种数据结构，是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构，如语句、表达式、变量声明等。语法树不是某一种编程语言独有的，几乎所有编程语言都有语法树，<strong>既然是一棵树，那一定存在节点，或遍历相关的概念</strong>。</p><ul><li><strong>安装 babel 库：</strong><code>npm install @babel/core --save-dev</code>（全局安装可能会有无法导入库的情况）</li><li><strong>将源代码解析为 AST 在线网站：</strong><a class="link"   href="https://astexplorer.net/"  target="_blank" rel="noopener">AST explorer<i class="fas fa-external-link-alt"></i></a>（解释器选择 @babel&#x2F;parser）</li><li><strong>小技巧：</strong>在 AST explorer 中，点击左侧某段代码的中间，对应右侧的 AST 树片段就会被标黄</li></ul><p><strong>在编译原理中，编译器转换代码要经过三个步骤：词法分析 &#x3D;&gt; 语法分析（构建 AST 语法树） &#x3D;&gt; 代码生成</strong></p><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1716090018-9dbb06e659303be.png"                                         ></blockquote><h3 id="0-AST-脱混淆思路"><a href="#0-AST-脱混淆思路" class="headerlink" title="0. AST -&gt; 脱混淆思路"></a>0. AST -&gt; 脱混淆思路</h3><blockquote><p><strong>匹配括号内全为字面量实参的正则表达式：</strong></p><ul><li>匹配多个：<code>\(\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\2)(\s*,\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\5))*\s*\)</code></li><li>匹配两个：<code>\(\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\2)\s*,\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\4)\s*\)</code></li><li>指定函数名匹配多个：<code>myFunction\s*\(\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\2)(\s*,\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\5))*\s*\)</code></li></ul></blockquote><ul><li><strong>数组还原思路：</strong>直接复制网页原始数组 <code>copy(_$UH.map(String))</code> 在本地通过 ast 遍历还原</li><li><strong>通用思路：</strong><ol><li><strong><span style="color:red;">拿到一段代码，先进行预处理，然后观察其整体结构，不要盲目还原，如果需要还原的函数调用，其里面还嵌套的有函数调用，那就应该先还原里面那层的</span></strong></li><li><strong>嵌套的节点还原，优先采用 exit 方式遍历：</strong><code>a = b = c = d;</code>、<code>(n = (n = (n = (n = n[]())</code>，如果此时插件中还要遍历其他类型节点进行处理，而这个处理结果又可以继续生成指定特征的还原，那么这个遍历<strong>也要用 exit 方式</strong>，因为<strong>要保证下面的遍历比上面的遍历晚退出</strong>（<strong>注意如果同时要在遍历过程中遍历处理其他类型节点，那么最好不要将其分开为多个插件，因为在同一个插件中，是会无限递归遍历此类型的节点，包括刚处理过的；而将插件分开写，就会导致每个插件分开作用，插件1遍历一次处理好了，然后插件2遍历插件1处理好的结果并再次处理，再然后就结束了</strong>，同时要注意配合 <code>scope.crawl()</code> 使用）</li><li><strong><span style="color:red;">在一个作用域内继续获取元素的 banding，就要使用当前 banding.path.scope.getBinding() 去获取</span></strong></li><li><strong>每一次调用插件还原后，都应该思考当前节点被还原后，其定义或其使用过的对象是否还有存在的必要</strong>，没有则应该立即删除，**<span style="color:red;">尽管删不干净同类型的，但至少应该清除与此次还原相关的垃圾代码</span><strong>，同类型的垃圾代码留给</strong>最后一次调用垃圾代码删除插件清除即可**，目的是为了此次还原不影响后续插件的调用</li><li><strong>在 obj 对象 value 实现之前，既要保证对象属性中的函数只有一条 return 语句，还要保证属性非函数的均为子面量，否则无法还原</strong>，所以需要调用一次折叠子面量或表达式的插件，并且在对象还原之后又会出现一些子面量，此时应该<strong>再次调用一次折叠子面量或表达式的插件</strong></li><li><strong><span style="color:red;">AST 删除的时候有个特点，就是其绑定相关的参数都要重新解析并删除一次后才会更新，即需要删除两次</span></strong></li></ol></li><li><strong>通用法则：</strong><ol><li><strong>一个插件中不允许同时遍历两种相同类型的节点，即使遍历内容不一样也不行，因为后者会覆盖前者</strong></li><li><strong>实参全部为字面量的函数才可还原</strong>，一定要判断实参是否全部为子面量，且还原后函数定义应该删除掉</li><li>在还原调用表达式时，<strong>需要先挑选一个还原</strong>，判断其需要哪些环境代码，将这些环境代码放入插件之前，再<strong>收集所有需要还原的调用表达式对应的函数定义</strong>，并加载执行代码，统一还原（另一种情况看下面）</li><li><strong>当插件无作用的时候，可以尝试重新解析一次 ast 树</strong></li><li><strong>在整个 ast 解混淆大致结束时，并且调用垃圾代码插件后，剩余的冗余代码，可自行判断手动删除更快</strong></li></ol></li><li><strong>注意细节：</strong><ol><li><strong><span style="color:red;">在 for 循环中，变量定义会被记录为改变一次；同时变量赋值的改变次数就等于循环次数</span></strong></li><li><strong><span style="color:red;">在 binding 中，对数组或对象进行元素赋值的操作也算引用 <code>arr[1] = 9</code>、<code>e[&#39;age&#39;]=18</code>、<code>++arr[1]</code></span></strong></li><li><strong><span style="color:red;">在一个作用域中，特别是函数中，若函数中存在与函数名同名的标识符（包括形参），则需要通过其父 path 获取当前节点的 binding，否则可能会获取错对象的绑定</span></strong></li><li>在编写插件中，<strong>需要通过 if 判断过滤出不需要的节点，这很重要</strong>，包括判读其父节点、子节点、参数等</li><li><strong>type.ExpressionStatement()：</strong>用于创建语句节点，通常用做<strong>包裹创建</strong>，目的是在语句结尾加上分号</li><li><strong>涉及节点、path 更改或赋值等操作时：</strong>被赋值的对象一定不能是最具体的那一层，而是其上一层或几层</li><li><strong>遍历赋值语句通常都需要过滤一下父 path 类型，因为不能改变在某些语句的判断条件中的赋值语句</strong></li><li><strong>object 对象合并：</strong>构造对象属性 <code>types.objectProperty(key, value)</code> ，插入 <code>properties.push()</code></li><li><strong>错误示范：</strong><code>let &#123; switchNode, breakNode &#125; = body.body;</code> 此时 body.body 是个<strong>数组</strong>，要中括号取</li><li><strong>在 for 循环中过滤节点应该使用 continue 或 break</strong>，不能使用 return，return 则直接结束遍历了</li></ol></li><li><strong>另一种还原方式（代码整体被自执行函数包裹，且无传参）：</strong><ol><li><strong>核心思想：想方设法拿到需要还原的函数的调用结果</strong></li><li><strong>核心步骤：</strong>复制一份 encode 文件为 change，<strong>去除外层自执行函数包裹并替换为 try-catch 语句</strong>，不仅可以让程序正常运行，还可以<strong>加大变量作用域的范围</strong>；如果此时可以拿到函数调用值，则表示可以还原了</li><li><strong>引入文件：</strong><code>let decodeObCode = files.readFileSync(&quot;change.js&quot;, &#123; encoding: &quot;utf-8&quot; &#125;);</code>，并通过 eval 执行文件</li></ol></li></ul><h3 id="1-代码混淆原理"><a href="#1-代码混淆原理" class="headerlink" title="1. 代码混淆原理"></a>1. 代码混淆原理</h3><ul><li><strong>为混淆做准备：</strong><ol><li>利用<strong>对象属性的两种访问方式</strong>，将<strong>打点调用方式</strong>转换成<strong>中括号调用方式</strong>，即 <code>p.name =&gt; p[&#39;name&#39;]</code></li><li>js 中很多内置对象都是 window 对象的属性，例 <code>Date() =&gt; window.Date() =&gt; window[&#39;Date&#39;]()</code></li></ol></li><li><strong>基本混淆处理：</strong><ol><li><strong>十六进制编码：</strong>将字符串循环拼接 <code>&quot;\\x&quot; + code.charCodeAt(i).toString(16)</code> 转换为十六进制形式，但是一般不大面积使用，因为还原简单，常用于变量名的转换，<strong>在 js 中变量名无法进行加密等操作</strong></li><li><strong>unicode 编码：</strong><code>&quot;\\u&quot; + (&quot;0000&quot; + code.charCodeAt(i).toString(16)).substr(-4)</code>，unicode 编码不仅仅适用于变量，<strong>还适用于 js 中的方法名等标识符</strong>，但也存在还原简单的问题</li><li><strong>转 ASCII 码数组：</strong>将字符串循环通过 str.charCodeAt(i) 方法转换为 ascii 数组，在使用时直接配合方法 String.fromCharCode(ascii_array) 代替字符串。这种方式还适用于<strong>混淆整句代码</strong>，配合 eval 执行代码</li><li><strong>字符串常量加密：</strong>先把字符串加密得到密文，然后在使用之前，调用对应的解密函数去解密，得到明文。例 Base64 编码后，通过 atob 解码，但在实际混淆应用中，atob 这种标识符一定要处理为没有语义的</li><li><strong>算法里的数值常量加密：</strong>在算法加密过程中，大致已经知道是什么算法加密，但是无法定位，则可以直接搜索算法中的常量，例如 md5 中的常量 0x67452301、0xefcdab89 等，达到定位代码关键位置的目的。而最常见的则是<strong>利用位异或的特性加密，例如 a^b&#x3D;c，那么 c^b&#x3D;a，此时 b 相当于加密密钥</strong>，网易常见</li></ol></li><li><strong>增加 js 逆向者的工作量：</strong><ol><li><strong>数组混淆：</strong>将所有的字符串都提取到一个数组中，然后在需要引用字符串的地方，全部都以数组下标的方式去访问数组成员。这归功于 js 语法的灵活，同一个数组可以存放任意类型的数据，包括函数。例如将 <code>&quot;&quot;[&#39;constructor&#39;][&#39;fromCharCode&#39;]</code> 放入数组，这里 <strong>“”[‘constructor’] 获取构造函数等同于 String</strong></li><li><strong>数组乱序：</strong>将数组成员顺序通过一定逻辑打乱，同时内置一段对应的还原顺序逻辑代码，确保引用正确</li><li><strong>花指令：</strong>添加一些没有意义却可以混淆视听的代码，瞬间膨胀代码量，是花指令的核心。常见的有二项式相加转函数的花指令、函数调用表达式的花指令等，并且都可以进行<strong>多级嵌套</strong></li><li><strong>jsfuck：</strong>基于 js 是弱类型语言，存在<strong>隐式转换</strong>的特点，将 js 代码转换成只用 6 个字符 ( ) + ! [ ] 就可以表示的代码，同时<strong>在 js 中只有 7 种值 false、undefined、null、0、-0、NaN、”” 为假</strong>，其余均为真。例 <code>(!+[]+!![]+[])</code> 等于 2，其中 +[] 会转换为字符串 +”” ，再由字符串转换为 0，则 !+[] 为 true（由于控制台可以直接还原，所以 jsfuck 应用较少）</li></ol></li><li><strong>代码执行流程的防护原理：</strong><ol><li><strong>流程平坦化：</strong>使用 switch case 语句实现，因为 case 块是平级的，调换 case 块的前后顺序，并不影响代码原先的执行逻辑。通过套入死循环，定义一个记录了真实执行顺序的文本字符串，将文本串分割为数组，作为 switch 语句的条件，并通过计数器每次递增，当索引越界时无匹配 case 则直接 break 跳出结束</li><li><strong>特点：</strong>case 的条件不仅仅是字符串，还可以是对象，数组等类型。同时 switch 混淆的执行顺序并不一定要通过文本串分割循环数组的方式实现，还可以通过在 case 块中修改 switch 条件，从而控制执行顺序</li><li><strong>逗号表达式：</strong>逗号表达式会执行都好前面所有的语句，但只返回最后一个逗号的表达式的值，这其中可以添加很多无用的花指令来混淆视听</li></ol></li><li><strong>其他代码防护方案：</strong><ol><li><strong>eval 加密：</strong>原理是通过一个自执行的匿名函数返回一段字符串，再用 eval 执行这段字符串，使其效果等同于原代码。匿名函数可以看作解密函数，eval 解密就是直接去掉 eval，执行剩余的代码，得到原代码</li><li><strong>内存爆破：</strong>在代码中加入死代码，正常情况下这段代码不执行，当检测到函数被格式化或者被 Hook 时，就跳转到这段代码执行，运行直到内存溢出。例如 for 循环使用数组长度为条件，无限往数组中添加成员</li><li><strong>检查代码是否格式化：</strong>通过正则表达式匹配某个函数的 toString() 来判断代码是否被格式化</li></ol></li></ul><h3 id="2-语法树节点名词"><a href="#2-语法树节点名词" class="headerlink" title="2. 语法树节点名词"></a>2. 语法树节点名词</h3><ul><li>Program（程序主体）：整段代码的主体</li><li>Identifier（标识符）：标识，例如声明变量时 var obj &#x3D; 5 中的 obj</li><li>VariableDeclarator（变量声明符）：对应一个具体变量的定义</li><li>Property（属性）</li><li>Literal（字面量）：<ul><li>BooleanLiteral（布尔型字面量）：布尔值，例如 true false</li><li>NumericLiteral（数字型字面量）：数字，例如 100</li><li>StringLiteral（字符型字面量）：字符串，例如 “vansenb”</li></ul></li><li>Declaration（声明）：<ul><li>VariableDeclaration（变量声明）：声明一个变量，例如 var let const</li><li>FunctionDeclaration（函数声明）：声明一个函数，例如 function</li></ul></li><li>Statement（语句）：<ul><li>ExpressionStatement（表达式语句）：通常是调用一个函数，例如 console.log()</li><li>BlockStatement（块语句）：包裹在 {} 块内的代码，例如 if (condition){var a &#x3D; 1;}</li><li>BreakStatement（中断语句）：通常指 break</li><li>ContinueStatement（持续语句）：通常指 continue</li><li>ReturnStatement（返回语句）：通常指 return</li><li>SwitchStatement（Switch 语句）通常指 Switch Case 语句中的 Switch</li><li><strong>SwitchCase（Case 语句）：</strong>通常指 Switch 语句中的 Case</li><li>IfStatement（If 控制流语句）：控制流语句，通常指 if(condition){}else{}</li></ul></li><li>Expression（表达式）：<ul><li>CallExpression（调用表达式）：通常指调用一个函数，例如 console.log()</li><li>BinaryExpression（二进制表达式）：通常指运算，例如 1+2</li><li>MemberExpression（成员表达式）：通常指调用对象的成员，例如 console 对象的 log 成员</li><li>ArrayExpression（数组表达式）：通常指一个数组，例如 [1, 3, 5]</li><li>NewExpression（New 表达式）：通常指使用 New 关键词</li><li>AssignmentExpression（赋值表达式）：通常指将函数的返回值赋值给变量</li><li>UpdateExpression（更新表达式）：通常指更新成员值，例如 i++</li></ul></li></ul><h3 id="3-bable"><a href="#3-bable" class="headerlink" title="3. bable"></a>3. bable</h3><blockquote><p><strong>JavaScirpt 的 Babel 编译器：</strong></p><ol><li><strong>@babel&#x2F;core：</strong>Babel 编译器本身，提供了 babel 的编译 API</li><li><strong>@babel&#x2F;parser：</strong>将 JavaScript 代码解析成 AST 语法树</li><li><strong>@babel&#x2F;traverse：</strong>用于遍历、修改 AST 语法树的各个节点</li><li><strong>@babel&#x2F;types：</strong>用于判断、验证节点的类型、构建新 AST 节点等</li><li><strong>@babel&#x2F;generator：</strong>将 AST 还原成 JavaScript 代码</li></ol></blockquote><ul><li><strong>Bable 中的组件：</strong><ol><li><strong>parser 组件：</strong>parser 的 parse 方法的第 2 个参数接受一个对象，默认值为 <code>&#123;sourceType: &quot;script&quot;&#125;</code><ul><li>当解析的 js 代码中含有 export 等 ES6 语法时，需要指定 sourceType 为 module 值，否则抛出异常</li></ul></li><li><strong>generator 组件：</strong>generator 方法的第 2 个参数接受一个对象，可以自定义设置输出结果的格式<ul><li><code>&#123;retainLines: false, comments: true, compact: true&#125;</code> 均为默认值</li><li>retainLines：表示是否使用与源代码相同的行号，即否是格式化</li><li>comments：表示是否保留注释</li><li>compact：表示是否压缩代码，压缩程度正常，minified 表示压缩程度高，concise表示压缩程度低</li></ul></li><li><strong>traverse 组件与 visitor 对象：</strong><ul><li><strong>visitor 对象：</strong>用于过滤节点的一个对象，配合 traverse 组件一起使用 <strong><code>traverse(ast, visitor);</code></strong></li><li><strong>enter、exit 函数：</strong>在遍历节点过程中，一个节点会有两次访问机会，即 enter 进入节点时（<strong>从整体到部分遍历，大 &#x3D;&gt; 小，默认</strong>）与 exit 退出节点时（<strong>从部分到整体遍历，小 &#x3D;&gt; 大</strong>）（<strong>深度优先</strong>）</li><li><strong>把一个函数应用到多个节点：</strong>使用 | 分隔，<code>&quot;FunctionExpression|BinaryExpression&quot;(path)</code></li><li><strong>把多个函数应用到一个节点：</strong>把多个函数的数组赋值给 enter 对象，<code>enter: [func1, func2]</code></li><li><strong>不一定从头，可以从任意节点向下开始遍历：</strong><code>path.traverse(visitor对象, 传入的参数对象)</code></li></ul></li><li><strong>types 组件：</strong><ul><li><strong>判断节点类型：</strong><code>t.isIdentifier(path.node, &#123;name: &#39;a&#39;&#125;)</code> 判断 node 的 type 是否是标识符，且名称是否为 a，等价于 <code>path.isIdentifier(&#123;name: &#39;a&#39;&#125;)</code>，但这判断的是 path 下的 type 类型</li><li><strong>断言式的判断节点类型：</strong>当节点不符合要求时，会抛出异常而不是返回布尔值 <code>t.assertIdentifier</code></li><li><strong>主要用于构建新的 AST 节点：</strong>树的结构对应代码的实现从下至上，代码的实现对应目标代码由外向内</li><li><strong>valueToNode 方法：</strong>生成各种类型对象，除了原始类型 undefined、null、string、number、boolean，还可以是对象类型 RegExp、ReadonlyArray、object，可以接受数组，传入什么生成什么</li></ul></li></ol></li><li><strong>定义 visitor 对象的三种方式（常用第 2 种）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const visitor1 = &#123;</span><br><span class="line">    FunctionExpression: function (path) &#123;</span><br><span class="line">        console.log(&quot;xfblog&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const visitor2 = &#123;</span><br><span class="line">    &quot;FunctionExpression|BinaryExpression&quot;(path) &#123;</span><br><span class="line">        console.log(&quot;xfblog&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const visitor3 = &#123;</span><br><span class="line">    FunctionExpression: &#123;</span><br><span class="line">        // enter(path) &#123;</span><br><span class="line">        //     console.log(&quot;xfblog&quot;);</span><br><span class="line">        // &#125;</span><br><span class="line">        enter: [</span><br><span class="line">            function (path) &#123;</span><br><span class="line">                console.log(&quot;func1&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            function (path) &#123;</span><br><span class="line">                console.log(&quot;func2&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>利用 types 组件构建新的 AST 节点：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 目标代码：</span><br><span class="line">// let obj = &#123;</span><br><span class="line">//     name: &quot;hhhh&quot;,</span><br><span class="line">//     add: function (a, b) &#123;</span><br><span class="line">//         return a + b + 1000;</span><br><span class="line">//     &#125;,</span><br><span class="line">//     eee: function (a, b) &#123;</span><br><span class="line">//         return null</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const t = require(&quot;@babel/types&quot;);</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line"></span><br><span class="line">const jscode = fs.readFileSync(&quot;./demo.js&quot;, &#123;</span><br><span class="line">    encoding: &quot;utf-8&quot;</span><br><span class="line">&#125;);</span><br><span class="line">let ast = parser.parse(jscode);</span><br><span class="line"></span><br><span class="line">let a = t.identifier(&#x27;a&#x27;);</span><br><span class="line">let b = t.identifier(&#x27;b&#x27;);</span><br><span class="line">let binExpr2 = t.binaryExpression(&quot;+&quot;, a, b);</span><br><span class="line">let binExpr3 = t.binaryExpression(&quot;*&quot;, a, b);</span><br><span class="line">let retSta2 = t.returnStatement(t.binaryExpression(&quot;+&quot;, binExpr2, t.numericLiteral(1000)));</span><br><span class="line">let retSta3 = t.returnStatement(t.binaryExpression(&quot;+&quot;, binExpr3, t.numericLiteral(1000)));</span><br><span class="line">let bloSta2 = t.blockStatement([retSta2]);</span><br><span class="line">let bloSta3 = t.blockStatement([retSta3]);</span><br><span class="line">let funcExpr2 = t.functionExpression(null, [a, b], bloSta2);</span><br><span class="line">let funcExpr3 = t.functionExpression(null, [a, b], bloSta3);</span><br><span class="line">let objProp1 = t.objectProperty(t.identifier(&#x27;name&#x27;), t.stringLiteral(&#x27;xiaojianbang&#x27;));</span><br><span class="line">let objProp2 = t.objectProperty(t.identifier(&#x27;add&#x27;), funcExpr2);</span><br><span class="line">let objProp3 = t.objectProperty(t.identifier(&#x27;mul&#x27;), funcExpr3);</span><br><span class="line">let objExpr = t.objectExpression([objProp1, objProp2, objProp3]);</span><br><span class="line">let varDec = t.variableDeclarator(t.identifier(&#x27;obj&#x27;), objExpr);</span><br><span class="line">let loaclAst = t.variableDeclaration(&#x27;let&#x27;, [varDec]);</span><br><span class="line">let code = generator(loaclAst).code;</span><br><span class="line">console.log(code);</span><br><span class="line"></span><br><span class="line">// code = generator(ast).code;</span><br><span class="line">fs.writeFile(&#x27;./demoNew.js&#x27;, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><h3 id="4-path"><a href="#4-path" class="headerlink" title="4. path"></a>4. path</h3><blockquote><p><strong>path 与 node 的区别：</strong>path 是在一开始 parser.parse 解析时就生成的，node 节点是被包含在 path 中的</p><p><strong>注意：在通过 type 组件构建新的 AST 节点时，生成的新 node 是没有 path 的。所以在对节点进行增删改后，需要先将 AST 转成代码，再重新 parser.parse 解析为 AST 语法树，此时 node 节点才会有 path 对象</strong></p><p><strong><span style="color:red;">重点：凡是涉及到节点的操作，都推荐使用 path 对象的方法，因为只有这样 Babel 才会更新 path 对象。但有时避免不了使用其他方法，所以最好的办法就是在修改之前，先将 AST 转成代码，再将代码解析为 AST</span></strong></p></blockquote><ul><li><strong>path.skip()：</strong>只跳过当前节点的子节点遍历，遍历器会继续处理当前节点之后的其他节点</li><li><strong>path.stop()：</strong>停止整个遍历过程，不再处理任何节点</li><li>**<span style="color:red;">path.evaluate()：</span>**用于评估一个表达式并返回其计算结果，返回一个对象，包含以下属性<ul><li><strong>confident：</strong>一个布尔值，表示 Babel 是否确信可以确定该表达式的值</li><li><strong>value：</strong>表达式的值（如果 confident 为 true），否则为 undefined</li></ul></li><li><strong><span style="color:red;">path.evaluateTruthy()：</span><strong>专门用于评估一个表达式的真假性，</strong>直接返回一个布尔值或 undefined 无法确定</strong></li><li><strong>判断 path 类型：</strong>path 的 type 属性通常与 node 中的 type 属性一致，用于判断自身类型，用法与 types 组件差不多，例 <code>path.get(&#39;left&#39;).isIdentifier()</code> 返回布尔值</li><li><strong>节点转代码：</strong>将 AST（部分）节点转成代码，<code>path.toString()</code>、<code>path + &#39;&#39;</code>，与 generator 组件作用相同</li><li><strong>替换节点属性：</strong>将标识符改为 x，<code>path.node.left = t.identifier(&quot;x&quot;)</code>（**这方式不会更新 path 对象，可以使用这种方式替换 <code>path.get(&#39;left&#39;).replaceWith(types.identifier(&#39;x&#39;))</code>**）</li><li><strong>path 的属性：</strong><ul><li>node：表示当前 path 下的 node 节点</li><li>parent：用于获取当前 path 下的父 node，多用于判断节点类型</li><li>parentPath：用于获取当前 path 下的父 path，多用于判断节点类型</li><li>scope：表示当前 path 下的作用域</li><li><strong>注意：</strong><code>path.parentPath.node</code> 等价于 <code>path.parent</code>，即 parent 是 parentPath 的一部分</li><li>type：用于获取当前path的节点类型</li><li>key：用于获取当前 path 的 key 值，key 通常用于 path.get 函数</li><li><strong>container：</strong>容器，用于获取当前path下的所有兄弟<strong>节点</strong>（<strong>包括自身</strong>），是一个 Array 类型</li><li>inList：判断是否有同级节点，即是否处于数组中（当数组只有一个成员时，也会返回 true）</li></ul></li><li><strong>container 容器内的属性：</strong><ul><li>key：表示当前节点在 container <strong>数组</strong>中的索引</li><li>listKey：表示 container 容器的名字</li></ul></li><li><strong>path 的方法：</strong><ul><li>toString：用来获取当前遍历 path 的 js 源代码，同样用法 <code>generator(path.node).code</code></li><li>get：获取子节点的 <strong>path</strong> 对象（区别于 path.node. 获取子节点的 node 对象）</li><li>findParent：向父节点搜寻节点，不包括当前节点，接受一个回调函数，根据回调函数的布尔值，从而返回找到节点的 path 或 null。例如 <code>path.findParent((p) =&gt; p.isObjectExpression())</code></li><li>find：向父节点搜寻节点，包括当前节点，用法与 findParent 一致</li><li>getFunctionParent：获取函数类型父节点的 path，存在则返回 path，不存在则返回 null</li><li>getStatementParent：获取 Statement 类型父节点的 path，这个基本上都会有返回值，如果当前遍历的是 Program 或者 File 节点，则会报错</li><li>getAncestry：获取所有的祖先节点的 path，没有实参，返回的是一个 Array 对象</li><li>isAncestor(someNode)：判断当前遍历的节点是否是传入节点的祖先节点</li><li>isDescendant(someNode)：判断当前遍历的节点是否是传入节点的子孙节点</li><li><strong>replaceWith：</strong>用 AST 节点替换该节点（<strong>严格一换一，替换新节点一般由 types 组件生成</strong>）</li><li><strong>replaceWithMultiple：</strong>用多个 AST 节点替换当前节点（<strong>多换一，实参为数组，或一换一单元素数组</strong>）</li><li><strong>replaceInline：</strong>整合 replaceWith 与 replaceWithMultiple（<strong>接受一个节点则一换一，数组则一换多</strong>）</li><li>replaceWithSourceString：直接使用字符串源码替换该节点（<strong>替换为表达式，而不是字符串</strong>）</li><li><strong>insertBefore：</strong>在当前节点之前插入一个或多个兄弟节点</li><li>insertAfter：在当前节点之后插入一个或多个兄弟节点</li><li><strong>remove：</strong>删除节点，直接调用即可将当前遍历的所有<strong>符合条件的路径</strong>全部删除</li><li>traverse：在当前节点下遍历其他的节点</li><li>getSibling：获取不同的同级 Path，接受容器数组中的索引为参数，通过传参 path.key 的增减定位</li><li>getPrevSibling：获取当前 path 的前一个兄弟节点，返回的是 path 类型</li><li>getAllPrevSiblings：获取当前 path 的所有前兄弟节点，返回的是 Array 类型，其元素都是 path 类型</li><li><strong>getNextSibling：</strong>获取当前 path 的后一个兄弟节点，返回的是 path 类型</li><li><strong>getAllNextSiblings：</strong>获取当前 path 的所有后兄弟节点，返回的是 Array 类型，其元素都是 path 类型</li><li><strong>path.evaluate：用于计算表达式的值</strong></li><li>unshiftContainer 和 pushContainer 方法：分别用于往容器的最前面和最后面加入节点，第一个参数为 listKey 容器名称，第二个参数为 Nodes 节点，<code>path.parentPath.unshiftContainer(body, [...])</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/** 测试代码：</span><br><span class="line"> * let obj = &#123;</span><br><span class="line"> *     name : &#x27;xiaofu&#x27;,</span><br><span class="line"> *     add: function(a, b)&#123;</span><br><span class="line"> *         return a + b + 1000;</span><br><span class="line"> *     &#125;,</span><br><span class="line"> *     mul: function(a, b)&#123;</span><br><span class="line"> *         return a * b + 1000;</span><br><span class="line"> *     &#125;,</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">    ReturnStatement(path) &#123;</span><br><span class="line">        console.log(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">/** 输出结果：</span><br><span class="line">NodePath &#123;</span><br><span class="line">  parentPath: NodePath &#123;......&#125;,</span><br><span class="line">  container: [</span><br><span class="line">    Node &#123;</span><br><span class="line">      type: &#x27;ReturnStatement&#x27;,</span><br><span class="line">      start: 272,</span><br><span class="line">      end: 292,</span><br><span class="line">      loc: [SourceLocation],</span><br><span class="line">      argument: [Node]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  listKey: &#x27;body&#x27;,</span><br><span class="line">  key: 0,</span><br><span class="line">  node: Node &#123;......&#125;,</span><br><span class="line">  type: &#x27;ReturnStatement&#x27;,</span><br><span class="line">  parent: Node &#123;......&#125;,</span><br><span class="line">  hub: undefined,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="5-scope"><a href="#5-scope" class="headerlink" title="5. scope"></a>5. scope</h3><blockquote><p><strong>path.scope：</strong>scope 提供了一些属性和方法，可以方便的查找标识符的作用域，获取标识符的所有引用，修改标识符的所有引用，以及识别标识符是否为参数、常量等，如果不是常量，也可以知道在哪里修改了它</p><p><strong><span style="color:red;">关于标识符在作用域中的引用次数与 scope.crawl() 的使用的重要解读：</span></strong></p><ol><li>在整个插件编写与调用遍历的过程中，可能会在某些插件中修改代码的 AST 结构或者创建新的节点，这将同时会影响到代码的作用域，<strong>但 scope 对象在某些情况下不会自动更新</strong>，从而导致其中的信息有误差</li><li><strong>scope.crawl()的使用：</strong>在涉及有关作用域的操作时，最好在其之前先调用 scope.crawl() 方法更新当前作用域信息，<strong>以确保获取对象的绑定信息正确，同时建议在每个插件的最后一行都调用此方法更新作用域（<span style="color:red;">已废弃，新解决思路是每个插件后重构 AST</span>）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scope.crawl()</span><br><span class="line"></span><br><span class="line">let nameBin = scope.getBinding(left.name)</span><br><span class="line">if (nameBin.references == 0) &#123;</span><br><span class="line">    path.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>scope.block：</strong>返回<strong>当前作用域</strong>下的所有 node，可用 <code>generator(path.scope.block).code</code> 查看代码；在遍历函数获取作用域时，返回的是函数本身的 node，其真实作用域应该为 <code>path.scope.parent.block</code></p></li><li><p><strong>scope.dump()：</strong>输出当前每个变量的作用域信息。调用后直接打印，不需要加打印函数</p></li><li><p><strong><span style="color:red;">scope.crawl()：</span>更新作用域信息，并确保之后对作用域信息的访问是最新的</strong></p></li><li><p><strong>scope.getBinding(name)：</strong>获取某个变量的 binding，可理解为其生命周期，包含引用，修改之类的信息。参数必须是当前节点能够引用的到的标识符名，<strong>只有变量定义和函数定义拥有 binding</strong>，其他的获取 binding 都是 undefined。返回的作用域中有几个关键属性：</p><ul><li><p>path：用于定位初始拥有 binding 的 path，例如形参或新定义的变量</p></li><li><p>identifier：是参数的 node 对象</p></li><li><p>scope：是参数的 scope 对象，将其中 block 节点转为代码后，一样可以得到其作用域范围代码</p></li><li><p>kind：表示此标识符的生成，是定义 let 还是参数 params 等，但是它并不代表就是当前函数的参数</p></li><li><p><strong>constant：</strong>用于判断当前变量是否<strong>没有</strong>被更改，<strong>在定义时赋值不是更改，但是先定义后赋值就算被更改，同时函数中形参也是有绑定的，为形参赋值就是改变，在还原时应判断其改变是否只有一次且为本身</strong></p></li><li><p><strong>constantViolations：</strong>Array 类型，包含所有<strong>修改</strong>该标识符节点的 path 对象，多用于判断</p></li><li><p><strong>referenced：</strong>用于判断当前变量是否被引用，<strong>赋值不算引用，取值才算（例外 e[‘age’]&#x3D;18; 算引用）</strong></p></li><li><p><strong>referencePaths：</strong>Array 类型，包含所有引用该标识符的节点的 path 对象，多用于替换（<strong>注意：</strong>循环遍历时，通常 item 的父 path 才是调用表达式或成员表达式）（<strong>修改变量时解决重名问题</strong>）</p></li><li><p><strong>references：</strong>代表标识符被引用的次数</p></li></ul></li><li><p><strong>scope.getOwnBinding()：</strong>用于获取当前节点自己的绑定，也就是不包含父级作用域中定义的标识符的绑定，但是该函数会得到子函数中定义的标识符的绑定</p></li><li><p><strong>scope.rename(oldName, newName, [block])：</strong>修改当前作用域下指定的变量名，<strong>同时修改所有引用该标识符的地方</strong>，实参为字符串类型。注意，oldName 需要有 binding，否则无法重命名</p><ul><li><strong>生成新标识符名：</strong><code>path.scope.generateUidIdentifier(&quot;uid&quot;).name</code></li></ul></li><li><p><strong>scope.traverse()：</strong>遍历当前作用域下的某些(个)插件，使用 path.scope.traverse 则是当前节点的作用域，而使用 path.scope.getBinding(name).scope.traverse 则是遍历标识符 name 的作用域，推荐后者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FunctionDeclaration(path) &#123;</span><br><span class="line">    let binding = path.scope.getBinding(&#x27;a&#x27;);</span><br><span class="line">    binding.scope.traverse(binding.scope.block, &#123;</span><br><span class="line">        AssignmentExpression(p) &#123;</span><br><span class="line">            if (p.node.left.name == &#x27;a&#x27;) &#123;</span><br><span class="line">                p.node.right = t.numericLiteral(5000)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>scope 的其他方法：</strong></p><ul><li><strong>scope.hasBinding(‘a’)：</strong>查询是否有标识符 a 的绑定，返回 true 或 false</li><li><strong>scope.hasOwnBinding(‘a’)：</strong>查询是否有自己的绑定，不包含函数本身，返回 true 或 false</li><li><strong>scope.getAllBindings()：</strong>获取当前节点的所有绑定，是包含全局变量的，返回一个对象。该对象以标识符名为属性名，对应的 Binding 为属性值</li><li><strong>scope.hasReference(‘a’)：</strong>查询当前节点中是否有 a 标识符的引用，返回 true 或 false</li><li><strong>scope.getBindingIdentifier(‘a’)：</strong>获取当前节点中绑定的 a 标识符，返回的是 Identifier 的 Node 对象。同样地，这个方法也有 Own 版本，scope.getOwnBindingldentifier(‘a’)</li></ul></li></ul><h3 id="6-常见语法技巧"><a href="#6-常见语法技巧" class="headerlink" title="6. 常见语法技巧"></a>6. 常见语法技巧</h3><ul><li><p><strong>获取节点源代码：</strong></p><ul><li><strong>path：<code>path.toString()</code></strong></li><li><strong>node：<code>generator(node).code</code></strong></li></ul></li><li><p><strong>使用 template 构造节点：</strong></p><ol><li><pre><code>// 创建一个模板let VAR_NODE = template(`var A = 1, B = A;`);// 定义替换的标识符let firstVar = types.identifier(&#39;a&#39;);let secondVar = types.identifier(&#39;b&#39;);// 生成新的节点let newNode = VAR_NODE(&#123; A: firstVar, B: secondVar &#125;);console.log(generator(newNode).code); // var a = 1, b = a;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   let newNode = template.ast(&quot;aaa = 666;&quot;);</span><br><span class="line">   console.log(generator(newNode).code); // aaa = 666;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p><strong>除了 path.remove() 的其他删除节点方式：</strong></p><ol><li><strong>delete path.node.extra：</strong>删除 <strong>StringLiteral</strong> 节点的 extra 属性，可以还原简单的进制混淆字面量</li><li><strong>body.pop()：</strong>需删除的节点存在多个兄弟节点，且存在 Array 中，则可通过遍历数组配合条件判断删除</li></ol></li></ul><h3 id="7-ast-必备-js-语法与特性"><a href="#7-ast-必备-js-语法与特性" class="headerlink" title="7. ast 必备 js 语法与特性"></a>7. ast 必备 js 语法与特性</h3><ol><li><strong>在 js 中只有 7 种值 false、undefined、null、0、-0、NaN、”” 为假</strong>，其余均为真</li><li>在 js 中对象的 key 可以不加引号，不同于 python</li><li><strong>在 js 中变量名和对象键无法直接进行加密，只能混淆</strong>，因为加密会导致 js 引擎无法正确解析和访问</li></ol><ul><li><p><strong>数组常用小方法：</strong></p><ol><li><strong>push(ele)：</strong>在数组末尾添加一个或多个元素，并返回数组的新长度</li><li><strong>pop()：</strong>从数组末尾移除最后一个元素，并返回该元素</li><li><strong>shift()：</strong>从数组开头移除第一个元素，并返回该元素</li><li><strong>unshift(ele)：</strong>在数组开头添加一个或多个元素，并返回数组的新长度</li><li><strong>concat(arr1, arr2)：</strong>合并两个或多个数组，并返回一个新数组</li><li><strong>sort()：</strong>就地对数组的元素进行排序，并返回此数组。默认排序顺序是根据字符串 Unicode 码点</li><li><strong>reverse()：</strong>就地颠倒数组中元素的顺序，并返回此数组</li><li><strong>join(separator)：</strong>将数组的所有元素连接成一个字符串，元素通过指定的分隔符 separator 分隔</li><li><strong>includes(ele)：</strong>如果数组包含某个元素，则返回 true，否则返回 false</li></ol></li><li><p><strong>数组常用遍历方法：</strong></p><ol><li><strong>forEach(callback)：</strong>对数组的每个元素执行一次提供的函数</li><li><strong>filter(callback)：</strong>创建一个新数组，其中包含所有通过所提供函数实现的测试的元素</li><li><strong>every(callback)：</strong>测试一个数组的所有元素是否都通过了指定函数的测试，返回布尔值</li><li><strong>some(callback)：</strong>测试数组中的某些元素是否至少有一个通过了提供的函数的测试，返回布尔值</li><li><strong>map(callback)：</strong>创建一个新数组，其结果是该数组中的每个元素调用一次提供的函数后的返回值</li><li><strong>slice(beginIndex, endIndex)：</strong>返回一个新数组，包含从开始到结束（左闭右开）选择的数组的一部分</li><li><strong>splice(startIndex, deleteCount[, item…])：</strong>通过删除或替换现有元素和&#x2F;或添加新元素来修改数组的内容，并返回被删除的元素</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.every(element =&gt; element.toString() == &#x27;xfblog.cn&#x27;)</span><br></pre></td></tr></table></figure><h2 id="二、判断节点通用函数"><a href="#二、判断节点通用函数" class="headerlink" title="二、判断节点通用函数"></a>二、判断节点通用函数</h2><h3 id="1-函数-–-节点字面量基础判断"><a href="#1-函数-–-节点字面量基础判断" class="headerlink" title="1. 函数 –&gt; 节点字面量基础判断"></a>1. 函数 –&gt; 节点字面量基础判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-函数-节点字面量递归判断"><a href="#2-函数-节点字面量递归判断" class="headerlink" title="2. 函数 -&gt; 节点字面量递归判断"></a>2. 函数 -&gt; 节点字面量递归判断</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">if (Array.isArray(node))</span><br><span class="line">    return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isThisExpression(node))</span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">if (types.isLiteral(node))</span><br><span class="line">    return node.value != null;</span><br><span class="line"></span><br><span class="line">if (types.isBinaryExpression(node))</span><br><span class="line">    return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">    return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">if (types.isObjectExpression(node))</span><br><span class="line">    return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isArrayExpression(node))</span><br><span class="line">    return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 用于检查一个给定的 AST 节点是否可以被视为字面量(Literal)</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    // node 是数组，函数会递归地检查数组中的每个元素是否都符合字面量的条件</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    // node 是一个 ThisExpression (例`this`关键字)，则返回true，因为this可以被视为字面量</span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    // node 是字面量，函数会进一步检查它的值。如果value为null，返回false，否则返回true</span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    // node 是二元表达式，函数会递归地检查表达式的左操作数和右操作数是否都为字面量</span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    // node 是一元表达式，且操作符是 + 或 -，函数会递归地检查表达式的参数是否为字面量</span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    // node 是对象表达式，例`&#123;a: 1, b: 2&#125;`，函数会检查对象的属性，属性为空则返回true，否则递归检查每个属性是否为字面量</span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    // node 是数组表达式，例`[1, 2, 3]`，函数会检查数组的元素，元素为空则返回true，否则递归检查每个元素是否为字面量</span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数优化-节点子面量判断"><a href="#3-函数优化-节点子面量判断" class="headerlink" title="3. 函数优化 -&gt; 节点子面量判断"></a>3. 函数优化 -&gt; 节点子面量判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数-判断节点是否纯函数"><a href="#3-函数-判断节点是否纯函数" class="headerlink" title="3. 函数 -&gt; 判断节点是否纯函数"></a>3. 函数 -&gt; 判断节点是否纯函数</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line"> let isPure = true;</span><br><span class="line"></span><br><span class="line"> // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line"> let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line"> let sourceCode = path.toString();</span><br><span class="line"> let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line"> if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line"> path.traverse(&#123;</span><br><span class="line">     MemberExpression(innerPath) &#123;</span><br><span class="line">         const &#123; object &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">             isPure = false;</span><br><span class="line">             innerPath.stop();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     AssignmentExpression(innerPath) &#123;</span><br><span class="line">         const &#123; left &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">             isPure = false;</span><br><span class="line">             innerPath.stop();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     CallExpression(innerPath) &#123;</span><br><span class="line">         const &#123; callee &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(callee)) &#123;</span><br><span class="line">             const binding = path.scope.getBinding(callee.name);</span><br><span class="line">             if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                 isPure = false;</span><br><span class="line">                 innerPath.stop();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     UpdateExpression(innerPath) &#123;</span><br><span class="line">         const &#123; argument &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">             isPure = false;</span><br><span class="line">             innerPath.stop();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> return isPure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line">    </span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    // 访问函数内部的所有节点</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        // 检查是否有副作用</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            // 如果访问了外部变量</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 检查是否修改了外部状态</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 检查是否调用了非纯函数</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 其他可能的副作用</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 检查使用了全局对象</span><br><span class="line">        Identifier(innerPath) &#123;</span><br><span class="line">            if ([&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;Date&#x27;, &#x27;random&#x27;].includes(innerPath.node.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、解混淆通用插件"><a href="#三、解混淆通用插件" class="headerlink" title="三、解混淆通用插件"></a>三、解混淆通用插件</h2><h3 id="0-模版-通用解混淆模版"><a href="#0-模版-通用解混淆模版" class="headerlink" title="0. 模版 -&gt; 通用解混淆模版"></a>0. 模版 -&gt; 通用解混淆模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">const visitor = &#123;</span><br><span class="line">    /**  @param  &#123;NodePath&#125; path */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, visitor);</span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><h3 id="1-插件-编码还原十进制"><a href="#1-插件-编码还原十进制" class="headerlink" title="1. 插件 -&gt; 编码还原十进制"></a>1. 插件 -&gt; 编码还原十进制</h3><ul><li>当代码中包含<strong>非ASCII字符</strong>时，要尽可能少地使用转义字符，以确保其被正确地保留和显示，而不是被转义<ul><li>配置：<code>let &#123; code &#125; = generator(ast, opts = &#123; jsescOption: &#123; &quot;minimal&quot;: true &#125; &#125;);</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 编码还原十进制</span><br><span class="line">const simplifyLiteral = &#123;</span><br><span class="line">    NumericLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /^0[obx]/i.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    StringLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /\\[ux]/gi.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, simplifyLiteral);</span><br></pre></td></tr></table></figure><h3 id="2-插件-字面量化成员表达式"><a href="#2-插件-字面量化成员表达式" class="headerlink" title="2. 插件 -&gt; 字面量化成员表达式"></a>2. 插件 -&gt; 字面量化成员表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 字面量化成员表达式 `b.length` ==&gt; `b[&#x27;length&#x27;]`</span><br><span class="line">const keyToLiteral = &#123;</span><br><span class="line">    MemberExpression: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const prop = node.property;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(prop)) &#123;</span><br><span class="line">                node.property = types.stringLiteral(prop.name)</span><br><span class="line">                node.computed = true; // 只有当使用中括号调用才为true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 对象的 key 也由标识符转为字面量</span><br><span class="line">    ObjectProperty: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const key = node.key;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(key)) &#123;</span><br><span class="line">                node.key = types.stringLiteral(key.name);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.computed &amp;&amp; types.isStringLiteral(key)) &#123;</span><br><span class="line">                node.computed = false; // 不是通过计算得来的，computed为false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, keyToLiteral);</span><br></pre></td></tr></table></figure><h3 id="3-插件-折叠字面量或表达式"><a href="#3-插件-折叠字面量或表达式" class="headerlink" title="3. 插件 -&gt; 折叠字面量或表达式"></a>3. 插件 -&gt; 折叠字面量或表达式</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// 折叠计算部分字面量或表达式</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">if (Array.isArray(node))</span><br><span class="line">  return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isThisExpression(node))</span><br><span class="line">  return true;</span><br><span class="line"></span><br><span class="line">if (types.isLiteral(node))</span><br><span class="line">  return node.value != null;</span><br><span class="line"></span><br><span class="line">if (types.isBinaryExpression(node))</span><br><span class="line">  return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">  return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">if (types.isObjectExpression(node))</span><br><span class="line">  return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isArrayExpression(node))</span><br><span class="line">  return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">&quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">  exit(path) &#123;</span><br><span class="line">      let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">      let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">      if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">          path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">          path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">          path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">          const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">          if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">          if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">          try &#123;</span><br><span class="line">                 path.replaceWith(types.valueToNode(value));</span><br><span class="line">             &#125; catch &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     path.replaceWith(types.stringLiteral(value));</span><br><span class="line">                 &#125; catch (e) &#123;</span><br><span class="line">                     console.log(&quot;无法还原原因:&quot;, e.message);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 处理条件表达式（三目表达式）</span><br><span class="line">      if (path.isConditionalExpression()) &#123;</span><br><span class="line">          let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">          if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">              path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">          if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">          if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">          path.replaceWith(types.valueToNode(value));</span><br><span class="line">      &#125;</span><br><span class="line">      // 处理字符串相加</span><br><span class="line">      if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">          if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">              if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                  path.node.right.value += parent.right.value;</span><br><span class="line">                  parentPath.replaceWith(path.node);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/** 插件：折叠计算部分字面量或表达式</span><br><span class="line"> * var a = 1 + 2 + 3 + 4;                   ===&gt; var a = 10;</span><br><span class="line"> * var b = 3 - 5;                           ===&gt; var b = -2;</span><br><span class="line"> * var c = true ? 7 : 2;                    ===&gt; var c = 7;</span><br><span class="line"> * var d = !![];                            ===&gt; var d = true;</span><br><span class="line"> * var e = pw + 1 + 5 + 66;                 ===&gt; var e = pw + 72;</span><br><span class="line"> * var f = 3 + 100 - 30 + pw + 1 + 5 + 66;  ===&gt; var f = 145 + pw;</span><br><span class="line"> * var aaa = &quot;a&quot; + &quot;b&quot; + c;                 ===&gt; var aaa = &quot;ab&quot; + c;</span><br><span class="line"> * var bbb = c + &quot;d&quot; + &quot;e&quot;;                 ===&gt; var bbb = c + &quot;de&quot;;</span><br><span class="line"> * var ccc = &quot;a&quot; + &quot;b&quot; + c + &quot;d&quot; + &quot;e&quot;;     ===&gt; var ccc = &quot;ab&quot; + c + &quot;de&quot;;</span><br><span class="line"> * var ddd = &quot;111&quot;.toString().length        ===&gt; var ddd = 3</span><br><span class="line"> */</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression(&#123; operator: &#x27;!&#x27; &#125;) ||        // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isConditionalExpression() ||                   // 处理三目运算符</span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                // 评估当前路径（表达式）的值，confident表示评估结果是否确定，value表示评估的具体值</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return; // 排除value值为 1/0 无穷大的情况</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                // console.log(path + &#x27;&#x27;);</span><br><span class="line">                // console.log(parentPath + &#x27;&#x27;);</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果父节点是二元表达式，且父节点左侧操作数为当前节点          // 处理右侧字符串字面量相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                // 如果当前节点的左操作数不是字面量，操作符是加号，且右操作数是字面量</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    // 同时如果父节点的操作符也是加号，且右操作数也是字面量</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        // 合并当前节点和父节点的右侧字面量值，并替换父节点</span><br><span class="line">                        // console.log(path + &#x27;&#x27;);</span><br><span class="line">                        // console.log(parentPath + &#x27;&#x27;);</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 处理`var a = 73 + b + 72;`的情况</span><br><span class="line">                if (types.isNumericLiteral(left) &amp;&amp; types.isNumericLiteral(parent.right)) &#123;</span><br><span class="line">                    // console.log(path + &#x27;&#x27;);</span><br><span class="line">                    // console.log(parentPath + &#x27;&#x27;);   </span><br><span class="line">                    path.node.left.value += parent.right.value;</span><br><span class="line">                    parentPath.replaceWith(path.node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br></pre></td></tr></table></figure><h3 id="4-插件-简化循环和-If-语句"><a href="#4-插件-简化循环和-If-语句" class="headerlink" title="4. 插件 -&gt; 简化循环和 If 语句"></a>4. 插件 -&gt; 简化循环和 If 语句</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 美化循环语句和 if-else 语句，并简化逻辑</span><br><span class="line">const SimplifyLoopAndIf = &#123;</span><br><span class="line">    &quot;ForStatement|WhileStatement|ForInStatement|ForOfStatement&quot;(&#123; node &#125;) &#123;</span><br><span class="line">        if (!types.isBlockStatement(node.body)) &#123;</span><br><span class="line">            node.body = types.blockStatement([node.body]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IfStatement&quot;(path) &#123;</span><br><span class="line">        const test = path.get(&quot;test&quot;);</span><br><span class="line">        const consequent = path.get(&quot;consequent&quot;);</span><br><span class="line">        const alternate = path.get(&quot;alternate&quot;);</span><br><span class="line">        const evaluateTest = test.evaluateTruthy();</span><br><span class="line"></span><br><span class="line">     if (!consequent.isBlockStatement() &amp;&amp; !consequent.isEmptyStatement()) &#123;</span><br><span class="line">            consequent.replaceWith(types.blockStatement([consequent.node]));</span><br><span class="line">        &#125;</span><br><span class="line">        if (alternate.node !== null &amp;&amp; !alternate.isBlockStatement() &amp;&amp; !alternate.isEmptyStatement()) &#123;</span><br><span class="line">            alternate.replaceWith(types.blockStatement([alternate.node]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     if (consequent.isEmptyStatement() || consequent.node.body.length == 0) &#123;</span><br><span class="line">            if (alternate.node == null || alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                path.replaceWith(test.node);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent.replaceWith(alternate.node);</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">                test.replaceWith(types.unaryExpression(&quot;!&quot;, test.node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     if (alternate.node != null) &#123;</span><br><span class="line">            if (alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     if (evaluateTest === true) &#123;</span><br><span class="line">            path.replaceWithMultiple(consequent.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (evaluateTest === false) &#123;</span><br><span class="line">            (alternate.node === null || alternate.node.body.length == 0) ? path.remove() : path.replaceWithMultiple(alternate.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, SimplifyLoopAndIf);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/** 插件：美化循环语句和 if-else 语句，并简化逻辑</span><br><span class="line"> * if (a) b; else c;                ===&gt; if (a) &#123; b; &#125; else &#123; c; &#125;</span><br><span class="line"> * if (a);                          ===&gt; a;</span><br><span class="line"> * if (a) &#123; &#125;;                      ===&gt; a;</span><br><span class="line"> * if (a) &#123; &#125; else &#123; &#125;;             ===&gt; a;</span><br><span class="line"> * if (a) &#123; &#125; else &#123; b &#125;;           ===&gt; if (!a) &#123; b; &#125;</span><br><span class="line"> * if (a) &#123; &#125; else b;               ===&gt; if (!a) &#123; b; &#125;</span><br><span class="line"> * if (a) &#123; b &#125; else &#123; &#125;;           ===&gt; if (a) &#123; b; &#125;</span><br><span class="line"> * if (a) &#123; b &#125; else;               ===&gt; if (a) &#123; b; &#125;</span><br><span class="line"> * if (1 + 1) b; else c;            ===&gt; b;</span><br><span class="line"> * if (1 - 1) b; else c;            ===&gt; c;</span><br><span class="line"> */</span><br><span class="line">const SimplifyLoopAndIf = &#123;</span><br><span class="line">    &quot;ForStatement|WhileStatement|ForInStatement|ForOfStatement&quot;(&#123; node, scope &#125;) &#123;</span><br><span class="line">        if (!types.isBlockStatement(node.body)) &#123;</span><br><span class="line">            node.body = types.BlockStatement([node.body]);</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IfStatement&quot;(path) &#123;</span><br><span class="line">        const test = path.get(&quot;test&quot;);</span><br><span class="line">        const consequent = path.get(&quot;consequent&quot;);</span><br><span class="line">        const alternate = path.get(&quot;alternate&quot;);</span><br><span class="line">        const evaluateTest = test.evaluateTruthy(); // if的条件执行，返回布尔值</span><br><span class="line"></span><br><span class="line">        if (!consequent.isBlockStatement() &amp;&amp; !consequent.isEmptyStatement()) &#123;</span><br><span class="line">            consequent.replaceWith(types.BlockStatement([consequent.node]));</span><br><span class="line">        &#125;</span><br><span class="line">        if (alternate.node !== null &amp;&amp; !alternate.isBlockStatement() &amp;&amp; !alternate.isEmptyStatement()) &#123;</span><br><span class="line">            alternate.replaceWith(types.BlockStatement([alternate.node]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (consequent.isEmptyStatement() || consequent.node.body.length == 0) &#123; // `if(a);`或`if(a)&#123;&#125;;`</span><br><span class="line">            if (alternate.node == null || alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                path.replaceWith(test.node);</span><br><span class="line">            &#125; else &#123; // `if(a)&#123;&#125; else&#123;b&#125;;`</span><br><span class="line">                consequent.replaceWith(alternate.node);</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">                test.replaceWith(types.unaryExpression(&quot;!&quot;, test.node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `if(a)&#123;b&#125; else;`或`if(a)&#123;b&#125; else&#123;&#125;;`</span><br><span class="line">        if (alternate.node != null) &#123;</span><br><span class="line">            if (alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 能计算出条件真假值的情况</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            path.replaceWithMultiple(consequent.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (evaluateTest === false) &#123; // 也可能为undefined，此时不确定，则不处理</span><br><span class="line">            (alternate.node === null || alternate.node.body.length == 0) ? path.remove() : path.replaceWithMultiple(alternate.node.body);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, SimplifyLoopAndIf);</span><br></pre></td></tr></table></figure><h3 id="5-插件-简化逗号表达式"><a href="#5-插件-简化逗号表达式" class="headerlink" title="5. 插件 -&gt; 简化逗号表达式"></a>5. 插件 -&gt; 简化逗号表达式</h3><ul><li><strong>第 1 种（常用）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 去除逗号表达式1</span><br><span class="line">const resolveSequence1 = &#123;</span><br><span class="line">    SequenceExpression(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, parent &#125; = path;</span><br><span class="line">        if (parentPath.parentPath.isLabeledStatement()) return; // 标签节点无法往前插入</span><br><span class="line">        let ancestorPath = parentPath.parentPath;</span><br><span class="line">        let expressions = node.expressions;</span><br><span class="line">        </span><br><span class="line">        // 把 (0, xxx) 的逗号表达式直接替换为本身</span><br><span class="line">        if (parentPath.isCallExpression(&#123; callee: node &#125;) &amp;&amp; expressions.length == 2 &amp;&amp; types.isNumericLiteral(expressions[0], &#123; value: 0 &#125;)) &#123;</span><br><span class="line">            path.replaceWith(expressions[1])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentPath.isReturnStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isThrowStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isIfStatement(&#123; &#x27;test&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isWhileStatement(&#123; &quot;test&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForInStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForOfStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isSwitchStatement(&#123; &quot;discriminant&quot;: node &#125;) ||</span><br><span class="line">            (parentPath.isConditionalExpression(&#123; &quot;test&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isUnaryExpression(&#123; &quot;argument&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isAssignmentExpression(&#123; &quot;right&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            ((parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;) || parentPath.isNewExpression(&#123; &quot;callee&quot;: node &#125;)) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            parentPath.isLogicalExpression(&#123; &#x27;left&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isExpressionStatement(&#123; &quot;expression&quot;: node &#125;)) &#123;</span><br><span class="line"></span><br><span class="line">            let lastExpression = expressions.pop(); // 取出最后一个表达式</span><br><span class="line">            // 将前面的每个表达式都插入到父节点之前，作为单独的 ExpressionStatement</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                parentPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 for 循环的init处的所有逗号表达式都提出来</span><br><span class="line">        else if (parentPath.isForStatement(&#123; &#x27;init&#x27;: node &#125;)) &#123;</span><br><span class="line">            node.expressions.forEach(express =&gt; &#123; parentPath.insertBefore(types.expressionStatement(express)); &#125;);</span><br><span class="line">            path.remove();;</span><br><span class="line">        &#125;</span><br><span class="line">        // 变量定义应该插入到声明之前，不然会有问题</span><br><span class="line">        else if (parentPath.isVariableDeclarator(&#123; &quot;init&quot;: node &#125;) &amp;&amp; ancestorPath.isVariableDeclaration() &amp;&amp; ancestorPath.parentPath.isBlock()) &#123;</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line"></span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ancestorPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 逻辑表达式中的处理，不管父节点符号是&amp;&amp;还是||，左边都可以直接还原，右边则需判断</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;&amp;&amp;&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement(ifBody), null)</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        // js中逻辑或运算符 || 使用了短路求值，如果 || 运算符的左操作数为 true，右操作数将不会被计算或执行</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;||&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement([]), types.blockStatement(ifBody))</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, resolveSequence1);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><ul><li><strong>第 2 种：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 去除逗号表达式2</span><br><span class="line">const resolveSequence2 = &#123;</span><br><span class="line">    SequenceExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let statementPath = path.getStatementParent();</span><br><span class="line">            if (!statementPath) return;</span><br><span class="line"></span><br><span class="line">            let paths = [];</span><br><span class="line">            statementPath.traverse(&#123;</span><br><span class="line">                &quot;LogicalExpression|ConditionalExpression&quot;(_path) &#123;</span><br><span class="line">                    paths.push(_path); // 收集所有不确定会不会执行的表达式</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            let canVisitFlag = true;</span><br><span class="line"></span><br><span class="line">            for (let _path of paths) &#123;</span><br><span class="line">                if (_path.isAncestor(path)) &#123;</span><br><span class="line">                    canVisitFlag = false; // 过滤不能还原的情况</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (canVisitFlag) &#123;</span><br><span class="line">                if (statementPath.isLoop()) return; // 循环表达式内的test节点，不能随意插在该表达式前面</span><br><span class="line"></span><br><span class="line">                let expressions = path.node.expressions;</span><br><span class="line">                let lastNode = expressions.pop();</span><br><span class="line">                for (let expression of expressions) &#123;</span><br><span class="line">                    statementPath.insertBefore(types.ExpressionStatement(expression = expression));</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWith(lastNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, resolveSequence2);</span><br></pre></td></tr></table></figure><h3 id="6-插件-对象-val-值全为常量"><a href="#6-插件-对象-val-值全为常量" class="headerlink" title="6. 插件 -&gt; 对象 val 值全为常量"></a>6. 插件 -&gt; 对象 val 值全为常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// object对象的value值全部为字面量时的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObjectofValue = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, scope &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let properties = init.properties;</span><br><span class="line">        if (properties.length == 0 || !properties.every(property =&gt; isBaseLiteral(property.value))) return;</span><br><span class="line"></span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        for (const property of properties) &#123;</span><br><span class="line">            let &#123; key, value &#125; = property;</span><br><span class="line">            let KeyName = types.isIdentifier(key) ? key.name : key.value;</span><br><span class="line"></span><br><span class="line">            newMap.set(KeyName, value);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newMap.size != properties.length) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            let flag = false; // 用于标志当前对象是否可以删除</span><br><span class="line">            for (const referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isMemberExpression()) break;</span><br><span class="line"></span><br><span class="line">                let AncestorPath = parentPath.parentPath;</span><br><span class="line">                if (AncestorPath.isAssignmentExpression(&#123; &quot;left&quot;: parentPath.node &#125;)) &#123;</span><br><span class="line">                    break; // 特殊引用，其实是赋值 obj[&#x27;c&#x27;] = 789;，有赋值肯定直接取消还原</span><br><span class="line">                &#125;</span><br><span class="line">                if (AncestorPath.isUpdateExpression() &amp;&amp; [&#x27;++&#x27;, &#x27;--&#x27;].includes(AncestorPath.node.operator)) &#123;</span><br><span class="line">                    break; // 同理，有自增自减的操作，等同于赋值，也取消还原</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let &#123; property &#125; = parentPath.node;</span><br><span class="line">                let curKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">                if (!newMap.has(curKey)) break;</span><br><span class="line"></span><br><span class="line">                flag = true;</span><br><span class="line">                parentPath.replaceWith(newMap.get(curKey))</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                console.log(&quot;对象 val 值全为常量&quot;, &quot;删除 --&gt; 对象定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObjectofValue);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="7-插件-数组元素全为常量"><a href="#7-插件-数组元素全为常量" class="headerlink" title="7. 插件 -&gt; 数组元素全为常量"></a>7. 插件 -&gt; 数组元素全为常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// Array 数据类型还原，需要元素全部为 Literal</span><br><span class="line">// var a=[1,&#x27;xfblog&#x27;,window];  res=a[2](a[0]+a[1]);     ===&gt;     res = window(1 + &#x27;xfblog&#x27;);</span><br><span class="line">const replaceArrayElements = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, scope &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isArrayExpression(init) || init.elements.length == 0) return;</span><br><span class="line"></span><br><span class="line">        for (let ele of init.elements) &#123;</span><br><span class="line">            if (types.isArrayExpression(ele) || types.isObjectExpression(ele)) &#123;</span><br><span class="line">                return;  // 不处理数组中有嵌套数组或对象的情况</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            let flag = false;</span><br><span class="line">            for (let referPath of referencePaths) &#123;</span><br><span class="line">                let &#123; node, parent, parentPath &#125; = referPath;</span><br><span class="line">                if (!parentPath.isMemberExpression(&#123; object: node &#125;) || !types.isNumericLiteral(parent.property)) break;</span><br><span class="line"></span><br><span class="line">                if (parentPath.parentPath.isAssignmentExpression(&#123; &quot;left&quot;: parent &#125;)) break; // arr[1] = arr[0] + arr[2];</span><br><span class="line">                if (parentPath.parentPath.isUpdateExpression(&#123; &quot;argument&quot;: parent &#125;)) break; // ++arr[1];</span><br><span class="line"></span><br><span class="line">                flag = true;</span><br><span class="line">                let index = parent.property.value;</span><br><span class="line">                parentPath.replaceWith(init.elements[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                console.log(&quot;数组元素全为常量&quot;, &quot;删除 --&gt; 数组定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, replaceArrayElements);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="8-插件-垃圾代码删除"><a href="#8-插件-垃圾代码删除" class="headerlink" title="8. 插件 -&gt; 垃圾代码删除"></a>8. 插件 -&gt; 垃圾代码删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// 最后使用：垃圾代码删除</span><br><span class="line">function containsSequenceExpression(path) &#123;</span><br><span class="line">    let containsSequence = false;</span><br><span class="line">    // 深度优先遍历当前路径及其所有子路径</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        &quot;SequenceExpression|AssignmentExpression&quot;(_path) &#123;</span><br><span class="line">            containsSequence = true;</span><br><span class="line">            _path.stop(); // 找到逗号表达式后立即停止遍历</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    return containsSequence;</span><br><span class="line">&#125;</span><br><span class="line">const removeDeadCode = &#123;</span><br><span class="line">    &quot;IfStatement|ConditionalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; consequent, alternate &#125; = node;</span><br><span class="line">        let testPath = path.get(&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (testPath.isSequenceExpression() || testPath.isAssignmentExpression() || containsSequenceExpression(testPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateTest = testPath.evaluateTruthy();</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            if (types.isBlockStatement(consequent)) &#123;</span><br><span class="line">                consequent = consequent.body;</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceWithMultiple(consequent);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (evaluateTest === false) &#123;</span><br><span class="line">            if (alternate != null) &#123;</span><br><span class="line">                if (types.isBlockStatement(alternate)) &#123;</span><br><span class="line">                    alternate = alternate.body;</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWithMultiple(alternate);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;LogicalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let leftPath = path.get(&#x27;left&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (leftPath.isSequenceExpression() || leftPath.isAssignmentExpression() || containsSequenceExpression(leftPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateLeft = leftPath.evaluateTruthy();</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == true) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == false)) &#123;</span><br><span class="line">            path.replaceWith(left);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == false) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == true)) &#123;</span><br><span class="line">            path.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;EmptyStatement|DebuggerStatement&quot;(path) &#123;</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, parentPath, parent &#125; = path;</span><br><span class="line">        let ancestryPath = parentPath.parentPath;</span><br><span class="line"></span><br><span class="line">        // for循环中的变量定义不能删除</span><br><span class="line">        if (ancestryPath.isForOfStatement(&#123; left: parent &#125;) || ancestryPath.isForInStatement(&#123; left: parent &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        //目前只发现赋值语句和调用语句会有问题。后续待添加</span><br><span class="line">        if (!types.isIdentifier(id) || types.isCallExpression(init) || types.isAssignmentExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name); // 重新解析ast后，一定会有binding</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;AssignmentExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(path + &#x27;&#x27;, referenced, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 赋值语句:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ContinueStatement|BreakStatement|ReturnStatement|ThrowStatement&quot;(path) &#123;</span><br><span class="line">    if (!path.parentPath.isSwitchCase()) return; // 只处理在 switch-case 语句中的</span><br><span class="line">        let AllNextSiblings = path.getAllNextSiblings(); // 获取所有的后续兄弟节点</span><br><span class="line">        for (let nextSibling of AllNextSiblings) &#123;</span><br><span class="line">            if (nextSibling.isFunctionDeclaration() || nextSibling.isVariableDeclaration(&#123; kind: &quot;var&quot; &#125;)) &#123; //变量提升.....</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params &#125; = node;</span><br><span class="line">        if (!params) return;</span><br><span class="line">        let flag = true;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            for (let i of params) &#123;</span><br><span class="line">                if (!types.isIdentifier(i)) continue;</span><br><span class="line">                let binding = scope.getBinding(i.name);</span><br><span class="line">                if (!binding) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; references, constantViolations &#125; = binding;</span><br><span class="line">                if (references === 0 &amp;&amp; constantViolations.length === 0) &#123;</span><br><span class="line">                    // 将未使用的参数标记为删除</span><br><span class="line">                    console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数形参:&quot;, i.name);</span><br><span class="line">                    params = params.filter(param =&gt; param !== i);</span><br><span class="line">                    console.log(params);</span><br><span class="line">                &#125;</span><br><span class="line">                path.node.params = params;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, removeDeadCode); // 删除不够彻底则再调用一次，以此类推</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、变量相关插件"><a href="#四、变量相关插件" class="headerlink" title="四、变量相关插件"></a>四、变量相关插件</h2><h3 id="1-插件-分离多个变量同定义"><a href="#1-插件-分离多个变量同定义" class="headerlink" title="1. 插件 -&gt; 分离多个变量同定义"></a>1. 插件 -&gt; 分离多个变量同定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 分离多个变量同定义</span><br><span class="line">// var a, b, c;     ===&gt;     var a; var b; var c;</span><br><span class="line">const DeclaratorToDeclaration = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 避免处理那些在非块级节点内的变量声明`if (true) let a, b;`</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length == 1) return;</span><br><span class="line"></span><br><span class="line">        let newNodes = [];</span><br><span class="line">        for (let varNode of declarations) &#123;</span><br><span class="line">            let newDeclarationNode = types.variableDeclaration(kind, [varNode]);</span><br><span class="line">            newNodes.push(newDeclarationNode);</span><br><span class="line">        &#125;</span><br><span class="line">        path.replaceWithMultiple(newNodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, DeclaratorToDeclaration);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="2-插件-合并变量声明与定义"><a href="#2-插件-合并变量声明与定义" class="headerlink" title="2. 插件 -&gt; 合并变量声明与定义"></a>2. 插件 -&gt; 合并变量声明与定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 合并变量声明与定义</span><br><span class="line">// var a, b, c; a = 1; b = 2; c = 3;    ===&gt;    var a = 1, b = 2, c = 3;</span><br><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const combinDefineAndNextAssgin = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (init != null) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line">        if (!constantViolations[0].isAssignmentExpression()) return;</span><br><span class="line">        if (constantViolations[0].parentPath.isConditionalExpression() || constantViolations[0].parentPath.isLogicalExpression()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = constantViolations[0].node</span><br><span class="line">        if (!types.isIdentifier(left, &#123; name: name &#125;) || operator != &#x27;=&#x27; || !isNodeLiteral(right)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.set(&quot;init&quot;, right);</span><br><span class="line">        constantViolations[0].remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="3-插件-变量定义函数转自定"><a href="#3-插件-变量定义函数转自定" class="headerlink" title="3. 插件 -&gt; 变量定义函数转自定"></a>3. 插件 -&gt; 变量定义函数转自定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 由变量定义的函数表达式，统一还原为函数定义</span><br><span class="line">// var a =function()&#123;&#125;     ===&gt;     function a()&#123;&#125;</span><br><span class="line">const varDeclarToFuncDeclar = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, scope &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 过滤掉部分特殊情况，例如for循环里的变量定义</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = declarations[0];</span><br><span class="line">        if (!types.isFunctionExpression(init, &#123; id: null &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; params, body &#125; = init;</span><br><span class="line">        let newNode = types.functionDeclaration(id, params, body);</span><br><span class="line">        path.replaceWith(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, varDeclarToFuncDeclar);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="4-插件-定义字面量未改还原"><a href="#4-插件-定义字面量未改还原" class="headerlink" title="4. 插件 -&gt; 定义字面量未改还原"></a>4. 插件 -&gt; 定义字面量未改还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 变量初始化为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数（只能用这个，因为不能还原容器）</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (parentPath.parentPath.isForStatement() || parentPath.find((p) =&gt; p.isSwitchCase())) return;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="5-插件-赋值字面量未改还原"><a href="#5-插件-赋值字面量未改还原" class="headerlink" title="5. 插件 -&gt; 赋值字面量未改还原"></a>5. 插件 -&gt; 赋值字面量未改还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 在函数中形参变量赋值为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数（只能用这个，因为不能还原容器）</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const restoreAssignment = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return; // 必须只处理单独的语句，不能是嵌套在其他语句里的赋值语句，涉及删除</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !isBaseLiteral(right)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(left.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // 如果绑定不是形参而是变量定义，那么就存在一种情况，改变只有一次，但是赋了两次值，所以要确保变量定义无赋值</span><br><span class="line">        if (constantViolations.length != 1 || !binding.path.isVariableDeclarator(&#123; init: null &#125;)) return;</span><br><span class="line"></span><br><span class="line">        for (let referencePath of referencePaths) &#123;</span><br><span class="line">            referencePath.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;赋值字面量未改还原&quot;, &quot;删除 --&gt; 变量赋值与定义:&quot;, path + &#x27;&#x27;, binding.path + &#x27;&#x27;);</span><br><span class="line">        path.remove(); // 顺便还把形参为常量，但没有使用过的形参赋值也删了</span><br><span class="line">        binding.path.remove(); // 删除函数形参</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, restoreAssignment);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h2 id="五、函数相关插件"><a href="#五、函数相关插件" class="headerlink" title="五、函数相关插件"></a>五、函数相关插件</h2><h3 id="1-插件-内置函数调用还原"><a href="#1-插件-内置函数调用还原" class="headerlink" title="1. 插件 -&gt; 内置函数调用还原"></a>1. 插件 -&gt; 内置函数调用还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 万能调用表达式替换计算值插件</span><br><span class="line">// var a = &quot;motnahp&quot;[&quot;split&quot;](&#x27;&#x27;)[&quot;reverse&quot;]()[&quot;join&quot;](&#x27;&#x27;);    ===&gt;    var a = &quot;phantom&quot;;</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const callToStringLiteral = &#123;</span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; arguments &#125; = path.node;</span><br><span class="line">            if (!isNodeLiteral(arguments)) return;</span><br><span class="line">            try &#123;</span><br><span class="line">                let arr = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">                let flag = arr.every(ele =&gt; !path.toString().includes(ele));</span><br><span class="line">                if (!flag) return;</span><br><span class="line"></span><br><span class="line">                let value = eval(path.toString());</span><br><span class="line">                // if (typeof value != &quot;string&quot;) return; // 有时也需要还原为数字</span><br><span class="line">                console.log(path.toString(), &quot;--&gt;&quot;, value);</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToStringLiteral);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="2-插件-假函数体内容还原"><a href="#2-插件-假函数体内容还原" class="headerlink" title="2. 插件 -&gt; 假函数体内容还原"></a>2. 插件 -&gt; 假函数体内容还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 假函数体内容还原</span><br><span class="line">const untruthFuncContent = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; id, params, body &#125; = path.node;</span><br><span class="line">        if (params.length != 0 || body.body.length != 1 || !types.isExpressionStatement(body.body[0])) return;</span><br><span class="line"></span><br><span class="line">        let binding = path.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1 || !constant || referencePaths.length != 1) return;</span><br><span class="line">        let referPath = referencePaths[0]</span><br><span class="line">        let &#123; node, parentPath &#125; = referPath;</span><br><span class="line">        if (!parentPath.isCallExpression(&#123; callee: node &#125;)) return;</span><br><span class="line">        if (!parentPath.parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;假函数体内容还原:&quot;, path + &#x27;&#x27;);</span><br><span class="line">        parentPath.parentPath.replaceWith(body.body[0]);</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, untruthFuncContent);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="3-插件-ob-典型花指令还原"><a href="#3-插件-ob-典型花指令还原" class="headerlink" title="3. 插件 -&gt; ob 典型花指令还原"></a>3. 插件 -&gt; ob 典型花指令还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">// ob 典型花指令还原</span><br><span class="line">const reStoreUnaryExpressionOfReturn = &#123;</span><br><span class="line">    FunctionDeclaration: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; scope, node &#125; = path;</span><br><span class="line">            let &#123; id, params, body &#125; = node;</span><br><span class="line">            if (params.length != 1 || body.body.length != 1 || !types.isReturnStatement(body.body[0]) ||</span><br><span class="line">                !types.isUnaryExpression(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">            let &#123; operator, argument &#125; = body.body[0].argument;</span><br><span class="line">            if (!types.isIdentifier(argument)) return;</span><br><span class="line"></span><br><span class="line">            let binding = scope.getBinding(id.name);</span><br><span class="line">            if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">            let canRemoved = true;</span><br><span class="line">            for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referPath;</span><br><span class="line"></span><br><span class="line">                if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">                if (arguments.length != 1) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(parentPath.toString());</span><br><span class="line">                parentPath.replaceWith(types.UnaryExpression(operator, arguments[0], prefix = true));</span><br><span class="line">            &#125;</span><br><span class="line">            canRemoved &amp;&amp; path.remove();</span><br><span class="line">            path.stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reStoreBinaryExpressionOfReturn = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1 || !types.isReturnStatement(body.body[0]) ||</span><br><span class="line">            !types.isBinaryExpression(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; operator, left, right &#125; = body.body[0].argument;</span><br><span class="line">        if (!types.isIdentifier(left) || !types.isIdentifier(right)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">        let canRemoved = true;</span><br><span class="line">        for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">            let &#123; parentPath, node &#125; = referPath;</span><br><span class="line"></span><br><span class="line">            if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">            if (arguments.length != 2) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(parentPath.toString());</span><br><span class="line">            // console.log(&#x27;------&#x27;, parentPath.parentPath.parentPath.toString());</span><br><span class="line">            parentPath.replaceWith(types.BinaryExpression(operator, arguments[0], arguments[1]));</span><br><span class="line">        &#125;</span><br><span class="line">        canRemoved &amp;&amp; path.remove();</span><br><span class="line">        path.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reStoreArrayExpressionOfReturn = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 0 || body.body.length != 1 || !types.isReturnStatement(body.body[0]) ||</span><br><span class="line">            !types.isArrayExpression(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">        let canRemoved = true;</span><br><span class="line">        for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">            let &#123; parentPath, node &#125; = referPath;</span><br><span class="line"></span><br><span class="line">            if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">            if (arguments.length != 0) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(parentPath.toString());</span><br><span class="line">            // console.log(&#x27;------&#x27;, parentPath.parentPath.parentPath.toString());</span><br><span class="line">            parentPath.replaceWith(body.body[0].argument);</span><br><span class="line">        &#125;</span><br><span class="line">        canRemoved &amp;&amp; path.remove();</span><br><span class="line">        path.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, reStoreUnaryExpressionOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreBinaryExpressionOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreArrayExpressionOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、条件与逻辑表达式相关插件"><a href="#六、条件与逻辑表达式相关插件" class="headerlink" title="六、条件与逻辑表达式相关插件"></a>六、条件与逻辑表达式相关插件</h2><h3 id="1-嵌套在语句中的优化"><a href="#1-嵌套在语句中的优化" class="headerlink" title="1. 嵌套在语句中的优化"></a>1. 嵌套在语句中的优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 当条件表达式的父节点是赋值语句或者return语句时的优化</span><br><span class="line">// a = b ? c : d;   ===&gt;    b ? a = c : a = d;</span><br><span class="line">let retNODE = template(`if(A)&#123;return B;&#125;else&#123;return C;&#125;`);</span><br><span class="line">const TransConditionExpression = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isConditionalExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; test, consequent, alternate &#125; = right;</span><br><span class="line">        consequent = types.AssignmentExpression(operator, left, consequent);</span><br><span class="line">        alternate = types.AssignmentExpression(operator, left, alternate);</span><br><span class="line"></span><br><span class="line">        path.replaceWith(types.ConditionalExpression(test, consequent, alternate));</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;,</span><br><span class="line">    ReturnStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; argument &#125; = node;</span><br><span class="line">        if (!types.isConditionalExpression(argument)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; test, consequent, alternate &#125; = argument;</span><br><span class="line">        let retNode = retNODE(&#123; &quot;A&quot;: test, &quot;B&quot;: consequent, &quot;C&quot;: alternate &#125;)</span><br><span class="line">        path.replaceWith(retNode);</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, TransConditionExpression);</span><br></pre></td></tr></table></figure><h3 id="2-条件表达式转-if-语句"><a href="#2-条件表达式转-if-语句" class="headerlink" title="2. 条件表达式转 if 语句"></a>2. 条件表达式转 if 语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">// 条件表达式转 if 语句，支持嵌套的条件表达式，及子节点包含逗号表达式的情况</span><br><span class="line">const ConditionToIf = &#123;</span><br><span class="line">    ConditionalExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath, parent &#125; = path;</span><br><span class="line">        let &#123; test, consequent, alternate &#125; = node;</span><br><span class="line">        if (parentPath.isObjectProperty()) return;</span><br><span class="line"></span><br><span class="line">        if (parentPath.isAssignmentExpression(&#123; right: node &#125;)) &#123;</span><br><span class="line">            let &#123; left, operator, right &#125; = parent;</span><br><span class="line">            if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isConditionalExpression(right)) return;</span><br><span class="line">            let name = left.name;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(consequent)) &#123;</span><br><span class="line">                let lastExpression = consequent.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                consequent.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                retBody.push(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), lastExpression))</span><br><span class="line">                consequent = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent = types.ExpressionStatement(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), consequent));</span><br><span class="line">                consequent = types.BlockStatement([consequent]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(alternate)) &#123;</span><br><span class="line">                let lastExpression = alternate.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                alternate.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                retBody.push(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), lastExpression))</span><br><span class="line">                alternate = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternate = types.ExpressionStatement(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), alternate));</span><br><span class="line">                alternate = types.BlockStatement([alternate]);</span><br><span class="line">            &#125;</span><br><span class="line">            let ifStateNode = types.IfStatement(test, consequent, alternate);</span><br><span class="line">            parentPath.parentPath.replaceWith(ifStateNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (parentPath.isVariableDeclarator(&#123; init: node &#125;)) &#123;</span><br><span class="line">            let &#123; id, init &#125; = parent;</span><br><span class="line">            if (!types.isIdentifier(id) || !types.isConditionalExpression(init)) return;</span><br><span class="line">            let name = id.name;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(consequent)) &#123;</span><br><span class="line">                let lastExpression = consequent.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                consequent.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                let newNode = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), lastExpression)])</span><br><span class="line">                retBody.push(newNode)</span><br><span class="line">                consequent = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), consequent)]);</span><br><span class="line">                consequent = types.BlockStatement([consequent]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(alternate)) &#123;</span><br><span class="line">                let lastExpression = alternate.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                alternate.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                let newNode = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), lastExpression)])</span><br><span class="line">                retBody.push(newNode)</span><br><span class="line">                alternate = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternate = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), alternate)]);</span><br><span class="line">                alternate = types.BlockStatement([alternate]);</span><br><span class="line">            &#125;</span><br><span class="line">            let ifStateNode = types.IfStatement(test, consequent, alternate);</span><br><span class="line">            parentPath.parentPath.replaceWith(ifStateNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (types.isSequenceExpression(consequent)) &#123;</span><br><span class="line">                let retBody = [];</span><br><span class="line">                consequent.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)));</span><br><span class="line">                consequent = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent = types.ExpressionStatement(consequent);</span><br><span class="line">                consequent = types.BlockStatement([consequent]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(alternate)) &#123;</span><br><span class="line">                let retBody = [];</span><br><span class="line">                alternate.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)));</span><br><span class="line">                alternate = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternate = types.ExpressionStatement(alternate);</span><br><span class="line">                alternate = types.BlockStatement([alternate]);</span><br><span class="line">            &#125;</span><br><span class="line">            let ifStateNode = types.IfStatement(test, consequent, alternate);</span><br><span class="line">            parentPath.replaceWith(ifStateNode);</span><br><span class="line">        &#125;</span><br><span class="line">        path.skip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, ConditionToIf);</span><br></pre></td></tr></table></figure><h2 id="七、5s盾解混淆专题"><a href="#七、5s盾解混淆专题" class="headerlink" title="七、5s盾解混淆专题"></a>七、5s盾解混淆专题</h2><blockquote><p><strong>注意：新版 5s 盾是新版 ob 混淆特征，存在大数组函数、移位自执行函数（push shift关键字）、解密函数</strong></p></blockquote><h3 id="1-插件-还原调用表达式"><a href="#1-插件-还原调用表达式" class="headerlink" title="1. 插件 -&gt; 还原调用表达式"></a>1. 插件 -&gt; 还原调用表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ......代码环境</span><br><span class="line"></span><br><span class="line">// 执行需要的源代码</span><br><span class="line">const evalCode = &#123;</span><br><span class="line">    AssignmentExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; node &#125; = path;</span><br><span class="line">            let &#123; left, right, operator &#125; = node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; left.name.length == 2 &amp;&amp; operator == &#x27;=&#x27; &amp;&amp; types.isObjectExpression(right)) &#123;</span><br><span class="line">                eval(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; left.name.length == 2 &amp;&amp; operator == &#x27;=&#x27; &amp;&amp; types.isIdentifier(right, &#123; name: &#x27;b&#x27; &#125;)) &#123;</span><br><span class="line">                eval(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; left.name.length == 2 &amp;&amp; operator == &#x27;=&#x27; &amp;&amp; types.isIdentifier(right) &amp;&amp; right.name.length == 2) &#123;</span><br><span class="line">                eval(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, evalCode);</span><br><span class="line"></span><br><span class="line">const callToString = &#123;</span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parentPath, node, scope &#125; = path;</span><br><span class="line">            if (types.isIdentifier(node.callee) &amp;&amp; node.callee.name.length == 2 &amp;&amp; node.arguments.length == 1) &#123;</span><br><span class="line">                if (types.isNumericLiteral(node.arguments[0])) &#123;</span><br><span class="line">                    value = i9(node.arguments[0].value);</span><br><span class="line">                    console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                    path.replaceWith(types.valueToNode(value));</span><br><span class="line"></span><br><span class="line">                    // console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, eval(path.toString()));</span><br><span class="line">                    // path.replaceWith(types.StringLiteral(eval(path.toString())))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br></pre></td></tr></table></figure><h3 id="2-插件优化-插件1"><a href="#2-插件优化-插件1" class="headerlink" title="2. 插件优化 -&gt; 插件1"></a>2. 插件优化 -&gt; 插件1</h3><blockquote><p><strong>一个函数引用，通过多重的变量反复赋值，生成多个同引用不同函数名的调用，让需要被还原的函数超级多</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// ......代码环境</span><br><span class="line"></span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">var funcNameArr = [&#x27;b&#x27;]</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let &#123; name &#125; = left;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !funcNameArr.includes(right.name)) return;</span><br><span class="line">        funcNameArr.push(name)</span><br><span class="line"></span><br><span class="line">        let binding = path.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        const firstConstant = constantViolations[0];</span><br><span class="line">        let flag = constantViolations.every(constantPath =&gt; constantPath.toString() == firstConstant.toString());</span><br><span class="line">        if (!flag) return; // 在for循环中，函数执行两次，那么函数赋值就是两次，而这种情况也要还原，所以判断每次改变是否一样即可</span><br><span class="line"></span><br><span class="line">        let allCallFlag = 0;</span><br><span class="line">        let rebackFlag = 0;</span><br><span class="line">        referencePaths.forEach(element =&gt; &#123;</span><br><span class="line">            if (element.parentPath.isCallExpression()) &#123; ++allCallFlag; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 还原主要逻辑</span><br><span class="line">        for (let referencePath of referencePaths) &#123;</span><br><span class="line">            let &#123; parentPath &#125; = referencePath;</span><br><span class="line">            if (!parentPath.isCallExpression(&#123; callee: referencePath.node &#125;)) continue;</span><br><span class="line"></span><br><span class="line">            let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">            if (!isNodeLiteral(arguments)) continue;</span><br><span class="line"></span><br><span class="line">            let newCallExpression = types.callExpression(types.identifier(&#x27;b&#x27;), arguments);</span><br><span class="line">            let value = eval(generator(newCallExpression).code);</span><br><span class="line">            console.log(parentPath + &#x27;&#x27;, &quot;--&gt;&quot;, value, ++rebackFlag);</span><br><span class="line">            parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">        &#125;</span><br><span class="line">        if (rebackFlag == allCallFlag) &#123; // 如果还原的次数等于引用数组里所有调用表达式的个数，那么说明还原完了</span><br><span class="line">            console.log(&quot;删除无用节点:&quot;, binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            binding.path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br></pre></td></tr></table></figure><h3 id="3-插件-object-对象合并"><a href="#3-插件-object-对象合并" class="headerlink" title="3. 插件 -&gt; object 对象合并"></a>3. 插件 -&gt; object 对象合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// object对象合并</span><br><span class="line">const preDecodeObject = &#123;</span><br><span class="line">    // 针对OB混淆，5秒盾中都是赋值的，ob混淆中都是定义的</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, parent, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isObjectExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let properties = right.properties;</span><br><span class="line">        if (right.properties.length != 0) return;</span><br><span class="line"></span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isExpressionStatement()) break;</span><br><span class="line"></span><br><span class="line">            let expression = nextSibling.get(&#x27;expression&#x27;);</span><br><span class="line">            if (!expression.isAssignmentExpression(&#123; operator: &quot;=&quot; &#125;)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; left, right &#125; = expression.node;</span><br><span class="line">            if (!types.isMemberExpression(left)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; object, property &#125; = left;</span><br><span class="line">            if (!types.isIdentifier(object, &#123; name: name &#125;) || !types.isStringLiteral(property)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.push(types.ObjectProperty(property, right));</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, preDecodeObject);</span><br></pre></td></tr></table></figure><h3 id="4-插件-深拷贝赋值引用"><a href="#4-插件-深拷贝赋值引用" class="headerlink" title="4. 插件 -&gt; 深拷贝赋值引用"></a>4. 插件 -&gt; 深拷贝赋值引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝赋值引用</span><br><span class="line">const deepCopy = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isObjectExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let object = right;</span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isExpressionStatement()) break;</span><br><span class="line"></span><br><span class="line">            let expression = nextSibling.get(&#x27;expression&#x27;);</span><br><span class="line">            if (!expression.isAssignmentExpression(&#123; operator: &quot;=&quot; &#125;)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; left, right &#125; = expression.node;</span><br><span class="line">            if (!types.isIdentifier(left) || !types.isIdentifier(right, &#123; name: name &#125;)) break;</span><br><span class="line">            expression.node.right = object;</span><br><span class="line"></span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (references != 1 || constantViolations.length != 1) return;</span><br><span class="line">            if (constantViolations[0] == path) &#123;</span><br><span class="line">                console.log(&quot;深拷贝后删除无用节点与形参：&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, deepCopy);</span><br></pre></td></tr></table></figure><h3 id="5-插件-obj-对象-value-实现"><a href="#5-插件-obj-对象-value-实现" class="headerlink" title="5. 插件 -&gt; obj 对象 value 实现"></a>5. 插件 -&gt; obj 对象 value 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// object类型value字段的字面量和函数的还原</span><br><span class="line">// 保存对象中所有属性的特征到 Map 中</span><br><span class="line">function savePropertiesToObject(properties, newMap) &#123;</span><br><span class="line">    for (const property of properties) &#123;</span><br><span class="line">        if (!property.key) break; // ES6语法没有key</span><br><span class="line"></span><br><span class="line">        let propKey = property.key.value;</span><br><span class="line">        let propValue = property.value;</span><br><span class="line">        if (types.isStringLiteral(propValue)) &#123;</span><br><span class="line">            newMap.set(propKey, propValue.value); // 如果是字符串就直接存入字符串</span><br><span class="line">        &#125;</span><br><span class="line">        else if (types.isFunctionExpression(propValue)) &#123;</span><br><span class="line">            let retState = propValue.body.body; // 直接获取到 return 语句</span><br><span class="line">            if (retState.length == 1 &amp;&amp; types.isReturnStatement(retState[0])) &#123;</span><br><span class="line">                let argument = retState[0].argument;</span><br><span class="line">                if (types.isCallExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, &quot;Call&quot;); // 如果是调用表达式就存入 call 特证</span><br><span class="line">                &#125;</span><br><span class="line">                if (types.isBinaryExpression(argument) || types.isLogicalExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, argument.operator);</span><br><span class="line">                    // 如果是二项式表达式或者逻辑表达式，就存入 operator 操作符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历引用的地方，根据特征还原字符串或函数</span><br><span class="line">function replaceReferNode(newMap, referencePaths, scope) &#123;</span><br><span class="line">    for (const referPath of referencePaths.reverse()) &#123;</span><br><span class="line">        let &#123; node, parent, parentPath &#125; = referPath;</span><br><span class="line">        let ancestorPath = parentPath.parentPath; // 实参要通过祖先节点获取</span><br><span class="line">        if (!parentPath.isMemberExpression(&#123; object: node &#125;)) continue;</span><br><span class="line"></span><br><span class="line">        let property = parent.property;</span><br><span class="line">        let propKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">        let propValue = newMap.get(propKey);</span><br><span class="line">        if (!propValue) continue;</span><br><span class="line"></span><br><span class="line">        if (ancestorPath.isCallExpression(&#123; callee: parent &#125;)) &#123;</span><br><span class="line">            let &#123; arguments &#125; = ancestorPath.node;</span><br><span class="line">            switch (propValue) &#123;</span><br><span class="line">                case &quot;Call&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.CallExpression(arguments[0], arguments.slice(1)));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;||&quot;:</span><br><span class="line">                case &quot;&amp;&amp;&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.LogicalExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    ancestorPath.replaceWith(types.BinaryExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parentPath.replaceWith(types.valueToNode(propValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObject = &#123;</span><br><span class="line">    // AssignmentExpression对应5s盾，VariableDeclarator对应ob混淆</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isObjectExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; properties &#125; = right;</span><br><span class="line">        if (properties.length == 0) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line"></span><br><span class="line">        // Map 对象用于存储键值对，其中键和值都可以是任意类型；</span><br><span class="line">        // Map 保持键值对的插入顺序，这意味着迭代键值对时的顺序与插入它们时的顺序相同</span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        savePropertiesToObject(properties, newMap);</span><br><span class="line"></span><br><span class="line">        if (newMap.size != properties.length) return; // 判断一个对象中是否处理完所有key</span><br><span class="line">        try &#123;</span><br><span class="line">            replaceReferNode(newMap, referencePaths, scope);</span><br><span class="line">        &#125; catch &#123; &#125;;</span><br><span class="line">        scope.crawl();</span><br><span class="line"></span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;深拷贝后删除无用节点与形参:&quot;, path.toString());</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObject);</span><br></pre></td></tr></table></figure><h3 id="6-插件-处理平坦控制流"><a href="#6-插件-处理平坦控制流" class="headerlink" title="6. 插件 -&gt; 处理平坦控制流"></a>6. 插件 -&gt; 处理平坦控制流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 平坦控制流处理，switch-case语句</span><br><span class="line">const decode5sForSwitch = &#123;</span><br><span class="line">    &quot;ForStatement&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, praent, praentPath &#125; = path;</span><br><span class="line">        let &#123; test, body &#125; = node;</span><br><span class="line">        if (!types.isBooleanLiteral(test) || body.body.length != 2) return;</span><br><span class="line"></span><br><span class="line">        let [switchNode, breakNode] = body.body;</span><br><span class="line">        if (!types.isSwitchStatement(switchNode) || !types.isBreakStatement(breakNode)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; discriminant, cases &#125; = switchNode;</span><br><span class="line">        if (!types.isMemberExpression(discriminant)) return;</span><br><span class="line"></span><br><span class="line">        let arrName = switchNode.discriminant.object.name;</span><br><span class="line">        let binding = scope.getBinding(arrName);</span><br><span class="line">        if (!binding || !binding.path) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(&quot;处理平坦控制流:&quot;, arrName, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return; // 改变有多次，就不还原了</span><br><span class="line"></span><br><span class="line">        let &#123; left, right &#125; = constantViolations[0].node;</span><br><span class="line">        if (!types.isIdentifier(left) || !types.isCallExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; callee, arguments &#125; = right;</span><br><span class="line">        if (!types.isMemberExpression(callee) || arguments.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; object, property &#125; = callee;</span><br><span class="line">        if (!types.isStringLiteral(object) || !types.isStringLiteral(property, &#123; value: &#x27;split&#x27; &#125;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let disPatchArray = object.value.split(&#x27;|&#x27;);</span><br><span class="line">        let retBody = [];</span><br><span class="line">        disPatchArray.forEach(index =&gt; &#123;</span><br><span class="line">            let caseArr = cases[index].consequent;</span><br><span class="line">            if (types.isContinueStatement(caseArr[caseArr.length - 1])) &#123;</span><br><span class="line">                caseArr.pop() // 如果case中最后一条语句是continue语句，则删除最后一条</span><br><span class="line">            &#125;</span><br><span class="line">            retBody = retBody.concat(caseArr);</span><br><span class="line">        &#125;);</span><br><span class="line">        path.replaceWithMultiple(retBody);</span><br><span class="line">        if (references == 1) &#123;</span><br><span class="line">            constantViolations[0].remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decode5sForSwitch);</span><br><span class="line">ast = parser.parse(generator(ast).code);</span><br></pre></td></tr></table></figure><h2 id="八、OB解混淆专题"><a href="#八、OB解混淆专题" class="headerlink" title="八、OB解混淆专题"></a>八、OB解混淆专题</h2><blockquote><p><strong>ob混淆的注意事项（<a class="link"   href="https://obfuscator.io/"  target="_blank" rel="noopener">官方网址<i class="fas fa-external-link-alt"></i></a>）：</strong></p><ol><li><strong>代码格式化检测：</strong>通常在 <strong>大数组</strong>、<strong>移位自执行函数</strong> 或 <strong>解密函数</strong> 中，需要压缩为一行，否则运行会卡死</li><li><strong>解混淆数据值是乱码：</strong>通常是缺少了<strong>移位自执行函数</strong>对<strong>大数组</strong>元素进行正确排序，搜大数组名即可找到</li><li><strong>平坦控制流处理：</strong>在 ob 混淆的 switch-case 语句中，<strong>定位字符串分隔语句</strong>，可以通过 binding 绑定的 path 定位，因为 ob 的<strong>定义特性</strong>，在一个作用域中第一次出现的位置（定义），即是其绑定的 path</li></ol></blockquote><h3 id="1-插件-还原调用表达式-1"><a href="#1-插件-还原调用表达式-1" class="headerlink" title="1. 插件 -&gt; 还原调用表达式"></a>1. 插件 -&gt; 还原调用表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// 测试代码......</span><br><span class="line"></span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 收集所有需要还原的调用表达式对应的函数定义</span><br><span class="line">let decodeCode = &#x27;&#x27;;</span><br><span class="line">const collectObFuncs = &#123;</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; params, body &#125; = path.node;</span><br><span class="line">        if (params.length != 5 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isReturnStatement(body.body[0])) return;</span><br><span class="line">        decodeCode += path + &#x27;&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isVariableDeclaration()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isFunctionExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; params, body &#125; = init;</span><br><span class="line">        if (params.length != 5 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isReturnStatement(body.body[0])) return;</span><br><span class="line">        decodeCode += path + &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, collectObFuncs);</span><br><span class="line">eval(decodeCode); // 收集的函数为字符串，需要在这个 js 文件执行一次</span><br><span class="line">// 还原调用表达式</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    CallExpression(path) &#123;</span><br><span class="line">        let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">        if (!types.isIdentifier(callee) || arguments.length != 5 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">        value = eval(path + &#x27;&#x27;);</span><br><span class="line">        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">        path.replaceWith(types.valueToNode(value));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">// 删除没有调用的函数</span><br><span class="line">const removeNoCallFuncs = &#123;</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id &#125; = node;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;删除无用函数定义:&quot;, path.toString());</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isVariableDeclaration()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isFunctionExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;删除无用函数定义:&quot;, path.toString());</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ast = parser.parse(generator(ast).code);</span><br><span class="line">traverse(ast, removeNoCallFuncs); // 第一次是删除所有从未被调用的函数，此时刚刚还原的函数引用还存在</span><br><span class="line">ast = parser.parse(generator(ast).code);</span><br><span class="line">traverse(ast, removeNoCallFuncs); // 第二次删除的才是刚刚还原后，且没有地方再引用的函数</span><br></pre></td></tr></table></figure><h3 id="2-插件模版-插件1"><a href="#2-插件模版-插件1" class="headerlink" title="2. 插件模版 -&gt; 插件1"></a>2. 插件模版 -&gt; 插件1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 还原调用表达式</span><br><span class="line">const callToStringOb = &#123;</span><br><span class="line">    CallExpression(path) &#123;</span><br><span class="line">    let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; callee, arguments &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(callee) || arguments.length != 2 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">        value = eval(path + &#x27;&#x27;);</span><br><span class="line">        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">        path.replaceWith(types.valueToNode(value));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToStringOb);</span><br></pre></td></tr></table></figure><h3 id="3-插件-object-对象合并-1"><a href="#3-插件-object-对象合并-1" class="headerlink" title="3. 插件 -&gt; object 对象合并"></a>3. 插件 -&gt; object 对象合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// object对象合并</span><br><span class="line">const preDecodeObject = &#123;</span><br><span class="line">    // 针对OB混淆，ob混淆中都是定义的，5秒盾中都是赋值的</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, parentPath, scope &#125;=path;</span><br><span class="line">        const &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let properties = init.properties;</span><br><span class="line">        if (properties.length != 0) return;</span><br><span class="line">        </span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isExpressionStatement()) continue;</span><br><span class="line"></span><br><span class="line">            let expression = nextSibling.get(&#x27;expression&#x27;);</span><br><span class="line">            if (!expression.isAssignmentExpression(&#123; operator: &quot;=&quot; &#125;)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; left, right &#125; = expression.node;</span><br><span class="line">            if (!types.isMemberExpression(left)) break;</span><br><span class="line">            </span><br><span class="line">            let &#123; object, property &#125; = left;</span><br><span class="line">            if (!types.isIdentifier(object, &#123; name: name &#125;) || !types.isStringLiteral(property)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.push(types.ObjectProperty(property, right));</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, preDecodeObject);</span><br></pre></td></tr></table></figure><h3 id="4-插件-深拷贝赋值引用-1"><a href="#4-插件-深拷贝赋值引用-1" class="headerlink" title="4. 插件 -&gt; 深拷贝赋值引用"></a>4. 插件 -&gt; 深拷贝赋值引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝赋值引用</span><br><span class="line">const deepCopy = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let object = init;</span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isVariableDeclaration()) continue;</span><br><span class="line"></span><br><span class="line">            let declarations = nextSibling.get(&#x27;declarations&#x27;)[0];</span><br><span class="line">            if (!declarations.isVariableDeclarator()) break;</span><br><span class="line"></span><br><span class="line">            let &#123; id, init &#125; = declarations.node;</span><br><span class="line">            if (!types.isIdentifier(id) || !types.isIdentifier(init, &#123; name: name &#125;)) break;</span><br><span class="line">            declarations.node.init = object;</span><br><span class="line"></span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (references != 1 || !constant) return;</span><br><span class="line">            console.log(&quot;深拷贝赋值引用&quot;, &quot;删除 --&gt; 原对象:&quot;, id.name);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, deepCopy);</span><br></pre></td></tr></table></figure><h3 id="5-插件-obj-对象-value-实现-1"><a href="#5-插件-obj-对象-value-实现-1" class="headerlink" title="5. 插件 -&gt; obj 对象 value 实现"></a>5. 插件 -&gt; obj 对象 value 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// object类型value字段的字面量和函数的还原</span><br><span class="line">// 保存对象中所有属性的特征到 Map 中</span><br><span class="line">function savePropertiesToObject(properties, newMap) &#123;</span><br><span class="line">    for (const property of properties) &#123;</span><br><span class="line">        if (!property.key) break; // ES6语法没有key</span><br><span class="line"></span><br><span class="line">        let propKey = property.key.value;</span><br><span class="line">        let propValue = property.value;</span><br><span class="line">        if (types.isStringLiteral(propValue)) &#123;</span><br><span class="line">            newMap.set(propKey, propValue.value); // 如果是字符串就直接存入字符串</span><br><span class="line">        &#125;</span><br><span class="line">        else if (types.isFunctionExpression(propValue)) &#123;</span><br><span class="line">            let retState = propValue.body.body; // 直接获取到 return 语句</span><br><span class="line">            if (retState.length == 1 &amp;&amp; types.isReturnStatement(retState[0])) &#123;</span><br><span class="line">                let argument = retState[0].argument;</span><br><span class="line">                if (types.isCallExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, &quot;Call&quot;); // 如果是调用表达式就存入 call 特证</span><br><span class="line">                &#125;</span><br><span class="line">                if (types.isBinaryExpression(argument) || types.isLogicalExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, argument.operator);</span><br><span class="line">                    // 如果是二项式表达式或者逻辑表达式，就存入 operator 操作符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历引用的地方，根据特征还原字符串或函数</span><br><span class="line">function replaceReferNode(newMap, referencePaths, scope) &#123;</span><br><span class="line">    for (const referPath of referencePaths.reverse()) &#123;</span><br><span class="line">        let &#123; node, parent, parentPath &#125; = referPath;</span><br><span class="line">        let ancestorPath = parentPath.parentPath; // 实参要通过祖先节点获取</span><br><span class="line">        if (!parentPath.isMemberExpression(&#123; object: node &#125;)) continue;</span><br><span class="line"></span><br><span class="line">        let property = parent.property;</span><br><span class="line">        let propKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">        let propValue = newMap.get(propKey);</span><br><span class="line">        if (!propValue) continue;</span><br><span class="line"></span><br><span class="line">        if (ancestorPath.isCallExpression(&#123; callee: parent &#125;)) &#123;</span><br><span class="line">            let &#123; arguments &#125; = ancestorPath.node;</span><br><span class="line">            switch (propValue) &#123;</span><br><span class="line">                case &quot;Call&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.CallExpression(arguments[0], arguments.slice(1)));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;||&quot;:</span><br><span class="line">                case &quot;&amp;&amp;&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.LogicalExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    ancestorPath.replaceWith(types.BinaryExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parentPath.replaceWith(types.valueToNode(propValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObject = &#123;</span><br><span class="line">    // VariableDeclarator对应ob混淆，AssignmentExpression对应5s盾</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isVariableDeclaration()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; properties &#125; = init;</span><br><span class="line">        if (properties.length == 0) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (!constant) return;</span><br><span class="line"></span><br><span class="line">        // Map 对象用于存储键值对，其中键和值都可以是任意类型；</span><br><span class="line">        // Map 保持键值对的插入顺序，这意味着迭代键值对时的顺序与插入它们时的顺序相同</span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        savePropertiesToObject(properties, newMap);</span><br><span class="line"></span><br><span class="line">        if (newMap.size != properties.length) return; // 判断一个对象中是否处理完所有key</span><br><span class="line">        try &#123;</span><br><span class="line">            replaceReferNode(newMap, referencePaths, scope);</span><br><span class="line">            console.log(&quot;obj对象value实现&quot;, &quot;删除 --&gt; 已还原对象:&quot;, id.name);</span><br><span class="line">            path.remove(); // 上面遍历了所有引用，并且还原，那么就没有引用的地方了，直接删除即可</span><br><span class="line">        &#125; catch &#123; &#125;;</span><br><span class="line"></span><br><span class="line">        newMap.clear();</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObject);</span><br></pre></td></tr></table></figure><h3 id="6-插件-处理平坦控制流-1"><a href="#6-插件-处理平坦控制流-1" class="headerlink" title="6. 插件 -&gt; 处理平坦控制流"></a>6. 插件 -&gt; 处理平坦控制流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 平坦控制流处理，switch-case语句</span><br><span class="line">const decodeObWhileSwitch = &#123;</span><br><span class="line">    &quot;WhileStatement&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, praent, praentPath &#125; = path;</span><br><span class="line">        let &#123; test, body &#125; = node;</span><br><span class="line">        if (!types.isBooleanLiteral(test) || body.body.length != 2) return;</span><br><span class="line"></span><br><span class="line">        let [switchNode, breakNode] = body.body;</span><br><span class="line">        if (!types.isSwitchStatement(switchNode) || !types.isBreakStatement(breakNode)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; discriminant, cases &#125; = switchNode;</span><br><span class="line">        if (!types.isMemberExpression(discriminant)) return;</span><br><span class="line"></span><br><span class="line">        let arrName = switchNode.discriminant.object.name;</span><br><span class="line">        let binding = scope.getBinding(arrName);</span><br><span class="line">        if (!binding || !binding.path || !binding.path.isVariableDeclarator()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(&quot;处理平坦控制流:&quot;, arrName, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = binding.path.node; // 绑定的 path 就是在这个作用域中第一次出现（定义）的位置</span><br><span class="line">        if (!types.isIdentifier(id, &#123; name: arrName &#125;) || !types.isCallExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; callee, arguments &#125; = init;</span><br><span class="line">        if (!types.isMemberExpression(callee) || arguments.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; object, property &#125; = callee;</span><br><span class="line">        if (!types.isStringLiteral(object) || !types.isStringLiteral(property, &#123; value: &#x27;split&#x27; &#125;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let disPatchArray = object.value.split(&#x27;|&#x27;);</span><br><span class="line">        let retBody = [];</span><br><span class="line">        disPatchArray.forEach(index =&gt; &#123;</span><br><span class="line">            let caseArr = cases[index].consequent;</span><br><span class="line">            if (types.isContinueStatement(caseArr[caseArr.length - 1])) &#123;</span><br><span class="line">                caseArr.pop() // 如果case中最后一条语句是continue语句，则删除最后一条</span><br><span class="line">            &#125;</span><br><span class="line">            retBody = retBody.concat(caseArr);</span><br><span class="line">        &#125;);</span><br><span class="line">        path.replaceWithMultiple(retBody);</span><br><span class="line">        if (references == 1 &amp;&amp; (constant || constantViolations[0] == binding.path)) &#123;</span><br><span class="line">            // 在 for 循环中的变量定义，其绑定中会被记录为改变了一次</span><br><span class="line">            binding.path.remove()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObWhileSwitch);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h2 id="九、重点AST还原专题"><a href="#九、重点AST还原专题" class="headerlink" title="九、重点AST还原专题"></a>九、重点AST还原专题</h2><h3 id="0-模版-常用-banding-写法"><a href="#0-模版-常用-banding-写法" class="headerlink" title="0. 模版 -&gt; 常用 banding 写法"></a>0. 模版 -&gt; 常用 banding 写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let binding = scope.getBinding(name);</span><br><span class="line">if (!binding) return;</span><br><span class="line">let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">// console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">if (constantViolations.length &gt; 1) return;</span><br><span class="line">if (constant || constantViolations[0] == binding.path) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="1-案例-复杂控制流还原"><a href="#1-案例-复杂控制流还原" class="headerlink" title="1. 案例 -&gt; 复杂控制流还原"></a>1. 案例 -&gt; 复杂控制流还原</h3><blockquote><p><strong>encode.js 特征：</strong></p><ol><li>每一个 case 语句最后一段代码，都是 break 语句</li><li>没有 default 语句</li><li>每一个 case 语句的倒数第二段代码，是指向下一个 case 语句的 test、条件表达式、或者是 return 语句</li></ol><p><strong>还原思路：</strong></p><ol><li>给 return 语句的后面加上 break 语句，方便统一处理</li><li>先处理单线控制，即指向当前 case 的语句个数只有一个，则将当前语句与上一个 case 语句单线合并</li><li>再处理条件表达式，还原为 while 循环并删除 case 语句</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">function test(cU, cV) &#123;</span><br><span class="line">    var guagua = &quot;呱呱&quot;;</span><br><span class="line">    var cW = 1;</span><br><span class="line"></span><br><span class="line">    while (cW !== 0) &#123;</span><br><span class="line">        switch (cW) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                var cZ = [];</span><br><span class="line">                cW = 5;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 2:</span><br><span class="line">                cW = d0 &lt; cU ? 7 : 3;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 3:</span><br><span class="line">                cW = d1 &lt; cU ? 8 : 4;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 4:</span><br><span class="line">                return cZ;</span><br><span class="line"></span><br><span class="line">            case 5:</span><br><span class="line">                var d0 = 0;</span><br><span class="line">                cW = 6;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 6:</span><br><span class="line">                var d1 = 0;</span><br><span class="line">                cW = 2;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 7:</span><br><span class="line">                cZ[(d0 + cV) % cU] = [];</span><br><span class="line">                cW = 9;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 8:</span><br><span class="line">                var d2 = cU - 1;</span><br><span class="line">                cW = 10;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 9:</span><br><span class="line">                d0++;</span><br><span class="line">                cW = 2;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 10:</span><br><span class="line">                cW = d2 &gt;= 0 ? 12 : 11;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 11:</span><br><span class="line">                d1++;</span><br><span class="line">                cW = 3;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 12:</span><br><span class="line">                cZ[d1][(d2 + cV * d1) % cU] = cZ[d2];</span><br><span class="line">                cW = 13;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 13:</span><br><span class="line">                d2--;</span><br><span class="line">                cW = 10;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>手动还原：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function test(cU, cV) &#123;</span><br><span class="line">var guagua = &quot;呱呱&quot;;</span><br><span class="line">var cW = 1;</span><br><span class="line"></span><br><span class="line">var cZ = [];</span><br><span class="line">var d0 = 0;</span><br><span class="line">var d1 = 0;</span><br><span class="line">while (d0 &lt; cU) &#123;</span><br><span class="line">cZ[(d0 + cV) % cU] = [];</span><br><span class="line">d0++;</span><br><span class="line">&#125;</span><br><span class="line">while (d1 &lt; cU) &#123;</span><br><span class="line">var d2 = cU - 1;</span><br><span class="line">while (d2 &gt;= 0) &#123;</span><br><span class="line">cZ[d1][(d2 + cV * d1) % cU] = cZ[d2];</span><br><span class="line">d2--;</span><br><span class="line">&#125;</span><br><span class="line">d1++;</span><br><span class="line">&#125;</span><br><span class="line">return cZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>AST 还原：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// 给case语句结尾统一加上 break 语句，有则不加</span><br><span class="line">const addBreakStatement = &#123;</span><br><span class="line">    SwitchCase(&#123; node &#125;) &#123;</span><br><span class="line">        let &#123; test, consequent &#125; = node;</span><br><span class="line">        if (types.isBreakStatement(consequent[consequent.length - 1])) return;</span><br><span class="line">        consequent.push(types.breakStatement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, addBreakStatement)</span><br><span class="line">// 函数：根据case的test条件，获取对应case的node节点，还可以判断是否删除节点</span><br><span class="line">function getItemFromTestValue(path, testValue, is_remove) &#123;</span><br><span class="line">    let &#123; cases &#125; = path.node;</span><br><span class="line">    for (let caseIndex in cases) &#123;</span><br><span class="line">        let caseItem = cases[caseIndex];</span><br><span class="line">        if (caseItem.test.value == testValue) &#123;</span><br><span class="line">            if (is_remove) &#123;</span><br><span class="line">                return cases.splice(caseIndex, 1)[0]; // 从当前索引开始删除一个元素，并返回被删除的元素数组</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return caseItem</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const dealWithSwitch = &#123;</span><br><span class="line">    SwitchStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; cases &#125; = node;</span><br><span class="line">        // 不管switch从哪里开始，先单线合并，再处理条件表达式并用while循环替换</span><br><span class="line">        for (let i = 0; i &lt; cases.length; i++) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = cases[i];</span><br><span class="line">            let jumpTo = consequent[consequent.length - 2].expression; // 控制case跳转的赋值语句</span><br><span class="line">            if (!types.isAssignmentExpression(jumpTo)) continue;</span><br><span class="line"></span><br><span class="line">            // 1. 当跳转语句的右节点是字面量时</span><br><span class="line">            if (types.isLiteral(jumpTo.right)) &#123;</span><br><span class="line">                // 数组的长度含义：代表指向下一个case块的赋值语句的数量，即被指向的csae块有几次引用</span><br><span class="line">                let newArr = cases.filter(element =&gt; &#123;</span><br><span class="line">                    let jumpto = element.consequent[element.consequent.length - 2].expression</span><br><span class="line">                    return generator(jumpto).code == generator(jumpTo).code;</span><br><span class="line">                &#125;);</span><br><span class="line">                // 如果只有一次，则可以合并</span><br><span class="line">                if (newArr.length == 1) &#123;</span><br><span class="line">                    let nextItem = getItemFromTestValue(path, jumpTo.right.value, true);</span><br><span class="line">                    let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                    consequent.splice(consequent.length - 2, 2, ...nextItemConsequent)</span><br><span class="line">                    i = -1; // 每合并一次又从头遍历，因为被合并过的语句块可能还需要再次合并</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 当跳转语句的右节点是条件表达式时</span><br><span class="line">            if (types.isConditionalExpression(jumpTo.right)) &#123;</span><br><span class="line">                let nextTest = jumpTo.right.test</span><br><span class="line">                let nextConsequent = jumpTo.right.consequent</span><br><span class="line">                let nextAlternate = jumpTo.right.alternate</span><br><span class="line"></span><br><span class="line">                let nextItem = getItemFromTestValue(path, nextConsequent.value, false);</span><br><span class="line">                let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                let nextJumpTo = nextItemConsequent[nextItemConsequent.length - 2].expression</span><br><span class="line">                if (!types.isAssignmentExpression(nextJumpTo) || !types.isLiteral(nextJumpTo.right)) continue;</span><br><span class="line"></span><br><span class="line">                if (nextJumpTo.right.value == test.value) &#123;</span><br><span class="line">                    let bodyNode = nextItemConsequent.slice(0, nextItemConsequent.length - 2);</span><br><span class="line">                    let whileNode = types.whileStatement(nextTest, types.blockStatement(bodyNode));</span><br><span class="line">                    consequent.splice(consequent.length - 2, 0, whileNode); // 删除0，则表示插入while语句</span><br><span class="line"></span><br><span class="line">                    getItemFromTestValue(path, nextConsequent.value, true);</span><br><span class="line">                    jumpTo.right = nextAlternate;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 还原到最后，只剩一层case语句，则可以将整段代码从switch中脱离出来</span><br><span class="line">        if (cases.length == 1) &#123;</span><br><span class="line">            let caseNode = cases[0].consequent;</span><br><span class="line">            if (types.isBreakStatement(caseNode[caseNode.length - 1])) &#123;</span><br><span class="line">                caseNode.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            parentPath.parentPath.replaceWithMultiple(caseNode);</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, dealWithSwitch);</span><br></pre></td></tr></table></figure><h3 id="2-案例优化-复杂控制流还原"><a href="#2-案例优化-复杂控制流还原" class="headerlink" title="2. 案例优化 -&gt; 复杂控制流还原"></a>2. 案例优化 -&gt; 复杂控制流还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">// 函数：根据case的test条件，获取对应case的node节点，还可以判断是否删除节点</span><br><span class="line">function getItemFromTestValue(path, testValue, is_remove) &#123;</span><br><span class="line">    let &#123; cases &#125; = path.node;</span><br><span class="line">    for (let caseIndex in cases) &#123;</span><br><span class="line">        let caseItem = cases[caseIndex];</span><br><span class="line">        if (caseItem.test.value == testValue) &#123;</span><br><span class="line">            if (is_remove) &#123;</span><br><span class="line">                return cases.splice(caseIndex, 1)[0]; // 从当前索引开始删除一个元素，并返回被删除的元素数组</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return caseItem</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const dealWithSwitch = &#123;</span><br><span class="line">    SwitchStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; discriminant, cases &#125; = node;</span><br><span class="line">        let name = discriminant.name;</span><br><span class="line"></span><br><span class="line">        /* 获取 switch-case 的初始case条件，通常在外层 for 循环的init中定义</span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (!binding.path.isVariableDeclarator() &amp;&amp; !binding.path.isAssignmentExpression()) return;</span><br><span class="line">            if (binding.path.isVariableDeclarator() &amp;&amp; (startValue = binding.path.node.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">            if (binding.path.isAssignmentExpression() &amp;&amp; (startValue = binding.path.node.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        */</span><br><span class="line">        if (!parentPath.parentPath.isForStatement()) return;</span><br><span class="line">        let &#123; init &#125; = parentPath.parentPath.node;</span><br><span class="line">        init = types.isVariableDeclaration(init) ? init.declarations[init.declarations.length - 1] : init;</span><br><span class="line">        if (!types.isVariableDeclarator(init) &amp;&amp; !types.isAssignmentExpression(init)) return;</span><br><span class="line">        if (types.isVariableDeclarator(init) &amp;&amp; (startValue = init.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        if (types.isAssignmentExpression(init) &amp;&amp; (startValue = init.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line"></span><br><span class="line">        // 不管switch从哪里开始，先单线合并，再处理条件表达式并用while循环替换</span><br><span class="line">        for (let i = 0; i &lt; cases.length; i++) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = cases[i];</span><br><span class="line">            let jumpTo = consequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">            jumpTo = jumpTo[jumpTo.length - 1] ? jumpTo[jumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">            if (!types.isAssignmentExpression(jumpTo) || !types.isIdentifier(jumpTo.left, &#123; name: name &#125;)) continue;</span><br><span class="line"></span><br><span class="line">            // console.log(path + &#x27;&#x27;); // 打印出整个处理过程，用于调试</span><br><span class="line"></span><br><span class="line">            // 1. 当跳转语句的右节点是字面量时</span><br><span class="line">            if (types.isLiteral(jumpTo.right)) &#123;</span><br><span class="line">                // 数组的长度含义：代表指向下一个case块的赋值语句的数量，即被指向的csae块有几次引用</span><br><span class="line">                let newArr = cases.filter(ele =&gt; &#123;</span><br><span class="line">                    let jumpto = ele.consequent.filter(element =&gt; generator(element).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                    jumpto = jumpto[jumpto.length - 1] ? jumpto[jumpto.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                    return generator(jumpto).code == generator(jumpTo).code;</span><br><span class="line">                &#125;);</span><br><span class="line">                // 如果只有一次，则可以合并</span><br><span class="line">                if (newArr.length == 1) &#123;</span><br><span class="line">                    let nextItem = getItemFromTestValue(path, jumpTo.right.value, true);</span><br><span class="line">                    let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                    // --------******** 特别注意：每个case替换的行数由实际情况而定 ********--------</span><br><span class="line">                    // 经过测试：下一个case中只有一条语句 break; 时运行正常，但是如果是控制case跳转的赋值语句，就会还原错误</span><br><span class="line">                    consequent.splice(consequent.length - 2, 2, ...nextItemConsequent);</span><br><span class="line"></span><br><span class="line">                    i = -1; // 每合并一次又从头遍历，因为被合并过的语句块可能还需要再次合并</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 当跳转语句的右节点是条件表达式时</span><br><span class="line">            if (types.isConditionalExpression(jumpTo.right)) &#123;</span><br><span class="line">                let newTest = jumpTo.right.test</span><br><span class="line">                let newConsequent = jumpTo.right.consequent</span><br><span class="line">                let newAlternate = jumpTo.right.alternate</span><br><span class="line"></span><br><span class="line">                let nextItem = getItemFromTestValue(path, newConsequent.value, false);</span><br><span class="line">                let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                let nextJumpTo = nextItemConsequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                nextJumpTo = nextJumpTo[nextJumpTo.length - 1] ? nextJumpTo[nextJumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                if (!types.isAssignmentExpression(nextJumpTo) || !types.isLiteral(nextJumpTo.right)) continue;</span><br><span class="line"></span><br><span class="line">                if (nextJumpTo.right.value == test.value) &#123;</span><br><span class="line">                    let bodyNode = nextItemConsequent.slice(0, nextItemConsequent.length - 2); // 截取有效内容</span><br><span class="line">                    let whileNode = types.whileStatement(newTest, types.blockStatement(bodyNode));</span><br><span class="line">                    consequent.splice(consequent.length - 2, 0, whileNode); // 删除0，则表示插入while语句</span><br><span class="line"></span><br><span class="line">                    getItemFromTestValue(path, newConsequent.value, true);</span><br><span class="line">                    jumpTo.right = newAlternate;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 还原到最后，将有效代码从switch中脱离出来</span><br><span class="line">        for (let item of cases) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = item;</span><br><span class="line">            if (test.value == startValue.value) &#123;</span><br><span class="line">                let lastSta = consequent[consequent.length - 1];</span><br><span class="line">                if (types.isBreakStatement(lastSta) || types.isContinueStatement(lastSta)) &#123;</span><br><span class="line">                    consequent.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                parentPath.parentPath.replaceWithMultiple(consequent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, dealWithSwitch);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="3-模版-预处理解混淆模版"><a href="#3-模版-预处理解混淆模版" class="headerlink" title="3. 模版 -&gt; 预处理解混淆模版"></a>3. 模版 -&gt; 预处理解混淆模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">// 1. 编码还原十进制</span><br><span class="line">const simplifyLiteral = &#123;</span><br><span class="line">    NumericLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /^0[obx]/i.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    StringLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /\\[ux]/gi.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, simplifyLiteral);</span><br><span class="line"></span><br><span class="line">// 2. 分离多个变量同定义</span><br><span class="line">// var a, b, c;     ===&gt;     var a; var b; var c;</span><br><span class="line">const DeclaratorToDeclaration = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 避免处理那些在非块级节点内的变量声明`if (true) let a, b;`</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length == 1) return;</span><br><span class="line"></span><br><span class="line">        let newNodes = [];</span><br><span class="line">        for (let varNode of declarations) &#123;</span><br><span class="line">            let newDeclarationNode = types.variableDeclaration(kind, [varNode]);</span><br><span class="line">            newNodes.push(newDeclarationNode);</span><br><span class="line">        &#125;</span><br><span class="line">        path.replaceWithMultiple(newNodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, DeclaratorToDeclaration);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 3. 由变量定义的函数表达式，统一还原为函数定义</span><br><span class="line">// var a =function()&#123;&#125;     ===&gt;     function a()&#123;&#125;</span><br><span class="line">const varDeclarToFuncDeclar = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, scope &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 过滤掉部分特殊情况，例如for循环里的变量定义</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = declarations[0];</span><br><span class="line">        if (!types.isFunctionExpression(init, &#123; id: null &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; params, body &#125; = init;</span><br><span class="line">        let newNode = types.functionDeclaration(id, params, body);</span><br><span class="line">        path.replaceWith(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, varDeclarToFuncDeclar);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 4. 美化循环语句和 if-else 语句，并简化逻辑</span><br><span class="line">const SimplifyLoopAndIf = &#123;</span><br><span class="line">    &quot;ForStatement|WhileStatement|ForInStatement|ForOfStatement&quot;(&#123; node &#125;) &#123;</span><br><span class="line">        if (!types.isBlockStatement(node.body)) &#123;</span><br><span class="line">            node.body = types.blockStatement([node.body]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IfStatement&quot;(path) &#123;</span><br><span class="line">        const test = path.get(&quot;test&quot;);</span><br><span class="line">        const consequent = path.get(&quot;consequent&quot;);</span><br><span class="line">        const alternate = path.get(&quot;alternate&quot;);</span><br><span class="line">        const evaluateTest = test.evaluateTruthy();</span><br><span class="line"></span><br><span class="line">        if (!consequent.isBlockStatement() &amp;&amp; !consequent.isEmptyStatement()) &#123;</span><br><span class="line">            consequent.replaceWith(types.blockStatement([consequent.node]));</span><br><span class="line">        &#125;</span><br><span class="line">        if (alternate.node !== null &amp;&amp; !alternate.isBlockStatement() &amp;&amp; !alternate.isEmptyStatement()) &#123;</span><br><span class="line">            alternate.replaceWith(types.blockStatement([alternate.node]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (consequent.isEmptyStatement() || consequent.node.body.length == 0) &#123;</span><br><span class="line">            if (alternate.node == null || alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                path.replaceWith(test.node);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent.replaceWith(alternate.node);</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">                test.replaceWith(types.unaryExpression(&quot;!&quot;, test.node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (alternate.node != null) &#123;</span><br><span class="line">            if (alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            path.replaceWithMultiple(consequent.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (evaluateTest === false) &#123;</span><br><span class="line">            (alternate.node === null || alternate.node.body.length == 0) ? path.remove() : path.replaceWithMultiple(alternate.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, SimplifyLoopAndIf);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 5. 去除逗号表达式1</span><br><span class="line">const resolveSequence1 = &#123;</span><br><span class="line">    SequenceExpression(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, parent &#125; = path;</span><br><span class="line">        if (parentPath.parentPath.isLabeledStatement()) return; // 标签节点无法往前插入</span><br><span class="line">        let ancestorPath = parentPath.parentPath;</span><br><span class="line">        let expressions = node.expressions;</span><br><span class="line"></span><br><span class="line">        // 把 (0, xxx) 的逗号表达式直接替换为本身</span><br><span class="line">        if (parentPath.isCallExpression(&#123; callee: node &#125;) &amp;&amp; expressions.length == 2 &amp;&amp; types.isNumericLiteral(expressions[0], &#123; value: 0 &#125;)) &#123;</span><br><span class="line">            path.replaceWith(expressions[1])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentPath.isReturnStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isThrowStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isIfStatement(&#123; &#x27;test&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isWhileStatement(&#123; &quot;test&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForInStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForOfStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isSwitchStatement(&#123; &quot;discriminant&quot;: node &#125;) ||</span><br><span class="line">            (parentPath.isConditionalExpression(&#123; &quot;test&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isUnaryExpression(&#123; &quot;argument&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isAssignmentExpression(&#123; &quot;right&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            ((parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;) || parentPath.isNewExpression(&#123; &quot;callee&quot;: node &#125;)) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            parentPath.isLogicalExpression(&#123; &#x27;left&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isExpressionStatement(&#123; &quot;expression&quot;: node &#125;)) &#123;</span><br><span class="line"></span><br><span class="line">            let lastExpression = expressions.pop(); // 取出最后一个表达式</span><br><span class="line">            // 将前面的每个表达式都插入到父节点之前，作为单独的 ExpressionStatement</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                parentPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 for 循环的init处的所有逗号表达式都提出来</span><br><span class="line">        else if (parentPath.isForStatement(&#123; &#x27;init&#x27;: node &#125;)) &#123;</span><br><span class="line">            node.expressions.forEach(express =&gt; &#123; parentPath.insertBefore(types.expressionStatement(express)); &#125;);</span><br><span class="line">            path.remove();;</span><br><span class="line">        &#125;</span><br><span class="line">        // 变量定义应该插入到声明之前，不然会有问题</span><br><span class="line">        else if (parentPath.isVariableDeclarator(&#123; &quot;init&quot;: node &#125;) &amp;&amp; ancestorPath.isVariableDeclaration() &amp;&amp; ancestorPath.parentPath.isBlock()) &#123;</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line"></span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ancestorPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 逻辑表达式中的处理，不管父节点符号是&amp;&amp;还是||，左边都可以直接还原，右边则需判断</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;&amp;&amp;&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement(ifBody), null)</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        // js中逻辑或运算符 || 使用了短路求值，如果 || 运算符的左操作数为 true，右操作数将不会被计算或执行</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;||&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement([]), types.blockStatement(ifBody))</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, resolveSequence1);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 6. 字面量化成员表达式 `b.length` ==&gt; `b[&#x27;length&#x27;]`</span><br><span class="line">const keyToLiteral = &#123;</span><br><span class="line">    MemberExpression: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const prop = node.property;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(prop)) &#123;</span><br><span class="line">                node.property = types.stringLiteral(prop.name)</span><br><span class="line">                node.computed = true; // 只有当使用中括号调用才为true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 对象的 key 也由标识符转为字面量</span><br><span class="line">    ObjectProperty: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const key = node.key;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(key)) &#123;</span><br><span class="line">                node.key = types.stringLiteral(key.name);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.computed &amp;&amp; types.isStringLiteral(key)) &#123;</span><br><span class="line">                node.computed = false; // 不是通过计算得来的，computed为false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, keyToLiteral);</span><br><span class="line"></span><br><span class="line">// 7. object对象的value值全部为字面量时的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObjectofValue = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, scope &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let properties = init.properties;</span><br><span class="line">        if (properties.length == 0 || !properties.every(property =&gt; isBaseLiteral(property.value))) return;</span><br><span class="line"></span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        for (const property of properties) &#123;</span><br><span class="line">            let &#123; key, value &#125; = property;</span><br><span class="line">            let KeyName = types.isIdentifier(key) ? key.name : key.value;</span><br><span class="line"></span><br><span class="line">            newMap.set(KeyName, value);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newMap.size != properties.length) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            let flag = false; // 用于标志当前对象是否可以删除</span><br><span class="line">            for (const referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isMemberExpression()) break;</span><br><span class="line"></span><br><span class="line">                let AncestorPath = parentPath.parentPath;</span><br><span class="line">                if (AncestorPath.isAssignmentExpression(&#123; &quot;left&quot;: parentPath.node &#125;)) &#123;</span><br><span class="line">                    break; // 特殊引用，其实是赋值 obj[&#x27;c&#x27;] = 789;，有赋值肯定直接取消还原</span><br><span class="line">                &#125;</span><br><span class="line">                if (AncestorPath.isUpdateExpression() &amp;&amp; [&#x27;++&#x27;, &#x27;--&#x27;].includes(AncestorPath.node.operator)) &#123;</span><br><span class="line">                    break; // 同理，有自增自减的操作，等同于赋值，也取消还原</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let &#123; property &#125; = parentPath.node;</span><br><span class="line">                let curKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">                if (!newMap.has(curKey)) break;</span><br><span class="line"></span><br><span class="line">                flag = true;</span><br><span class="line">                parentPath.replaceWith(newMap.get(curKey))</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                console.log(&quot;对象 val 值全为常量&quot;, &quot;删除 --&gt; 对象定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObjectofValue);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 8. 合并变量声明与定义</span><br><span class="line">// var a, b, c; a = 1; b = 2; c = 3;    ===&gt;    var a = 1, b = 2, c = 3;</span><br><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const combinDefineAndNextAssgin = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (init != null) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line">        if (!constantViolations[0].isAssignmentExpression()) return;</span><br><span class="line">        if (constantViolations[0].parentPath.isConditionalExpression() || constantViolations[0].parentPath.isLogicalExpression()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = constantViolations[0].node</span><br><span class="line">        if (!types.isIdentifier(left, &#123; name: name &#125;) || operator != &#x27;=&#x27; || !isNodeLiteral(right)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.set(&quot;init&quot;, right);</span><br><span class="line">        constantViolations[0].remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 9. 变量初始化为字面量，且没有修改的还原</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (parentPath.parentPath.isForStatement() || parentPath.find((p) =&gt; p.isSwitchCase())) return;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 10. 通用还原纯函数调用表达式</span><br><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line"></span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 主要还原逻辑</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    &quot;CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">            let &#123; name &#125; = callee;</span><br><span class="line">            if (!types.isIdentifier(callee) || arguments.length == 0 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">            let binding = path.scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line"></span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            // 1. 当 binding.path 为函数时，只能还原纯函数</span><br><span class="line">            try &#123;</span><br><span class="line">                if (binding.path.isFunctionDeclaration()) &#123;</span><br><span class="line">                    // console.log(binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                    // ******** 为解决下面在 binding.path 为赋值语句时的还原中，不还原其本身的调用表达式的问题 ******** </span><br><span class="line">                    if (decryptCode.includes(binding.path.toString().match(/function\s+\w+\s*\([^)]*\)/g)[0])) &#123;</span><br><span class="line"></span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!isPureFunction(binding.path)) return; // 判断函数是否是纯函数，不是则不处理</span><br><span class="line"></span><br><span class="line">                    let &#123; id, params, body &#125; = binding.path.node;</span><br><span class="line">                    if (params.length == 0 || body.body.length == 0) return;</span><br><span class="line">                    // ******** 专用插件配置限制：函数名、函数调用的实参个数、函数定义的函数体大小 ********</span><br><span class="line">                    if (id.name == &#x27;ln&#x27; || body.body.length &gt; 10) return;</span><br><span class="line">                    if (!types.isReturnStatement(body.body[body.body.length - 1])) return;</span><br><span class="line"></span><br><span class="line">                    eval(binding.path.toString());</span><br><span class="line"></span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || constantViolations[0] == binding.path) &#123; // 如果为常量，或更改的那一次为定义的那一次</span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">            // 2. 当 binding.path 为赋值语句或变量定义时，需要在 decode 中准备唯一被还原函数</span><br><span class="line">            try &#123;</span><br><span class="line">                var funcNameArr = [&#x27;n&#x27;] // 唯一被还原函数的函数名</span><br><span class="line">                if (binding.path.isVariableDeclarator()) &#123;</span><br><span class="line">                    // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || (constantViolations.length == 1 &amp;&amp; constantViolations[0].isAssignmentExpression())) &#123; // 变量定义只有一次改变，或没改变</span><br><span class="line">                        // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                        let &#123; id, init &#125; = binding.path.node;</span><br><span class="line">                        let &#123; name &#125; = id;</span><br><span class="line">                        if (init == null) &#123;</span><br><span class="line">                            init = types.identifier(constantViolations[0].node.right.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!types.isIdentifier(id) || !funcNameArr.includes(init.name)) return;</span><br><span class="line">                        funcNameArr.push(name);</span><br><span class="line"></span><br><span class="line">                        let newCallExpression = types.callExpression(types.identifier(&#x27;n&#x27;), arguments);</span><br><span class="line">                        let value = eval(generator(newCallExpression).code);</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">// console.log(decryptCode);</span><br><span class="line"></span><br><span class="line">// 11. 折叠计算部分字面量或表达式</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(value));</span><br><span class="line">                &#125; catch &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        path.replaceWith(types.stringLiteral(value));</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        console.log(&quot;无法还原原因:&quot;, e.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理条件表达式（三目表达式）</span><br><span class="line">            if (path.isConditionalExpression()) &#123;</span><br><span class="line">                let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">                if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理字符串相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><h3 id="4-框架-通用纯函数还原"><a href="#4-框架-通用纯函数还原" class="headerlink" title="4. 框架 -&gt; 通用纯函数还原"></a>4. 框架 -&gt; 通用纯函数还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">// 框架 -&gt; 通用还原纯函数调用表达式</span><br><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line"></span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 主要还原逻辑</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    &quot;CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">            let &#123; name &#125; = callee;</span><br><span class="line">            if (!types.isIdentifier(callee) || arguments.length == 0 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">            let binding = path.scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line"></span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            // 1. 当 binding.path 为函数时，只能还原纯函数</span><br><span class="line">            try &#123;</span><br><span class="line">                if (binding.path.isFunctionDeclaration()) &#123;</span><br><span class="line">                    // console.log(binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                    // ******** 为解决下面在 binding.path 为赋值语句时的还原中，不还原其本身的调用表达式的问题 ******** </span><br><span class="line">                    if (decryptCode.includes(binding.path.toString().match(/function\s+\w+\s*\([^)]*\)/g)[0])) &#123;</span><br><span class="line"></span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!isPureFunction(binding.path)) return; // 判断函数是否是纯函数，不是则不处理</span><br><span class="line"></span><br><span class="line">                    let &#123; id, params, body &#125; = binding.path.node;</span><br><span class="line">                    if (params.length == 0 || body.body.length == 0) return;</span><br><span class="line">                    // ******** 专用插件配置限制：函数名、函数调用的实参个数、函数定义的函数体大小 ********</span><br><span class="line">                    if (id.name == &#x27;ln&#x27; || body.body.length &gt; 10) return;</span><br><span class="line">                    if (!types.isReturnStatement(body.body[body.body.length - 1])) return;</span><br><span class="line"></span><br><span class="line">                    eval(binding.path.toString());</span><br><span class="line"></span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || constantViolations[0] == binding.path) &#123; // 如果为常量，或更改的那一次为定义的那一次</span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">            // 2. 当 binding.path 为赋值语句或变量定义时，需要在 decode 中准备唯一被还原函数</span><br><span class="line">            try &#123;</span><br><span class="line">                var funcNameArr = [&#x27;n&#x27;] // 唯一被还原函数的函数名</span><br><span class="line">                if (binding.path.isVariableDeclarator()) &#123;</span><br><span class="line">                    // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || (constantViolations.length == 1 &amp;&amp; constantViolations[0].isAssignmentExpression())) &#123; // 变量定义只有一次改变，或没改变</span><br><span class="line">                        // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                        let &#123; id, init &#125; = binding.path.node;</span><br><span class="line">                        let &#123; name &#125; = id;</span><br><span class="line">                        if (init == null) &#123;</span><br><span class="line">                            init = types.identifier(constantViolations[0].node.right.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!types.isIdentifier(id) || !funcNameArr.includes(init.name)) return;</span><br><span class="line">                        funcNameArr.push(name);</span><br><span class="line"></span><br><span class="line">                        let newCallExpression = types.callExpression(types.identifier(&#x27;n&#x27;), arguments);</span><br><span class="line">                        let value = eval(generator(newCallExpression).code);</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">// console.log(decryptCode);</span><br></pre></td></tr></table></figure><h3 id="5-模版-专用函数还原模版"><a href="#5-模版-专用函数还原模版" class="headerlink" title="5. 模版 -&gt; 专用函数还原模版"></a>5. 模版 -&gt; 专用函数还原模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// 专用调用表达式还原插件模版</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const tsCallToString = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        var name = id.name;</span><br><span class="line">        // ******** 配置专用函数需要过滤的节点 ********</span><br><span class="line">        if (name != &#x27;ln&#x27;) return;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        collectFuncCode.push(binding.path.toString());</span><br><span class="line"></span><br><span class="line">        // 收集所有需要的环境函数到 collectFuncCode 数组中，最终执行</span><br><span class="line"></span><br><span class="line">        eval(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line">        // console.log(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == binding.path) &#123;</span><br><span class="line">            let flag = true;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;;</span><br><span class="line">                // 不处理环境函数中的调用表达式，会有问题</span><br><span class="line">                if (parentPath.parentPath.isCallExpression() &amp;&amp; parentPath.parentPath.node.callee.name == &#x27;parseInt&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                // 不一定能删，根据具体情况而定</span><br><span class="line">                // path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="6-案例-datadome还原"><a href="#6-案例-datadome还原" class="headerlink" title="6. 案例 -&gt; datadome还原"></a>6. 案例 -&gt; datadome还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;ok_encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">// 专用调用表达式还原插件模版</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const tsCallToString = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; node, parentPath &#125; = path;</span><br><span class="line">        let name = node.id.name;</span><br><span class="line">        if (name != &#x27;ln&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        let preNodePath = path.getPrevSibling();</span><br><span class="line">        eval(preNodePath.toString() + path.toString());</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == binding.path) &#123;</span><br><span class="line">            let flag = true;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">                preNodePath.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString);</span><br><span class="line"></span><br><span class="line">// 变量初始化为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 折叠计算部分字面量或表达式</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理条件表达式（三目表达式）</span><br><span class="line">            if (path.isConditionalExpression()) &#123;</span><br><span class="line">                let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">                if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理字符串相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">const callToStringLiteral = &#123;</span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; arguments &#125; = path.node;</span><br><span class="line">            if (!isNodeLiteral(arguments)) return;</span><br><span class="line">            try &#123;</span><br><span class="line">                let arr = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">                let flag = arr.every(ele =&gt; !path.toString().includes(ele));</span><br><span class="line">                if (!flag) return;</span><br><span class="line"></span><br><span class="line">                let value = eval(path.toString());</span><br><span class="line">                // if (typeof value != &quot;string&quot;) return; // 有时也需要还原为数字</span><br><span class="line">                console.log(path.toString(), &quot;--&gt;&quot;, value);</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToStringLiteral);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 最后使用：垃圾代码删除</span><br><span class="line">function containsSequenceExpression(path) &#123;</span><br><span class="line">    let containsSequence = false;</span><br><span class="line">    // 深度优先遍历当前路径及其所有子路径</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        &quot;SequenceExpression|AssignmentExpression&quot;(_path) &#123;</span><br><span class="line">            containsSequence = true;</span><br><span class="line">            _path.stop(); // 找到逗号表达式后立即停止遍历</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    return containsSequence;</span><br><span class="line">&#125;</span><br><span class="line">const removeDeadCode = &#123;</span><br><span class="line">    &quot;IfStatement|ConditionalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; consequent, alternate &#125; = node;</span><br><span class="line">        let testPath = path.get(&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (testPath.isSequenceExpression() || testPath.isAssignmentExpression() || containsSequenceExpression(testPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateTest = testPath.evaluateTruthy();</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            if (types.isBlockStatement(consequent)) &#123;</span><br><span class="line">                consequent = consequent.body;</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceWithMultiple(consequent);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (evaluateTest === false) &#123;</span><br><span class="line">            if (alternate != null) &#123;</span><br><span class="line">                if (types.isBlockStatement(alternate)) &#123;</span><br><span class="line">                    alternate = alternate.body;</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWithMultiple(alternate);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;LogicalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let leftPath = path.get(&#x27;left&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (leftPath.isSequenceExpression() || leftPath.isAssignmentExpression() || containsSequenceExpression(leftPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateLeft = leftPath.evaluateTruthy();</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == true) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == false)) &#123;</span><br><span class="line">            path.replaceWith(left);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == false) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == true)) &#123;</span><br><span class="line">            path.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;EmptyStatement|DebuggerStatement&quot;(path) &#123;</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, parentPath, parent &#125; = path;</span><br><span class="line">        let ancestryPath = parentPath.parentPath;</span><br><span class="line"></span><br><span class="line">        // for循环中的变量定义不能删除</span><br><span class="line">        if (ancestryPath.isForOfStatement(&#123; left: parent &#125;) || ancestryPath.isForInStatement(&#123; left: parent &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        //目前只发现赋值语句和调用语句会有问题。后续待添加</span><br><span class="line">        if (!types.isIdentifier(id) || types.isCallExpression(init) || types.isAssignmentExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name); // 重新解析ast后，一定会有binding</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;AssignmentExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(path + &#x27;&#x27;, referenced, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 赋值语句:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ContinueStatement|BreakStatement|ReturnStatement|ThrowStatement&quot;(path) &#123;</span><br><span class="line">        if (!path.parentPath.isSwitchCase()) return; // 只处理在 switch-case 语句中的</span><br><span class="line">        let AllNextSiblings = path.getAllNextSiblings(); // 获取所有的后续兄弟节点</span><br><span class="line">        for (let nextSibling of AllNextSiblings) &#123;</span><br><span class="line">            if (nextSibling.isFunctionDeclaration() || nextSibling.isVariableDeclaration(&#123; kind: &quot;var&quot; &#125;)) &#123; //变量提升.....</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params &#125; = node;</span><br><span class="line">        if (!params) return;</span><br><span class="line">        let flag = true;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(id.name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            for (let i of params) &#123;</span><br><span class="line">                if (!types.isIdentifier(i)) continue;</span><br><span class="line">                let binding = scope.getBinding(i.name);</span><br><span class="line">                if (!binding) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; references, constantViolations &#125; = binding;</span><br><span class="line">                if (references === 0 &amp;&amp; constantViolations.length === 0) &#123;</span><br><span class="line">                    // 将未使用的参数标记为删除</span><br><span class="line">                    console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数形参:&quot;, i.name);</span><br><span class="line">                    params = params.filter(param =&gt; param !== i);</span><br><span class="line">                    console.log(params);</span><br><span class="line">                &#125;</span><br><span class="line">                path.node.params = params;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    traverse(ast, removeDeadCode); // 删除不够彻底则再调用一次，以此类推</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数：根据case的test条件，获取对应case的node节点，还可以判断是否删除节点</span><br><span class="line">function getItemFromTestValue(path, testValue, is_remove) &#123;</span><br><span class="line">    let &#123; cases &#125; = path.node;</span><br><span class="line">    for (let caseIndex in cases) &#123;</span><br><span class="line">        let caseItem = cases[caseIndex];</span><br><span class="line">        if (caseItem.test.value == testValue) &#123;</span><br><span class="line">            if (is_remove) &#123;</span><br><span class="line">                return cases.splice(caseIndex, 1)[0]; // 从当前索引开始删除一个元素，并返回被删除的元素数组</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return caseItem</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const dealWithSwitch = &#123;</span><br><span class="line">    SwitchStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; discriminant, cases &#125; = node;</span><br><span class="line">        let name = discriminant.name;</span><br><span class="line"></span><br><span class="line">        /* 获取 switch-case 的初始case条件，通常在外层 for 循环的init中定义</span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (!binding.path.isVariableDeclarator() &amp;&amp; !binding.path.isAssignmentExpression()) return;</span><br><span class="line">            if (binding.path.isVariableDeclarator() &amp;&amp; (startValue = binding.path.node.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">            if (binding.path.isAssignmentExpression() &amp;&amp; (startValue = binding.path.node.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        */</span><br><span class="line">        if (!parentPath.parentPath.isForStatement()) return;</span><br><span class="line">        let &#123; init &#125; = parentPath.parentPath.node;</span><br><span class="line">        init = types.isVariableDeclaration(init) ? init.declarations[init.declarations.length - 1] : init;</span><br><span class="line">        if (!types.isVariableDeclarator(init) &amp;&amp; !types.isAssignmentExpression(init)) return;</span><br><span class="line">        if (types.isVariableDeclarator(init) &amp;&amp; (startValue = init.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        if (types.isAssignmentExpression(init) &amp;&amp; (startValue = init.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line"></span><br><span class="line">        // 不管switch从哪里开始，先单线合并，再处理条件表达式并用while循环替换</span><br><span class="line">        for (let i = 0; i &lt; cases.length; i++) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = cases[i];</span><br><span class="line">            let jumpTo = consequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">            jumpTo = jumpTo[jumpTo.length - 1] ? jumpTo[jumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">            if (!types.isAssignmentExpression(jumpTo) || !types.isIdentifier(jumpTo.left, &#123; name: name &#125;)) continue;</span><br><span class="line"></span><br><span class="line">            // console.log(path + &#x27;&#x27;); // 打印出整个处理过程，用于调试</span><br><span class="line"></span><br><span class="line">            // 1. 当跳转语句的右节点是字面量时</span><br><span class="line">            if (types.isLiteral(jumpTo.right)) &#123;</span><br><span class="line">                // 数组的长度含义：代表指向下一个case块的赋值语句的数量，即被指向的csae块有几次引用</span><br><span class="line">                let newArr = cases.filter(ele =&gt; &#123;</span><br><span class="line">                    let jumpto = ele.consequent.filter(element =&gt; generator(element).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                    jumpto = jumpto[jumpto.length - 1] ? jumpto[jumpto.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                    return generator(jumpto).code == generator(jumpTo).code;</span><br><span class="line">                &#125;);</span><br><span class="line">                // 如果只有一次，则可以合并</span><br><span class="line">                if (newArr.length == 1) &#123;</span><br><span class="line">                    let nextItem = getItemFromTestValue(path, jumpTo.right.value, true);</span><br><span class="line">                    let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                    // --------******** 特别注意：每个case替换的行数由实际情况而定 ********--------</span><br><span class="line">                    // 经过测试：下一个case中只有一条语句 break; 时运行正常，但是如果是控制case跳转的赋值语句，就会还原错误</span><br><span class="line">                    consequent.splice(consequent.length - 2, 2, ...nextItemConsequent);</span><br><span class="line"></span><br><span class="line">                    i = -1; // 每合并一次又从头遍历，因为被合并过的语句块可能还需要再次合并</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 当跳转语句的右节点是条件表达式时</span><br><span class="line">            if (types.isConditionalExpression(jumpTo.right)) &#123;</span><br><span class="line">                let newTest = jumpTo.right.test</span><br><span class="line">                let newConsequent = jumpTo.right.consequent</span><br><span class="line">                let newAlternate = jumpTo.right.alternate</span><br><span class="line"></span><br><span class="line">                let nextItem = getItemFromTestValue(path, newConsequent.value, false);</span><br><span class="line">                let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                let nextJumpTo = nextItemConsequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                nextJumpTo = nextJumpTo[nextJumpTo.length - 1] ? nextJumpTo[nextJumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                if (!types.isAssignmentExpression(nextJumpTo) || !types.isLiteral(nextJumpTo.right)) continue;</span><br><span class="line"></span><br><span class="line">                if (nextJumpTo.right.value == test.value) &#123;</span><br><span class="line">                    let bodyNode = nextItemConsequent.slice(0, nextItemConsequent.length - 2); // 截取有效内容</span><br><span class="line">                    let whileNode = types.whileStatement(newTest, types.blockStatement(bodyNode));</span><br><span class="line">                    consequent.splice(consequent.length - 2, 0, whileNode); // 删除0，则表示插入while语句</span><br><span class="line"></span><br><span class="line">                    getItemFromTestValue(path, newConsequent.value, true);</span><br><span class="line">                    jumpTo.right = newAlternate;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 还原到最后，将有效代码从switch中脱离出来</span><br><span class="line">        for (let item of cases) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = item;</span><br><span class="line">            if (test.value == startValue.value) &#123;</span><br><span class="line">                let lastSta = consequent[consequent.length - 1];</span><br><span class="line">                if (types.isBreakStatement(lastSta) || types.isContinueStatement(lastSta)) &#123;</span><br><span class="line">                    consequent.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                parentPath.parentPath.replaceWithMultiple(consequent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, dealWithSwitch);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><h3 id="7-案例-px3-还原"><a href="#7-案例-px3-还原" class="headerlink" title="7. 案例 -&gt; px3 还原"></a>7. 案例 -&gt; px3 还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;ok_encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">// 合并变量声明与定义</span><br><span class="line">// var a, b, c; a = 1; b = 2; c = 3;    ===&gt;    var a = 1, b = 2, c = 3;</span><br><span class="line">const combinDefineAndNextAssgin = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (init != null) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line">        if (!constantViolations[0].isAssignmentExpression()) return;</span><br><span class="line">        if (constantViolations[0].parentPath.isConditionalExpression() || constantViolations[0].parentPath.isLogicalExpression()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = constantViolations[0].node</span><br><span class="line">        if (!types.isIdentifier(left, &#123; name: name &#125;) || operator != &#x27;=&#x27; || !isBaseLiteral(right)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.set(&quot;init&quot;, right);</span><br><span class="line">        constantViolations[0].remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 变量初始化为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (parentPath.parentPath.isForStatement()) return;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 折叠计算部分字面量或表达式</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理条件表达式（三目表达式）</span><br><span class="line">            if (path.isConditionalExpression()) &#123;</span><br><span class="line">                let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">                if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理字符串相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 专用调用表达式还原插件模版</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const tsCallToString = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isCallExpression(node.body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        var name = id.name;</span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        collectFuncCode.push(path.toString());</span><br><span class="line">        // console.log(binding.path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        function xxx(path) &#123;</span><br><span class="line">            let tempName = path.node.body.body[0].argument.callee.name;</span><br><span class="line">            let tempBinding = path.scope.getBinding(tempName);</span><br><span class="line">            if (!tempBinding) return;</span><br><span class="line">            // 处理收集的函数中存在同名的问题</span><br><span class="line">            if (name == tempName) &#123;</span><br><span class="line">                tempBinding.scope.rename(tempName, path.scope.generateUidIdentifier(tempName).name);</span><br><span class="line">                collectFuncCode.pop();</span><br><span class="line">                collectFuncCode.push(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            collectFuncCode.push(tempBinding.path.toString());</span><br><span class="line">            // console.log(&quot;-----------------&quot;, tempBinding.path + &#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">            if (tempBinding.path.node.body.body.length == 1) &#123;</span><br><span class="line">                let recursiveBinding = xxx(tempBinding.path);</span><br><span class="line">                if (recursiveBinding) return recursiveBinding;</span><br><span class="line">            &#125;</span><br><span class="line">            return tempBinding;</span><br><span class="line">        &#125;</span><br><span class="line">        callFuncBinding = xxx(path);</span><br><span class="line">        if (!callFuncBinding) return;</span><br><span class="line"></span><br><span class="line">        let bigArrFuncName = callFuncBinding.path.node.body.body[0].declarations[0].init.callee.name;</span><br><span class="line">        let bigArrFuncBinding = callFuncBinding.scope.getBinding(bigArrFuncName);</span><br><span class="line">        if (!bigArrFuncBinding) return;</span><br><span class="line">        collectFuncCode.push(bigArrFuncBinding.path.toString());</span><br><span class="line"></span><br><span class="line">        // 处理有些大数组存在的移位自执行函数</span><br><span class="line">        let referencePaths_3 = bigArrFuncBinding.referencePaths;</span><br><span class="line">        for (let reference of referencePaths_3) &#123;</span><br><span class="line">            if (!reference.parentPath.isCallExpression()) continue;</span><br><span class="line"></span><br><span class="line">            let &#123; callee, arguments &#125; = reference.parentPath.node;</span><br><span class="line">            if (!types.isFunctionExpression(callee) || arguments.length != 1 || arguments[0].name != bigArrFuncName) continue;</span><br><span class="line">            collectFuncCode.push(reference.parentPath.parentPath.toString());</span><br><span class="line">            // console.log(reference.parentPath.parentPath + &#x27;&#x27;, reference.parentPath.type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eval(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line">        // console.log(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == binding.path) &#123;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 不处理环境函数中的调用表达式，会有问题</span><br><span class="line">                if (parentPath.parentPath.isCallExpression() &amp;&amp; parentPath.parentPath.node.callee.name == &#x27;parseInt&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">const tsCallToString2 = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length &lt; 2) return;</span><br><span class="line">        if (!types.isVariableDeclaration(node.body.body[0]) ||</span><br><span class="line">            !types.isCallExpression(node.body.body[0].declarations[0].init) ||</span><br><span class="line">            !types.isIdentifier(node.body.body[0].declarations[0].init.callee)) return;</span><br><span class="line"></span><br><span class="line">        var name = id.name;</span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        collectFuncCode.push(path.toString());</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        let bigArrFuncName = node.body.body[0].declarations[0].init.callee.name;</span><br><span class="line">        let bigArrFuncBinding = path.scope.getBinding(bigArrFuncName);</span><br><span class="line">        if (!bigArrFuncBinding) return;</span><br><span class="line">        collectFuncCode.push(bigArrFuncBinding.path.toString());</span><br><span class="line"></span><br><span class="line">        // 处理有些大数组存在的移位自执行函数</span><br><span class="line">        let referencePaths_3 = bigArrFuncBinding.referencePaths;</span><br><span class="line">        for (let reference of referencePaths_3) &#123;</span><br><span class="line">            if (!reference.parentPath.isCallExpression()) continue;</span><br><span class="line"></span><br><span class="line">            let &#123; callee, arguments &#125; = reference.parentPath.node;</span><br><span class="line">            if (!types.isFunctionExpression(callee) || arguments.length != 1 || arguments[0].name != bigArrFuncName) continue;</span><br><span class="line">            collectFuncCode.push(reference.parentPath.parentPath.toString());</span><br><span class="line">            // console.log(reference.parentPath.parentPath + &#x27;&#x27;, reference.parentPath.type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eval(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line">        // console.log(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] != 1) &#123;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                // console.log(&quot;sdfewrew2342&quot;,parentPath+&#x27;&#x27;);</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 不处理环境函数中的调用表达式，会有问题</span><br><span class="line">                if (parentPath.parentPath.isCallExpression() &amp;&amp; parentPath.parentPath.node.callee.name == &#x27;parseInt&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(&quot;第二种类型的还原:&quot;, parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString2);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line"></span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 主要还原逻辑</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    &quot;CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">            let &#123; name &#125; = callee;</span><br><span class="line">            if (!types.isIdentifier(callee) || arguments.length == 0 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">            let binding = path.scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line"></span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            // 1. 当 binding.path 为函数时，只能还原纯函数</span><br><span class="line">            try &#123;</span><br><span class="line">                if (binding.path.isFunctionDeclaration()) &#123;</span><br><span class="line">                    // console.log(binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                    // ******** 为解决下面在 binding.path 为赋值语句时的还原中，不还原其本身的调用表达式的问题 ******** </span><br><span class="line">                    if (decryptCode.includes(binding.path.toString().match(/function\s+\w+\s*\([^)]*\)/g)[0])) &#123;</span><br><span class="line"></span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!isPureFunction(binding.path)) return; // 判断函数是否是纯函数，不是则不处理</span><br><span class="line"></span><br><span class="line">                    let &#123; id, params, body &#125; = binding.path.node;</span><br><span class="line">                    if (params.length == 0 || body.body.length == 0) return;</span><br><span class="line">                    // ******** 专用插件配置限制：函数名、函数调用的实参个数、函数定义的函数体大小 ********</span><br><span class="line">                    if (id.name == &#x27;ln&#x27; || body.body.length &gt; 10) return;</span><br><span class="line">                    if (!types.isReturnStatement(body.body[body.body.length - 1])) return;</span><br><span class="line"></span><br><span class="line">                    eval(binding.path.toString());</span><br><span class="line"></span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || constantViolations[0] == binding.path) &#123; // 如果为常量，或更改的那一次为定义的那一次</span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">            // 2. 当 binding.path 为赋值语句或变量定义时，需要在 decode 中准备唯一被还原函数</span><br><span class="line">            try &#123;</span><br><span class="line">                var funcNameArr = [&#x27;n&#x27;] // 唯一被还原函数的函数名</span><br><span class="line">                if (binding.path.isVariableDeclarator()) &#123;</span><br><span class="line">                    // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || (constantViolations.length == 1 &amp;&amp; constantViolations[0].isAssignmentExpression())) &#123; // 变量定义只有一次改变，或没改变</span><br><span class="line">                        // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                        let &#123; id, init &#125; = binding.path.node;</span><br><span class="line">                        let &#123; name &#125; = id;</span><br><span class="line">                        if (init == null) &#123;</span><br><span class="line">                            init = types.identifier(constantViolations[0].node.right.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!types.isIdentifier(id) || !funcNameArr.includes(init.name)) return;</span><br><span class="line">                        funcNameArr.push(name);</span><br><span class="line"></span><br><span class="line">                        let newCallExpression = types.callExpression(types.identifier(&#x27;n&#x27;), arguments);</span><br><span class="line">                        let value = eval(generator(newCallExpression).code);</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 删除还原使用的环境函数，已无用</span><br><span class="line">const collectRemoveTsCallToString = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isCallExpression(node.body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        var name = id.name;</span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        collectFuncCode.push(path);</span><br><span class="line"></span><br><span class="line">        try &#123; // 使用 try 是因为明明节点存在，但依然会报错，实测捕获异常不影响删除功能</span><br><span class="line">            function xxx(path) &#123;</span><br><span class="line">                let tempName = path.node.body.body[0].argument.callee.name;</span><br><span class="line">                let tempBinding = path.scope.getBinding(tempName);</span><br><span class="line">                if (!tempBinding) return;</span><br><span class="line">                collectFuncCode.push(tempBinding.path);</span><br><span class="line"></span><br><span class="line">                if (tempBinding.path.node.body.body.length == 1) &#123;</span><br><span class="line">                    let recursiveBinding = xxx(tempBinding.path);</span><br><span class="line">                    if (recursiveBinding) return recursiveBinding;</span><br><span class="line">                &#125;</span><br><span class="line">                return tempBinding;</span><br><span class="line">            &#125;</span><br><span class="line">            callFuncBinding = xxx(path);</span><br><span class="line">            if (!callFuncBinding) return;</span><br><span class="line"></span><br><span class="line">            let bigArrFuncName = callFuncBinding.path.node.body.body[0].declarations[0].init.callee.name;</span><br><span class="line">            let bigArrFuncBinding = callFuncBinding.scope.getBinding(bigArrFuncName);</span><br><span class="line">            if (!bigArrFuncBinding) return;</span><br><span class="line">            collectFuncCode.push(bigArrFuncBinding.path);</span><br><span class="line"></span><br><span class="line">            // 处理有些大数组存在的移位自执行函数</span><br><span class="line">            let referencePaths_3 = bigArrFuncBinding.referencePaths;</span><br><span class="line">            for (let reference of referencePaths_3) &#123;</span><br><span class="line">                if (!reference.parentPath.isCallExpression()) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; callee, arguments &#125; = reference.parentPath.node;</span><br><span class="line">                if (!types.isFunctionExpression(callee) || arguments.length != 1 || arguments[0].name != bigArrFuncName) continue;</span><br><span class="line">                collectFuncCode.push(reference.parentPath.parentPath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let i of collectFuncCode) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, collectRemoveTsCallToString);</span><br><span class="line"></span><br><span class="line">// 最后使用：垃圾代码删除</span><br><span class="line">function containsSequenceExpression(path) &#123;</span><br><span class="line">    let containsSequence = false;</span><br><span class="line">    // 深度优先遍历当前路径及其所有子路径</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        &quot;SequenceExpression|AssignmentExpression&quot;(_path) &#123;</span><br><span class="line">            containsSequence = true;</span><br><span class="line">            _path.stop(); // 找到逗号表达式后立即停止遍历</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    return containsSequence;</span><br><span class="line">&#125;</span><br><span class="line">const removeDeadCode = &#123;</span><br><span class="line">    &quot;IfStatement|ConditionalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; consequent, alternate &#125; = node;</span><br><span class="line">        let testPath = path.get(&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (testPath.isSequenceExpression() || testPath.isAssignmentExpression() || containsSequenceExpression(testPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateTest = testPath.evaluateTruthy();</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            if (types.isBlockStatement(consequent)) &#123;</span><br><span class="line">                consequent = consequent.body;</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceWithMultiple(consequent);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (evaluateTest === false) &#123;</span><br><span class="line">            if (alternate != null) &#123;</span><br><span class="line">                if (types.isBlockStatement(alternate)) &#123;</span><br><span class="line">                    alternate = alternate.body;</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWithMultiple(alternate);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;LogicalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let leftPath = path.get(&#x27;left&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (leftPath.isSequenceExpression() || leftPath.isAssignmentExpression() || containsSequenceExpression(leftPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateLeft = leftPath.evaluateTruthy();</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == true) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == false)) &#123;</span><br><span class="line">            path.replaceWith(left);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == false) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == true)) &#123;</span><br><span class="line">            path.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;EmptyStatement|DebuggerStatement&quot;(path) &#123;</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, parentPath, parent &#125; = path;</span><br><span class="line">        let ancestryPath = parentPath.parentPath;</span><br><span class="line"></span><br><span class="line">        // for循环中的变量定义不能删除</span><br><span class="line">        if (ancestryPath.isForOfStatement(&#123; left: parent &#125;) || ancestryPath.isForInStatement(&#123; left: parent &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        //目前只发现赋值语句和调用语句会有问题。后续待添加</span><br><span class="line">        if (!types.isIdentifier(id) || types.isCallExpression(init) || types.isAssignmentExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name); // 重新解析ast后，一定会有binding</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;AssignmentExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(path + &#x27;&#x27;, referenced, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 赋值语句:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ContinueStatement|BreakStatement|ReturnStatement|ThrowStatement&quot;(path) &#123;</span><br><span class="line">        if (!path.parentPath.isSwitchCase()) return; // 只处理在 switch-case 语句中的</span><br><span class="line">        let AllNextSiblings = path.getAllNextSiblings(); // 获取所有的后续兄弟节点</span><br><span class="line">        for (let nextSibling of AllNextSiblings) &#123;</span><br><span class="line">            if (nextSibling.isFunctionDeclaration() || nextSibling.isVariableDeclaration(&#123; kind: &quot;var&quot; &#125;)) &#123; //变量提升.....</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params &#125; = node;</span><br><span class="line">        if (!params) return;</span><br><span class="line">        let flag = true;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            for (let i of params) &#123;</span><br><span class="line">                if (!types.isIdentifier(i)) continue;</span><br><span class="line">                let binding = scope.getBinding(i.name);</span><br><span class="line">                if (!binding) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; references, constantViolations &#125; = binding;</span><br><span class="line">                if (references === 0 &amp;&amp; constantViolations.length === 0) &#123;</span><br><span class="line">                    // 将未使用的参数标记为删除</span><br><span class="line">                    console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数形参:&quot;, i.name);</span><br><span class="line">                    params = params.filter(param =&gt; param !== i);</span><br><span class="line">                    console.log(params);</span><br><span class="line">                &#125;</span><br><span class="line">                path.node.params = params;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    traverse(ast, removeDeadCode); // 删除不够彻底则再调用一次，以此类推</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><h3 id="8-插件-px3-函数重命名"><a href="#8-插件-px3-函数重命名" class="headerlink" title="8. 插件 -&gt; px3 函数重命名"></a>8. 插件 -&gt; px3 函数重命名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">自执行函数外面有个Q函数，自执行函数里面又一个同名的Q函数，如果使用 ob混淆一键还原脚本里的思路，是会覆盖掉前一个 Q 函数的声明，对于它的调用，解密肯定会出错。</span><br><span class="line"></span><br><span class="line">因此，我的思路，是，将所有的这种 特征函数，将它的函数名重命名，并同时修改引用的位置，这样，就可以避免同名函数了。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">function getRandomName(length) &#123;</span><br><span class="line">    let initArr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;];</span><br><span class="line">    let puzzleArr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;];</span><br><span class="line">    let ranInx = Math.floor(Math.random() * initArr.length);</span><br><span class="line">    let randomName = initArr[ranInx];</span><br><span class="line"></span><br><span class="line">    for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">        ranInx = Math.floor(Math.random() * puzzleArr.length);</span><br><span class="line">        randomName += puzzleArr[ranInx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return randomName;</span><br><span class="line">&#125;</span><br><span class="line">let allNewNames = new Map(); //定义一个全局变量，保存需要处理的函数</span><br><span class="line"></span><br><span class="line">//获取未被使用的名称,返回 Identifier 类型。</span><br><span class="line">function getUnusedIdentifier() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        var newName = &quot;$C_&quot; + getRandomName(3);</span><br><span class="line">    &#125; while (allNewNames.has(newName))</span><br><span class="line"></span><br><span class="line">    allNewNames.set(newName, 1);</span><br><span class="line">    let UnusedIdentifier = types.Identifier(newName);</span><br><span class="line"></span><br><span class="line">    return UnusedIdentifier;</span><br><span class="line">&#125;</span><br><span class="line">const renameFunc = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        let name = id.name;</span><br><span class="line"></span><br><span class="line">        // PX3特征函数</span><br><span class="line">        if (params.length != 2 || body.body.length != 1 ||</span><br><span class="line">            !types.isReturnStatement(body.body[0]) || !types.isCallExpression(body.body[0].argument)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">        let newNameId = getUnusedIdentifier();</span><br><span class="line">        for (let referPath of binding.referencePaths) &#123;</span><br><span class="line">            referPath.replaceWith(newNameId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let newName = newNameId.name;</span><br><span class="line">        allNewNames.set(newName, name)</span><br><span class="line">        path.node.id.name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, renameFunc);</span><br><span class="line">allNewNames.clear();</span><br></pre></td></tr></table></figure><h2 id="十、Akamai-2-0-还原专题"><a href="#十、Akamai-2-0-还原专题" class="headerlink" title="十、Akamai 2.0 还原专题"></a>十、Akamai 2.0 还原专题</h2><blockquote><p><strong>有个坑，还原过后，有些代码的定义在最外层 return 下面导致替换无效，需要手动将其移上去</strong></p></blockquote><h3 id="0-技巧-过-toString-检测"><a href="#0-技巧-过-toString-检测" class="headerlink" title="0. 技巧 -&gt; 过 toString 检测"></a>0. 技巧 -&gt; 过 toString 检测</h3><ul><li><strong>实现步骤：</strong><ol><li>从网页上复制下来的源码不要格式化，压缩为一行，直接用于 AST 解析的 encode.js 文件</li><li>利用以下脚本对源码进行解析，得到用于过掉 toString 检测的脚本方法</li><li>最后将上一步得到的脚本方法，添加到最终经过 AST 还原（单独对源码进行解混淆）后的代码的最前面</li><li>最后通过浏览器映射技术，比如 Charles 的本地映射来实现替换网页文件并调试</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;toStringResult.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">let funStringPointArray = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 保存函数源代码，不使用 toString() 和 compact 压缩选项，非原始混淆代码</span><br><span class="line">const saveFuncString = &#123;</span><br><span class="line">&quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">let &#123; id, start, end &#125; = path.node;</span><br><span class="line">funStringPointArray[id.name] = [start, end];</span><br><span class="line">&#125;,</span><br><span class="line">&quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">let &#123; id, init &#125; = path.node;</span><br><span class="line">if (types.isFunctionExpression(init)) &#123;</span><br><span class="line">let &#123; start, end &#125; = init;</span><br><span class="line">funStringPointArray[id.name] = [start, end];</span><br><span class="line"></span><br><span class="line">if (init.id != null) &#123;</span><br><span class="line">funStringPointArray[init.id.name] = [start, end];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (types.isCallExpression(init) &amp;&amp; types.isFunctionExpression(init.callee)) &#123;</span><br><span class="line">let &#123; start, end &#125; = init.callee;</span><br><span class="line">funStringPointArray[id.name] = [start, end];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, saveFuncString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var funStringArray = &#123;&#125;;</span><br><span class="line">for (var funName in funStringPointArray) &#123;</span><br><span class="line">funStringArray[funName] = sourceCode.substring(funStringPointArray[funName][0], funStringPointArray[funName][1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过重写 Function.prototype.toString，确保当调用 toString() 方法时，返回的是原始的未混淆代码片段</span><br><span class="line">let data = `var _old = Function.prototype.toString.call;</span><br><span class="line">var tostringData = ` + JSON.stringify(funStringArray) + `\n</span><br><span class="line">Function.prototype.toString.call = function (arg) &#123;</span><br><span class="line">    if(tostringData.hasOwnProperty(arg.name))&#123;</span><br><span class="line">        return tostringData[arg.name];</span><br><span class="line">    &#125;</span><br><span class="line">    return _old.call(this, arg);</span><br><span class="line">&#125;;</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">files.writeFile(decodeFile, data, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><h3 id="1-思路-固定结果函数还原"><a href="#1-思路-固定结果函数还原" class="headerlink" title="1. 思路 -&gt; 固定结果函数还原"></a>1. 思路 -&gt; 固定结果函数还原</h3><ul><li><strong>特点：</strong>通过基本跟栈定位至 58 位大数组生成位置，可以发现其上面的类似 <code>Sx.zb.call(null, aa, bb)</code> 的函数调用，经过测试可以知道<strong>这类函数调用的结果与形参无关，无论传入什么形参都是一样的结果</strong></li><li><strong>还原思路：</strong>创建新对象 deObj，将主要调用对象 enObj 中的每个属性和方法的调用结果都存储在 deObj 中，再利用 AST 遍历对应函数，将其调用方法还原为这个 JSON 对象中的结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/* ******** 将 enObj 中的每个属性和方法的调用结果存储在 deObj 中 ********</span><br><span class="line">let enObj = Fn; // 这里的 Fn 即为调用的最外层的对象，需要修改</span><br><span class="line"></span><br><span class="line">let deObj = new Object();</span><br><span class="line">for (let key of Object.keys(enObj)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        deObj[key] = enObj[key].apply(null,);</span><br><span class="line">    &#125; catch &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy(JSON.stringify(deObj))</span><br><span class="line">*********************************************************************/</span><br><span class="line"></span><br><span class="line">let enObjName = &quot;T6&quot;; // 上面用到的 enObj 对象</span><br><span class="line">let deObj = &#123;&quot;H2&quot;:&quot;-103&quot;,&quot;Rh&quot;:&quot;ButtonHighlight&quot;,&quot;ph&quot;:&quot;CaptionText&quot;, ...&#125; // 存储所有调用结果的 JSON 对象</span><br><span class="line"></span><br><span class="line">// 主要还原 Fn.xx.call(null, aa, bb) 或 Fn.xx(aa, bb) 类型的调用表达式，且结果不受形参影响</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    CallExpression(path) &#123;</span><br><span class="line">        let &#123; callee &#125; = path.node;</span><br><span class="line">        if (!types.isMemberExpression(callee)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; object, property, computed &#125; = callee;</span><br><span class="line">        // 如果 object 是标识符，即 Fn.xx(aa, bb)</span><br><span class="line">        if (types.isIdentifier(object, &#123; name: enObjName &#125;)) &#123;</span><br><span class="line">            let proName = computed ? property.value : property.name;</span><br><span class="line"></span><br><span class="line">            if (deObj.hasOwnProperty(proName)) &#123;</span><br><span class="line">                console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, deObj[proName]);</span><br><span class="line">                path.replaceWith(types.valueToNode(deObj[proName]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 object 是成员表达式，即 Fn.xx.call(null, aa, bb)</span><br><span class="line">        if (types.isMemberExpression(object)) &#123;</span><br><span class="line">            let proName = computed ? property.value : property.name;</span><br><span class="line">            if (![&#x27;apply&#x27;, &#x27;call&#x27;].includes(proName)) return;</span><br><span class="line"></span><br><span class="line">            if (object.object.name == enObjName) &#123;</span><br><span class="line">                let proName = object.computed ? object.property.value : object.property.name;</span><br><span class="line"></span><br><span class="line">                if (deObj.hasOwnProperty(proName)) &#123;</span><br><span class="line">                    console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, deObj[proName]);</span><br><span class="line">                    path.replaceWith(types.valueToNode(deObj[proName]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="2-思路-假函数体内容还原"><a href="#2-思路-假函数体内容还原" class="headerlink" title="2. 思路 -&gt; 假函数体内容还原"></a>2. 思路 -&gt; 假函数体内容还原</h3><ul><li>Akamai 存在由函数体调用的形式来执行的代码，函数本身没有任何意义，所以使用<strong>假函数体内容还原</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 假函数体内容还原</span><br><span class="line">const untruthFuncContent = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; id, params, body &#125; = path.node;</span><br><span class="line">        if (params.length != 0 || body.body.length != 1 || !types.isExpressionStatement(body.body[0])) return;</span><br><span class="line"></span><br><span class="line">        let binding = path.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1 || !constant || referencePaths.length != 1) return;</span><br><span class="line">        let referPath = referencePaths[0]</span><br><span class="line">        let &#123; node, parentPath &#125; = referPath;</span><br><span class="line">        if (!parentPath.isCallExpression(&#123; callee: node &#125;)) return;</span><br><span class="line">        if (!parentPath.parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;假函数体内容还原:&quot;, path + &#x27;&#x27;);</span><br><span class="line">        parentPath.parentPath.replaceWith(body.body[0]);</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, untruthFuncContent);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure><h3 id="3-思路-大量字面量还原"><a href="#3-思路-大量字面量还原" class="headerlink" title="3. 思路 -&gt; 大量字面量还原"></a>3. 思路 -&gt; 大量字面量还原</h3><ul><li>基于预处理解混淆模版，调用多次 <strong>合并变量声明与定义</strong>、<strong>定义字面量未改还原</strong>、<strong>折叠字面量或表达式</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, rebackVarDeclarator);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, calcPartBinaryExpression);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-思路-ob-典型花指令还原"><a href="#4-思路-ob-典型花指令还原" class="headerlink" title="4. 思路 -&gt; ob 典型花指令还原"></a>4. 思路 -&gt; ob 典型花指令还原</h3><ul><li>Akamai 存在大量典型的 OB 混淆函数花指令，AST 兼容 3 种表达式还原即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// OB 典型花指令还原，分别处理单元表达式、二元表达式、数组</span><br><span class="line">const replaceExpressionOfReturn = (typeCheck, createReplacement) =&gt; (&#123;</span><br><span class="line">    FunctionDeclaration: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; scope, node &#125; = path;</span><br><span class="line">            let &#123; id, params, body &#125; = node;</span><br><span class="line">            if (body.body.length != 1 || !types.isReturnStatement(body.body[0]) || !typeCheck(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">            let expression = body.body[0].argument;</span><br><span class="line">            let binding = scope.getBinding(id.name);</span><br><span class="line">            if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">            let canRemoved = true;</span><br><span class="line">            for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referPath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let args = parentPath.node.arguments;</span><br><span class="line">                if (!createReplacement(args, expression)) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(parentPath.toString());</span><br><span class="line">                parentPath.replaceWith(createReplacement(args, expression));</span><br><span class="line">            &#125;</span><br><span class="line">            canRemoved &amp;&amp; path.remove();</span><br><span class="line">            path.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const reStoreUnaryOfReturn = replaceExpressionOfReturn(</span><br><span class="line">    expr =&gt; types.isUnaryExpression(expr) &amp;&amp; types.isIdentifier(expr.argument),</span><br><span class="line">    (args, expr) =&gt; args.length == 1 ? types.unaryExpression(expr.operator, args[0], true) : null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const reStoreBinaryOfReturn = replaceExpressionOfReturn(</span><br><span class="line">    expr =&gt; types.isBinaryExpression(expr) &amp;&amp; types.isIdentifier(expr.left) &amp;&amp; types.isIdentifier(expr.right),</span><br><span class="line">    (args, expr) =&gt; args.length == 2 ? types.binaryExpression(expr.operator, args[0], args[1]) : null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const reStoreArrayOfReturn = replaceExpressionOfReturn(</span><br><span class="line">    expr =&gt; types.isArrayExpression(expr),</span><br><span class="line">    (args, expr) =&gt; args.length == 0 ? expr : null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, reStoreUnaryOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreBinaryOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreArrayOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、AST技术专题&quot;&gt;&lt;a href=&quot;#一、AST技术专题&quot; class=&quot;headerlink&quot; title=&quot;一、AST技术专题&quot;&gt;&lt;/a&gt;一、AST技术专题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;AST 抽象语法树（Abstract Sy</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="JS逆向" scheme="http://example.com/tags/JS%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向_4_补环境专题</title>
    <link href="http://example.com/2024/07/01/JS%E9%80%86%E5%90%91_4_%E8%A1%A5%E7%8E%AF%E5%A2%83%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2024/07/01/JS%E9%80%86%E5%90%91_4_%E8%A1%A5%E7%8E%AF%E5%A2%83%E4%B8%93%E9%A2%98/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2025-01-17T02:00:36.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JS-语法基础"><a href="#一、JS-语法基础" class="headerlink" title="一、JS 语法基础"></a>一、JS 语法基础</h2><h3 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h3><ul><li><p><strong>null 和 undefined：</strong>null 的类型是对象，即 object。null 和 undefined 都是 false，但是 null 是表示一个**”空”的对象<strong>，转换为数值为 0，而 undefined 是表示一个</strong>“此处无定义”的原始值**，转换为数值为 NaN</p></li><li><p><strong>NaN：</strong>表示非数字，主要出现在字符串解析成数字出错的场合</p><ul><li>NaN 不是独立的数据类型，而是一个特殊数值，数据类型为 Number</li><li>NaN 不等于任何值，包括其本身</li><li>NaN 与任何数（包括自己）的运算，得到的都是 NaN</li></ul></li><li><p><strong>查看类型的运算符：</strong></p><ol><li><strong>typeof：</strong>返回一个值的数据类型</li><li><strong>instanceof：</strong>表示对象是否为某个构造函数的实例</li></ol></li><li><p><strong>布尔值：</strong>在 js 中只有 6 种值 false、undefined、null、0 或 -0、NaN、”” 或 ‘’ 为 false 假，其余均为 true 真</p></li><li><p><strong>字符串：</strong>可以使用 &#96;&#96; 表示模版字符串，输出多行，其中使用 ${} 可以动态传参</p></li><li><p><strong>Base64 转码：</strong></p><ul><li>btoa()：任意值转为 Base64 编码（非 ASCII 码 –&gt; 中文要转码再 base64，en&#x2F;decodeURLComponent）</li><li>atob()：Base64 编码转为原来的值</li><li>nodejs –&gt; base64 编码：<code>var b64encode = Buffer.from(&#39;JavaScript&#39;).toString(&#39;base64&#39;)</code></li><li>nodejs –&gt; base64 解码：<code>var b64decode = Buffer.from(b64encode, &#39;base64&#39;).toString()</code></li></ul></li><li><p><strong>对象：</strong></p><ul><li>查看对象 obj 的所有属性：Object.keys(obj)</li><li><strong>判断属性：obj.hasOwnProperty(‘toString’) 方法用于判断属性 toString 是否为对象自身的属性</strong></li><li>属性遍历：for … in 循环可以遍历一个对象的全部属性，包括继承的属性（可以配合 hasOwnProperty）</li></ul></li><li><p><strong>函数：</strong></p><ul><li><strong>混淆声明方式：</strong><code>var c = New Function(&#39;a&#39;,&#39;b&#39;,&#39;return a+b&#39;); console.log(c(1, 2)); --&gt; 3</code></li><li><strong>返回值：</strong>当函数 return 多个值用逗号间隔时，只能成功返回最后一个值（<strong>逗号表达式</strong>，数组&#x2F;对象解决）</li></ul></li><li><p><strong>变量提升：</strong></p><ol><li><strong>变量提升：</strong>变量使用 var 声明时，js引擎会将变量声明提升到作用域顶部，但不会提升其赋值操作</li><li><strong>函数提升：整个函数</strong>都会被提升到作用域顶部。因此，声明的函数可以在其定义之前调用</li><li><strong>let 和 const：</strong>与 var 不同，使用 let 和 const 声明的变量被提升后存在**”暂时性死区”**，使用它们之前会抛出 ReferenceError 异常，即在声明之前无法访问这些变量</li></ol></li><li><p><strong>闭包：</strong>闭包就是将函数内部和函数外部连接起来的一座桥梁，可以简单理解为定义在一个函数内部的函数。最大的作用是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 计数器实现，count是f函数内部的一个局部变量，只能被f函数内部的add函数访问。</span><br><span class="line">// 由于count是函数内部的变量，它不会被外部代码直接读取或修改，这种特性确保了变量的封装和数据安全</span><br><span class="line">function f() &#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    function add() &#123;</span><br><span class="line">        count++</span><br><span class="line">        console.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    return add;</span><br><span class="line">&#125;</span><br><span class="line">var f2 = f()</span><br><span class="line">f2()  // 1</span><br><span class="line">f2()  // 2</span><br><span class="line">f2()  // 3</span><br></pre></td></tr></table></figure><ul><li><p><strong>eval函数：本质是在当前作用域之中注入代码，没有自己的作用域，都是在当前作用域内执行</strong>（混淆常用）</p><ul><li><strong>别名调用：</strong>为了保证 eval 的别名不影响代码优化，所以 eval 如果别名调用则 eval 内部一律是全局作用域</li></ul></li><li><p><strong>数组：</strong></p><ol><li>数组也是对象，typeof 类型为 Object，也可以使用 Object.keys(array) 打印出所有元素</li><li>数组的 length 属性是可写的，相当于截断，设置为 0 则直接清空数组</li><li>可以像对象一样添加键值对，但是不会增加数组 length 长度，也无法通过 arr.length &#x3D; 0 清除掉此键值对</li></ol></li><li><p><strong>异常捕获：</strong>在异常中，<strong>浏览器的异常堆栈信息和 nodejs 的异常堆栈信息可能不一样，也可能成为环境检测点</strong></p></li></ul><h3 id="2-函数的-arguments-对象"><a href="#2-函数的-arguments-对象" class="headerlink" title="2. 函数的 arguments 对象"></a>2. 函数的 arguments 对象</h3><ul><li><strong>arguments对象：</strong>在 js 中，函数的形参可通过 arguments 对象获取，该对象包含了传递给函数的所有实参<ul><li>通过数组形式输出所有形参：<code>Array.prototype.slice.call(arguments);</code></li><li>arguments.callee 属性：返回对应的原函数</li></ul></li><li><strong>对比 python：</strong>在 Python 中，如果函数的定义中没有使用 *args 或 **kwargs，则函数在被调用时实参与形参必须相匹配，否则 python 将引发 TypeError 异常，而 js 不会</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在函数内部通过 arguments 对象来处理传递的参数</span><br><span class="line">function fun1() &#123;</span><br><span class="line">    console.log(arguments[&#x27;0&#x27;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1(1, 2)  // 1</span><br></pre></td></tr></table></figure><h3 id="3-自执行函数"><a href="#3-自执行函数" class="headerlink" title="3. 自执行函数"></a>3. 自执行函数</h3><ul><li><strong>注意：</strong>由于 js 代码是可以压缩成一行的，所以自执行方法前的属性或方法必须以顿号结尾，所以通常<strong>在自执行方法前加上强制符（! 或 ~），可以避免其因整体被当作上一个属性或方法的方法调用而抛出的异常</strong></li><li><strong>作用：</strong><ol><li>不必为函数命名，避免了污染全局变量</li><li>自执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!(function () &#123; var a = 1; console.log(a) &#125;)()</span><br><span class="line"></span><br><span class="line">console.log(a);  // ReferenceError: a is not defined</span><br></pre></td></tr></table></figure><h3 id="4-原型链与构造函数"><a href="#4-原型链与构造函数" class="headerlink" title="4. 原型链与构造函数"></a>4. 原型链与构造函数</h3><blockquote><p><strong>Object 对象：</strong>js 中所有对象都继承自 Object 对象，即对象都是 Object 的实例</p><ol><li><strong>通过 dir(Object) 可以查看对象的所有自身属性</strong></li><li>通过已创建的实例对象 obj 作为模版，使用 <code>var obj2 = Object.create(obj, &#123;b:&#39;123&#39;&#125;)</code> 可以生成新的实例对象，其中 obj2 是继承至 obj 对象，区别是 obj 的原型指向 Object.prototype，而 obj2 的原型指向 create 的第一个参数，如果参数为空对象，则没有原型</li></ol><p><strong>原型链</strong>：在 js 中每个对象都有自己的原型对象 prototype，<strong>作用是实现继承</strong>。当需要访问一个对象的属性或方法时，js 引擎会首先在该对象本身查找，如果找不到，则会沿着实例的 __proto__ 即构造函数的 prototype 的顺序在原型中往上方查找，直到找到 Object.prototype 为止，找不到则报错或返回 undefined</p><p><strong>注意：</strong>__proto__ 和 prototype 本身没有区别，都是原型，只是一个在实例对象上，一个在构造函数上</p></blockquote><ul><li><p><strong>原型对象 Object.prototype 的特点：</strong></p><ol><li>如果原型对象上的属性是一个引用，那么一个实例改变了引用的属性，就会直接改变原型上此引用的属性</li></ol></li><li><p><strong>constructor 属性：</strong>prototype 对象有一个 constructor 属性，默认指向 prototype 对象所在的构造函数</p></li></ul><ol><li><strong>实例的 constructor 属性是构造函数</strong>，即 <code>navigator.constructor == Navigator</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 简单的过环境检测（不太优雅，不太好用）</span><br><span class="line">var navigator = &#123;&#125;</span><br><span class="line">// console.log(navigator.constructor);</span><br><span class="line">function Navigator() &#123; &#125;</span><br><span class="line">// console.log(Navigator);</span><br><span class="line">var navigator = new Navigator();</span><br><span class="line">// console.log(navigator.constructor.toString());</span><br><span class="line">navigator.constructor.toString = function () &#123;</span><br><span class="line">    return &#x27;function Navigator() &#123; [native code] &#125;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简单的过环境检测（优雅的）</span><br><span class="line">function Navigator() &#123; &#125;</span><br><span class="line">Navigator.prototype.constructor.toString = function () &#123;</span><br><span class="line">    return &#x27;function Navigator() &#123; [native code] &#125;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// 第一种方式</span><br><span class="line">// var navigator = new Navigator();</span><br><span class="line">// 第二种方式（同第三种，不同写法）</span><br><span class="line">// var navigator = &#123;&#125;;</span><br><span class="line">// Object.setPrototypeOf(navigator, Navigator.prototype)</span><br><span class="line">// 第三种方式</span><br><span class="line">var navigator = Object.setPrototypeOf(&#123;&#125;, Navigator.prototype)</span><br><span class="line">console.log(Object.getPrototypeOf(navigator) == Navigator.prototype);  // true</span><br><span class="line"></span><br><span class="line">console.log(navigator.constructor);</span><br><span class="line">console.log(navigator.constructor === Navigator);  // true</span><br><span class="line">console.log(navigator.constructor.toString());</span><br><span class="line"></span><br><span class="line">function checknavigator() &#123;</span><br><span class="line">    return navigator.constructor.toString() === &#x27;function Navigator() &#123; [native code] &#125;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(checknavigator());  // true</span><br></pre></td></tr></table></figure><ul><li><strong>构造函数的原型链关系：</strong><ol><li>实例的 __proto__ 指向构造函数的 prototype，<code>navigator.__proto__ === Navigator.prototype</code>，这个称为<strong>构造函数的原型对象</strong></li><li>构造函数的 __proto__ 指向 Function.prototype（<strong>包括 Function 自己</strong>），即构造函数的 constructor 属性就是 Function，有 <code>Navigator.constructor == Function</code>，得 <code>Navigator.__proto__ === Function.prototype</code>，值为 <code>ƒ () &#123; [native code] &#125;</code>，暂时将 Function 称为<strong>构造器函数</strong></li><li>构造器函数的 __proto__ 指向 Object.prototype，但是由于其自己也是构造函数，所以 <code>Function.constructor == Function</code>，即 <code>Navigator.__proto__.__proto__ === Function.__proto__.__proto__. === Object.prototype</code>，<strong>包含了所有对象都继承的方法和属性</strong></li></ol></li></ul><h3 id="5-Object-相关重点方法"><a href="#5-Object-相关重点方法" class="headerlink" title="5. Object 相关重点方法"></a>5. Object 相关重点方法</h3><blockquote><p><strong>注意：很多方法有两种写法</strong></p><ol><li><strong>先定义对象，再在第一个参数指定该对象，而后参数对该对象进行操作</strong></li><li><strong>定义对象时赋值，赋值为调用该方法，此时第一个参数即为对象的值，而后参数对该对象进行操作</strong></li></ol></blockquote><ul><li><p><strong>Object 的静态方法，即部署在 Object 对象自身上的方法：</strong></p><ol><li><p>Object.keys()：返回对象自身的可枚举属性名组成的数组。只遍历自有属性，且仅返回可枚举的属性名</p></li><li><p>Object.getOwnPropertyName()：返回对象自身所有属性的属性名，<strong>包括不可枚举属性</strong>，组成一个数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">Object.defineProperty(obj, &#x27;b&#x27;, &#123; value: 2, enumerable: false &#125;);</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj)); // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertyDescriptor(obj, prop)：用于获取对象中某个特定属性的属性描述符</p></li><li><p><strong>Object.getOwnPropertyDescriptors()：</strong>返回对象自身所有属性的属性描述符对象，包括可否枚举的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">Object.defineProperty(obj, &#x27;b&#x27;, &#123; value: 2, enumerable: false &#125;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(obj));</span><br><span class="line">// &#123;</span><br><span class="line">//   a: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span><br><span class="line">//   b: &#123; value: 2, writable: false, enumerable: false, configurable: false &#125;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Object.defineProperty()：</strong>给对象定义或修改一个属性的属性描述符，通过描述符控制该属性的行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &#x27;a&#x27;, &#123; value: 1, writable: false &#125;);</span><br><span class="line">console.log(obj.a); // 1</span><br><span class="line">obj.a = 2;</span><br><span class="line">console.log(obj.a); // 1 （属性不可写）</span><br></pre></td></tr></table></figure></li><li><p><strong>Object.defineProperties()：</strong>一次性定义或修改对象的多个属性及其属性描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.defineProperties(obj, &#123;</span><br><span class="line">  a: &#123; value: 1, writable: true &#125;,</span><br><span class="line">  b: &#123; value: 2, writable: false &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj.a); // 1</span><br><span class="line">console.log(obj.b); // 2</span><br></pre></td></tr></table></figure></li><li><p><strong>Object.getPrototypeOf() 检测点：</strong>返回指定对象的原型（即 [[Prototype]] 内部属性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">const proto = Object.getPrototypeOf(obj);</span><br><span class="line">console.log(proto === Object.prototype); // true</span><br></pre></td></tr></table></figure></li><li><p><strong>Object.setPrototypeOf()：</strong>设置指定对象的原型为另一个对象或 null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const proto = &#123; greet: () =&gt; console.log(&#x27;Hello!&#x27;) &#125;;</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">obj.greet(); // &#x27;Hello!&#x27;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>Object 的实例方法：</strong></p><ol><li><p><strong>Object.prototype.valueOf()：</strong>返回指定对象的原始值。大多数情况下，对于基本对象，这个方法返回对象本身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">console.log(obj.valueOf());  // 输出：&#123; a: 1 &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Object.prototype.toString()：</strong>返回一个表示对象的字符串。默认情况返回对象的类型信息，由于实例对象可以直接重写此方法来覆盖掉原型上的方法，所以最好直接使用 Object.prototype.toString.call() 方法，可以获取原生的类型判断结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">console.log(obj.toString());  // 输出：[object Object]</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(123));          // [object Number]</span><br><span class="line">console.log(Object.prototype.toString.call(&#x27;hello&#x27;));      // [object String]</span><br><span class="line">console.log(Object.prototype.toString.call(true));         // [object Boolean]</span><br><span class="line">console.log(Object.prototype.toString.call([]));           // [object Array]</span><br><span class="line">console.log(Object.prototype.toString.call(&#123;&#125;));           // [object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(null));         // [object Null]</span><br><span class="line">console.log(Object.prototype.toString.call(undefined));    // [object Undefined]</span><br><span class="line">console.log(Object.prototype.toString.call(function()&#123;&#125;)); // [object Function]</span><br><span class="line">console.log(Object.prototype.toString.call(/regex/));      // [object RegExp]</span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toLocaleString()：类似于 toString()，返回当前对象对应的本地字符串形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let date = new Date();</span><br><span class="line">console.log(date.toLocaleString());  // 根据本地设置输出日期字符串</span><br></pre></td></tr></table></figure></li><li><p><strong>Object.prototype.hasOwnProperty()：</strong>用于检查对象是否具有指定的属性（这个属性不能是从原型链继承的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">console.log(obj.hasOwnProperty(&#x27;a&#x27;));  // 输出：true</span><br><span class="line">console.log(obj.hasOwnProperty(&#x27;toString&#x27;));  // 输出：false（来自原型链）</span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.isPrototypeOf()：检查某个对象是否存在于另一个对象的原型链上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;&#125;</span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">let child = new Child();</span><br><span class="line">console.log(Parent.prototype.isPrototypeOf(child));  // 输出：true</span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.propertylsEnumerable()：用于判断对象的某个属性是否可枚举。不可枚举的则返回 false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;;</span><br><span class="line">console.log(obj.propertyIsEnumerable(&#x27;a&#x27;));  // 输出：true</span><br><span class="line">console.log(obj.propertyIsEnumerable(&#x27;toString&#x27;));  // 输出：false（继承的属性不可枚举）</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="6-常用对象-API"><a href="#6-常用对象-API" class="headerlink" title="6. 常用对象 API"></a>6. 常用对象 API</h3><ul><li><p><strong>控制台API：</strong></p><ol><li><p>inspect(object)：打开相关面板，并选中相应的元素，显示其细节</p></li><li><p><strong>getEventListeners：</strong>是 Chrome 开发者工具中内置的一个方法，用于获取特定 DOM 元素上注册的所有事件监听器，可以看到这个元素上绑定的事件及其回调函数。每个事件（如 click、keydown）都会作为返回对象的属性名，属性值是一个数组，数组中的每个元素代表绑定在该事件上的回调函数及相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 选择一个按钮元素</span><br><span class="line">var button = document.querySelector(&#x27;button&#x27;);</span><br><span class="line"></span><br><span class="line">// 给按钮添加点击事件和鼠标移动事件</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, () =&gt; console.log(&#x27;Button clicked!&#x27;));</span><br><span class="line">button.addEventListener(&#x27;mousemove&#x27;, () =&gt; console.log(&#x27;Mouse moved!&#x27;));</span><br><span class="line"></span><br><span class="line">getEventListeners(button);</span><br><span class="line">&#123;</span><br><span class="line">  click: [</span><br><span class="line">    &#123;listener: ƒ, useCapture: false, passive: false, once: false, type: &quot;click&quot;&#125;</span><br><span class="line">  ],</span><br><span class="line">  mousemove: [</span><br><span class="line">    &#123;listener: ƒ, useCapture: false, passive: false, once: false, type: &quot;mousemove&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>keys(object)，values(object)：返回一个数组，包含 object 的所有的键名&#x2F;键值</p></li><li><p><strong>monitorEvents(object, events)：</strong>用来监听指定对象上发生的某类事件。当某类事件发生时，返回一个 Event 对象，该对象包含该事件的相关信息。使用 unmonitorEvents(object) 方法可以停止监听指定对象上的事件。事件可以分为四大类，每一类都包含一系列具体事件：</p><ul><li>Mouse 事件：mousedown mouseup click dblclick mousemove mouseover mouseout mousewheel</li><li>Key 事件：keydown keyup keypress textinput</li><li>Touch 事件：touchstart touchmove touchend touchcancel</li><li>Control 事件：resize scroll zoom focus blur select change submit reset</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 监听 document 上的所有鼠标事件</span><br><span class="line">monitorEvents(document, &#x27;mouse&#x27;);</span><br><span class="line">// 停止监听 document 上的所有事件</span><br><span class="line">unmonitorEvents(document);</span><br></pre></td></tr></table></figure></li><li><p>copy(object)：复制特定 DOM 元素到剪贴板</p></li><li><p>debugger：断点</p></li></ol></li><li><p><strong>console - API：</strong></p><ol><li>不同日志等级的打印输出：console.log()、info()、debug()、warn()、error()</li><li>console.table()：用表格形式打印一些复合类型数据，如对象、数组</li><li>console.count()：计数输出多少次</li><li>**console.dir()**、dirxml()：打印一个 dom 的对象形式、目录树的形式</li><li>console.assert()：主要用于程序运行过程中，进行条件判断，如果不满足条件，则显示一个错误，但不会中断程序执行，可以达到一个提示用户内部状态不正确的作用</li><li>console.time()、timeEnd()：用于计时，可以计算出一个操作所花费的准确时间</li><li>console.group()、groupEnd()、groupCollapsed()：将显示的信息分组，在输出大量信息时有用</li><li>**console.trace()**、clear()：显示当前执行的代码在堆栈中的调用路径、清空控制台输出</li></ol></li></ul><h3 id="7-this-–-call、apply-和-bind"><a href="#7-this-–-call、apply-和-bind" class="headerlink" title="7. this –&gt; call、apply 和 bind"></a>7. this –&gt; call、apply 和 bind</h3><blockquote><p><strong>this 机制：</strong>在 js 中，this 的指向依赖于<strong>调用函数的上下文</strong>。js 的方法在脱离对象后调用时，其 this 指向默认变为全局对象，这种情况下如果不显式地绑定 this 到正确的对象，则会抛出 TypeError 异常</p><p><strong>绑定 this 的方法（call、apply 和 bind）：</strong></p><ol><li>Function.prototype.call(thisValue, arg1, arg2, …)：函数实例的 call 方法，可以指定函数内部 this 的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数</li><li>Function.prototype.apply(thisValue, [arg1, arg2, ….])：apply 方法的作用与 call 方法类似，也是改变 this 指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数</li><li>Function.prototype.bind(thisValue, arg1, arg2, …)：用于将函数体内的 this 绑定到某个对象，然后返回一个<strong>新函数</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date()</span><br><span class="line">var gettime = d.getTime</span><br><span class="line">gettime() // TypeError: this is not a Date object.</span><br><span class="line">// 当直接引用 d.getTime 时，实际上是将 getTime 函数提取了出来，而它的上下文 (this) 已经不再是 d 对象，而是指向全局对象，因此会导致错误</span><br><span class="line"></span><br><span class="line">/* 解决方法</span><br><span class="line">var d = new Date()</span><br><span class="line">var gettime = d.getTime.bind(d)</span><br><span class="line">console.log(gettime())</span><br><span class="line"></span><br><span class="line">var d = new Date()</span><br><span class="line">var gettime = d.getTime</span><br><span class="line">console.log(gettime.call(d))</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>全局上下文：</strong>在全局作用域中，this 通常指向全局对象（在浏览器中为 windows，在 nodejs 中为 global ）</p></li><li><p><strong>对象方法中的 this：</strong>当 this 在一个对象的方法中使用时，this 指向调用该方法的对象，赋值给另一个对象则指向改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &#x27;Alice&#x27;,</span><br><span class="line">    sayHello: function() &#123;</span><br><span class="line">        console.log(this.name); // 这里的 `this` 指向 person 对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayHello(); // 输出 &#x27;Alice&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数中的 this：</strong>在构造函数中，this 指向新创建的实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;  // `this` 指向当前创建的对象实例</span><br><span class="line">&#125;</span><br><span class="line">const alice = new Person(&#x27;Jack&#x27;);</span><br><span class="line">console.log(alice.name); // 输出 &#x27;=Jack&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件处理器中的 this：</strong>在事件处理器中，this 通常指向触发事件的 DOM 元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const button = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">    console.log(this);  // 这里的 `this` 指向触发事件的 button 元素</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>箭头函数中的 this：</strong>箭头函数的 this 与普通函数不同，它不绑定自己的 this，而是从定义时的上下文继承 this</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &#x27;haha&#x27;,</span><br><span class="line">    sayHello: () =&gt; &#123;</span><br><span class="line">        console.log(this.name); // 这里的 `this` 指向定义时的上下文，不是 person 对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayHello(); // 输出 undefined，因为箭头函数的 this 不是 person 对象</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-ES6语法糖"><a href="#8-ES6语法糖" class="headerlink" title="8. ES6语法糖"></a>8. ES6语法糖</h3><ul><li>简易属性和方法表达：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const myname = &#x27;jack&#x27;</span><br><span class="line">const temp = &#123; myname &#125;</span><br><span class="line">console.log(temp); // &#123; myname: &#x27;jack&#x27; &#125;</span><br><span class="line"></span><br><span class="line">const team = &#123;</span><br><span class="line">    dowork() &#123;</span><br><span class="line">        return &#x27;work!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(team.dowork()) // work!</span><br></pre></td></tr></table></figure><ul><li><strong>var、let 和 const：</strong><ol><li>let 可以完全取代 var，因为两者语义相同，且 let 没有副作用，也不存在变量提升代码不易读</li><li>var 变量定义会挂载到全局对象 window 上，不会被垃圾回收；而 let 和 const 不用担心这个问题</li><li>全局常量 const 优于 let，既可以限制值不被修改，也可以提高程序的运行效率（js 编译器优化）</li></ol></li><li><strong>自执行函数：</strong><ul><li>箭头函数的 this 与普通函数不同，它不绑定自己的 this，而是从定义时的上下文继承 this</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;jack&quot;);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">function Timer() &#123;</span><br><span class="line">    this.s1 = 0;</span><br><span class="line">    this.s2 = 0;</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        this.s1++</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    setInterval(function () &#123;</span><br><span class="line">        this.s2++;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">let timer = new Timer();</span><br><span class="line">setInterval(() =&gt; console.log(`s1: $&#123;timer.s1&#125;`), 2000)</span><br><span class="line">setInterval(() =&gt; console.log(`s2: $&#123;timer.s2&#125;`), 2000)</span><br><span class="line">// s1: 1 s2: 0 ---- s1: 3 s2: 0 ---- s1: 5 s2: 0</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3].forEach((x) =&gt; &#123;</span><br><span class="line">    console.log(x); // 1 2 3</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr); // undefined</span><br><span class="line"></span><br><span class="line">var newarr = [1, 2, 3].map((x) =&gt; &#123;</span><br><span class="line">    return x * 2</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newarr); // [ 2, 4, 6 ]</span><br></pre></td></tr></table></figure><ul><li><strong>CommonJS 模块：</strong><ul><li>导出：通过 moudle.exports &#x3D; obj; 导出一个对象，moudle.exports &#x3D; {add, subtract} 导出多个对象</li><li>引入：使用 require(‘模块路径’) 来引入模块。单个导出的引入直接调用，多个导出的引入通过对象成员来调用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = add;  // 导出单个函数</span><br><span class="line"></span><br><span class="line">const add = require(&#x27;./math&#x27;);  // 引入单个导出的函数</span><br><span class="line">console.log(add(2, 5));  // 输出 7</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function subtract(a, b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; add, subtract &#125;;  // 导出多个函数</span><br><span class="line"></span><br><span class="line">const math = require(&#x27;./math&#x27;);  // 引入包含多个导出的对象</span><br><span class="line">console.log(math.add(2, 5));  // 输出 7</span><br><span class="line">console.log(math.subtract(5, 2));  // 输出 3</span><br></pre></td></tr></table></figure><ul><li><strong>计算属性名：</strong>在对象字面量中，可以使用方括号 [] 来动态地计算属性名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let boss = &#x27;DTA Boss&#x27;;</span><br><span class="line"></span><br><span class="line">const DTA = &#123;</span><br><span class="line">    &#x27;employee&#x27;: &#x27;bxl&#x27;,</span><br><span class="line">    [boss]: &#x27;xfblog&#x27;,</span><br><span class="line">    [&#x27;do&#x27; + &#x27;work&#x27;]() &#123;</span><br><span class="line">        return &#x27;work&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(DTA.employee); // bxl</span><br><span class="line">console.log(DTA[&#x27;DTA Boss&#x27;]); // xfblog</span><br><span class="line">console.log(DTA.dowork()); // work</span><br></pre></td></tr></table></figure><ul><li><strong>对象扩展运算符 … ：</strong>用于取出参数对象的所有可遍历属性，拷贝到当前对象之中，与 Object.assign 作用一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const NewDAT1 = &#123; ...DTA &#125;</span><br><span class="line">console.log(NewDAT1); // &#123; employee: &#x27;bxl&#x27;, &#x27;DTA Boss&#x27;: &#x27;xfblog&#x27;, dowork: [Function: dowork] &#125;</span><br><span class="line">const NewDAT2 = Object.assign(&#123;&#125;, DTA)</span><br><span class="line">console.log(NewDAT2); // &#123; employee: &#x27;bxl&#x27;, &#x27;DTA Boss&#x27;: &#x27;xfblog&#x27;, dowork: [Function: dowork] &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>链判断运算符 ?. 和 null 判断运算符 ??：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        age: &#123;</span><br><span class="line">            sex: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果把??换成||，那么前面的值是存在的，但是为0，就会被判断为false，就会输出 1</span><br><span class="line">// ??只有当某个值是null或undefined时，才会输出默认值</span><br><span class="line">console.log(person?.name?.age?.sex ?? &#x27;1&#x27;); // 0</span><br></pre></td></tr></table></figure><h2 id="二、JS-语法补充"><a href="#二、JS-语法补充" class="headerlink" title="二、JS 语法补充"></a>二、JS 语法补充</h2><h3 id="1-完全拷贝对象"><a href="#1-完全拷贝对象" class="headerlink" title="1. 完全拷贝对象"></a>1. 完全拷贝对象</h3><blockquote><ol><li>﻿确保拷贝后的对象，与原对象具有同样的原型</li><li>﻿确保拷贝后的对象，与原对象具有同样的实例属性</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function copyObject(orig) &#123;</span><br><span class="line">    return Object.create(</span><br><span class="line">        Object.getPrototypeOf(orig),</span><br><span class="line">        Object.getOwnPropertyDescriptors(orig)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-内部函数导出"><a href="#2-内部函数导出" class="headerlink" title="2. 内部函数导出"></a>2. 内部函数导出</h3><ul><li><strong>目的：</strong>在局部作用域中想要导出一个函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var temp;</span><br><span class="line"></span><br><span class="line">!(function () &#123;</span><br><span class="line">    console.log(&quot;自执行方法...&quot;)</span><br><span class="line"></span><br><span class="line">    function test() &#123;</span><br><span class="line">        console.log(&#x27;123&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 将内部函数的引用赋值给全局变量temp</span><br><span class="line">    temp = test</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">temp()  // 123</span><br></pre></td></tr></table></figure><h3 id="3-置空方法"><a href="#3-置空方法" class="headerlink" title="3. 置空方法"></a>3. 置空方法</h3><ul><li><strong>置空方法：</strong>在 JavaScript 中，要将一个变量或对象的值置为空（或清空），可以使用不同的方法将其设置为何种类型的空值<ol><li><strong>将变量设置为 null 或 undefined：</strong><code>var myVariable = null;</code> 或者 <code>myVariable = undefined;</code></li><li><strong>清空数组：</strong><code>var myArray = [];</code> 或者 <code>myArray.length = 0;</code></li><li><strong>清空对象：</strong><code>var myObject = &#123;&#125;;</code> 或者删除对象的属性</li><li><strong>清空字符串：</strong><code>var myString = &quot;&quot;;</code></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 置空方法就是给一个方法赋值一个空方法，同时可以接受参数执行一次</span><br><span class="line">setTimeout = function (res) &#123;</span><br><span class="line">    res()</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(hello, 3000)</span><br></pre></td></tr></table></figure><h3 id="4-json-数据的处理"><a href="#4-json-数据的处理" class="headerlink" title="4. json 数据的处理"></a>4. json 数据的处理</h3><ul><li><strong>js 处理 json 数据的方法：</strong><ul><li><strong>JSON.parse()：</strong>用于将 JSON 字符串解析为 JavaScript 对象</li><li><strong>JSON.stringify()：</strong>用于将 JavaScript 对象转换为 JSON 字符串</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var jsonString = &#x27;&#123;&quot;key&quot;: &quot;value&quot;, &quot;number&quot;: 42&#125;&#x27;;</span><br><span class="line">console.log(typeof jsonString);  // string</span><br><span class="line"></span><br><span class="line">var jsonObject = JSON.parse(jsonString);</span><br><span class="line">console.log(typeof jsonObject);  // object</span><br><span class="line"></span><br><span class="line">var jsonStrings = JSON.stringify(jsonObject)</span><br><span class="line">console.log(typeof jsonStrings);  // string</span><br></pre></td></tr></table></figure><h3 id="5-定时器详解"><a href="#5-定时器详解" class="headerlink" title="5. 定时器详解"></a>5. 定时器详解</h3><blockquote><p><strong>运行机制：</strong>定时器的运行机制是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间，如果到了就执行代码，否则继续等待。这意味着指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行；由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证 setTimeout 和 setInterval 指定的任务一定会按照预定的时间执行。</p><p><strong>思考：<code>setTimeout(f, 0)</code> 会立即执行吗？不会，要先执行完同步代码，才会执行异步代码。</strong></p></blockquote><ul><li><p><strong>setTimeout：</strong>用来指定某个函数或某段代码，在多少毫秒之后执行，返回一个整数，表示定时器的编号，可以通过编号取消这个定时器</p><ul><li><strong>语法：</strong>function setTimeout(callback, ms, …args)</li></ul><ul><li><strong>this 指针：</strong>﻿如果回调函数是对象的方法，那么 setTimeout 使得方法内部的 this 关键字将指向全局环境，而不是定义时所在的那个对象</li><li><strong>解决 this 指针指向：</strong>一是在对象的方法调用外层套上一个函数；二是使用 bind 方法直接绑定对应对象</li></ul></li><li><p><strong>setInterval：</strong>用法与 setTimeout 完全一致，区别仅在于 setInterval 指是某个任务每隔一段时间就执行一次，也就是无限次的定时执行</p><ul><li><strong>注意：</strong>setlnterval 指定的是<strong>开始执行</strong>之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setlnterval 指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后 95 毫秒，第二次执行就会开始。如果某次执行耗时特别长，超过了间隔时间，那么这一次结束后，下一次执行就会立即开始</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 一定要隔多久执行一次任务，可以使用嵌套 setTimeout</span><br><span class="line">let i = 1;</span><br><span class="line">setTimeout(function f() &#123;</span><br><span class="line">    console.log(123);</span><br><span class="line">    setTimeout(f, 2000);</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure><ul><li><strong>clearTimeout()，clearInterval() 特性：</strong><ul><li>setTimeout 和 setlnterval 函数，都返回一个整数值，表示计数器编号。将该整数传入 clearTimeout 和 clearlnterval 函数，就可以取消对应的定时器。<strong>特点就是返回的整数值是连续增大的</strong>，﻿﻿利用这一点，可以写一个函数，取消当前所有的 setTimeout 定时器（可以过一些检测）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;叽里呱啦......&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;叽里呱啦......&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;叽里呱啦......&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">(function () &#123;</span><br><span class="line">    let gid = setInterval(clearAllTimeouts, 0);</span><br><span class="line">    console.log(gid);</span><br><span class="line">    function clearAllTimeouts() &#123;</span><br><span class="line">        let id = setTimeout(function () &#123; &#125;, 0);</span><br><span class="line">        while (id &gt; 0) &#123;</span><br><span class="line">            if (id !== gid) &#123;</span><br><span class="line">                clearTimeout(id);</span><br><span class="line">            &#125;</span><br><span class="line">            id--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="三、JS-异步操作"><a href="#三、JS-异步操作" class="headerlink" title="三、JS 异步操作"></a>三、JS 异步操作</h2><blockquote><p><strong>背景：</strong>js 是单线程模型，除了一个正在运行的主线程，引擎还提供了一个任务队列（task queue），存储当前需要处理的异步任务</p><p><strong>异步：</strong>异步的核心在于不需要等待上一个操作完成才能执行下一个操作，它允许多个操作并发进行。在 js 中，异步处理可以通过 Promise、async&#x2F;await、callback 等实现，特别是在 <strong>Ajax</strong> 请求中，异步处理非常重要</p><ul><li><strong>传统的回调函数（回调地狱）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;https://api.example.com/data1&#x27;,</span><br><span class="line">    success: function(response1) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &#x27;https://api.example.com/data2&#x27;,</span><br><span class="line">            success: function(response2) &#123;</span><br><span class="line">                console.log(response1, response2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>Promise 链式处理：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#x27;https://api.example.com/data1&#x27;)</span><br><span class="line">    .then(response1 =&gt; &#123;</span><br><span class="line">        console.log(response1.data);</span><br><span class="line">        return axios.get(&#x27;https://api.example.com/data2&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(response2 =&gt; &#123;</span><br><span class="line">        console.log(response2.data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">        console.error(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-XHR-对象"><a href="#1-XHR-对象" class="headerlink" title="1. XHR 对象"></a>1. XHR 对象</h3><blockquote><p><strong>XMLHttpRequest</strong>（简称XHR）：是浏览器中用于与服务器进行交互的API，允许网页在不重新加载页面的情况下请求数据</p></blockquote><ul><li><strong>功能：</strong>提供了基础的异步通信能力，用来发送 HTTP 请求并接收响应，能够异步更新网页内容</li><li><strong>特点：</strong><ul><li>支持同步和异步请求，但通常使用异步请求</li><li>可以发送各种格式的数据，如XML、JSON、文本等</li><li>可以监听不同的事件，如 onreadystatechange，当请求状态改变时触发</li></ul></li></ul><ul><li><strong>缺点：</strong>代码复杂且容易产生回调地狱（嵌套的回调函数），可读性较差</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function AJAX() &#123;</span><br><span class="line">    this.request = function (method, url, async, string, func) &#123;</span><br><span class="line">        // 创建 XMLHttpRequest 对象</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        // 设置请求参数：使用 open 方法设置请求的类型、请求的url、是否异步处理</span><br><span class="line">        xhr.open(method, url, async);</span><br><span class="line">        // 处理状态变化：通过监听 readystatechange 事件，可以获取到 XHR 对象的状态变化</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            // 处理响应数据：responseText 用于处理文本响应，responseXML 用于处理 XML 响应</span><br><span class="line">            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">                /** readyState</span><br><span class="line">                * 0: 请求（未初始化）还没有调用send()方法</span><br><span class="line">                * 1: 请求连接已建立（载入）已调用send()方法，正在发送请求</span><br><span class="line">                * 2: 请求已接收（载入完成）send()方法执行完成，刚刚接收到全部响应内容</span><br><span class="line">                * 3: 请求处理中（交互）正在解析响应内容</span><br><span class="line">                * 4: 请求已完成（完成）响应内容解析完成</span><br><span class="line">                */</span><br><span class="line">                var responseData = xhr.responseText;</span><br><span class="line">                func(responseData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 发送请求：对于GET请求，不需要传递参数；对于POST请求，可以在 send 方法中传递请求体的数据</span><br><span class="line">        xhr.send(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ajax = new AJAX();</span><br><span class="line">var api_url = &#x27;https://xfblog.cn:5000/test&#x27;;</span><br><span class="line">ajax.request(&#x27;GET&#x27;, api_url, true, &#x27;&#x27;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-ajax-技术"><a href="#2-ajax-技术" class="headerlink" title="2. ajax 技术"></a>2. ajax 技术</h3><blockquote><p><strong>AJAX</strong>（Asynchronous JavaScript and XML）<strong>：</strong>是一种用于在网页不刷新或重新加载的情况下，异步获取和发送数据的技术</p><p><strong>同源策略：</strong>AJAX 受到同源策略的限制，即只能从相同的协议、域名和端口发起请求</p></blockquote><ul><li><p><strong>功能：</strong>ajax 的核心是 xhr 对象，通过异步的方式与服务器通信，动态更新页面内容</p></li><li><p><strong>特点：</strong></p><ul><li>可以加载部分内容，不需要刷新整个页面，从而提高用户体验</li><li>不依赖 XML，通常使用 json</li></ul></li><li><p><strong>组成：</strong></p><ul><li>使用 JavaScript 来操作 XHR 对象进行 HTTP 请求</li><li>可以与 HTML、CSS、JavaScript 结合使用，创建动态交互式的 Web 应用</li></ul></li><li><p><strong>缺点：</strong>可能产生回调嵌套问题（回调地狱）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// jquery 框架中的 $.ajax() 方法</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    // 1. url 请求地址</span><br><span class="line">    url: &#x27;&#x27;,</span><br><span class="line">    // 2. type 请求方式，默认是&#x27;GET&#x27;，常用的还有&#x27;POST&#x27;</span><br><span class="line">    type: &#x27;GET&#x27;,</span><br><span class="line">    // 3. dataType 设置返回的数据格式，常用的是&#x27;json&#x27;格式</span><br><span class="line">    dataType: &#x27;JSON&#x27;,</span><br><span class="line">    // 4. data 设置发送给服务器的数据, 没有参数不需要设置</span><br><span class="line">    data: &#x27;&#x27;,</span><br><span class="line">    // 5. success/done/then 设置请求成功后的回调函数，</span><br><span class="line">    success: function (response) &#123;</span><br><span class="line">        console.log(response);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 6. error/faile 设置请求失败后的回调函数</span><br><span class="line">    error: function () &#123;</span><br><span class="line">        alert(&quot;请求失败，请稍后再试！&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 7. async 设置是否异步，默认值是&#x27;true&#x27;，表示异步，一般不用写</span><br><span class="line">    async: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-Promise-对象"><a href="#3-Promise-对象" class="headerlink" title="3. Promise 对象"></a>3. Promise 对象</h3><blockquote><p><strong>Promise：是一种用来处理异步操作的对象，也是一个构造函数，它代表了一个异步操作的最终完成或失败</strong></p><ul><li><p><strong>Promise 对象的状态：</strong></p><ul><li><strong>Pending（进行中）</strong>：等待中，或者进行中，表示还没有得到结果</li><li><strong>resolved、Fulfilled（已成功）</strong>：已经完成，表示得到了我们想要的结果，可以继续往下执行</li><li><strong>Rejected（已失败）</strong>：得到结果，但是由于结果并非我们所愿，因此拒绝执行</li></ul></li><li><p><strong>状态的变化途径（只有两种）：</strong>从 pedding 未完成到 fulfilled 成功；从 pedding 未完成到 rejected 失败</p></li></ul><p><strong>调用栈与事件循环：</strong>在 js 中，所有的代码执行都是在一个单线程上进行的，这个线程包含了一个调用栈和一个事件循环。调用栈（call stack）用来存储函数调用的栈结构，而事件循环（event loop）则负责处理异步操作和事件处理。当执行一个 Promise 异步操作时，该操作会被推到事件队列中，等待调用栈中的代码执行完成后再执行。这种机制确保了 js 在处理异步操作时不会阻塞其他代码的执行。</p><p><strong>微任务执行机制：</strong>Promise 的回调函数不是正常的异步任务，而是 microtask 微任务。微任务的执行时间一定早于正常的回调函数，因为正常异步任务会追加到下一轮事件循环，而微任务会追加到本轮事件循环。所以 .then 回调函数的执行时间一定早于 setTimeout(fn, 0)。</p></blockquote><ul><li><p><strong>基础语法：<code> new Promise(function(resolve, reject) &#123; &#125;);</code></strong></p><ol><li>Promise 构造函数接受一个函数为参数，函数拥有 resolve 和 reject 两个参数，由 js 引擎提供不用部署</li><li>Promise 的参数在构造之后会直接被<strong>异步运行</strong>，即起始函数，异步任务执行成功时调用 resolve 返回结果</li><li>Promise 对象的 then 方法用来处理成功时响应的数据，catch 方法用来接受处理失败时响应的数据</li></ol></li><li><p><strong>resolve 函数：</strong>将 Promise 对象的状态设置为成功，从 pending 变为 resolved，在异步操作成功的时候调用，并将异步操作结果作为参数传递出去</p></li><li><p><strong>reject 函数：</strong>将 Promise 对象的状态设置为失败，从 pending 变为 rejected，在异步操作失败的时候调用，并将异步操作抛出的异常作为参数传递出去</p></li><li><p><strong>Promise.prototype.then()：</strong>对于 Promise 对象，可以使用 then 方法分别指定 resolved 和 rejected 状态的回调函数</p><ul><li><p><strong>返回值：</strong>返回一个新的 Promise 实例，所以可以采用链式写法，即 then 方法再调用一个 then 方法</p></li><li><p><strong>注意：如果 .then 中写了参数而不是函数，则会变成 Promise 穿透</strong></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;成功&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">const results = p.then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">        console.log(&quot;第一次:&quot;, res); // 第一次: 成功</span><br><span class="line">        // return 6</span><br><span class="line">        // 这里的是否有返回值决定了第二次 .then 中处理成功的回调函数是否能接收到有效参数</span><br><span class="line">    &#125;,</span><br><span class="line">    (rej) =&gt; &#123;</span><br><span class="line">        console.log(rej); // 不执行</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">        console.log(&quot;第二次:&quot;, res); // 第二次: undefined</span><br><span class="line">        // 原因：因为第一个 .then 中处理 resolved 状态的回调函数中成功没有给返回值，</span><br><span class="line">        // 所以在第二个 .then 中剥离掉 promise，拿到的 results 就是 undefined</span><br><span class="line"></span><br><span class="line">        console.log(&quot;异步:&quot;, results); // 异步: Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">        // 原因：因为这里执行时，results 虽然已经定义，但因为 .then 链是异步的，</span><br><span class="line">        // results 还是处于 pending 状态，直到所有的 then 回调都执行完毕后才会变成 fulfilled</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 这个是最先打印，所以执行这里的时候，显示还是在 pending 状态</span><br><span class="line">console.log(&quot;单线程:&quot;, results); // 单线程: Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line"></span><br><span class="line">// *********************** Promise 穿透 ************************</span><br><span class="line">const pp = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;成功&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">const result = pp.then(Promise.resolve(&quot;传不过去&quot;)); // 不是函数</span><br><span class="line">result.then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); // 成功</span><br><span class="line">    console.log(result) // Promise &#123; &#x27;成功&#x27; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 相当于以下这种写法</span><br><span class="line">pp.then(null).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); // 成功</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>Promise.prototype.catch()：</strong>用于注册在 Promise 对象拒绝（rejected）时的回调函数，同 .then 中的第二个参数的作用，两者可以同时存在，前者捕获异常则后者不会执行<ul><li><strong>冒泡性质：</strong>若 .then 中产生异常则能在 .catch 或者下一个 .then 中捕获。.then 的第二个参数和 .catch 本质上是没有区别的，但也需要分场合使用，一般异常用 .catch，拒绝状态用 .then</li><li><strong>注意：</strong>异常一旦被捕获，则后面中的 .then 不管多少，都不会执行。一般是在最后写 .catch 去捕获异常，而不会一层层 rejected 回调函数，这样代码可读性更高，且能捕获到上面最先报错的信息</li></ul></li><li><strong>Promise.prototype.finally()：</strong>用于清理和最终处理逻辑，回调函数不接受任何参数，且是否执行与 Promise 状态无关</li><li><strong>案例1：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 第一层：获取用户信息</span><br><span class="line">function getUserInfo(userId) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        // 模拟异步操作，获取用户信息</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            const userInfo = &#123;</span><br><span class="line">                id: userId,</span><br><span class="line">                name: &quot;John Doe&quot;,</span><br><span class="line">                email: &quot;johndoe@example.com&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            resolve(userInfo);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二层：获取用户订单列表</span><br><span class="line">function getUserOrders(userId) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        // 模拟异步操作，获取用户订单列表</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            const orders = [</span><br><span class="line">                &#123;id: 1, product: &quot;Product A&quot;&#125;,</span><br><span class="line">                &#123;id: 2, product: &quot;Product B&quot;&#125;,</span><br><span class="line">                &#123;id: 3, product: &quot;Product C&quot;&#125;</span><br><span class="line">            ];</span><br><span class="line">            resolve(orders);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第三层：获取订单详情</span><br><span class="line">function getOrderDetails(orderId) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        // 模拟异步操作，获取订单详情</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            const orderDetails = &#123;</span><br><span class="line">                id: orderId,</span><br><span class="line">                status: &quot;Delivered&quot;,</span><br><span class="line">                address: &quot;123 Main St&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            resolve(orderDetails);</span><br><span class="line">        &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用示例</span><br><span class="line">const userId = 123;</span><br><span class="line"></span><br><span class="line">getUserInfo(userId)</span><br><span class="line">    .then(userInfo =&gt; &#123;</span><br><span class="line">        console.log(&quot;User Info:&quot;, userInfo);</span><br><span class="line">        return getUserOrders(userInfo.id);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(orders =&gt; &#123;</span><br><span class="line">        console.log(&quot;User Orders:&quot;, orders);</span><br><span class="line">        const orderId = orders[0].id;</span><br><span class="line">        return getOrderDetails(orderId);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(orderDetails =&gt; &#123;</span><br><span class="line">        console.log(&quot;Order Details:&quot;, orderDetails);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">        console.error(&quot;Error:&quot;, error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;后续操作！！！&quot;)</span><br></pre></td></tr></table></figure><ul><li><strong>案例2：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function fetchData(url) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&#x27;GET&#x27;, url);</span><br><span class="line">        xhr.onload = function () &#123;</span><br><span class="line">            if (xhr.status === 200) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject(Error(xhr.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.onerror = function () &#123;</span><br><span class="line">            reject(Error(&#x27;Network Error&#x27;));</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用fetchData()函数并处理Promise对象的结果</span><br><span class="line">fetchData(&#x27;https://xfblog.cn:5000/test&#x27;).then(function (response) &#123;</span><br><span class="line">    // 如果Promise对象成功解决，执行这里的代码</span><br><span class="line">    var data = JSON.parse(response)</span><br><span class="line">    console.log(&quot;result_data：&quot;, data)</span><br><span class="line"></span><br><span class="line">&#125;).catch(function (error) &#123;</span><br><span class="line">    // 如果Promise对象被拒绝，执行这里的代码</span><br><span class="line">    console.log(&#x27;Error loading data:&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="四、补环境-demo"><a href="#四、补环境-demo" class="headerlink" title="四、补环境 demo"></a>四、补环境 demo</h2><h3 id="1-getOwnPropertyDescriptors"><a href="#1-getOwnPropertyDescriptors" class="headerlink" title="1. getOwnPropertyDescriptors"></a>1. getOwnPropertyDescriptors</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var navigator = &#123;</span><br><span class="line">    &quot;platform&quot;: &quot;MacIntel&quot; // 这样补就是错的，会返回true，因为浏览器上 navigator 的属性都是原型继承来的</span><br><span class="line">&#125;</span><br><span class="line">// function Navigator() &#123; &#125;</span><br><span class="line">// Navigator.prototype.constructor.platform = &quot;MacIntel&quot;</span><br><span class="line">// var navigator = new Navigator();</span><br><span class="line">function decect(r, e) &#123;</span><br><span class="line">    var i = [];</span><br><span class="line">    Object[&quot;getOwnPropertyDescriptor&quot;] &amp;&amp; i[&quot;push&quot;](Object[&quot;getOwnPropertyDescriptor&quot;](r, e));</span><br><span class="line">    Object[&quot;getOwnPropertyDescriptors&quot;] &amp;&amp; i[&quot;push&quot;](!!Object[&quot;getOwnPropertyDescriptors&quot;](r)[e]);</span><br><span class="line">    for (var a = 0; a &lt; i[&quot;length&quot;]; a++) if (i[a]) return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">console.log(decect(navigator, &quot;platform&quot;)); // true</span><br></pre></td></tr></table></figure><h3 id="2-hook-Date-伪造时间间隔"><a href="#2-hook-Date-伪造时间间隔" class="headerlink" title="2. hook Date 伪造时间间隔"></a>2. hook Date 伪造时间间隔</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var timeArray = []</span><br><span class="line">for (let i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    timeArray.push(Math.random() * 1000)</span><br><span class="line">&#125;</span><br><span class="line">// console.log(timeArray);</span><br><span class="line"></span><br><span class="line">function huakuai() &#123;</span><br><span class="line">    // 闭包，timee 初始化只会执行一次，执行时 Date.prototype 原型还没有被修改</span><br><span class="line">    var timee = new Date().getTime()</span><br><span class="line"></span><br><span class="line">    function slide() &#123;</span><br><span class="line">        console.log(new Date().getTime() - timee);</span><br><span class="line">    &#125;</span><br><span class="line">    return slide</span><br><span class="line">&#125;</span><br><span class="line">var hk = huakuai()</span><br><span class="line"></span><br><span class="line">var now = new Date().getTime();</span><br><span class="line">function go(timeArray) &#123;</span><br><span class="line">    for (let i = 0; i &lt; timeArray.length; i++) &#123;</span><br><span class="line">        Date.prototype.getTime = function () &#123;</span><br><span class="line">            return now + timeArray[i]</span><br><span class="line">        &#125;</span><br><span class="line">        hk()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">go(timeArray)</span><br></pre></td></tr></table></figure><h3 id="3-hook-Function-绕过反-hook"><a href="#3-hook-Function-绕过反-hook" class="headerlink" title="3. hook Function 绕过反 hook"></a>3. hook Function 绕过反 hook</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function Navigator() &#123; &#125;</span><br><span class="line">Navigator.prototype.constructor.toString = function () &#123;</span><br><span class="line">    return &#x27;function Navigator() &#123; [native code] &#125;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">var navigator = new Navigator();</span><br><span class="line"></span><br><span class="line">console.log(Function.prototype.toString.call(navigator.constructor)) // function Navigator()&#123;&#125;</span><br><span class="line">/* 原理：</span><br><span class="line">1. 定义 function Navigator()&#123;&#125; 时，Navigator.prototype.constructor 默认会被设置为 Navigator 本身。</span><br><span class="line">因此，navigator.constructor 是 Navigator，而 navigator.constructor.toString() 调用的默认是 Function.prototype.toString 方法。</span><br><span class="line"></span><br><span class="line">2. 通过重写 Navigator.prototype.constructor.toString 并没有改变 Function.prototype.toString 的默认行为，</span><br><span class="line">而是给 Navigator.prototype.constructor 上定义了一个新的 toString 方法。</span><br><span class="line">这意味着只有在显式调用 navigator.constructor.toString() 时，才会返回 &#x27;function Navigator() &#123; [native code] &#125;&#x27;</span><br><span class="line"></span><br><span class="line">3. Function.prototype.toString.call(navigator.constructor) 实际上调用的是 Function.prototype.toString，</span><br><span class="line">返回的是函数本身的字符串表示形式，不会调用 constructor.toString。</span><br><span class="line">换句话说，Function.prototype.toString 是返回函数定义的原始代码形式，而不是通过 toString 方法定制的结果。</span><br><span class="line">因此，它仍然会返回 function Navigator()&#123;&#125;，这是该函数的默认表示形式</span><br><span class="line"></span><br><span class="line">总结：Function.prototype.toString 是一个内置方法，用于返回函数的代码表示，主要用于调试或显示目的，</span><br><span class="line">它会忽略我们在原型链上手动重写的 toString 方法，直接返回函数的代码结构，并不依赖于 toString 方法的覆盖。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var oldtostr = Function.prototype.toString;</span><br><span class="line">Function.prototype.toString = function () &#123;</span><br><span class="line">    var res = oldtostr.call(this);</span><br><span class="line">    if (this.name === &quot;Navigator&quot;) &#123;</span><br><span class="line">        console.log(&quot;原始：&quot; + this.name + &#x27; --&gt; toString：&#x27; + res);</span><br><span class="line">        return &quot;function Navigator() &#123; [native code] &#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function checknavigator() &#123;</span><br><span class="line">    return Function.prototype.toString.call(navigator.constructor) === &#x27;function Navigator() &#123; [native code] &#125;&#x27;</span><br><span class="line">    // return navigator.constructor.toString() === &#x27;function Navigator() &#123; [native code] &#125;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(checknavigator()); // true</span><br><span class="line">console.log(navigator.constructor.toString()); // function Navigator() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure><h3 id="4-hook-indexOf-异常堆栈检测"><a href="#4-hook-indexOf-异常堆栈检测" class="headerlink" title="4. hook indexOf 异常堆栈检测"></a>4. hook indexOf 异常堆栈检测</h3><blockquote><p>注意：IndexOf 通常用于对异常堆栈的输出内容的检测，通过 Hook 脚本配合 if 判断入参，修改 indexOf 的返回值即可绕过检测（遇到类似 indexOf 这样常用的检测方法，可以 Hook 其调用，通常会打印出一些检测点）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let old_indexOf = String.prototype.indexOf;</span><br><span class="line">String.prototype.indexOf = function (args) &#123;</span><br><span class="line">    let res = old_indexOf.call(this, args);</span><br><span class="line">    console.log(`【 indexOf 】--&gt; &quot;$&#123;this&#125;&quot;.indexOf(&quot;$&#123;args&#125;&quot;) --&gt; $&#123;res&#125;`);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let old_indexOf = String.prototype.indexOf;</span><br><span class="line">String.prototype.indexOf = function (args) &#123;</span><br><span class="line">    let res = old_indexOf.call(this, args);</span><br><span class="line">    let new_res = undefined;</span><br><span class="line">    if (args == &#x27;flight_touch_react&#x27;) &#123;</span><br><span class="line">        new_res = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(`【 indexOf 】--&gt; &quot;$&#123;this&#125;&quot;.indexOf(&quot;$&#123;args&#125;&quot;) --&gt; $&#123;res&#125; --&gt; 修改返回值：$&#123;new_res&#125;`);</span><br><span class="line">    return new_res ? new_res : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【 indexOf 】--&gt; &quot;ReferenceError: a is not defined</span><br><span class="line">    at _0x210380 (eval at doom (/Users/xfblog/Desktop/study/补环境demo/demo2.js:133:21), &lt;anonymous&gt;:1:21735)</span><br><span class="line">    at doom (/Users/xfblog/Desktop/study/补环境demo/demo2.js:134:16)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/xfblog/Desktop/study/补环境demo/demo2.js:139:11)</span><br><span class="line">    at Module._compile (node:internal/modules/cjs/loader:1546:14)</span><br><span class="line">    at Module._extensions..js (node:internal/modules/cjs/loader:1691:10)</span><br><span class="line">    at Module.load (node:internal/modules/cjs/loader:1317:32)</span><br><span class="line">    at Module._load (node:internal/modules/cjs/loader:1127:12)</span><br><span class="line">    at TracingChannel.traceSync (node:diagnostics_channel:315:14)</span><br><span class="line">    at wrapModuleLoad (node:internal/modules/cjs/loader:217:24)</span><br><span class="line">    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:166:5)&quot;.indexOf(&quot;flight_touch_react&quot;) --&gt; -1 --&gt; 修改返回值：1</span><br></pre></td></tr></table></figure><h3 id="5-内置-Symbol-环境检测"><a href="#5-内置-Symbol-环境检测" class="headerlink" title="5. 内置 Symbol 环境检测"></a>5. 内置 Symbol 环境检测</h3><blockquote><p><strong>Symbol.toPrimitive：</strong>为对象定义一个<strong>原始值转换</strong>方法。这个方法会在对象参与一些类型转换时被调用，比如在对象与字符串或数字进行相加、比较等操作时，通过 Symbol.toPrimitive 指定的函数可以自定义对象如何转换成原始值</p><ol><li><strong>字符串上下文</strong>：例如字符串拼接操作 <code>object + &quot;string&quot;</code></li><li><strong>数字上下文</strong>：例如数值运算操作 <code>object - 0</code></li><li><strong>默认上下文</strong>：例如 <code>alert(object)</code> 或者 <code>object == &quot;value&quot;</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.toPrimitive](hint) &#123;</span><br><span class="line">    if (hint === &quot;number&quot;) &#123;</span><br><span class="line">      return 42; // 数字上下文中返回 42</span><br><span class="line">    &#125;</span><br><span class="line">    if (hint === &quot;string&quot;) &#123;</span><br><span class="line">      return &quot;Hello&quot;; // 字符串上下文中返回 &quot;Hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return true; // 默认上下文中返回 true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(+obj);           // 42，数字上下文</span><br><span class="line">console.log(`$&#123;obj&#125;`);       // &quot;Hello&quot;，字符串上下文</span><br><span class="line">console.log(obj + &quot; world&quot;); // &quot;Hello world&quot;，默认上下文</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line">/* ================================= 补环境区域 START ================================= */</span><br><span class="line">window = global;</span><br><span class="line">exports = undefined;</span><br><span class="line">// ----------------------------------------------------------------------------------</span><br><span class="line">// navigator[Symbol.toStringTag] --&gt; Navigator.prototype[Symbol.toStringTag] --&gt; &#x27;Navigator&#x27;</span><br><span class="line">// 属性描述符：Object.getOwnPropertyDescriptor(Navigator.prototype, Symbol.toStringTag)</span><br><span class="line">function Navigator() &#123; &#125;</span><br><span class="line">Object.defineProperties(Navigator.prototype, &#123;</span><br><span class="line">[Symbol.toStringTag]: &#123;</span><br><span class="line">&quot;value&quot;: &quot;Navigator&quot;,</span><br><span class="line">&quot;writable&quot;: false,</span><br><span class="line">&quot;enumerable&quot;: false,</span><br><span class="line">&quot;configurable&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">navigator = new Navigator();</span><br><span class="line"></span><br><span class="line">// window[Symbol.toStringTag] --&gt; Window.prototype[Symbol.toStringTag] --&gt; &#x27;Window&#x27;</span><br><span class="line">Object.defineProperties(global, &#123;</span><br><span class="line">[Symbol.toStringTag]: &#123;</span><br><span class="line">&quot;value&quot;: &quot;Window&quot;,</span><br><span class="line">&quot;writable&quot;: false,</span><br><span class="line">&quot;enumerable&quot;: false,</span><br><span class="line">&quot;configurable&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var Document = function () &#123; &#125;</span><br><span class="line">// function Document() &#123; &#125;</span><br><span class="line">Document.prototype[Symbol.toStringTag] = &quot;Document&quot;;</span><br><span class="line">// typeof HTMLDocument --&gt; &#x27;function&#x27;</span><br><span class="line">function HTMLDocument() &#123; &#125;</span><br><span class="line">// HTMLDocument 构造函数的原型并没有自定义的 Symbol.toStringTag 属性，</span><br><span class="line">// 因此 document 对象继承了默认的 Object.prototype.toString，输出为 [object Object]</span><br><span class="line">HTMLDocument.prototype[Symbol.toStringTag] = &quot;HTMLDocument&quot;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(HTMLDocument.prototype, Document.prototype);</span><br><span class="line">document = Object.setPrototypeOf(&#123;&#125;, HTMLDocument.prototype);</span><br><span class="line">// ----------------------------------------------------------------------------------</span><br><span class="line">!(function getEnvironment(proxyArray) &#123;</span><br><span class="line">function getObjhandler(proxyName) &#123;</span><br><span class="line">return &#123;</span><br><span class="line">get(target, property, receiver) &#123;</span><br><span class="line">if (target[property] instanceof Object) &#123;</span><br><span class="line">console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">return new Proxy(target[property], getObjhandler(`$&#123;proxyName&#125;.$&#123;String(property)&#125;`));</span><br><span class="line">&#125;</span><br><span class="line">if (typeof property == &#x27;symbol&#x27;) &#123;</span><br><span class="line">console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;target[property]&#125;`);</span><br><span class="line">return Reflect.get(...arguments);</span><br><span class="line">&#125;</span><br><span class="line">console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">try &#123;</span><br><span class="line">return Reflect.get(...arguments);</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">console.error(`【异常捕获】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;target[property]&#125;: \n$&#123;error.message&#125; --------`);</span><br><span class="line">if (property == &quot;userAgent&quot;) &#123;</span><br><span class="line">return &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 根据业务逻辑返回默认值或进行其他处理</span><br><span class="line">return target[property];  // 或者其他合适的默认值</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">set(target, property, value, receiver) &#123;</span><br><span class="line">console.log(`【 set 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof value&#125; --&gt; $&#123;value&#125;`);</span><br><span class="line">return Reflect.set(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">has(target, propKey) &#123;</span><br><span class="line">console.log(`【 has 】--&gt; [$&#123;String(propKey)&#125;] in [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.has(...arguments)&#125;`);</span><br><span class="line">return Reflect.has(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">deleteProperty(target, propKey) &#123;</span><br><span class="line">console.log(`【 deleteProperty 】--&gt; delete [$&#123;String(propKey)&#125;] from [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.deleteProperty(...arguments)&#125;`);</span><br><span class="line">return Reflect.deleteProperty(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">getOwnPropertyDescriptor(target, propKey) &#123;</span><br><span class="line">console.log(`【 getOwnPropertyDescriptor 】--&gt; ($&#123;proxyName&#125;, &quot;$&#123;String(propKey)&#125;&quot;) --&gt; $&#123;JSON.stringify(Reflect.getOwnPropertyDescriptor(...arguments))&#125;`);</span><br><span class="line">return Reflect.getOwnPropertyDescriptor(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">defineProperty(target, propKey, propDesc) &#123;</span><br><span class="line">console.log(`【 defineProperty 】--&gt; $&#123;proxyName&#125;.$&#123;String(propKey)&#125; --&gt; $&#123;JSON.stringify(propDesc)&#125; --&gt; $&#123;Reflect.defineProperty(...arguments)&#125;`);</span><br><span class="line">return Reflect.defineProperty(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">preventExtensions(target) &#123;</span><br><span class="line">console.log(`【 preventExtensions 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.preventExtensions(...arguments)&#125;`);</span><br><span class="line">return Reflect.preventExtensions(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">isExtensible(target) &#123;</span><br><span class="line">console.log(`【 isExtensible 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.isExtensible(...arguments)&#125;`);</span><br><span class="line">return Reflect.isExtensible(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">getPrototypeOf(target) &#123;</span><br><span class="line">console.log(`【 getPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.getPrototypeOf(...arguments)&#125;`);</span><br><span class="line">return Reflect.getPrototypeOf(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">setPrototypeOf(target, proto) &#123;</span><br><span class="line">console.log(`【 setPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(proto)&#125; --&gt; $&#123;Reflect.setPrototypeOf(...arguments)&#125;`);</span><br><span class="line">return Reflect.setPrototypeOf(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line">ownKeys(target) &#123;</span><br><span class="line">console.log(`【 ownKeys 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(Reflect.ownKeys(...arguments))&#125;`);</span><br><span class="line">return Reflect.ownKeys(...arguments)</span><br><span class="line">&#125;,</span><br><span class="line">apply(target, thisArg, args) &#123;</span><br><span class="line">console.log(`【 apply 】--&gt; $&#123;proxyName&#125;($&#123;args&#125;) --&gt; $&#123;Reflect.apply(...arguments)&#125;`);</span><br><span class="line">return Reflect.apply(...arguments)</span><br><span class="line">&#125;,</span><br><span class="line">construct(target, args) &#123;</span><br><span class="line">console.log(`【 construct 】--&gt; new Proxy($&#123;args&#125;) --&gt; $&#123;Reflect.construct(...arguments)&#125;`);</span><br><span class="line">return Reflect.construct(...arguments)</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxyArray.forEach(proxyName =&gt; &#123;</span><br><span class="line">globalThis[proxyName] = new Proxy(globalThis[proxyName] || &#123;&#125;, getObjhandler(proxyName))</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)([&#x27;window&#x27;, &#x27;document&#x27;, &#x27;location&#x27;, &#x27;navigator&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;]);</span><br><span class="line">// window 在经过代理器设置后，转换为了 Proxy 对象，Object.is(window, globalThis) 检测则为 false</span><br><span class="line">globalThis = window;</span><br><span class="line">/* ================================== 补环境区域 END ================================== */</span><br><span class="line"></span><br><span class="line">var _0x4f2a = [&#x27;xZb4mZK4nti1&#x27;, &#x27;mZa3ndy5u0Xgt2nZ&#x27;, &#x27;mti0nJuWmMnHwLDszq&#x27;, &#x27;ExOWmtiZndu2nW&#x27;, &#x27;mJG3mdLHuuDiwNa&#x27;, &#x27;odKRlW&#x27;, &#x27;BMrVD10&#x27;, &#x27;vvzxwfLAywjJza&#x27;, &#x27;qujdrevg&#x27;, &#x27;oeDjvNbuzW&#x27;, &#x27;w29IAMvJDcboyq&#x27;, &#x27;zhrH&#x27;, &#x27;y29Uy2f0&#x27;, &#x27;xZb4mtm0zMnI&#x27;, &#x27;mJroEML4sg0&#x27;, &#x27;mtaXm2n1BwrtuW&#x27;, &#x27;zNvUy3rPB24&#x27;, &#x27;DMLNyxrVCL0&#x27;, &#x27;mtmWotG2vvDAA2Xt&#x27;, &#x27;mdeYmZq1nJC4oq&#x27;, &#x27;ywjJzgvM&#x27;, &#x27;w29IAMvJDcbxAq&#x27;, &#x27;y2HHCKnVzgvbDa&#x27;, &#x27;nJK0uvHZDLfZ&#x27;, &#x27;Dg9tDhjPBMC&#x27;, &#x27;xZb4ntjLowiX&#x27;, &#x27;y2HHCKf0&#x27;, &#x27;BgvUz3rO&#x27;, &#x27;qujdrevgr0HjsG&#x27;, &#x27;mJe0mvP1zufwBq&#x27;, &#x27;ndq0otL5v1DivMC&#x27;, &#x27;z2v0uhjVDg90Eq&#x27;, &#x27;CMfUzg9T&#x27;];</span><br><span class="line">var _0x3b2a2b = _0x5299;</span><br><span class="line">(function (_0x484f5c, _0x4c9781) &#123;</span><br><span class="line">var _0x5b5144 = _0x5299;</span><br><span class="line">while (!![]) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var _0x8f4b64 = parseInt(_0x5b5144(0x1d2)) * -parseInt(_0x5b5144(0x1da)) + -parseInt(_0x5b5144(0x1e1)) * parseInt(_0x5b5144(&#x27;0x1cc&#x27;)) + parseInt(_0x5b5144(&#x27;0x1e6&#x27;)) + -parseInt(_0x5b5144(0x1e5)) + -parseInt(_0x5b5144(0x1e0)) + parseInt(_0x5b5144(&#x27;0x1d5&#x27;)) + -parseInt(_0x5b5144(&#x27;0x1e8&#x27;)) * -parseInt(_0x5b5144(0x1d1));</span><br><span class="line">if (_0x8f4b64 === _0x4c9781) break; else _0x484f5c[&#x27;push&#x27;](_0x484f5c[&#x27;shift&#x27;]());</span><br><span class="line">&#125; catch (_0x24a143) &#123;</span><br><span class="line">_0x484f5c[&#x27;push&#x27;](_0x484f5c[&#x27;shift&#x27;]());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(_0x4f2a, 0xaa618));</span><br><span class="line">var hexcase = 0x0, b64pad = &#x27;&#x27;, chrsz = 0x8;</span><br><span class="line"></span><br><span class="line">function _0x5299(_0x3d96c8, _0x6e00cb) &#123;</span><br><span class="line">return _0x5299 = function (_0x4f2a0d, _0x52996e) &#123;</span><br><span class="line">_0x4f2a0d = _0x4f2a0d - 0x1cb;</span><br><span class="line">var _0x4419a2 = _0x4f2a[_0x4f2a0d];</span><br><span class="line">if (_0x5299[&#x27;NuRqdF&#x27;] === undefined) &#123;</span><br><span class="line">var _0x2ee095 = function (_0x3a9367) &#123;</span><br><span class="line">var _0x134fcb = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=&#x27;;</span><br><span class="line">var _0x398525 = &#x27;&#x27;, _0x52e9b1 = &#x27;&#x27;;</span><br><span class="line">for (var _0x2f7fc6 = 0x0, _0x55745b, _0x47055a, _0xdf9aa5 = 0x0; _0x47055a = _0x3a9367[&#x27;charAt&#x27;](_0xdf9aa5++); ~_0x47055a &amp;&amp; (_0x55745b = _0x2f7fc6 % 0x4 ? _0x55745b * 0x40 + _0x47055a : _0x47055a, _0x2f7fc6++ % 0x4) ? _0x398525 += String[&#x27;fromCharCode&#x27;](0xff &amp; _0x55745b &gt;&gt; (-0x2 * _0x2f7fc6 &amp; 0x6)) : 0x0) &#123;</span><br><span class="line">_0x47055a = _0x134fcb[&#x27;indexOf&#x27;](_0x47055a);</span><br><span class="line">&#125;</span><br><span class="line">for (var _0x2853cd = 0x0, _0x4b5792 = _0x398525[&#x27;length&#x27;]; _0x2853cd &lt; _0x4b5792; _0x2853cd++) &#123;</span><br><span class="line">_0x52e9b1 += &#x27;%&#x27; + (&#x27;00&#x27; + _0x398525[&#x27;charCodeAt&#x27;](_0x2853cd)[&#x27;toString&#x27;](0x10))[&#x27;slice&#x27;](-0x2);</span><br><span class="line">&#125;</span><br><span class="line">return decodeURIComponent(_0x52e9b1);</span><br><span class="line">&#125;;</span><br><span class="line">_0x5299[&#x27;xuuilA&#x27;] = _0x2ee095, _0x3d96c8 = arguments, _0x5299[&#x27;NuRqdF&#x27;] = !![];</span><br><span class="line">&#125;</span><br><span class="line">var _0x1b36c9 = _0x4f2a[0x0], _0x7dadab = _0x4f2a0d + _0x1b36c9, _0x1af7e2 = _0x3d96c8[_0x7dadab];</span><br><span class="line">return !_0x1af7e2 ? (_0x4419a2 = _0x5299[&#x27;xuuilA&#x27;](_0x4419a2), _0x3d96c8[_0x7dadab] = _0x4419a2) : _0x4419a2 = _0x1af7e2, _0x4419a2;</span><br><span class="line">&#125;, _0x5299(_0x3d96c8, _0x6e00cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let lmd5 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function core_md5(_0x2f7fc6, _0x55745b) &#123;</span><br><span class="line">_0x2f7fc6[_0x55745b &gt;&gt; 0x5] |= 0x80 &lt;&lt; _0x55745b % 0x20, _0x2f7fc6[(_0x55745b + 0x40 &gt;&gt;&gt; 0x9 &lt;&lt; 0x4) + 0xe] = _0x55745b;</span><br><span class="line">var _0x47055a = 0x67452301, _0xdf9aa5 = -0x10325477, _0x2853cd = -0x67452302, _0x4b5792 = 0x10325476;</span><br><span class="line">for (var _0xc26d62 = 0x0; _0xc26d62 &lt; _0x2f7fc6[&#x27;length&#x27;]; _0xc26d62 += 0x10) &#123;</span><br><span class="line">var _0x41dc6f = _0x47055a, _0x1477b2 = _0xdf9aa5, _0x1723b5 = _0x2853cd, _0x3f85d4 = _0x4b5792;</span><br><span class="line">_0x47055a = md5_ff(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x0], 0x7, -0x28955b88), _0x4b5792 = md5_ff(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x1], 0xc, -0x173848aa), _0x2853cd = md5_ff(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x2], 0x11, 0x242070db), _0xdf9aa5 = md5_ff(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x3], 0x16, -0x3e423112), _0x47055a = md5_ff(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x4], 0x7, -0xa83f051), _0x4b5792 = md5_ff(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x5], 0xc, 0x4787c62a), _0x2853cd = md5_ff(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x6], 0x11, -0x57cfb9ed), _0xdf9aa5 = md5_ff(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x7], 0x16, -0x2b96aff), _0x47055a = md5_ff(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x8], 0x7, 0x698098d8), _0x4b5792 = md5_ff(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x9], 0xc, -0x74bb0851), _0x2853cd = md5_ff(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xa], 0x11, -0xa44f), _0xdf9aa5 = md5_ff(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0xb], 0x16, -0x76a32842), _0x47055a = md5_ff(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0xc], 0x7, 0x6b901122), _0x4b5792 = md5_ff(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0xd], 0xc, -0x2678e6d), _0x2853cd = md5_ff(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xe], 0x11, -0x5986bc72), _0xdf9aa5 = md5_ff(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0xf], 0x16, 0x49b40821), _0x47055a = md5_gg(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x1], 0x5, -0x9e1da9e), _0x4b5792 = md5_gg(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x6], 0x9, -0x3fbf4cc0), _0x2853cd = md5_gg(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xb], 0xe, 0x265e5a51), _0xdf9aa5 = md5_gg(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x0], 0x14, -0x16493856), _0x47055a = md5_gg(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x5], 0x5, -0x29d0efa3), _0x4b5792 = md5_gg(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0xa], 0x9, 0x2441453), _0x2853cd = md5_gg(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xf], 0xe, -0x275e197f), _0xdf9aa5 = md5_gg(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x4], 0x14, -0x182c0438), _0x47055a = md5_gg(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x9], 0x5, 0x21e1cde6), _0x4b5792 = md5_gg(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0xe], 0x9, -0x3cc8f82a), _0x2853cd = md5_gg(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x3], 0xe, -0xb2af279), _0xdf9aa5 = md5_gg(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x8], 0x14, 0x455a14ed), _0x47055a = md5_gg(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0xd], 0x5, -0x561c16fb), _0x4b5792 = md5_gg(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x2], 0x9, -0x3105c08), _0x2853cd = md5_gg(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x7], 0xe, 0x676f02d9), _0xdf9aa5 = md5_gg(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0xc], 0x14, -0x72d5b376), _0x47055a = md5_hh(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x5], 0x4, -0x5c6be), _0x4b5792 = md5_hh(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x8], 0xb, -0x788e097f), _0x2853cd = md5_hh(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xb], 0x10, 0x6d9d6122), _0xdf9aa5 = md5_hh(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0xe], 0x17, -0x21ac7f4), _0x47055a = md5_hh(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x1], 0x4, -0x5b4115bc), _0x4b5792 = md5_hh(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x4], 0xb, 0x4bdecfa9), _0x2853cd = md5_hh(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x7], 0x10, -0x944b4a0), _0xdf9aa5 = md5_hh(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0xa], 0x17, -0x41404390), _0x47055a = md5_hh(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0xd], 0x4, 0x289b7ec6), _0x4b5792 = md5_hh(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x0], 0xb, -0x155ed806), _0x2853cd = md5_hh(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x3], 0x10, -0x2b10cf7b), _0xdf9aa5 = md5_hh(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x6], 0x17, 0x4881d05), _0x47055a = md5_hh(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x9], 0x4, -0x262b2fc7), _0x4b5792 = md5_hh(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0xc], 0xb, -0x1924661b), _0x2853cd = md5_hh(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xf], 0x10, 0x1fa27cf8), _0xdf9aa5 = md5_hh(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x2], 0x17, -0x3b53a99b), _0x47055a = md5_ii(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x0], 0x6, -0xbd6ddbc), _0x4b5792 = md5_ii(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x7], 0xa, 0x432aff97), _0x2853cd = md5_ii(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xe], 0xf, -0x546bdc59), _0xdf9aa5 = md5_ii(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x5], 0x15, -0x36c5fc7), _0x47055a = md5_ii(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0xc], 0x6, 0x655b59c3), _0x4b5792 = md5_ii(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0x3], 0xa, -0x70f3336e), _0x2853cd = md5_ii(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0xa], 0xf, -0x100b83), _0xdf9aa5 = md5_ii(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x1], 0x15, -0x7a7ba22f), _0x47055a = md5_ii(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x8], 0x6, 0x6fa87e4f), _0x4b5792 = md5_ii(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0xf], 0xa, -0x1d31920), _0x2853cd = md5_ii(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x6], 0xf, -0x5cfebcec), _0xdf9aa5 = md5_ii(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0xd], 0x15, 0x4e0811a1), _0x47055a = md5_ii(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792, _0x2f7fc6[_0xc26d62 + 0x4], 0x6, -0x8ac817e), _0x4b5792 = md5_ii(_0x4b5792, _0x47055a, _0xdf9aa5, _0x2853cd, _0x2f7fc6[_0xc26d62 + 0xb], 0xa, -0x42c50dcb), _0x2853cd = md5_ii(_0x2853cd, _0x4b5792, _0x47055a, _0xdf9aa5, _0x2f7fc6[_0xc26d62 + 0x2], 0xf, 0x2ad7d2bb), _0xdf9aa5 = md5_ii(_0xdf9aa5, _0x2853cd, _0x4b5792, _0x47055a, _0x2f7fc6[_0xc26d62 + 0x9], 0x15, -0x14792c6f), _0x47055a = safe_add(_0x47055a, _0x41dc6f), _0xdf9aa5 = safe_add(_0xdf9aa5, _0x1477b2), _0x2853cd = safe_add(_0x2853cd, _0x1723b5), _0x4b5792 = safe_add(_0x4b5792, _0x3f85d4);</span><br><span class="line">&#125;</span><br><span class="line">return Array(_0x47055a, _0xdf9aa5, _0x2853cd, _0x4b5792);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5_cmn(_0x4fedd5, _0x4ad202, _0x3dab77, _0xe30333, _0x179e32, _0x134940) &#123;</span><br><span class="line">return safe_add(bit_rol(safe_add(safe_add(_0x4ad202, _0x4fedd5), safe_add(_0xe30333, _0x134940)), _0x179e32), _0x3dab77);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5_ff(_0x48dd01, _0x590894, _0x2a8b56, _0x5a1ed7, _0x39782e, _0x1c6730, _0x65ff94) &#123;</span><br><span class="line">return md5_cmn(_0x590894 &amp; _0x2a8b56 | ~_0x590894 &amp; _0x5a1ed7, _0x48dd01, _0x590894, _0x39782e, _0x1c6730, _0x65ff94);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5_gg(_0x38eafa, _0x3c9926, _0x494836, _0x9ba7f5, _0x29faac, _0x4a5104, _0x1a6d52) &#123;</span><br><span class="line">return md5_cmn(_0x3c9926 &amp; _0x9ba7f5 | _0x494836 &amp; ~_0x9ba7f5, _0x38eafa, _0x3c9926, _0x29faac, _0x4a5104, _0x1a6d52);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5_hh(_0x493e8f, _0x241c10, _0x4b56bc, _0x511e91, _0x5cacdb, _0x12d467, _0x19c090) &#123;</span><br><span class="line">return md5_cmn(_0x241c10 ^ _0x4b56bc ^ _0x511e91, _0x493e8f, _0x241c10, _0x5cacdb, _0x12d467, _0x19c090);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5_ii(_0x1e564b, _0x1cb61f, _0x40aea0, _0x1cd8ad, _0x3a955f, _0x527294, _0x2a51ff) &#123;</span><br><span class="line">return md5_cmn(_0x40aea0 ^ (_0x1cb61f | ~_0x1cd8ad), _0x1e564b, _0x1cb61f, _0x3a955f, _0x527294, _0x2a51ff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function core_hmac_md5(_0x22b4fd, _0x599a94) &#123;</span><br><span class="line">var _0x1e547d = _0x5299, _0x3440f1 = str2binl(_0x22b4fd);</span><br><span class="line">if (_0x3440f1[_0x1e547d(0x1de)] &gt; 0x10) _0x3440f1 = core_md5(_0x3440f1, _0x22b4fd[_0x1e547d(0x1de)] * chrsz);</span><br><span class="line">var _0x2074c1 = Array(0x10), _0x1a616d = Array(0x10);</span><br><span class="line">for (var _0x57b248 = 0x0; _0x57b248 &lt; 0x10; _0x57b248++) &#123;</span><br><span class="line">_0x2074c1[_0x57b248] = _0x3440f1[_0x57b248] ^ 0x36363636, _0x1a616d[_0x57b248] = _0x3440f1[_0x57b248] ^ 0x5c5c5c5c;</span><br><span class="line">&#125;</span><br><span class="line">var _0x15a71b = core_md5(_0x2074c1[_0x1e547d(&#x27;0x1cf&#x27;)](str2binl(_0x599a94)), 0x200 + _0x599a94[&#x27;length&#x27;] * chrsz);</span><br><span class="line">return core_md5(_0x1a616d[_0x1e547d(0x1cf)](_0x15a71b), 0x200 + 0x80);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function safe_add(_0x1d693d, _0x2213b8) &#123;</span><br><span class="line">var _0xf479d8 = (_0x1d693d &amp; 0xffff) + (_0x2213b8 &amp; 0xffff),</span><br><span class="line">_0x1654f5 = (_0x1d693d &gt;&gt; 0x10) + (_0x2213b8 &gt;&gt; 0x10) + (_0xf479d8 &gt;&gt; 0x10);</span><br><span class="line">return _0x1654f5 &lt;&lt; 0x10 | _0xf479d8 &amp; 0xffff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bit_rol(_0x582e5a, _0x296943) &#123;</span><br><span class="line">return _0x582e5a &lt;&lt; _0x296943 | _0x582e5a &gt;&gt;&gt; 0x20 - _0x296943;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function str2binl(_0xb2b531) &#123;</span><br><span class="line">var _0x49f657 = _0x5299, _0x2694a4 = Array(), _0x3c61d4 = (0x1 &lt;&lt; chrsz) - 0x1;</span><br><span class="line">for (var _0xcf1ffd = 0x0; _0xcf1ffd &lt; _0xb2b531[_0x49f657(&#x27;0x1de&#x27;)] * chrsz; _0xcf1ffd += chrsz) _0x2694a4[_0xcf1ffd &gt;&gt; 0x5] |= (_0xb2b531[_0x49f657(&#x27;0x1d9&#x27;)](_0xcf1ffd / chrsz) &amp; _0x3c61d4) &lt;&lt; _0xcf1ffd % 0x20;</span><br><span class="line">return _0x2694a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function binl2str(_0x494a15) &#123;</span><br><span class="line">var _0x21474f = _0x5299, _0x22bebd = &#x27;&#x27;, _0x4ae780 = (0x1 &lt;&lt; chrsz) - 0x1;</span><br><span class="line">for (var _0x5339a0 = 0x0; _0x5339a0 &lt; _0x494a15[_0x21474f(0x1de)] * 0x20; _0x5339a0 += chrsz) _0x22bebd += String[&#x27;fromCharCo&#x27; + &#x27;de&#x27;](_0x494a15[_0x5339a0 &gt;&gt; 0x5] &gt;&gt;&gt; _0x5339a0 % 0x20 &amp; _0x4ae780);</span><br><span class="line">return _0x22bebd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function binl2hex(_0x105709) &#123;</span><br><span class="line">var _0x3e0fbc = _0x5299,</span><br><span class="line">_0x3090af = hexcase ? _0x3e0fbc(0x1d6) + _0x3e0fbc(0x1cb) : _0x3e0fbc(0x1d6) + _0x3e0fbc(&#x27;0x1d7&#x27;), _0x48992b = &#x27;&#x27;;</span><br><span class="line">for (var _0x27af63 = 0x0; _0x27af63 &lt; _0x105709[_0x3e0fbc(&#x27;0x1de&#x27;)] * 0x4; _0x27af63++) &#123;</span><br><span class="line">_0x48992b += _0x3090af[_0x3e0fbc(&#x27;0x1dd&#x27;)](_0x105709[_0x27af63 &gt;&gt; 0x2] &gt;&gt; _0x27af63 % 0x4 * 0x8 + 0x4 &amp; 0xf) + _0x3090af[_0x3e0fbc(&#x27;0x1dd&#x27;)](_0x105709[_0x27af63 &gt;&gt; 0x2] &gt;&gt; _0x27af63 % 0x4 * 0x8 &amp; 0xf);</span><br><span class="line">&#125;</span><br><span class="line">return _0x48992b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function binl2b64(_0x1fcb8d) &#123;</span><br><span class="line">var _0x1f69a8 = _0x5299,</span><br><span class="line">_0x4b8368 = _0x1f69a8(0x1df) + &#x27;KLMNOPQRST&#x27; + _0x1f69a8(&#x27;0x1eb&#x27;) + &#x27;efghijklmn&#x27; + &#x27;opqrstuvwx&#x27; + _0x1f69a8(0x1e7) + _0x1f69a8(0x1e9),</span><br><span class="line">_0x37174f = &#x27;&#x27;;</span><br><span class="line">for (var _0x539d82 = 0x0; _0x539d82 &lt; _0x1fcb8d[_0x1f69a8(0x1de)] * 0x4; _0x539d82 += 0x3) &#123;</span><br><span class="line">var _0x3a7b6d = (_0x1fcb8d[_0x539d82 &gt;&gt; 0x2] &gt;&gt; 0x8 * (_0x539d82 % 0x4) &amp; 0xff) &lt;&lt; 0x10 | (_0x1fcb8d[_0x539d82 + 0x1 &gt;&gt; 0x2] &gt;&gt; 0x8 * ((_0x539d82 + 0x1) % 0x4) &amp; 0xff) &lt;&lt; 0x8 | _0x1fcb8d[_0x539d82 + 0x2 &gt;&gt; 0x2] &gt;&gt; 0x8 * ((_0x539d82 + 0x2) % 0x4) &amp; 0xff;</span><br><span class="line">for (var _0x7aed3a = 0x0; _0x7aed3a &lt; 0x4; _0x7aed3a++) &#123;</span><br><span class="line">if (_0x539d82 * 0x8 + _0x7aed3a * 0x6 &gt; _0x1fcb8d[_0x1f69a8(0x1de)] * 0x20) _0x37174f += b64pad; else _0x37174f += _0x4b8368[_0x1f69a8(&#x27;0x1dd&#x27;)](_0x3a7b6d &gt;&gt; 0x6 * (0x3 - _0x7aed3a) &amp; 0x3f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return _0x37174f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window[_0x3b2a2b(&#x27;0x1ce&#x27;)] = function (_0x4ecca8) &#123;</span><br><span class="line">var _0x5d2d42 = _0x3b2a2b;</span><br><span class="line">typeof Document !== _0x5d2d42(&#x27;0x1d3&#x27;) &amp;&amp; (Document = function () &#123;</span><br><span class="line">&#125;);</span><br><span class="line">try &#123;</span><br><span class="line">return navigator + &#x27;&#x27; === _0x5d2d42(&#x27;0x1cd&#x27;) + _0x5d2d42(0x1d4)</span><br><span class="line">&amp;&amp; window[_0x5d2d42(&#x27;0x1db&#x27;)]() === _0x5d2d42(&#x27;0x1d8&#x27;) + _0x5d2d42(&#x27;0x1ea&#x27;)</span><br><span class="line">&amp;&amp; Object[_0x5d2d42(0x1e2) + &#x27;peOf&#x27;](document) instanceof Document</span><br><span class="line">&amp;&amp; Object[&#x27;is&#x27;](window, globalThis) ? lmd5[_0x5d2d42(0x1d0)](&#x27;dta&#x27;, _0x4ecca8) : lmd5[_0x5d2d42(0x1e4)](_0x4ecca8);</span><br><span class="line">&#125; catch (_0x57ab12) &#123;</span><br><span class="line">return lmd5[&#x27;_0x398525&#x27;](_0x4ecca8);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, lmd5[_0x3b2a2b(&#x27;0x1dc&#x27;)] = function (_0x4ad119) &#123;</span><br><span class="line">return binl2hex(core_md5(str2binl(_0x4ad119), _0x4ad119[&#x27;length&#x27;] * chrsz));</span><br><span class="line">&#125;, lmd5[_0x3b2a2b(&#x27;0x1e4&#x27;)] = function (_0x523268) &#123;</span><br><span class="line">var _0x30c42f = _0x3b2a2b;</span><br><span class="line">let _0x184fa8 = String(Math[_0x30c42f(0x1e3)]());</span><br><span class="line">return binl2hex(core_md5(str2binl(_0x184fa8), _0x184fa8[_0x30c42f(&#x27;0x1de&#x27;)] * chrsz));</span><br><span class="line">&#125;, lmd5[_0x3b2a2b(0x1d0)] = function (_0x2d7b8d, _0x2916db) &#123;</span><br><span class="line">return binl2hex(core_hmac_md5(_0x2d7b8d, _0x2916db));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(window.dta(&quot;&quot;));</span><br></pre></td></tr></table></figure><h2 id="五、补环境-VS-环境检测"><a href="#五、补环境-VS-环境检测" class="headerlink" title="五、补环境 VS 环境检测"></a>五、补环境 VS 环境检测</h2><blockquote><p><strong>吐环境脚本使用注意事项：</strong></p><ol><li>对于初始化过的 navigator、document 等浏览器对象，补环境时不需要 var&#x2F;let 重新声明，而是直接使用</li><li>在自执行函数中的补环境脚本需要考虑<strong>函数声明和变量声明的作用域规则</strong>，新版本的吐环境脚本与补环境区域脱离，无需考虑</li></ol><p><strong>优化版代理器：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">/* ================================= 补环境区域 START ================================= */</span><br><span class="line">function getObjhandler(proxyName) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        get(target, property, receiver) &#123;</span><br><span class="line">            if (target[property] instanceof Object) &#123;</span><br><span class="line">                // prototype 只可读不可写，所以不能代理这个对象，直接返回值，但是可以断点到这里，看到环境</span><br><span class="line">                if (String(property) == &#x27;prototype&#x27;) &#123;</span><br><span class="line">                    return Reflect.get(...arguments);</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">                return new Proxy(target[property], getObjhandler(`$&#123;proxyName&#125;.$&#123;String(property)&#125;`));</span><br><span class="line">            &#125;</span><br><span class="line">            if (typeof property == &#x27;symbol&#x27;) &#123;</span><br><span class="line">                console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;target[property]&#125;`);</span><br><span class="line">                return Reflect.get(...arguments);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">            try &#123;</span><br><span class="line">                return Reflect.get(...arguments);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">                console.error(`【异常捕获】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;target[property]&#125;: \n$&#123;error.message&#125; --------`);</span><br><span class="line">                if (property == &quot;userAgent&quot;) &#123;</span><br><span class="line">                    return &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span><br><span class="line">                &#125;</span><br><span class="line">                // 根据业务逻辑返回默认值或进行其他处理</span><br><span class="line">                return target[property];  // 或者其他合适的默认值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, property, value, receiver) &#123;</span><br><span class="line">            console.log(`【 set 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof value&#125; --&gt; $&#123;value&#125;`);</span><br><span class="line">            return Reflect.set(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        has(target, propKey) &#123;</span><br><span class="line">            console.log(`【 has 】--&gt; [$&#123;String(propKey)&#125;] in [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.has(...arguments)&#125;`);</span><br><span class="line">            return Reflect.has(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        deleteProperty(target, propKey) &#123;</span><br><span class="line">            console.log(`【 deleteProperty 】--&gt; delete [$&#123;String(propKey)&#125;] from [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.deleteProperty(...arguments)&#125;`);</span><br><span class="line">            return Reflect.deleteProperty(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        getOwnPropertyDescriptor(target, propKey) &#123;</span><br><span class="line">            console.log(`【 getOwnPropertyDescriptor 】--&gt; ($&#123;proxyName&#125;, &quot;$&#123;String(propKey)&#125;&quot;) --&gt; $&#123;JSON.stringify(Reflect.getOwnPropertyDescriptor(...arguments))&#125;`);</span><br><span class="line">            return Reflect.getOwnPropertyDescriptor(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        defineProperty(target, propKey, propDesc) &#123;</span><br><span class="line">            console.log(`【 defineProperty 】--&gt; $&#123;proxyName&#125;.$&#123;String(propKey)&#125; --&gt; $&#123;JSON.stringify(propDesc)&#125; --&gt; $&#123;Reflect.defineProperty(...arguments)&#125;`);</span><br><span class="line">            return Reflect.defineProperty(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        preventExtensions(target) &#123;</span><br><span class="line">            console.log(`【 preventExtensions 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.preventExtensions(...arguments)&#125;`);</span><br><span class="line">            return Reflect.preventExtensions(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        isExtensible(target) &#123;</span><br><span class="line">            console.log(`【 isExtensible 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.isExtensible(...arguments)&#125;`);</span><br><span class="line">            return Reflect.isExtensible(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        getPrototypeOf(target) &#123;</span><br><span class="line">            console.log(`【 getPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.getPrototypeOf(...arguments)&#125;`);</span><br><span class="line">            return Reflect.getPrototypeOf(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        setPrototypeOf(target, proto) &#123;</span><br><span class="line">            console.log(`【 setPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(proto)&#125; --&gt; $&#123;Reflect.setPrototypeOf(...arguments)&#125;`);</span><br><span class="line">            return Reflect.setPrototypeOf(...arguments);</span><br><span class="line">        &#125;,</span><br><span class="line">        ownKeys(target) &#123;</span><br><span class="line">            console.log(`【 ownKeys 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(Reflect.ownKeys(...arguments))&#125;`);</span><br><span class="line">            return Reflect.ownKeys(...arguments)</span><br><span class="line">        &#125;,</span><br><span class="line">        apply(target, thisArg, args) &#123;</span><br><span class="line">            console.log(`【 apply 】--&gt; $&#123;proxyName&#125;($&#123;args&#125;) --&gt; $&#123;Reflect.apply(...arguments)&#125;`);</span><br><span class="line">            return Reflect.apply(...arguments)</span><br><span class="line">        &#125;,</span><br><span class="line">        construct(target, args) &#123;</span><br><span class="line">            console.log(`【 construct 】--&gt; new Proxy($&#123;args&#125;) --&gt; $&#123;Reflect.construct(...arguments)&#125;`);</span><br><span class="line">            return Reflect.construct(...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// ------------------------------------ 初始化环境 -------------------------------------</span><br><span class="line">window = global;</span><br><span class="line">exports = undefined;</span><br><span class="line"></span><br><span class="line">// ------------------------------------ 初始化代理 -------------------------------------</span><br><span class="line">!(function getEnvironment(proxyArray) &#123;</span><br><span class="line">    proxyArray.forEach(proxyName =&gt; &#123;</span><br><span class="line">        globalThis[proxyName] = new Proxy(globalThis[proxyName] || &#123;&#125;, getObjhandler(proxyName))</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)([&#x27;window&#x27;, &#x27;document&#x27;, &#x27;location&#x27;, &#x27;navigator&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;]);</span><br><span class="line">// window 在经过代理器设置后，转换为了 Proxy 对象，Object.is(window, globalThis) 检测则为 false</span><br><span class="line">globalThis = window;</span><br><span class="line">/* ================================== 补环境区域 END ================================== */</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">/* ================================= 补环境区域 START ================================= */</span><br><span class="line">window = global;</span><br><span class="line">exports = undefined;</span><br><span class="line">// ----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------------------------------</span><br><span class="line">!(function getEnvironment(proxyArray) &#123;</span><br><span class="line">    function getObjhandler(proxyName) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            get(target, property, receiver) &#123;</span><br><span class="line">                if (target[property] instanceof Object) &#123;</span><br><span class="line">                    // prototype 只可读不可写，所以不能代理这个对象，直接返回值，但是可以断点到这里，看到环境</span><br><span class="line">                    if (String(property) == &#x27;prototype&#x27;) &#123;</span><br><span class="line">                        return Reflect.get(...arguments);</span><br><span class="line">                    &#125;</span><br><span class="line">                    console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">                    return new Proxy(target[property], getObjhandler(`$&#123;proxyName&#125;.$&#123;String(property)&#125;`));</span><br><span class="line">                &#125;</span><br><span class="line">                if (typeof property == &#x27;symbol&#x27;) &#123;</span><br><span class="line">                    console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;target[property]&#125;`);</span><br><span class="line">                    return Reflect.get(...arguments);</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">                try &#123;</span><br><span class="line">                    return Reflect.get(...arguments);</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                    console.error(`【异常捕获】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;target[property]&#125;: \n$&#123;error.message&#125; --------`);</span><br><span class="line">                    if (property == &quot;userAgent&quot;) &#123;</span><br><span class="line">                        return &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 根据业务逻辑返回默认值或进行其他处理</span><br><span class="line">                    return target[property];  // 或者其他合适的默认值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(target, property, value, receiver) &#123;</span><br><span class="line">                console.log(`【 set 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof value&#125; --&gt; $&#123;value&#125;`);</span><br><span class="line">                return Reflect.set(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            has(target, propKey) &#123;</span><br><span class="line">                console.log(`【 has 】--&gt; [$&#123;String(propKey)&#125;] in [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.has(...arguments)&#125;`);</span><br><span class="line">                return Reflect.has(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            deleteProperty(target, propKey) &#123;</span><br><span class="line">                console.log(`【 deleteProperty 】--&gt; delete [$&#123;String(propKey)&#125;] from [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.deleteProperty(...arguments)&#125;`);</span><br><span class="line">                return Reflect.deleteProperty(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            getOwnPropertyDescriptor(target, propKey) &#123;</span><br><span class="line">                console.log(`【 getOwnPropertyDescriptor 】--&gt; ($&#123;proxyName&#125;, &quot;$&#123;String(propKey)&#125;&quot;) --&gt; $&#123;JSON.stringify(Reflect.getOwnPropertyDescriptor(...arguments))&#125;`);</span><br><span class="line">                return Reflect.getOwnPropertyDescriptor(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            defineProperty(target, propKey, propDesc) &#123;</span><br><span class="line">                console.log(`【 defineProperty 】--&gt; $&#123;proxyName&#125;.$&#123;String(propKey)&#125; --&gt; $&#123;JSON.stringify(propDesc)&#125; --&gt; $&#123;Reflect.defineProperty(...arguments)&#125;`);</span><br><span class="line">                return Reflect.defineProperty(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            preventExtensions(target) &#123;</span><br><span class="line">                console.log(`【 preventExtensions 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.preventExtensions(...arguments)&#125;`);</span><br><span class="line">                return Reflect.preventExtensions(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            isExtensible(target) &#123;</span><br><span class="line">                console.log(`【 isExtensible 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.isExtensible(...arguments)&#125;`);</span><br><span class="line">                return Reflect.isExtensible(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            getPrototypeOf(target) &#123;</span><br><span class="line">                console.log(`【 getPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.getPrototypeOf(...arguments)&#125;`);</span><br><span class="line">                return Reflect.getPrototypeOf(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            setPrototypeOf(target, proto) &#123;</span><br><span class="line">                console.log(`【 setPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(proto)&#125; --&gt; $&#123;Reflect.setPrototypeOf(...arguments)&#125;`);</span><br><span class="line">                return Reflect.setPrototypeOf(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            ownKeys(target) &#123;</span><br><span class="line">                console.log(`【 ownKeys 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(Reflect.ownKeys(...arguments))&#125;`);</span><br><span class="line">                return Reflect.ownKeys(...arguments)</span><br><span class="line">            &#125;,</span><br><span class="line">            apply(target, thisArg, args) &#123;</span><br><span class="line">                console.log(`【 apply 】--&gt; $&#123;proxyName&#125;($&#123;args&#125;) --&gt; $&#123;Reflect.apply(...arguments)&#125;`);</span><br><span class="line">                return Reflect.apply(...arguments)</span><br><span class="line">            &#125;,</span><br><span class="line">            construct(target, args) &#123;</span><br><span class="line">                console.log(`【 construct 】--&gt; new Proxy($&#123;args&#125;) --&gt; $&#123;Reflect.construct(...arguments)&#125;`);</span><br><span class="line">                return Reflect.construct(...arguments)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxyArray.forEach(proxyName =&gt; &#123;</span><br><span class="line">        globalThis[proxyName] = new Proxy(globalThis[proxyName] || &#123;&#125;, getObjhandler(proxyName))</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)([&#x27;window&#x27;, &#x27;document&#x27;, &#x27;location&#x27;, &#x27;navigator&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;]);</span><br><span class="line">// window 在经过代理器设置后，转换为了 Proxy 对象，Object.is(window, globalThis) 检测则为 false</span><br><span class="line">globalThis = window;</span><br><span class="line">/* ================================== 补环境区域 END ================================== */</span><br></pre></td></tr></table></figure><h3 id="1-nvm-–-node-版本"><a href="#1-nvm-–-node-版本" class="headerlink" title="1. nvm – node 版本"></a>1. nvm – node 版本</h3><blockquote><p><strong>踩坑：Node.js 21 版本以上环境中自带 navigator 对象，会导致补环境过程中一些检测点被忽略（代理对象无法正常吐环境）</strong></p><p><strong>解决办法（<code>brew install nvm</code>）：</strong></p><ol><li>安装指定的 16.x 版本：<code>nvm install 16.20.2</code></li><li>设置默认版本：<code>nvm alias default 16.20.2</code></li><li>验证当前版本：<code>node -v</code></li></ol></blockquote><ul><li><p><strong>node 中 nvm 不能使用：</strong></p><ul><li>设置 –&gt; Executor Map –&gt; 第一个 settings.json –&gt; which node –&gt; <code>*&quot;javascript&quot;*: &quot;path/node&quot;</code></li></ul></li><li><p><strong>检查 nvm 安装的全局模块路径：</strong></p><ol><li>查看当前使用的 Node 版本：<code>nvm current</code></li><li>查看全局模块安装路径：<code>npm prefix -g</code></li><li>查看全局模块目录：<code>ls $(npm prefix -g)/lib/node_modules</code></li></ol></li><li><p><strong>nvm 命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nvm use &lt;version&gt;           ## 切换使用指定的版本node</span><br><span class="line">nvm ls                      ## 列出所有安装的版本</span><br><span class="line">nvm current                 ## 显示当前的版本</span><br><span class="line">nvm ls-remote --lts         ## 查看所有可以安装的LTS版本（长期支持版）</span><br><span class="line">nvm alias default v6.9.0    ## 设定默认的node版本</span><br><span class="line">nvm uninstall v9.5.0        ## 删除指定版本的node 版本</span><br><span class="line"></span><br><span class="line">nvm install 命令 - 安装指定版本nodejs</span><br><span class="line">nvm install 14.5.0 // 安装14.5.0版本node</span><br><span class="line">nvm install latest // 安装最新版本node</span><br><span class="line"></span><br><span class="line">nvm use v12.19.1            ## 使用指定版本</span><br><span class="line">nvm alias default v14.15.1  ## 设置默认版本</span><br><span class="line">nvm run v14.15.1 app.js     ## 使用指定版本运行脚本</span><br><span class="line">nvm uninstall v14.15.1      ## 卸载指定版本</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>单独安装 node（<a class="link"   href="https://nodejs.org/zh-cn/download/package-manager"  target="_blank" rel="noopener">官方网站<i class="fas fa-external-link-alt"></i></a>）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brew install node@18</span><br><span class="line">echo &#x27;export PATH=&quot;/opt/homebrew/opt/node@18/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">echo &#x27;export LDFLAGS=&quot;-L/opt/homebrew/opt/node@18/lib&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">echo &#x27;export CPPFLAGS=&quot;-I/opt/homebrew/opt/node@18/include&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"># 设置淘宝源，查看源：npm config get registry</span><br><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-Proxy-Reflect-代理"><a href="#2-Proxy-Reflect-代理" class="headerlink" title="2. Proxy|Reflect 代理"></a>2. Proxy|Reflect 代理</h3><blockquote><p><strong>Proxy</strong> 是 ES6 引入的一种元编程特性，它允许通过代理对象<strong>拦截</strong>和自定义对原对象的操作行为，例如读写属性、函数调用等；可以在不直接修改对象的情况下”拦截”对对象的操作，并通过自定义行为来处理这些操作。</p><p><strong>Reflect</strong> 是 ES6 引入的另一个工具，它提供了一组方法，用来对 js 对象进行默认的操作。可以认为 Reflect 提供了与 Proxy 捕捉器<strong>相对的</strong>“默认行为”，在 Proxy 捕捉器中，常常会结合 Reflect 来调用默认行为。</p><p><strong>注意：Proxy 实例也可以作为其他对象的原型对象，可以拦截原型链的访问，并对原型链上属性进行修改</strong></p></blockquote><ul><li><strong>Proxy 基本语法：</strong><code>let proxy = new Proxy(target, handler);</code><ol><li>target：想要代理的目标对象（可以是对象、数组、函数等）</li><li>handler：一个对象，包含若干”捕捉器”函数，这些函数可以拦截对代理对象的操作</li></ol></li><li><strong>Proxy 支持的 13 种拦截操作：</strong><ol><li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]</li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，如 proxy.foo&#x2F;[‘foo’] &#x3D; v，返回布尔值</li><li>has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值</li><li>deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值</li><li>ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy) 和 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性</li><li>getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象</li><li>defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc) 和 Object.defineProperties(proxy, propDescs)，返回一个布尔值</li><li>preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值</li><li>getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象</li><li>isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值</li><li>setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args) 和 proxy.apply(…)</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)</li></ol></li><li><strong>Reflect 静态方法：</strong><ul><li>Reflect.get(target, name, receiver)：查找并返回 target 对象的 name 属性，receiver 绑定 this</li><li>Reflect.set(target, name, value, receiver)：设置 target 对象的 name 属性等于 value</li><li>Reflect.has(obj, name)：作用对应 python 的 in 运算符</li><li>Reflect.deleteProperty(obj, name)：方法等同于 delete obj[name]，用于删除对象的属性</li><li>Reflect.construct(target, args)：等同于 new target(…args)，调用构造函数的方法</li><li>Reflect.getPrototypeOf(obj)：读取对象的 __proto__ 属性，对应 Object.getPrototypeOf</li><li>Reflect.setPrototypeOf(obj, newProto)：设置目标对象的原型，对应 Object.setPrototypeOf</li><li>Reflect.apply(func, thisArg, args)：等同于 Function.prototype.apply.call(func, thisArg, args)</li><li>Reflect.defineProperty(target, propertyKey, attributes)：等同于 Object.defineProperty</li><li>Reflect.getOwnPropertyDescriptor(target, propertyKey)：等同于 Object.getOwnPropertyDescriptor</li><li>Reflect.isExtensible(target)：对应 Object.isExtensible 表示当前对象是否可扩展</li><li>Reflect.preventExtensions(target)：对应 Object.preventExtensions 让一个对象变为不可扩展，当一个对象被标记为不可扩展后，你不能再向这个对象中添加新的属性，但仍然可以修改或删除现有的属性</li><li>Reflect.ownKeys(target)：返回对象的所有属性，可以返回 Symbol 类型</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">!(function getEnvironment(proxyArray) &#123;</span><br><span class="line">    window = global;</span><br><span class="line">    exports = undefined;</span><br><span class="line">    // ============ 脚本仅补了大致环境，需要在此处补其余缺失环境 ============</span><br><span class="line"></span><br><span class="line">    window.aaa = function () &#123; &#125;</span><br><span class="line"></span><br><span class="line">    function getObjhandler(proxyName) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            get(target, property, receiver) &#123;</span><br><span class="line">                if (target[property] instanceof Object) &#123;</span><br><span class="line">                    console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">                    return new Proxy(target[property], getObjhandler(`$&#123;proxyName&#125;.$&#123;String(property)&#125;`))</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof target[property]&#125;`);</span><br><span class="line">                return Reflect.get(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            set(target, property, value, receiver) &#123;</span><br><span class="line">                console.log(`【 set 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof value&#125; --&gt; $&#123;value&#125;`);</span><br><span class="line">                return Reflect.set(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            has(target, propKey) &#123;</span><br><span class="line">                console.log(`【 has 】--&gt; [$&#123;String(propKey)&#125;] in [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.has(...arguments)&#125;`);</span><br><span class="line">                return Reflect.has(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            deleteProperty(target, propKey) &#123;</span><br><span class="line">                console.log(`【 deleteProperty 】--&gt; delete [$&#123;String(propKey)&#125;] from [$&#123;proxyName&#125;] --&gt; $&#123;Reflect.deleteProperty(...arguments)&#125;`);</span><br><span class="line">                return Reflect.deleteProperty(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            getOwnPropertyDescriptor(target, propKey) &#123;</span><br><span class="line">                console.log(`【 getOwnPropertyDescriptor 】--&gt; ($&#123;proxyName&#125;, &quot;$&#123;String(propKey)&#125;&quot;) --&gt; $&#123;JSON.stringify(Reflect.getOwnPropertyDescriptor(...arguments))&#125;`);</span><br><span class="line">                return Reflect.getOwnPropertyDescriptor(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            defineProperty(target, propKey, propDesc) &#123;</span><br><span class="line">                console.log(`【 defineProperty 】--&gt; $&#123;proxyName&#125;.$&#123;String(propKey)&#125; --&gt; $&#123;JSON.stringify(propDesc)&#125; --&gt; $&#123;Reflect.defineProperty(...arguments)&#125;`);</span><br><span class="line">                return Reflect.defineProperty(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            preventExtensions(target) &#123;</span><br><span class="line">                console.log(`【 preventExtensions 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.preventExtensions(...arguments)&#125;`);</span><br><span class="line">                return Reflect.preventExtensions(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            isExtensible(target) &#123;</span><br><span class="line">                console.log(`【 isExtensible 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;Reflect.isExtensible(...arguments)&#125;`);</span><br><span class="line">                return Reflect.isExtensible(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            getPrototypeOf(target) &#123;</span><br><span class="line">                console.log(`【 getPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(Reflect.getPrototypeOf(...arguments))&#125;`);</span><br><span class="line">                return Reflect.getPrototypeOf(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            setPrototypeOf(target, proto) &#123;</span><br><span class="line">                console.log(`【 setPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(proto)&#125; --&gt; $&#123;Reflect.setPrototypeOf(...arguments)&#125;`);</span><br><span class="line">                return Reflect.setPrototypeOf(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            ownKeys(target) &#123;</span><br><span class="line">                console.log(`【 ownKeys 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(Reflect.ownKeys(...arguments))&#125;`);</span><br><span class="line">                return Reflect.ownKeys(...arguments)</span><br><span class="line">            &#125;,</span><br><span class="line">            apply(target, thisArg, args) &#123;</span><br><span class="line">                console.log(`【 apply 】--&gt; $&#123;proxyName&#125;($&#123;args&#125;) --&gt; $&#123;Reflect.apply(...arguments)&#125;`);</span><br><span class="line">                return Reflect.apply(...arguments)</span><br><span class="line">            &#125;,</span><br><span class="line">            construct(target, args) &#123;</span><br><span class="line">                console.log(`【 construct 】--&gt; new Proxy($&#123;args&#125;) --&gt; $&#123;Reflect.construct(...arguments)&#125;`);</span><br><span class="line">                return Reflect.construct(...arguments)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; proxyArray.length; i++) &#123;</span><br><span class="line">        var proxyName = proxyArray[i];</span><br><span class="line">        global[proxyName] = new Proxy(global[proxyName] || &#123;&#125;, getObjhandler(proxyName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)([&#x27;window&#x27;, &#x27;document&#x27;, &#x27;location&#x27;, &#x27;navigator&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;]);</span><br><span class="line"></span><br><span class="line">window.aaa.bbb = 666</span><br><span class="line">window.aaa.ccc = 123</span><br><span class="line">&#x27;bbb&#x27; in window.aaa</span><br><span class="line">delete window.aaa.bbb</span><br><span class="line">Object.getOwnPropertyDescriptor(window.aaa, &#x27;ccc&#x27;)</span><br><span class="line">Object.defineProperty(window, &#x27;bbb&#x27;, &#123;</span><br><span class="line">    value: 123,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;)</span><br><span class="line">// Object.preventExtensions(window)</span><br><span class="line">Object.isExtensible(window)</span><br><span class="line">Object.getPrototypeOf(window)</span><br><span class="line">Object.setPrototypeOf(window, &#123;gpt: &#x27;chatgpt&#x27;&#125;)</span><br><span class="line">window.gpt</span><br><span class="line"></span><br><span class="line">window.aaa(1)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">【 get 】--&gt; window.aaa --&gt; function</span><br><span class="line">【 set 】--&gt; window.aaa.bbb --&gt; number --&gt; 666</span><br><span class="line">【 getOwnPropertyDescriptor 】--&gt; (window.aaa, &quot;bbb&quot;) --&gt; undefined</span><br><span class="line">【 defineProperty 】--&gt; window.aaa.bbb --&gt; &#123;&quot;value&quot;:666,&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125; --&gt; true</span><br><span class="line">【 get 】--&gt; window.aaa --&gt; function</span><br><span class="line">【 set 】--&gt; window.aaa.ccc --&gt; number --&gt; 123</span><br><span class="line">【 getOwnPropertyDescriptor 】--&gt; (window.aaa, &quot;ccc&quot;) --&gt; undefined</span><br><span class="line">【 defineProperty 】--&gt; window.aaa.ccc --&gt; &#123;&quot;value&quot;:123,&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125; --&gt; true</span><br><span class="line">【 get 】--&gt; window.aaa --&gt; function</span><br><span class="line">【 has 】--&gt; [bbb] in [window.aaa] --&gt; true</span><br><span class="line">【 get 】--&gt; window.aaa --&gt; function</span><br><span class="line">【 deleteProperty 】--&gt; delete [bbb] from [window.aaa] --&gt; true</span><br><span class="line">【 get 】--&gt; window.aaa --&gt; function</span><br><span class="line">【 getOwnPropertyDescriptor 】--&gt; (window.aaa, &quot;ccc&quot;) --&gt; &#123;&quot;value&quot;:123,&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125;</span><br><span class="line">【 defineProperty 】--&gt; window.bbb --&gt; &#123;&quot;value&quot;:123,&quot;writable&quot;:true&#125; --&gt; true</span><br><span class="line">【 isExtensible 】--&gt; window --&gt; true</span><br><span class="line">【 getPrototypeOf 】--&gt; window --&gt; &#123;&#125;</span><br><span class="line">【 setPrototypeOf 】--&gt; window --&gt; &#123;&quot;gpt&quot;:&quot;chatgpt&quot;&#125; --&gt; true</span><br><span class="line">【 get 】--&gt; window.gpt --&gt; string</span><br><span class="line">【 get 】--&gt; window.aaa --&gt; function</span><br><span class="line">【 apply 】--&gt; window.aaa(1) --&gt; undefined</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="3-补环境思路"><a href="#3-补环境思路" class="headerlink" title="3. 补环境思路"></a>3. 补环境思路</h3><ul><li><strong>通过 Object.getPrototypeOf 方法检测原型的补法：</strong><ol><li>首先确认浏览器中，当前对象的原型类型，<code>typeof HTMLDocument</code> 来确定补原型对象的类型</li><li>观察补出来的对象的原型链是否和浏览器中当前对象的原型链一致</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Document() &#123; &#125;</span><br><span class="line">Document.prototype[Symbol.toStringTag] = &quot;Document&quot;;</span><br><span class="line"></span><br><span class="line">function HTMLDocument() &#123; &#125;</span><br><span class="line">HTMLDocument.prototype[Symbol.toStringTag] = &quot;HTMLDocument&quot;;</span><br><span class="line"></span><br><span class="line">// 将 Document 作为 HTMLDocument 的原型</span><br><span class="line">Object.setPrototypeOf(HTMLDocument.prototype, Document.prototype);</span><br><span class="line"></span><br><span class="line">// 创建 document 对象，并设置它的原型为 HTMLDocument.prototype</span><br><span class="line">const document = Object.setPrototypeOf(&#123;&#125;, HTMLDocument.prototype);</span><br><span class="line"></span><br><span class="line">// 测试原型链</span><br><span class="line">console.log(Object.prototype.toString.call(document)); // [object HTMLDocument]</span><br><span class="line">console.log(Object.getPrototypeOf(document)); // HTMLDocument &#123; [Symbol(Symbol.toStringTag)]: &#x27;HTMLDocument&#x27; &#125;</span><br><span class="line">console.log(Object.getPrototypeOf(Object.getPrototypeOf(document))); // Document &#123; [Symbol(Symbol.toStringTag)]: &#x27;Document&#x27; &#125;</span><br><span class="line">console.log(Object.getPrototypeOf(document) instanceof Document); // true</span><br></pre></td></tr></table></figure><ul><li><p><strong>补环境技巧：</strong></p><ol><li><p>遇到程序卡死不动时，可以直接暂停 debug 调试，即可断点至对应卡死的程序代码</p></li><li><p>程序中存在 eval 执行的一段代码，可打断点至其调用处，单步调试走进被执行代码；如果代码是被压缩过的，不方便调试，可以将代码抠出来格式化后，替换被执行代码进行调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const data = fs.readFileSync(&#x27;/Users/xfblog/Desktop/xxx.js&#x27;, &#x27;utf8&#x27;);</span><br><span class="line"></span><br><span class="line">eval(t1000Source) --&gt; eval(data)</span><br></pre></td></tr></table></figure></li><li><p>pycharm 执行 js 文件有异常断点，可以通过调试自动在 try 中的异常处断下断点，避免错过环境监测</p></li><li><p><strong>在环境都补完了，却发现还是非正常输出，则需进一步观察具体代码，是否有环境缺漏，例如 <code>typeof</code> 检测对象是不报错的</strong></p></li></ol></li><li><p><strong>吐环境异常解决思路：</strong></p><ol><li><p><strong>无法在一个未定义的对象上设置&#x2F;读取属性：</strong>是因为其调用的对象为 undefined，所以应该补其调用的对象环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Cannot read properties of undefined (reading &#x27;indexOf&#x27;)</span><br><span class="line">TypeError: Cannot set properties of undefined (setting &#x27;bbb&#x27;)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="4-浏览器复制对象"><a href="#4-浏览器复制对象" class="headerlink" title="4. 浏览器复制对象"></a>4. 浏览器复制对象</h3><blockquote><p><strong>原理：</strong>for…in 循环的特点是可以遍历一个对象的<strong>所有可枚举属性</strong>，包括它自身的属性以及从原型链中<strong>继承的属性</strong></p></blockquote><ul><li>在当前浏览器环境下，打开控制台执行脚本，并右键复制 object</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let myobj = &#123;&#125;;</span><br><span class="line">for (let key in navigator) &#123;</span><br><span class="line">    // 只存储自身属性到 obj</span><br><span class="line">    // if (!myobj.hasOwnProperty(key)) &#123;</span><br><span class="line">    //     continue;</span><br><span class="line">    // &#125;</span><br><span class="line">    let value = navigator[key];</span><br><span class="line">    myobj[key] = value;</span><br><span class="line">&#125;</span><br><span class="line">console.log(myobj);</span><br></pre></td></tr></table></figure><h3 id="5-浏览器内存漫游定位"><a href="#5-浏览器内存漫游定位" class="headerlink" title="5. 浏览器内存漫游定位"></a>5. 浏览器内存漫游定位</h3><blockquote><p><strong>Github 源码地址：</strong><a class="link"   href="https://github.com/JSREI/ast-hook-for-js-RE"  target="_blank" rel="noopener">aHR0cHM6Ly9naXRodWIuY29tL0pTUkVJL2FzdC1ob29rLWZvci1qcy1SRQ&#x3D;&#x3D;<i class="fas fa-external-link-alt"></i></a></p><p><strong>快速启动：</strong></p><ol><li><code>npx node src/proxy-server/proxy-server.js</code></li><li><code>npx node src/api-server/api-server.js</code></li></ol></blockquote><ul><li><strong>项目安装：</strong><ol><li><code>git clone git@github.com:JSREI/ast-hook-for-js-RE.git</code></li><li><code>cd ast-hook-for-js-RE</code></li><li><code>npm install</code></li><li>安装异常：<code>rm -rf node_modules</code>、<code>npm cache verify</code>、<code>npm cache clean --force</code></li></ol></li><li><strong>项目启动：</strong><ol><li><code>npx anyproxy ca</code></li><li>浏览器打开 <code>http://127.0.0.1:8002/</code>，RootCA 下载根证书</li><li>双击证书安装到<strong>系统</strong>，显示简介将其设置为<strong>信任</strong>证书</li><li>在项目路径下，开启代理服务 <code>npx node src/proxy-server/proxy-server.js</code></li><li>产生了缓存文件夹 <code>js-file-cache</code></li><li><strong>浏览器进行代理（Proxy SwitchyOmega）：</strong>添加 127.0.0.1:10086 代理</li></ol></li></ul><h3 id="6-EventTarget-API"><a href="#6-EventTarget-API" class="headerlink" title="6. EventTarget API"></a>6. EventTarget API</h3><blockquote><p> <strong>EventTarget：</strong>是一个 Web API，几乎所有 DOM 元素（例 div 或 button）都继承自它。通过构造函数 EventTarget()，可以创建一个新的 EventTarget 对象实例，即一个没有 UI 表现的自定义对象，用于处理和触发事件和自定义事件</p></blockquote><ul><li><p><strong>原型方法：</strong></p><ol><li><strong>EventTarget.addEventListener：</strong>注册事件，在 EventTarget 对象上注册特定事件类型的事件监听器，即事件处理函数</li><li><strong>EventTarget.removeEventListener：</strong>注销事件，从 EventTarget 对象中移除指定的事件监听器</li><li><strong>EventTarget.dispatchEvent：</strong>触发事件，将 Event 事件分派到此 EventTarget 实例上，返回布尔值表示是否成功触发了事件</li></ol></li><li><p><strong>简单实现：</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">EventTarget</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">listeners</span> = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">listeners</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span> = <span class="keyword">function</span> (<span class="params">type, callback</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">listeners</span>)) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">listeners</span>[type] = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">listeners</span>[type].<span class="title function_">push</span>(callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeEventListener</span> = <span class="keyword">function</span> (<span class="params">type, callback</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">listeners</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stack = <span class="variable language_">this</span>.<span class="property">listeners</span>[type];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = stack.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (stack[i] === callback) &#123;</span><br><span class="line">stack.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeEventListener</span>(type, callback);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">dispatchEvent</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(event.<span class="property">type</span> <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">listeners</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stack = <span class="variable language_">this</span>.<span class="property">listeners</span>[event.<span class="property">type</span>];</span><br><span class="line">event.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = stack.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">stack[i].<span class="title function_">call</span>(<span class="variable language_">this</span>, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="六、自制-VM2-补环境框架"><a href="#六、自制-VM2-补环境框架" class="headerlink" title="六、自制 VM2 补环境框架"></a>六、自制 VM2 补环境框架</h2><blockquote><p><strong>项目地址：<a class="link"   href="https://github.com/xfblogcn/xfblogProjects/tree/main/%E8%A1%A5%E7%8E%AF%E5%A2%83%E4%B8%93%E9%A2%98"  target="_blank" rel="noopener">da9436cbc8a477d1c6761b5b89b26a0e<i class="fas fa-external-link-alt"></i></a></strong></p><p><strong>使用注意：</strong></p><ol><li><strong><span style="color:red">在脱环境脚本时，尽量都脱 get&#x2F;set 为 debugger 函数的一版，这样在补一个环境的 get&#x2F;set 时再配合 <code>if(...)&#123;return ...&#125;debugger;</code> 的格式，就不会破坏下一个对象需要补这个环境时的断点了</span></strong></li><li><strong><span style="color:red">在输出代理日志时，遇到 debugger 断住，这一帧的环境是在跳过这个 debugger 的下一帧，即继续执行后才能看到（在继续执行前，可以先清空日志更清晰的看到后面输出的日志）</span></strong></li><li></li></ol></blockquote><h3 id="1-核心脱环境脚本"><a href="#1-核心脱环境脚本" class="headerlink" title="1. 核心脱环境脚本"></a>1. 核心脱环境脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">// 在浏览器中的 JavaScript 描述符中，value 和 get/set 是互斥的，</span><br><span class="line">// 不能同时定义在一个属性描述符中，因为描述符必须要选择其中一种模式，才能够正确处理不同类型的属性</span><br><span class="line">function extractProperties(obj, falg = false) &#123;</span><br><span class="line">    const nameMap = &#123;</span><br><span class="line">        navigator, document, window, location, history, screen,</span><br><span class="line">        localStorage, sessionStorage, temp1: typeof temp1 !== &#x27;undefined&#x27; ? temp1 : &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const getRootName = (obj) =&gt; Object.keys(nameMap).find(name =&gt; nameMap[name] === obj) || &#x27;&#x27;;</span><br><span class="line">    const getObjectName = (obj) =&gt; &#123;</span><br><span class="line">        const rootName = getRootName(obj);</span><br><span class="line">        return rootName ? rootName.charAt(0).toUpperCase() + rootName.slice(1) : obj.constructor.name || &#x27;Unknown&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">    const checkNewError = (constructorName) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            new window[constructorName]();</span><br><span class="line">            return false;</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const defineStatements = [];</span><br><span class="line">    const rootName = getRootName(obj);</span><br><span class="line">    let current = obj;  // 记录当前对象</span><br><span class="line">    let lastCurrentName = null; // 用于记录上一层的原型名称</span><br><span class="line">    let lastCurrentStatements = []; // 用于记录上一层原型的输出语句</span><br><span class="line"></span><br><span class="line">    while (current) &#123;</span><br><span class="line">        const prototypeName = getRootName(current) ? getRootName(current) : getObjectName(current);</span><br><span class="line">        const prototype_name = current === obj ? prototypeName : `$&#123;prototypeName || &#x27;Object&#x27;&#125;.prototype`;</span><br><span class="line">        const parentPrototype = Object.getPrototypeOf(current);  // 获取下一层的原型对象</span><br><span class="line"></span><br><span class="line">        // 构造函数定义</span><br><span class="line">        if (prototypeName !== rootName) &#123;</span><br><span class="line">            if (checkNewError(prototypeName)) &#123;</span><br><span class="line">                defineStatements.push(`$&#123;prototypeName&#125; = function $&#123;prototypeName&#125;() &#123;`);</span><br><span class="line">                defineStatements.push(`    _r8y9x2w0.throwError(&#x27;$&#123;prototypeName&#125;&#x27;);`);</span><br><span class="line">                defineStatements.push(`&#125;;`);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                defineStatements.push(`$&#123;prototypeName&#125; = function $&#123;prototypeName&#125;() &#123;&#125;;`);</span><br><span class="line">            &#125;</span><br><span class="line">            defineStatements.push(`_r8y9x2w0.func_set_native($&#123;prototypeName&#125;);`);</span><br><span class="line">            defineStatements.push(`_r8y9x2w0.rename($&#123;prototype_name&#125;, &quot;$&#123;prototypeName&#125;&quot;);`);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历属性</span><br><span class="line">        Object.getOwnPropertyNames(current).forEach((prop) =&gt; &#123;</span><br><span class="line">            const descriptor = Object.getOwnPropertyDescriptor(current, prop);</span><br><span class="line">            const &#123; value, get, set, enumerable, configurable, writable &#125; = descriptor;</span><br><span class="line">            if (current === obj) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 针对函数单独处理</span><br><span class="line">                    if (typeof value === &#x27;function&#x27;) &#123;</span><br><span class="line">                        let output = `_r8y9x2w0.defineProperty($&#123;prototype_name&#125;, &#x27;$&#123;prop&#125;&#x27;, function $&#123;prop&#125;()&#123; debugger; &#125;, $&#123;enumerable&#125;, $&#123;configurable&#125;, $&#123;writable&#125;); _r8y9x2w0.func_set_native($&#123;prototype_name&#125;.$&#123;prop&#125;);`;</span><br><span class="line">                        lastCurrentStatements.push(output);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        let output = `_r8y9x2w0.defineProperty($&#123;prototype_name&#125;, &#x27;$&#123;prop&#125;&#x27;, `;</span><br><span class="line"></span><br><span class="line">                        if (get || set) &#123;</span><br><span class="line">                            let get_value = get.call(obj);</span><br><span class="line">                            // 针对 HTMLAllCollection 类型专门序列化</span><br><span class="line">                            if (get_value instanceof HTMLCollection || get_value instanceof HTMLAllCollection) &#123;</span><br><span class="line">                                get_value = &#123; length: get_value.length &#125;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            let getter = get ? `function () &#123; return $&#123;JSON.stringify(get_value)&#125;; &#125;` : undefined;</span><br><span class="line">                            let setter = set ? `function (params) &#123; debugger ; &#125;` : undefined;</span><br><span class="line">                            output += `undefined, $&#123;enumerable&#125;, $&#123;configurable&#125;, undefined, $&#123;getter || &#x27;undefined&#x27;&#125;, $&#123;setter || &#x27;undefined&#x27;&#125;);`;</span><br><span class="line"></span><br><span class="line">                            // 保护 get 和 set 函数</span><br><span class="line">                            output += get ? `_r8y9x2w0.func_set_native(Object.getOwnPropertyDescriptors($&#123;prototype_name&#125;)[&quot;$&#123;prop&#125;&quot;].get, &quot;get $&#123;prop&#125;&quot;);` : &#x27;&#x27;</span><br><span class="line">                            output += set ? `_r8y9x2w0.func_set_native(Object.getOwnPropertyDescriptors($&#123;prototype_name&#125;)[&quot;$&#123;prop&#125;&quot;].set, &quot;set $&#123;prop&#125;&quot;);` : &#x27;&#x27;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            output += `$&#123;JSON.stringify(value)&#125;, $&#123;enumerable&#125;, $&#123;configurable&#125;, $&#123;writable&#125;);`;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        lastCurrentStatements.push(output);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    lastCurrentStatements.push(`_r8y9x2w0.defineProperty($&#123;prototype_name&#125;, &#x27;$&#123;prop&#125;&#x27;, &#123;temp: &quot;$&#123;value || get.call(obj)&#125;&quot;&#125;);`);</span><br><span class="line">                    debugger;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (prop !== &#x27;constructor&#x27;) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 针对函数单独处理</span><br><span class="line">                    if (typeof value === &#x27;function&#x27;) &#123;</span><br><span class="line">                        let output = `_r8y9x2w0.defineProperty($&#123;prototype_name&#125;, &#x27;$&#123;prop&#125;&#x27;, function $&#123;prop&#125;()&#123;debugger;&#125;, $&#123;enumerable&#125;, $&#123;configurable&#125;, $&#123;writable&#125;); _r8y9x2w0.func_set_native($&#123;prototype_name&#125;.$&#123;prop&#125;);`;</span><br><span class="line">                        defineStatements.push(output);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        let output = `_r8y9x2w0.defineProperty($&#123;prototype_name&#125;, &#x27;$&#123;prop&#125;&#x27;, `;</span><br><span class="line"></span><br><span class="line">                        if (get || set) &#123;</span><br><span class="line">                            let get_value = get.call(obj);</span><br><span class="line">                            // 针对 HTMLAllCollection 类型专门序列化</span><br><span class="line">                            if (get_value instanceof HTMLCollection || get_value instanceof HTMLAllCollection) &#123;</span><br><span class="line">                                get_value = &#123; length: get_value.length &#125;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            let getter;</span><br><span class="line">                            if (falg) &#123;</span><br><span class="line">                                getter = get ? `function () &#123; return $&#123;JSON.stringify(get_value)&#125;; &#125;` : undefined;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                getter = get ? `function () &#123; debugger; &#125;` : undefined;</span><br><span class="line">                            &#125;</span><br><span class="line">                            let setter = set ? `function (params) &#123; debugger ; &#125;` : undefined;</span><br><span class="line">                            output += `undefined, $&#123;enumerable&#125;, $&#123;configurable&#125;, undefined, $&#123;getter || &#x27;undefined&#x27;&#125;, $&#123;setter || &#x27;undefined&#x27;&#125;);`;</span><br><span class="line"></span><br><span class="line">                            // 保护 get 和 set 函数</span><br><span class="line">                            output += get ? `_r8y9x2w0.func_set_native(Object.getOwnPropertyDescriptors($&#123;prototype_name&#125;)[&quot;$&#123;prop&#125;&quot;].get, &quot;get $&#123;prop&#125;&quot;);` : &#x27;&#x27;</span><br><span class="line">                            output += set ? `_r8y9x2w0.func_set_native(Object.getOwnPropertyDescriptors($&#123;prototype_name&#125;)[&quot;$&#123;prop&#125;&quot;].set, &quot;set $&#123;prop&#125;&quot;);` : &#x27;&#x27;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            output += `$&#123;JSON.stringify(value)&#125;, $&#123;enumerable&#125;, $&#123;configurable&#125;, $&#123;writable&#125;);`;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        defineStatements.push(output);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    defineStatements.push(`_r8y9x2w0.defineProperty($&#123;prototype_name&#125;, &#x27;$&#123;prop&#125;&#x27;, &#123;temp: &quot;$&#123;value || get.call(obj)&#125;&quot;&#125;);`);</span><br><span class="line">                    debugger;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        if (lastCurrentName === rootName) &#123;</span><br><span class="line">            defineStatements.push(`Object.setPrototypeOf($&#123;prototype_name&#125;, $&#123;getObjectName(parentPrototype)&#125;.prototype);\n`, `$&#123;lastCurrentName&#125; = Object.setPrototypeOf(&#123;&#125;, $&#123;prototype_name&#125;);`, ...lastCurrentStatements, &quot;\n&quot;);</span><br><span class="line">        &#125; else if (prototypeName === rootName) &#123;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            defineStatements.push(`Object.setPrototypeOf($&#123;prototype_name&#125;, $&#123;getObjectName(parentPrototype)&#125;.prototype);\n`);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastCurrentName = prototypeName;</span><br><span class="line">        current = parentPrototype;</span><br><span class="line">        if (!Object.getPrototypeOf(current)) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const output = defineStatements.join(&quot;\n&quot;);</span><br><span class="line">    console.log(output);</span><br><span class="line">    copy(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用函数，对于大多数对象，第二个参数默认为false，即将 get 函数设置为 debugger 函数，</span><br><span class="line">// 对于普通指纹对象，参数 2 可以传入 true，即将 get 方法设置为返回具体值，可以暂时补上指纹</span><br><span class="line">// 同时对于实例对象本身，默认还是直接脱 get 函数为返回具体值</span><br><span class="line">// extractProperties(document);</span><br><span class="line">// extractProperties(navigator, true);</span><br></pre></td></tr></table></figure><h3 id="2-核心代理脚本"><a href="#2-核心代理脚本" class="headerlink" title="2. 核心代理脚本"></a>2. 核心代理脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">_r8y9x2w0.proxy = function (targetObject, proxyName) &#123;</span><br><span class="line">    function getObjhandler(proxyName) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            get(target, property, receiver) &#123;</span><br><span class="line">                let result = Reflect.get(...arguments);</span><br><span class="line">                // 如果 result 也是对象，那么可以递归代理，即对嵌套对象或函数的访问和修改进行代理</span><br><span class="line">                if (result instanceof Object) &#123;</span><br><span class="line">                    // 有些属性例如 prototype 只可读不可写，所以不能代理这个对象，只能直接返回结果，但是可以断点到这里，看到环境</span><br><span class="line">                    if (Object.getOwnPropertyDescriptor(target, property)?.writable === false) &#123;</span><br><span class="line">                        console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof result&#125; --&gt; It is non-writable !!!`);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof result&#125;`);</span><br><span class="line">                    return new Proxy(result, getObjhandler(`$&#123;proxyName&#125;.$&#123;String(property)&#125;`));</span><br><span class="line">                &#125;</span><br><span class="line">                // 过滤掉多余的 symbol toString 打印</span><br><span class="line">                if (typeof property !== &quot;symbol&quot; &amp;&amp; property !== &quot;toString&quot;) &#123;</span><br><span class="line">                    console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof result&#125;`);</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">                // try &#123;</span><br><span class="line">                //     return result;</span><br><span class="line">                // &#125; catch (error) &#123;</span><br><span class="line">                //     console.error(`【异常捕获】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;result&#125;: \n$&#123;error.message&#125; --------`);</span><br><span class="line">                //     if (property == &quot;userAgent&quot;) &#123;</span><br><span class="line">                //         return &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span><br><span class="line">                //     &#125;</span><br><span class="line">                //     // 根据业务逻辑返回默认值或进行其他处理</span><br><span class="line">                //     return result;  // 或者其他合适的默认值</span><br><span class="line">                // &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(target, property, value, receiver) &#123;</span><br><span class="line">                console.log(`【 set 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof value&#125; --&gt; $&#123;value&#125;`);</span><br><span class="line">                return Reflect.set(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            has(target, propKey) &#123;</span><br><span class="line">                let result = Reflect.has(...arguments);</span><br><span class="line">                console.log(`【 has 】--&gt; [$&#123;String(propKey)&#125;] in [$&#123;proxyName&#125;] --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            deleteProperty(target, propKey) &#123;</span><br><span class="line">                let result = Reflect.deleteProperty(...arguments);</span><br><span class="line">                console.log(`【 deleteProperty 】--&gt; delete [$&#123;String(propKey)&#125;] from [$&#123;proxyName&#125;] --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            getOwnPropertyDescriptor(target, propKey) &#123;</span><br><span class="line">                let result = Reflect.getOwnPropertyDescriptor(...arguments);</span><br><span class="line">                console.log(`【 getOwnPropertyDescriptor 】--&gt; ($&#123;proxyName&#125;, &quot;$&#123;String(propKey)&#125;&quot;) --&gt; $&#123;JSON.stringify(result)&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            defineProperty(target, propKey, propDesc) &#123;</span><br><span class="line">                let result = Reflect.defineProperty(...arguments);</span><br><span class="line">                console.log(`【 defineProperty 】--&gt; $&#123;proxyName&#125;.$&#123;String(propKey)&#125; --&gt; $&#123;JSON.stringify(propDesc)&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            preventExtensions(target) &#123;</span><br><span class="line">                let result = Reflect.preventExtensions(...arguments);</span><br><span class="line">                console.log(`【 preventExtensions 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            isExtensible(target) &#123;</span><br><span class="line">                let result = Reflect.isExtensible(...arguments);</span><br><span class="line">                console.log(`【 isExtensible 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            getPrototypeOf(target) &#123;</span><br><span class="line">                let result = Reflect.getPrototypeOf(...arguments);</span><br><span class="line">                console.log(`【 getPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            setPrototypeOf(target, proto) &#123;</span><br><span class="line">                let result = Reflect.setPrototypeOf(...arguments);</span><br><span class="line">                console.log(`【 setPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(proto)&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            ownKeys(target) &#123;</span><br><span class="line">                let result = Reflect.ownKeys(...arguments);</span><br><span class="line">                console.log(`【 ownKeys 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(result)&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            apply(target, thisArg, args) &#123;</span><br><span class="line">                // debugger;</span><br><span class="line">                let result = Reflect.apply(...arguments);</span><br><span class="line">                if (target.name !== &quot;toString&quot;) &#123;</span><br><span class="line">                    console.log(`【 apply 】--&gt; $&#123;proxyName&#125;($&#123;args&#125;) --&gt; $&#123;result&#125;`);</span><br><span class="line">                    return result;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            construct(target, args) &#123;</span><br><span class="line">                let result = Reflect.construct(...arguments);</span><br><span class="line">                console.log(`【 construct 】--&gt; new Proxy($&#123;args&#125;) --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果配置禁用代理，直接返回目标对象</span><br><span class="line">    if (_r8y9x2w0.config.proxy === false) &#123;</span><br><span class="line">        return targetObject;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回代理后的对象</span><br><span class="line">    return new Proxy(targetObject, getObjhandler(proxyName || &#x27;target&#x27;));</span><br><span class="line">    // window 在经过代理器设置后，转换为了 Proxy 对象，Object.is(window, globalThis) 检测则为 false，与浏览器不一致</span><br><span class="line">    globalThis = window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分离对象与函数代理，嵌套对象为函数时只代理一层：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">_r8y9x2w0.proxy = function (targetObject, proxyName) &#123;</span><br><span class="line">    function getMethodHandler(proxyName) &#123;</span><br><span class="line">        let methodhandler = &#123;</span><br><span class="line">            apply(target, thisArg, args) &#123;</span><br><span class="line">                // debugger;</span><br><span class="line">                let result = Reflect.apply(...arguments);</span><br><span class="line">                if (target.name !== &quot;toString&quot;) &#123;</span><br><span class="line">                    console.log(`【 apply 】--&gt; $&#123;proxyName&#125;($&#123;args&#125;) --&gt; $&#123;result&#125;`);</span><br><span class="line">                    return result;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            construct(target, args) &#123;</span><br><span class="line">                let result = Reflect.construct(...arguments);</span><br><span class="line">                console.log(`【 construct 】--&gt; new Proxy($&#123;args&#125;) --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return methodhandler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getObjhandler(proxyName) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            get(target, property, receiver) &#123;</span><br><span class="line">                let result = Reflect.get(...arguments);</span><br><span class="line">                // 如果 result 也是对象，那么可以递归代理，即对嵌套对象或函数的访问和修改进行代理</span><br><span class="line">                if (result instanceof Object) &#123;</span><br><span class="line">                    // 有些属性例如 prototype 只可读不可写，所以不能代理这个对象，只能直接返回结果，但是可以断点到这里，看到环境</span><br><span class="line">                    if (Object.getOwnPropertyDescriptor(target, property)?.writable === false) &#123;</span><br><span class="line">                        debugger;</span><br><span class="line">                        console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof result&#125; --&gt; It is non-writable !!!`);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果嵌套的对象是函数，单独代理</span><br><span class="line">                    if (typeof result === &quot;function&quot;) &#123;</span><br><span class="line">                        console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof result&#125;`)</span><br><span class="line">                        return new Proxy(result, getMethodHandler(proxyName))</span><br><span class="line">                    &#125;</span><br><span class="line">                    console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof result&#125;`);</span><br><span class="line">                    return new Proxy(result, getObjhandler(`$&#123;proxyName&#125;.$&#123;String(property)&#125;`));</span><br><span class="line">                &#125;</span><br><span class="line">                // 过滤掉多余的 symbol toString 打印</span><br><span class="line">                if (typeof property !== &quot;symbol&quot; &amp;&amp; property !== &quot;toString&quot;) &#123;</span><br><span class="line">                    console.log(`【 get 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof result&#125;`);</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">                // try &#123;</span><br><span class="line">                //     return result;</span><br><span class="line">                // &#125; catch (error) &#123;</span><br><span class="line">                //     console.error(`【异常捕获】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;result&#125;: \n$&#123;error.message&#125; --------`);</span><br><span class="line">                //     if (property == &quot;userAgent&quot;) &#123;</span><br><span class="line">                //         return &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36&quot;</span><br><span class="line">                //     &#125;</span><br><span class="line">                //     // 根据业务逻辑返回默认值或进行其他处理</span><br><span class="line">                //     return result;  // 或者其他合适的默认值</span><br><span class="line">                // &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(target, property, value, receiver) &#123;</span><br><span class="line">                console.log(`【 set 】--&gt; $&#123;proxyName&#125;.$&#123;String(property)&#125; --&gt; $&#123;typeof value&#125; --&gt; $&#123;value&#125;`);</span><br><span class="line">                return Reflect.set(...arguments);</span><br><span class="line">            &#125;,</span><br><span class="line">            has(target, propKey) &#123;</span><br><span class="line">                let result = Reflect.has(...arguments);</span><br><span class="line">                console.log(`【 has 】--&gt; [$&#123;String(propKey)&#125;] in [$&#123;proxyName&#125;] --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            deleteProperty(target, propKey) &#123;</span><br><span class="line">                let result = Reflect.deleteProperty(...arguments);</span><br><span class="line">                console.log(`【 deleteProperty 】--&gt; delete [$&#123;String(propKey)&#125;] from [$&#123;proxyName&#125;] --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            getOwnPropertyDescriptor(target, propKey) &#123;</span><br><span class="line">                let result = Reflect.getOwnPropertyDescriptor(...arguments);</span><br><span class="line">                console.log(`【 getOwnPropertyDescriptor 】--&gt; ($&#123;proxyName&#125;, &quot;$&#123;String(propKey)&#125;&quot;) --&gt; $&#123;JSON.stringify(result)&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            defineProperty(target, propKey, propDesc) &#123;</span><br><span class="line">                let result = Reflect.defineProperty(...arguments);</span><br><span class="line">                console.log(`【 defineProperty 】--&gt; $&#123;proxyName&#125;.$&#123;String(propKey)&#125; --&gt; $&#123;JSON.stringify(propDesc)&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            preventExtensions(target) &#123;</span><br><span class="line">                let result = Reflect.preventExtensions(...arguments);</span><br><span class="line">                console.log(`【 preventExtensions 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            isExtensible(target) &#123;</span><br><span class="line">                let result = Reflect.isExtensible(...arguments);</span><br><span class="line">                console.log(`【 isExtensible 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            getPrototypeOf(target) &#123;</span><br><span class="line">                let result = Reflect.getPrototypeOf(...arguments);</span><br><span class="line">                console.log(`【 getPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            setPrototypeOf(target, proto) &#123;</span><br><span class="line">                let result = Reflect.setPrototypeOf(...arguments);</span><br><span class="line">                console.log(`【 setPrototypeOf 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(proto)&#125; --&gt; $&#123;result&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            ownKeys(target) &#123;</span><br><span class="line">                let result = Reflect.ownKeys(...arguments);</span><br><span class="line">                console.log(`【 ownKeys 】--&gt; $&#123;proxyName&#125; --&gt; $&#123;JSON.stringify(result)&#125;`);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;,</span><br><span class="line">            // apply(target, thisArg, args) &#123;</span><br><span class="line">            //     // debugger;</span><br><span class="line">            //     let result = Reflect.apply(...arguments);</span><br><span class="line">            //     if (target.name !== &quot;toString&quot;) &#123;</span><br><span class="line">            //         console.log(`【 apply 】--&gt; $&#123;proxyName&#125;($&#123;args&#125;) --&gt; $&#123;result&#125;`);</span><br><span class="line">            //         return result;</span><br><span class="line">            //     &#125; else &#123;</span><br><span class="line">            //         return result;</span><br><span class="line">            //     &#125;</span><br><span class="line"></span><br><span class="line">            // &#125;,</span><br><span class="line">            // construct(target, args) &#123;</span><br><span class="line">            //     let result = Reflect.construct(...arguments);</span><br><span class="line">            //     console.log(`【 construct 】--&gt; new Proxy($&#123;args&#125;) --&gt; $&#123;result&#125;`);</span><br><span class="line">            //     return result;</span><br><span class="line">            // &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果配置禁用代理，直接返回目标对象</span><br><span class="line">    if (_r8y9x2w0.config.proxy === false) &#123;</span><br><span class="line">        return targetObject;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回代理后的对象</span><br><span class="line">    return new Proxy(targetObject, getObjhandler(proxyName || &#x27;target&#x27;));</span><br><span class="line">    // window 在经过代理器设置后，转换为了 Proxy 对象，Object.is(window, globalThis) 检测则为 false，与浏览器不一致</span><br><span class="line">    globalThis = window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-特殊环境对象补法"><a href="#3-特殊环境对象补法" class="headerlink" title="3. 特殊环境对象补法"></a>3. 特殊环境对象补法</h3><blockquote><p>在通过脱环境脚本脱 Image 实例的环境时，发现脱下来的环境中并没有 Image 构造函数，而是 HTMLImageElement，并且实例直接继承自 HTMLImageElement 的原型，与 Image 仿佛没有半点关系，于是……我遇到了<strong>一个非常有趣的问题！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp1 = new Image()</span><br><span class="line">temp1.__proto__  --&gt; HTMLImageElement &#123;…&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么 temp1 由 Image 构造，其原型却是 HTMLImageElement ？继续看</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Image.prototype  --&gt; HTMLImageElement &#123;…&#125;</span><br><span class="line">temp1.__proto__ == Image.prototype  --&gt; true</span><br><span class="line">temp1.__proto__ == HTMLImageElement.prototype--&gt; true</span><br></pre></td></tr></table></figure><blockquote><p><strong>可是 Image 的原型也是 HTMLImageElement，那他们就相等啊，那 temp1 的原型既是 HTMLImageElement 又是 Image ？</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp1.constructor  --&gt; ƒ HTMLImageElement() &#123; [native code] &#125;</span><br><span class="line">temp1.constructor == HTMLImageElement  --&gt; true</span><br><span class="line">temp1.constructor == Image  --&gt; false</span><br></pre></td></tr></table></figure><blockquote><p><strong>可是 temp1 的构造函数却是 HTMLImageElement，啊 ？？？why ？？？那我们 Image 算小三吗 ？？？</strong></p></blockquote><p><span style="color:red;">在前面关于原型链的学习中，知道实例的 __proto__ 指向构造函数的 prototype，所以这里 temp1 是有两个构造函数吗？同时，有实例的 constructor 属性是构造函数的理论，可是 temp1 由 Image 构造，constructor 属性却是 HTMLImageElement，奇怪！那到底是为什么呢，又该如何补原型链呢？</span></p></blockquote><ul><li><strong>关于 Image 构造函数：</strong><ol><li>Image 是一个浏览器提供的构造函数，用于创建图片对象，<strong>没有自己的独立原型链</strong>，其原型 <code>Image.__proto__</code> 直接指向Function.prototype，即 Function 构造函数，<strong>实际上它是对 HTMLImageElement 的一种封装</strong>。当使用 <code>new Image()</code> 创建对象时，返回的是一个 HTMLImageElement 类型的对象，所以原型自然是 HTMLImageElement.prototype</li><li><code>temp1.__proto__</code> 指向的是 Image 构造函数的原型，而 <code>Image.prototype</code> 实际上等同于 <code>HTMLImageElement.prototype</code>。这是因为在浏览器实现中直接将 <code>Image.prototype</code> 指向了 <code>HTMLImageElement.prototype</code>，是同一个对象，所以 Image 只是一个构造函数的封装，它不定义新的原型链，而是直接复用了 HTMLImageElement 的原型</li></ol></li><li><strong>如果在脱环境中遇到脱出的环境和不包含目标环境对象，则大概率是这种情况：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTMLImageElement = function HTMLImageElement() &#123;</span><br><span class="line">    _r8y9x2w0.throwError(&#x27;HTMLImageElement&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">_r8y9x2w0.func_set_native(HTMLImageElement);</span><br><span class="line">_r8y9x2w0.rename(HTMLImageElement.prototype, &quot;HTMLImageElement&quot;);</span><br><span class="line">Object.setPrototypeOf(HTMLImageElement.prototype, HTMLElement.prototype);</span><br><span class="line"></span><br><span class="line">// 手动创建目标环境对象（构造函数），直接将 HTMLImageElement.prototype 赋值给 Image.prototype</span><br><span class="line">Image = function Image() &#123; &#125;;</span><br><span class="line">_r8y9x2w0.func_set_native(Image);</span><br><span class="line">_r8y9x2w0.rename(Image.prototype, &quot;Image&quot;);</span><br><span class="line">Image.prototype = HTMLImageElement.prototype;</span><br></pre></td></tr></table></figure><h3 id="4-脱环境之-Event-事件"><a href="#4-脱环境之-Event-事件" class="headerlink" title="4. 脱环境之 Event 事件"></a>4. 脱环境之 Event 事件</h3><ul><li><p><strong>关于 Event 鼠标事件（脱环境）：</strong></p><ol><li><p>首先在触发事件本身的对象上添加监听事件，通过手动触发，得到<strong>事件执行顺序</strong>与事件对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&quot;#slideVerify &gt; div &gt; div &gt; div&quot;).addEventListener(&quot;mousemove&quot;, function (e) &#123;</span><br><span class="line">    console.log(&quot;mousemove&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">document.querySelector(&quot;#slideVerify &gt; div &gt; div &gt; div&quot;).addEventListener(&quot;mouseup&quot;, function (e) &#123;</span><br><span class="line">    console.log(&quot;mouseup&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">document.querySelector(&quot;#slideVerify &gt; div &gt; div &gt; div&quot;).addEventListener(&quot;mousedown&quot;, function (e) &#123;</span><br><span class="line">    console.log(&quot;mousedown&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>随便打印一个 e 事件对象，并存储为 temp1 全局变量，则可以对 temp1 <code>extractProperties(temp1)</code> 脱环境了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&quot;#slideVerify &gt; div &gt; div &gt; div&quot;).addEventListener(&quot;mousemove&quot;, function (e) &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在补完对应原型的环境后，在 env.node.js 中按照原型链从上到下导出，同时在补出来的事件本身上也可以加上代理，即可吐出事件需要的环境，当然如果原型上补的都是 debugger 函数，自然会被断住，只是代理输出的日志中看不到具体事件对象的环境</p></li></ol></li></ul><h3 id="5-补环境之-jsvmp"><a href="#5-补环境之-jsvmp" class="headerlink" title="5. 补环境之 jsvmp"></a>5. 补环境之 jsvmp</h3><ul><li><strong>jsvmp 的常见样式与补环境方法：</strong><ol><li>完整的 jsvmp 代码，可以直接完整的单独拿到浏览器一个<strong>代码段</strong>中执行，进行断点调试环境</li><li>重点看 <strong>typeof、instanceof、eval</strong> 等部分，可以打日志断点输出部分环境检测</li><li>通常 jsvmp 会在调度虚拟解释器解释字节码时，跟上大量的 typeof 环境检测确保代码运行安全性，这段环境检测会作为函数实参传给虚拟解释器，在浏览器中执行并在解释器进入开始时打上断点，便可查看当前虚拟解释器的运行时环境检测</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var glb;</span><br><span class="line">(glb = &quot;undefined&quot; == typeof window ? global : window)._$jsvmprt = function (b, e, f) &#123;</span><br><span class="line">    &quot;use strict&quot;</span><br><span class="line">    debugger;</span><br><span class="line">    &quot;function ......&quot;</span><br><span class="line">&#125;,</span><br><span class="line">    (glb = &quot;undefined&quot; == typeof window ? global : window)._$jsvmprt(&quot;484e4f4a403f5243000d2d1aea78184c36c3d671000000000000ab4......e67&quot;,</span><br><span class="line">        [, , &quot;undefined&quot; != typeof exports ? exports :</span><br><span class="line">            void 0, &quot;undefined&quot; != typeof module ? module :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof define ? define :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Object ? Object :</span><br><span class="line">                void 0, void 0, &quot;undefined&quot; != typeof TypeError ? TypeError :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof document ? document :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof InstallTrigger ? InstallTrigger :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof safari ? safari :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Date ? Date :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Math ? Math :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof navigator ? navigator :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof location ? location :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof history ? history :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Image ? Image :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof console ? console :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof PluginArray ? PluginArray :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof indexedDB ? indexedDB :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof DOMException ? DOMException :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof parseInt ? parseInt :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof String ? String :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Array ? Array :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Error ? Error :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof JSON ? JSON :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Promise ? Promise :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof WebSocket ? WebSocket :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof eval ? eval :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof setTimeout ? setTimeout :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof encodeURIComponent ? encodeURIComponent :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof encodeURI ? encodeURI :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Request ? Request :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof Headers ? Headers :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof decodeURIComponent ? decodeURIComponent :</span><br><span class="line">                void 0, &quot;undefined&quot; != typeof RegExp ? RegExp :</span><br><span class="line">                void 0</span><br><span class="line">        ]</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="七、Canvas-与验证码专题"><a href="#七、Canvas-与验证码专题" class="headerlink" title="七、Canvas 与验证码专题"></a>七、Canvas 与验证码专题</h2><blockquote><p><strong>逆向技巧：</strong>事件监听断点 –&gt; canvas 画布</p></blockquote><h3 id="1-canvas-绘图操作"><a href="#1-canvas-绘图操作" class="headerlink" title="1. canvas 绘图操作"></a>1. canvas 绘图操作</h3><ul><li>在 HTML 中使用 canvas 标签：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个宽500像素、高400像素的画布，并加上黑色边框</span><br><span class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;400&quot; style=&quot;border:1px solid #000;&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>js 获取 canvas 上下文，进行绘图操作：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const canvas = document.getElementById(&#x27;myCanvas&#x27;);</span><br><span class="line">const ctx = canvas.getContext(&#x27;2d&#x27;); // 获取2D上下文，canvas 有两种上下文类型：2d 和 webgl（3D绘图）</span><br><span class="line"></span><br><span class="line">1. 填充矩形（fillRect）：fillRect(x, y, width, height) 表示在指定位置绘制一个填充的矩形</span><br><span class="line">ctx.fillStyle = &#x27;blue&#x27;; // 设置填充颜色</span><br><span class="line">ctx.fillRect(50, 50, 100, 100); // 在(50, 50)位置绘制100x100的矩形</span><br><span class="line"></span><br><span class="line">2. 绘制矩形边框（strokeRect）</span><br><span class="line">ctx.strokeStyle = &#x27;red&#x27;; // 设置边框颜色</span><br><span class="line">ctx.lineWidth = 5; // 设置边框宽度</span><br><span class="line">ctx.strokeRect(200, 50, 100, 100); // 在(200, 50)位置绘制矩形边框</span><br><span class="line"></span><br><span class="line">3. 清除区域（clearRect）</span><br><span class="line">ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空整个画布</span><br><span class="line"></span><br><span class="line">4. 绘制路径（beginPath、moveTo、lineTo、stroke）</span><br><span class="line">ctx.beginPath(); // 开始新路径</span><br><span class="line">ctx.moveTo(50, 150); // 移动到(50, 150)</span><br><span class="line">ctx.lineTo(200, 150); // 画一条线到(200, 150)</span><br><span class="line">ctx.lineTo(125, 250); // 再画一条线到(125, 250)</span><br><span class="line">ctx.closePath(); // 闭合路径</span><br><span class="line">ctx.stroke(); // 绘制路径</span><br><span class="line"></span><br><span class="line">5. 绘制圆形或弧线（arc）：arc(x, y, radius, startAngle, endAngle, anticlockwise) 方法用于绘制弧线或圆形</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(150, 150, 75, 0, Math.PI * 2, false); // 绘制圆形</span><br><span class="line">ctx.fillStyle = &#x27;green&#x27;;</span><br><span class="line">ctx.fill(); // 填充圆形</span><br><span class="line"></span><br><span class="line">6. 绘制文本（fillText、strokeText）</span><br><span class="line">ctx.font = &#x27;30px Arial&#x27;; // 设置字体</span><br><span class="line">ctx.fillStyle = &#x27;black&#x27;;</span><br><span class="line">ctx.fillText(&#x27;Hello Canvas&#x27;, 50, 300); // 填充文本</span><br><span class="line"></span><br><span class="line">7. 添加图片（drawImage）</span><br><span class="line">const img = new Image();</span><br><span class="line">img.src = &#x27;https://example.com/image.jpg&#x27;;</span><br><span class="line">img.onload = () =&gt; &#123;</span><br><span class="line">  ctx.drawImage(img, 0, 0, 300, 200); // 在画布上绘制图片</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>动画效果：</strong>通过不断清除画布和重绘，可以实现动画效果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 0;</span><br><span class="line">function animate() &#123;</span><br><span class="line">  ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除画布</span><br><span class="line">  ctx.fillRect(x, 100, 50, 50); // 绘制矩形</span><br><span class="line">  x += 2; // 更新x坐标</span><br><span class="line">  if (x &gt; canvas.width) x = 0; // 重置位置</span><br><span class="line">  requestAnimationFrame(animate); // 循环调用动画</span><br><span class="line">&#125;</span><br><span class="line">animate(); // 启动动画</span><br></pre></td></tr></table></figure><ul><li><strong>事件交互：</strong>可以给Canvas绑定事件，比如鼠标点击</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">canvas.addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;</span><br><span class="line">  const rect = canvas.getBoundingClientRect(); // 获取画布的位置</span><br><span class="line">  const x = event.clientX - rect.left;</span><br><span class="line">  const y = event.clientY - rect.top;</span><br><span class="line">  console.log(`点击位置: ($&#123;x&#125;, $&#123;y&#125;)`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-hook-canvas-还原方法"><a href="#2-hook-canvas-还原方法" class="headerlink" title="2. hook canvas 还原方法"></a>2. hook canvas 还原方法</h3><blockquote><p>在 js 验证码逆向过程中，需要逆向的第一步挑战通常是图片被切割成多个<strong>乱序块</strong>，需要将这些小块按正确顺序拼接成原图（逆向）</p><p><strong>还原思路：</strong>验证码通常将一张图片切割为若干块，并打乱顺序组成一张新的图片。乱序图片块通常会以数组或元素列表的形式给出，通过 hook 其还原函数（对应 canvas 中的 drawImage、putImageData 函数），逆向分析还原逻辑完成乱序图片绘制还原</p></blockquote><ul><li><strong>drawIamge：</strong>是用于将图片（或视频帧）绘制到 Canvas 上的重要方法，支持<strong>缩放、裁剪和位移</strong><ul><li><code>c.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></li><li>image：要绘制的图像对象</li><li>sx, sy：源图像的裁剪起始位置（左上角）</li><li>sWidth, sHeight：裁剪区域的宽度和高度</li><li>dx, dy：目标画布上的绘制位置（左上角）</li><li>dWidth, dHeight：绘制到目标画布上的尺寸</li></ul></li><li><strong>putImageData：</strong>用于将像素数据写入 Canvas 的指定位置，适合进行<strong>图像处理和像素级操作</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 通过打印就可以知道当前主要通过 canvas 的什么函数进行还原的，确定后再 hook + debugger 调试</span><br><span class="line">// 劫持 drawImage 方法</span><br><span class="line">let _drawImage = CanvasRenderingContext2D.prototype.drawImage;</span><br><span class="line">CanvasRenderingContext2D.prototype.drawImage = function (...args) &#123;</span><br><span class="line">    console.log(&quot;【 drawImage 】--&gt;&quot;, args);</span><br><span class="line">    // debugger;</span><br><span class="line">    return _drawImage.apply(this, args);</span><br><span class="line">&#125;;</span><br><span class="line">// 劫持 putImageData 方法</span><br><span class="line">let _putImageData = CanvasRenderingContext2D.prototype.putImageData;</span><br><span class="line">CanvasRenderingContext2D.prototype.putImageData = function (...args) &#123;</span><br><span class="line">    console.log(&quot;【 putImageData 】--&gt;&quot;, args);</span><br><span class="line">    // debugger;</span><br><span class="line">    return _putImageData.apply(this, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-验证码底图乱序还原"><a href="#3-验证码底图乱序还原" class="headerlink" title="3. 验证码底图乱序还原"></a>3. 验证码底图乱序还原</h3><blockquote><p><strong>常见验证码平台：</strong></p><ul><li>网易易盾（yidun，背景带缺口+缺口）：<a class="link"   href="https://dun.163.com/trial/jigsaw"  target="_blank" rel="noopener">03fff674e9e95e3ac8bfe84466f24c6c<i class="fas fa-external-link-alt"></i></a></li><li>顶象（dx，canvas，背景带缺口+缺口）：<a class="link"   href="https://www.dingxiang-inc.com/business/captcha"  target="_blank" rel="noopener">ef51a97e8dfa006dbca1825bae38cf48<i class="fas fa-external-link-alt"></i></a></li><li>小盾安全，同盾（td，canvas，背景带缺口+缺口）：<a class="link"   href="https://xiaodun.com/onlineExperience/slidingPuzzle"  target="_blank" rel="noopener">ad4cc66dab6d1618e3ed703379ce2d0b<i class="fas fa-external-link-alt"></i></a></li><li>数美（shumei，背景带缺口+缺口）：<a class="link"   href="https://www.ishumei.com/new/product/tw/code"  target="_blank" rel="noopener">70dba825d22eeeb5cec343ec195067e4<i class="fas fa-external-link-alt"></i></a></li><li>极验（geetest，canvas，背景带缺口+缺口+完整背景）：<a class="link"   href="https://www.geetest.com/show"  target="_blank" rel="noopener">3281b0760f9fc3cee6e0e2d0a87d5034<i class="fas fa-external-link-alt"></i></a></li><li>VAPTCHA（vp，canvas，画轨迹）：<a class="link"   href="https://www.vaptcha.com/?lang=cn&from=0#demo"  target="_blank" rel="noopener">a9e9cdc19da9fd4ba57abecae8ffaced<i class="fas fa-external-link-alt"></i></a></li><li>腾讯（tc，背景带缺口+缺口）：<a class="link"   href="https://admin.xiaoe-tech.com/t/login?reg_source=0101&src_page=A#/acount"  target="_blank" rel="noopener">b7d893c351d69c0da5a545cbff1d5520<i class="fas fa-external-link-alt"></i></a></li><li>谷歌（hcaptcha，9图找实物）：<a class="link"   href="https://www.google.com/recaptcha/api2/demo"  target="_blank" rel="noopener">e497cdff45d62c05b741c80b38584632<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://www.yescaptcha.com/auth/register"  target="_blank" rel="noopener">定制解决方案<i class="fas fa-external-link-alt"></i></a></li></ul></blockquote><ul><li><strong>具体还原思路：</strong><ol><li>通过 hook canvas 定位乱序图片还原逻辑，主要逆向还原逻辑中循环对图片进行正确顺序绘制的数组的生成</li></ol></li><li><strong>还原代码逻辑：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import execjs</span><br><span class="line">import math</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">def draw_image(canvas, source_img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight):</span><br><span class="line">    &quot;&quot;&quot;模拟JS中的 c.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</span><br><span class="line">    :param canvas: 在循环开始之前创建一个空的 canvas，以便所有块都在同一个画布上绘制</span><br><span class="line">    :param source_img: 传入源图片对象，避免在每次循环中重新加载图片，提升效率</span><br><span class="line">    :param sx, sy: 源图像的裁剪起始位置（左上角）</span><br><span class="line">    :param sWidth, sHeight: 裁剪区域的宽度和高度</span><br><span class="line">    :param dx, dy: 目标画布上的绘制位置（左上角）</span><br><span class="line">    :param dWidth, dHeight: 绘制到目标画布上的尺寸</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 裁剪出指定区域 (sx, sy, sx + sWidth, sy + sHeight)</span><br><span class="line">    cropped_img = source_img.crop((sx, sy, sx + sWidth, sy + sHeight))</span><br><span class="line">    # 缩放裁剪后的图像到指定尺寸</span><br><span class="line">    resized_img = cropped_img.resize((dWidth, dHeight))</span><br><span class="line">    # 在目标画布上粘贴缩放后的图像</span><br><span class="line">    canvas.paste(resized_img, (dx, dy))</span><br><span class="line"></span><br><span class="line"># 假设的输入数据</span><br><span class="line">input_image_path = &#x27;./6dfe1f16aa0c4f32be0072c5ca0d2f02.webp&#x27;  # 乱的图片路径</span><br><span class="line"></span><br><span class="line"># 加载原始图片</span><br><span class="line">image = Image.open(input_image_path)</span><br><span class="line">img_width, img_height = image.size  # 获取图片的宽度和高度</span><br><span class="line"></span><br><span class="line"># 创建目标画布，大小与原始图片相同</span><br><span class="line">canvas = Image.new(&#x27;RGBA&#x27;, (img_width, img_height))</span><br><span class="line"></span><br><span class="line"># ---------------- 逆向逻辑：模拟 t 数组和乱序逻辑 ----------------</span><br><span class="line">arr = execjs.compile(open(&#x27;./get_canvas.js&#x27;).read()).call(&#x27;f1&#x27;, &#x27;6dfe1f16aa0c4f32be0072c5ca0d2f02&#x27;)</span><br><span class="line">s = math.floor(400 / len(arr))</span><br><span class="line"></span><br><span class="line">def drow_image(n, r):</span><br><span class="line">    t = n * s</span><br><span class="line">    i = s</span><br><span class="line">    draw_image(canvas, image, t, 0, i, img_height, r * s, 0, i, img_height)</span><br><span class="line"></span><br><span class="line"># 遍历 arr 数组，并在同一个画布上绘制所有块</span><br><span class="line">for index, item in enumerate(arr):</span><br><span class="line">    drow_image(item, index)</span><br><span class="line"></span><br><span class="line"># 最终保存结果</span><br><span class="line">canvas.save(&#x27;./restored-image.png&#x27;)</span><br></pre></td></tr></table></figure><ul><li><strong>网页手动提取图片数据：</strong><ol><li>分析验证码时，发现其是通过 Canvas 画布生成的，且没有提供 API 接口可以获取图片</li><li>通过 <code>document.querySelector(&#39;&#39;).toDataURL()</code> 将 Canvas 内容转换为包含图像数据的 Data URL</li><li>通过使用 base64 和 PIL 库来处理包含在 Data URL 中的图像数据，并将其保存为本地文件</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import base64, io</span><br><span class="line">from PIL import Image  # pip install pillow</span><br><span class="line"></span><br><span class="line">bg = &#x27;data:image/png;base64,......JRU5ErkJggg==&#x27;</span><br><span class="line"></span><br><span class="line">images = bg.split(&#x27;,&#x27;)[1]</span><br><span class="line">images = base64.b64decode(images)  # 将base64编码的图像数据解码为二进制数据</span><br><span class="line">images = Image.open(io.BytesIO(images))  # 将二进制数据包装为一个类文件对象</span><br><span class="line">images.save(&#x27;bg.png&#x27;)</span><br></pre></td></tr></table></figure><h3 id="4-万能-canvas-底图还原"><a href="#4-万能-canvas-底图还原" class="headerlink" title="4. 万能 canvas 底图还原"></a>4. 万能 canvas 底图还原</h3><blockquote><p><strong>安装 <a class="link"   href="https://github.com/Automattic/node-canvas"  target="_blank" rel="noopener">node-canvas<i class="fas fa-external-link-alt"></i></a> 库：</strong></p><ol><li><code>brew install pkg-config cairo pango libpng jpeg giflib librsvg pixman python-setuptools</code></li><li><code>export SDKROOT=$(xcrun --show-sdk-path)</code></li><li><code>npm install canvas</code>（项目里安装）</li></ol></blockquote><ul><li><strong>Hook 步骤：</strong><ol><li>通过快速批量 hook 框架，直接 hook CanvasRenderingContext2D 原型上所有方法，根据日志进行断点跟栈</li><li>扣验证码的主体 js 还原部分，直接利用 js 中的 canvas 库进行还原</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const &#123; createCanvas, Image &#125; = require(&#x27;canvas&#x27;);</span><br><span class="line">var CryptoJS = require(&quot;crypto-js&quot;);</span><br><span class="line"></span><br><span class="line">const canvas = createCanvas(400, 200);</span><br><span class="line">const ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line"></span><br><span class="line">// Draw cat with lime helmet</span><br><span class="line">function main() &#123;</span><br><span class="line">    let image = new Image()</span><br><span class="line">    image.src = &quot;data:image/png;base64,xxxxxx...&quot;</span><br><span class="line"></span><br><span class="line">    // 主体还原逻辑</span><br><span class="line">    ctx.drawImage(image, 50, 0, 70, 70)</span><br><span class="line"></span><br><span class="line">    return canvas.toDataURL()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-滑动距离-distance-识别"><a href="#5-滑动距离-distance-识别" class="headerlink" title="5. 滑动距离 distance 识别"></a>5. 滑动距离 distance 识别</h3><ul><li><strong>计算方法：</strong><ol><li><strong>GitHub 基于人工智能的深度网络训练模型 ddddocr 开源库：</strong><a class="link"   href="https://github.com/sml2h3/ddddocr"  target="_blank" rel="noopener">f70901e4adbfaa715cd0753e2adf6bea<i class="fas fa-external-link-alt"></i></a></li><li><strong>第三方打码平台（<a class="link"   href="https://www.jfbym.com/demo.html"  target="_blank" rel="noopener">云码<i class="fas fa-external-link-alt"></i></a>）：</strong>通过完整图片与缺失滑块的图片进行像素对比（图片 –&gt; 矩阵 –&gt; 像素点）</li><li><strong>边缘检测算法：</strong>OpenCV 识别滑动距离</li></ol></li><li><strong>边缘检测算法：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from PIL import Image</span><br><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line">def imshow(img, winname=&#x27;test&#x27;, delay=0):</span><br><span class="line">    &quot;&quot;&quot;使用OpenCV显示图片&quot;&quot;&quot;</span><br><span class="line">    cv2.imshow(winname, img)</span><br><span class="line">    cv2.waitKey(delay)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">def cv2_open(img, flag=None):</span><br><span class="line">    &quot;&quot;&quot;将不同类型的图片统一转换为OpenCV格式&quot;&quot;&quot;</span><br><span class="line">    if isinstance(img, bytes):</span><br><span class="line">        img = cv2.imdecode(np.frombuffer(img, dtype=np.uint8), 1)</span><br><span class="line">    elif isinstance(img, (str, Path)):</span><br><span class="line">        img = cv2.imread(str(img))</span><br><span class="line">    elif isinstance(img, np.ndarray):</span><br><span class="line">        img = img</span><br><span class="line">    elif isinstance(img, Image.Image):</span><br><span class="line">        img = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line">    else:</span><br><span class="line">        raise ValueError(f&#x27;无法解析的图片类型: &#123;type(img)&#125;&#x27;)</span><br><span class="line">    if flag is not None:</span><br><span class="line">        img = cv2.cvtColor(img, flag)</span><br><span class="line">    return img</span><br><span class="line"></span><br><span class="line">def get_distance(bg_img, slice_img):</span><br><span class="line">    &quot;&quot;&quot;核心逻辑，完成背景图与滑块之间的匹配计算&quot;&quot;&quot;</span><br><span class="line">    # 读取两张图片，在读取图像的同时进行灰度转换</span><br><span class="line">    tp_gray = cv2_open(slice_img, flag=cv2.COLOR_BGR2GRAY)</span><br><span class="line">    bg_gray = cv2_open(bg_img, flag=cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    # 对背景图进行非局部均值去噪，能够同时保留边缘和细节</span><br><span class="line">    bg_shift = cv2.fastNlMeansDenoising(bg_gray, None, h=10, templateWindowSize=7, searchWindowSize=21)</span><br><span class="line">    # 边缘检测</span><br><span class="line">    tp_gray = cv2.Canny(tp_gray, 255, 255)</span><br><span class="line">    bg_gray = cv2.Canny(bg_shift, 255, 255)</span><br><span class="line"></span><br><span class="line">    # 模板匹配</span><br><span class="line">    result = cv2.matchTemplate(bg_gray, tp_gray, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)  # 解析匹配结果</span><br><span class="line">    # if save_path or im_show:</span><br><span class="line">    #     # 需要绘制的方框高度和宽度</span><br><span class="line">    #     tp_height, tp_width = tp_gray.shape[:2]</span><br><span class="line">    #     # 矩形左上角点位置</span><br><span class="line">    #     x, y = max_loc</span><br><span class="line">    #     # 矩形右下角点位置</span><br><span class="line">    #     _x, _y = x + tp_width, y + tp_height</span><br><span class="line">    #     # 绘制矩形</span><br><span class="line">    #     bg_img = cv2_open(bg_img)</span><br><span class="line">    #     cv2.rectangle(bg_img, (x, y), (_x, _y), (0, 0, 255), 2)</span><br><span class="line">    #     # 保存缺口识别结果到背景图</span><br><span class="line">    #     if save_path:</span><br><span class="line">    #         save_path = Path(save_path).resolve()</span><br><span class="line">    #         save_path = save_path.parent / f&quot;&#123;save_path.stem&#125;&#123;save_path.suffix&#125;&quot;</span><br><span class="line">    #         save_path = save_path.__str__()</span><br><span class="line">    #         cv2.imwrite(save_path, bg_img)</span><br><span class="line">    #     # 显示缺口识别结果</span><br><span class="line">    #     if im_show:</span><br><span class="line">    #         imshow(bg_img)</span><br><span class="line">    return max_loc[0]</span><br><span class="line"></span><br><span class="line">with open(&quot;./bg_img.png&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    bg_img = f.read()</span><br><span class="line">with open(&quot;./slider_img.webp&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    slice_img = f.read()</span><br><span class="line">distance = get_distance(bg_img, slice_img)</span><br><span class="line">print(distance)</span><br></pre></td></tr></table></figure><ul><li><strong>边缘检测算法详解：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from PIL import Image</span><br><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line">def imshow(img, winname=&#x27;test&#x27;, delay=0):</span><br><span class="line">    &quot;&quot;&quot;使用OpenCV显示图片&quot;&quot;&quot;</span><br><span class="line">    cv2.imshow(winname, img)</span><br><span class="line">    cv2.waitKey(delay)  # 等待按键</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">def pil_to_cv2(img):</span><br><span class="line">    &quot;&quot;&quot;PIL图像转为OpenCV格式&quot;&quot;&quot;</span><br><span class="line">    img = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line">    return img</span><br><span class="line"></span><br><span class="line">def bytes_to_cv2(img):</span><br><span class="line">    &quot;&quot;&quot;将二进制图片转换为OpenCV格式&quot;&quot;&quot;</span><br><span class="line">    img_buffer_np = np.frombuffer(img, dtype=np.uint8)</span><br><span class="line">    img_np = cv2.imdecode(img_buffer_np, 1)</span><br><span class="line">    return img_np</span><br><span class="line"></span><br><span class="line">def cv2_open(img, flag=None):</span><br><span class="line">    &quot;&quot;&quot;将不同类型的图片统一转换为OpenCV格式&quot;&quot;&quot;</span><br><span class="line">    if isinstance(img, bytes):</span><br><span class="line">        img = bytes_to_cv2(img)</span><br><span class="line">    elif isinstance(img, (str, Path)):</span><br><span class="line">        img = cv2.imread(str(img))</span><br><span class="line">    elif isinstance(img, np.ndarray):</span><br><span class="line">        img = img</span><br><span class="line">    elif isinstance(img, Image.Image):</span><br><span class="line">        img = pil_to_cv2(img)</span><br><span class="line">    else:</span><br><span class="line">        raise ValueError(f&#x27;无法解析的图片类型: &#123;type(img)&#125;&#x27;)</span><br><span class="line">    if flag is not None:</span><br><span class="line">        img = cv2.cvtColor(img, flag)</span><br><span class="line">    return img</span><br><span class="line"></span><br><span class="line"># 第一步：读取图片并展示原图</span><br><span class="line">with open(&quot;./DXCaptcha_20241028/bg_img.png&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    bg_img = f.read()</span><br><span class="line">with open(&quot;./DXCaptcha_20241028/slider_img.webp&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    slice_img = f.read()</span><br><span class="line"></span><br><span class="line">bg = cv2_open(bg_img)</span><br><span class="line">tp = cv2_open(slice_img)</span><br><span class="line"></span><br><span class="line"># 展示背景图和滑块图</span><br><span class="line">print(&quot;展示原始背景图：&quot;)</span><br><span class="line">imshow(bg, &#x27;Background&#x27;)</span><br><span class="line">print(&quot;展示原始滑块图：&quot;)</span><br><span class="line">imshow(tp, &#x27;Slider&#x27;)</span><br><span class="line"></span><br><span class="line"># 第二步：将两张图片都转为灰度图</span><br><span class="line">tp_gray = cv2.cvtColor(tp, cv2.COLOR_BGR2GRAY)</span><br><span class="line">bg_gray = cv2.cvtColor(bg, cv2.COLOR_BGR2GRAY)</span><br><span class="line"># 展示灰度化后的图片</span><br><span class="line">print(&quot;展示灰度滑块图：&quot;)</span><br><span class="line">imshow(tp_gray, &#x27;Gray Slider&#x27;)  # 展示灰度滑块</span><br><span class="line">imshow(bg_gray, &#x27;Gray Background&#x27;)  # 展示灰度背景</span><br><span class="line"></span><br><span class="line"># 第三步：对背景灰度图进行非局部均值去噪，能够同时保留边缘和细节</span><br><span class="line">bg_shift = cv2.fastNlMeansDenoising(bg_gray, None, h=10, templateWindowSize=7, searchWindowSize=21)</span><br><span class="line"># 对背景图进行金字塔均值漂移滤波处理</span><br><span class="line"># bg_shift = cv2.pyrMeanShiftFiltering(bg_img, 5, 50)</span><br><span class="line"># 对背景图进行高斯滤波处理</span><br><span class="line"># bg_shift = cv2.GaussianBlur(bg_img, (5, 5), 0)</span><br><span class="line">print(&quot;展示滤波后的背景图：&quot;)</span><br><span class="line">imshow(bg_shift, &#x27;Filtered Background&#x27;)</span><br><span class="line"></span><br><span class="line">def trackbar(x):</span><br><span class="line">    &quot;&quot;&quot;使用 OpenCV 创建一个窗口，并在该窗口中添加两个滑动条（trackbars），用于调整 Canny 边缘检测算法的阈值&quot;&quot;&quot;</span><br><span class="line">    test1 = cv2.getTrackbarPos(&quot;test1&quot;, &quot;cannyTest&quot;)</span><br><span class="line">    test2 = cv2.getTrackbarPos(&quot;test2&quot;, &quot;cannyTest&quot;)</span><br><span class="line">    canny_img1 = cv2.Canny(tp_gray, test1, test2)</span><br><span class="line">    canny_img2 = cv2.Canny(bg_shift, test1, test2)</span><br><span class="line">    cv2.imshow(&quot;canny_img1&quot;, canny_img1)</span><br><span class="line">    cv2.imshow(&quot;canny_img2&quot;, canny_img2)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(&#x27;cannyTest&#x27;)</span><br><span class="line">cv2.createTrackbar(&quot;test1&quot;, &quot;cannyTest&quot;, 0, 255, trackbar)</span><br><span class="line">cv2.createTrackbar(&quot;test2&quot;, &quot;cannyTest&quot;, 0, 255, trackbar)</span><br><span class="line"></span><br><span class="line"># 第四步：对滤波后的背景图和滑块进行边缘检测并展示</span><br><span class="line">tp_edge = cv2.Canny(tp_gray, 255, 255)</span><br><span class="line">bg_edge = cv2.Canny(bg_shift, 255, 255)</span><br><span class="line">print(&quot;展示滑块边缘检测结果：&quot;)</span><br><span class="line">imshow(tp_edge, &#x27;Slider Edge&#x27;)</span><br><span class="line">print(&quot;展示背景图边缘检测结果：&quot;)</span><br><span class="line">imshow(bg_edge, &#x27;Background Edge&#x27;)</span><br><span class="line"></span><br><span class="line"># 第五步：使用模板匹配，并展示匹配结果</span><br><span class="line">result = cv2.matchTemplate(bg_edge, tp_edge, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)</span><br><span class="line"></span><br><span class="line"># 标出匹配位置</span><br><span class="line">x, y = max_loc</span><br><span class="line">tp_height, tp_width = tp_gray.shape[:2]</span><br><span class="line">cv2.rectangle(bg, (x, y), (x + tp_width, y + tp_height), (0, 0, 255), 2)</span><br><span class="line"></span><br><span class="line">print(f&quot;匹配到的位置：x=&#123;x&#125;, y=&#123;y&#125;&quot;)</span><br><span class="line">print(&quot;展示匹配后的背景图：&quot;)</span><br><span class="line">imshow(bg, &#x27;Matched Background&#x27;)</span><br></pre></td></tr></table></figure><h3 id="6-鼠标轨迹-track-生成"><a href="#6-鼠标轨迹-track-生成" class="headerlink" title="6. 鼠标轨迹 track 生成"></a>6. 鼠标轨迹 track 生成</h3><blockquote><p>基于贝塞尔曲线生成轨迹可以参考：<a class="link"   href="https://github.com/2833844911/gurs"  target="_blank" rel="noopener">fa5294b67caaf91f4de8d6ed551a810e<i class="fas fa-external-link-alt"></i></a></p><p>使用 tanh 和 arctan 函数整合生成轨迹可以参考：<a class="link"   href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1162979"  target="_blank" rel="noopener">7a15c1aca3c556ac8b660040c6811234<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li><strong>轨迹生成算法 new：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">trail_1 = [</span><br><span class="line">    [</span><br><span class="line">        9,</span><br><span class="line">        1,</span><br><span class="line">        111</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        13,</span><br><span class="line">        1,</span><br><span class="line">        121</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        19,</span><br><span class="line">        1,</span><br><span class="line">        126</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        28,</span><br><span class="line">        1,</span><br><span class="line">        136</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        36,</span><br><span class="line">        1,</span><br><span class="line">        146</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        49,</span><br><span class="line">        1,</span><br><span class="line">        153</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        61,</span><br><span class="line">        1,</span><br><span class="line">        163</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        75,</span><br><span class="line">        -2,</span><br><span class="line">        171</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        86,</span><br><span class="line">        -2,</span><br><span class="line">        180</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        96,</span><br><span class="line">        -4,</span><br><span class="line">        190</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        104,</span><br><span class="line">        -4,</span><br><span class="line">        198</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        114,</span><br><span class="line">        -5,</span><br><span class="line">        204</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        122,</span><br><span class="line">        -5,</span><br><span class="line">        214</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        128,</span><br><span class="line">        -6,</span><br><span class="line">        222</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        134,</span><br><span class="line">        -7,</span><br><span class="line">        230</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        139,</span><br><span class="line">        -7,</span><br><span class="line">        242</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        143,</span><br><span class="line">        -7,</span><br><span class="line">        246</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        147,</span><br><span class="line">        -8,</span><br><span class="line">        253</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        151,</span><br><span class="line">        -8,</span><br><span class="line">        266</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        155,</span><br><span class="line">        -8,</span><br><span class="line">        272</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        158,</span><br><span class="line">        -8,</span><br><span class="line">        292</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        161,</span><br><span class="line">        -9,</span><br><span class="line">        299</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        165,</span><br><span class="line">        -9,</span><br><span class="line">        303</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        168,</span><br><span class="line">        -10,</span><br><span class="line">        306</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        171,</span><br><span class="line">        -10,</span><br><span class="line">        313</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        176,</span><br><span class="line">        -10,</span><br><span class="line">        322</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        179,</span><br><span class="line">        -10,</span><br><span class="line">        330</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        184,</span><br><span class="line">        -11,</span><br><span class="line">        341</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        188,</span><br><span class="line">        -11,</span><br><span class="line">        355</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        191,</span><br><span class="line">        -11,</span><br><span class="line">        361</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        194,</span><br><span class="line">        -11,</span><br><span class="line">        367</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        196,</span><br><span class="line">        -11,</span><br><span class="line">        375</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        198,</span><br><span class="line">        -12,</span><br><span class="line">        384</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        201,</span><br><span class="line">        -12,</span><br><span class="line">        393</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        203,</span><br><span class="line">        -12,</span><br><span class="line">        401</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        206,</span><br><span class="line">        -12,</span><br><span class="line">        412</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        208,</span><br><span class="line">        -12,</span><br><span class="line">        420</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        211,</span><br><span class="line">        -13,</span><br><span class="line">        430</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        214,</span><br><span class="line">        -13,</span><br><span class="line">        437</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        215,</span><br><span class="line">        -13,</span><br><span class="line">        448</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        218,</span><br><span class="line">        -13,</span><br><span class="line">        454</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        220,</span><br><span class="line">        -13,</span><br><span class="line">        465</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        223,</span><br><span class="line">        -13,</span><br><span class="line">        473</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        225,</span><br><span class="line">        -13,</span><br><span class="line">        485</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        227,</span><br><span class="line">        -13,</span><br><span class="line">        497</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        228,</span><br><span class="line">        -14,</span><br><span class="line">        505</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        229,</span><br><span class="line">        -14,</span><br><span class="line">        516</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        231,</span><br><span class="line">        -14,</span><br><span class="line">        525</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        232,</span><br><span class="line">        -14,</span><br><span class="line">        534</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        233,</span><br><span class="line">        -14,</span><br><span class="line">        540</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        235,</span><br><span class="line">        -14,</span><br><span class="line">        551</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        237,</span><br><span class="line">        -14,</span><br><span class="line">        562</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        239,</span><br><span class="line">        -14,</span><br><span class="line">        573</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        240,</span><br><span class="line">        -14,</span><br><span class="line">        583</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        241,</span><br><span class="line">        -14,</span><br><span class="line">        588</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        243,</span><br><span class="line">        -14,</span><br><span class="line">        612</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        244,</span><br><span class="line">        -14,</span><br><span class="line">        621</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        245,</span><br><span class="line">        -14,</span><br><span class="line">        632</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        247,</span><br><span class="line">        -14,</span><br><span class="line">        638</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        248,</span><br><span class="line">        -14,</span><br><span class="line">        653</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        249,</span><br><span class="line">        -14,</span><br><span class="line">        661</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        250,</span><br><span class="line">        -14,</span><br><span class="line">        673</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        251,</span><br><span class="line">        -14,</span><br><span class="line">        684</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        252,</span><br><span class="line">        -14,</span><br><span class="line">        696</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        253,</span><br><span class="line">        -14,</span><br><span class="line">        709</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        254,</span><br><span class="line">        -14,</span><br><span class="line">        727</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        255,</span><br><span class="line">        -14,</span><br><span class="line">        740</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        256,</span><br><span class="line">        -14,</span><br><span class="line">        762</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        256,</span><br><span class="line">        -15,</span><br><span class="line">        785</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        257,</span><br><span class="line">        -15,</span><br><span class="line">        809</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        258,</span><br><span class="line">        -15,</span><br><span class="line">        836</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        259,</span><br><span class="line">        -15,</span><br><span class="line">        864</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        260,</span><br><span class="line">        -15,</span><br><span class="line">        875</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        261,</span><br><span class="line">        -15,</span><br><span class="line">        899</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        262,</span><br><span class="line">        -15,</span><br><span class="line">        950</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        263,</span><br><span class="line">        -15,</span><br><span class="line">        969</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        264,</span><br><span class="line">        -15,</span><br><span class="line">        983</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        265,</span><br><span class="line">        -15,</span><br><span class="line">        1016</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        266,</span><br><span class="line">        -15,</span><br><span class="line">        1035</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        267,</span><br><span class="line">        -15,</span><br><span class="line">        1057</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        268,</span><br><span class="line">        -15,</span><br><span class="line">        1069</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        269,</span><br><span class="line">        -15,</span><br><span class="line">        1102</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        270,</span><br><span class="line">        -15,</span><br><span class="line">        1244</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">trail_2 = [</span><br><span class="line">    [</span><br><span class="line">        11,</span><br><span class="line">        0,</span><br><span class="line">        140</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        13,</span><br><span class="line">        0,</span><br><span class="line">        147</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        16,</span><br><span class="line">        0,</span><br><span class="line">        158</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        19,</span><br><span class="line">        0,</span><br><span class="line">        168</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        21,</span><br><span class="line">        0,</span><br><span class="line">        177</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        24,</span><br><span class="line">        -1,</span><br><span class="line">        184</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        27,</span><br><span class="line">        -1,</span><br><span class="line">        193</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        30,</span><br><span class="line">        -1,</span><br><span class="line">        202</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        32,</span><br><span class="line">        -1,</span><br><span class="line">        213</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        34,</span><br><span class="line">        -1,</span><br><span class="line">        217</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        37,</span><br><span class="line">        -1,</span><br><span class="line">        228</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        38,</span><br><span class="line">        -1,</span><br><span class="line">        235</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        41,</span><br><span class="line">        -1,</span><br><span class="line">        249</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        43,</span><br><span class="line">        -1,</span><br><span class="line">        261</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        45,</span><br><span class="line">        -2,</span><br><span class="line">        270</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        47,</span><br><span class="line">        -2,</span><br><span class="line">        282</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        49,</span><br><span class="line">        -2,</span><br><span class="line">        293</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        50,</span><br><span class="line">        -2,</span><br><span class="line">        301</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        51,</span><br><span class="line">        -2,</span><br><span class="line">        312</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        53,</span><br><span class="line">        -2,</span><br><span class="line">        322</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        54,</span><br><span class="line">        -2,</span><br><span class="line">        332</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        56,</span><br><span class="line">        -2,</span><br><span class="line">        342</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        58,</span><br><span class="line">        -2,</span><br><span class="line">        352</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        60,</span><br><span class="line">        -2,</span><br><span class="line">        362</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        62,</span><br><span class="line">        -2,</span><br><span class="line">        374</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        65,</span><br><span class="line">        -2,</span><br><span class="line">        384</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        66,</span><br><span class="line">        -2,</span><br><span class="line">        392</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        68,</span><br><span class="line">        -2,</span><br><span class="line">        399</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        69,</span><br><span class="line">        -2,</span><br><span class="line">        409</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        71,</span><br><span class="line">        -2,</span><br><span class="line">        422</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        73,</span><br><span class="line">        -2,</span><br><span class="line">        428</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        74,</span><br><span class="line">        -2,</span><br><span class="line">        436</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        76,</span><br><span class="line">        -2,</span><br><span class="line">        447</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        77,</span><br><span class="line">        -2,</span><br><span class="line">        452</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        79,</span><br><span class="line">        -2,</span><br><span class="line">        466</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        82,</span><br><span class="line">        -2,</span><br><span class="line">        476</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        83,</span><br><span class="line">        -2,</span><br><span class="line">        485</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        85,</span><br><span class="line">        -2,</span><br><span class="line">        495</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        86,</span><br><span class="line">        -2,</span><br><span class="line">        506</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        87,</span><br><span class="line">        -2,</span><br><span class="line">        515</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        88,</span><br><span class="line">        -2,</span><br><span class="line">        523</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        90,</span><br><span class="line">        -2,</span><br><span class="line">        542</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        91,</span><br><span class="line">        -2,</span><br><span class="line">        549</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        93,</span><br><span class="line">        -2,</span><br><span class="line">        562</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        94,</span><br><span class="line">        -2,</span><br><span class="line">        568</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        95,</span><br><span class="line">        -2,</span><br><span class="line">        586</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        96,</span><br><span class="line">        -2,</span><br><span class="line">        604</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        97,</span><br><span class="line">        -2,</span><br><span class="line">        630</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        98,</span><br><span class="line">        -2,</span><br><span class="line">        640</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        99,</span><br><span class="line">        -2,</span><br><span class="line">        661</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        100,</span><br><span class="line">        -2,</span><br><span class="line">        680</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        101,</span><br><span class="line">        -2,</span><br><span class="line">        708</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        102,</span><br><span class="line">        -2,</span><br><span class="line">        728</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        103,</span><br><span class="line">        -2,</span><br><span class="line">        756</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        104,</span><br><span class="line">        -2,</span><br><span class="line">        782</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        105,</span><br><span class="line">        -2,</span><br><span class="line">        804</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        106,</span><br><span class="line">        -2,</span><br><span class="line">        821</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        107,</span><br><span class="line">        -2,</span><br><span class="line">        862</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        108,</span><br><span class="line">        -2,</span><br><span class="line">        890</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        109,</span><br><span class="line">        -2,</span><br><span class="line">        927</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        110,</span><br><span class="line">        -2,</span><br><span class="line">        951</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        111,</span><br><span class="line">        -2,</span><br><span class="line">        1029</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        112,</span><br><span class="line">        -2,</span><br><span class="line">        1052</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        113,</span><br><span class="line">        -2,</span><br><span class="line">        1095</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        114,</span><br><span class="line">        -2,</span><br><span class="line">        1112</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        115,</span><br><span class="line">        -2,</span><br><span class="line">        1135</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        116,</span><br><span class="line">        -2,</span><br><span class="line">        1213</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">trail_3 = [</span><br><span class="line">    [</span><br><span class="line">        13,</span><br><span class="line">        0,</span><br><span class="line">        86</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        18,</span><br><span class="line">        -1,</span><br><span class="line">        96</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        22,</span><br><span class="line">        -1,</span><br><span class="line">        102</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        28,</span><br><span class="line">        -1,</span><br><span class="line">        114</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        33,</span><br><span class="line">        -2,</span><br><span class="line">        120</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        38,</span><br><span class="line">        -2,</span><br><span class="line">        125</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        43,</span><br><span class="line">        -2,</span><br><span class="line">        139</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        47,</span><br><span class="line">        -3,</span><br><span class="line">        149</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        51,</span><br><span class="line">        -3,</span><br><span class="line">        156</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        55,</span><br><span class="line">        -3,</span><br><span class="line">        164</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        58,</span><br><span class="line">        -3,</span><br><span class="line">        172</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        60,</span><br><span class="line">        -4,</span><br><span class="line">        179</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        63,</span><br><span class="line">        -4,</span><br><span class="line">        186</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        65,</span><br><span class="line">        -4,</span><br><span class="line">        195</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        68,</span><br><span class="line">        -4,</span><br><span class="line">        204</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        70,</span><br><span class="line">        -4,</span><br><span class="line">        217</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        72,</span><br><span class="line">        -4,</span><br><span class="line">        221</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        75,</span><br><span class="line">        -4,</span><br><span class="line">        232</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        77,</span><br><span class="line">        -5,</span><br><span class="line">        239</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        78,</span><br><span class="line">        -5,</span><br><span class="line">        251</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        81,</span><br><span class="line">        -5,</span><br><span class="line">        257</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        82,</span><br><span class="line">        -5,</span><br><span class="line">        269</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        84,</span><br><span class="line">        -6,</span><br><span class="line">        276</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        85,</span><br><span class="line">        -6,</span><br><span class="line">        284</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        86,</span><br><span class="line">        -6,</span><br><span class="line">        292</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        87,</span><br><span class="line">        -6,</span><br><span class="line">        305</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        88,</span><br><span class="line">        -6,</span><br><span class="line">        312</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        89,</span><br><span class="line">        -6,</span><br><span class="line">        323</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        90,</span><br><span class="line">        -6,</span><br><span class="line">        340</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        91,</span><br><span class="line">        -6,</span><br><span class="line">        362</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        92,</span><br><span class="line">        -6,</span><br><span class="line">        370</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        93,</span><br><span class="line">        -6,</span><br><span class="line">        391</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        94,</span><br><span class="line">        -6,</span><br><span class="line">        401</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        96,</span><br><span class="line">        -6,</span><br><span class="line">        417</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        97,</span><br><span class="line">        -6,</span><br><span class="line">        438</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        98,</span><br><span class="line">        -6,</span><br><span class="line">        464</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        99,</span><br><span class="line">        -6,</span><br><span class="line">        487</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        100,</span><br><span class="line">        -6,</span><br><span class="line">        501</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        101,</span><br><span class="line">        -6,</span><br><span class="line">        521</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        102,</span><br><span class="line">        -6,</span><br><span class="line">        548</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        103,</span><br><span class="line">        -6,</span><br><span class="line">        565</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        104,</span><br><span class="line">        -6,</span><br><span class="line">        590</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        105,</span><br><span class="line">        -6,</span><br><span class="line">        642</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        106,</span><br><span class="line">        -6,</span><br><span class="line">        688</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        107,</span><br><span class="line">        -6,</span><br><span class="line">        721</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        108,</span><br><span class="line">        -6,</span><br><span class="line">        735</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        109,</span><br><span class="line">        -6,</span><br><span class="line">        770</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        110,</span><br><span class="line">        -6,</span><br><span class="line">        832</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        111,</span><br><span class="line">        -6,</span><br><span class="line">        857</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        112,</span><br><span class="line">        -6,</span><br><span class="line">        887</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        113,</span><br><span class="line">        -6,</span><br><span class="line">        902</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        114,</span><br><span class="line">        -6,</span><br><span class="line">        923</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        115,</span><br><span class="line">        -6,</span><br><span class="line">        950</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        115,</span><br><span class="line">        -5,</span><br><span class="line">        999</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        116,</span><br><span class="line">        -5,</span><br><span class="line">        1008</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        117,</span><br><span class="line">        -5,</span><br><span class="line">        1034</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        118,</span><br><span class="line">        -5,</span><br><span class="line">        1081</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        118,</span><br><span class="line">        -4,</span><br><span class="line">        1089</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        119,</span><br><span class="line">        -4,</span><br><span class="line">        1100</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        120,</span><br><span class="line">        -4,</span><br><span class="line">        1122</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        121,</span><br><span class="line">        -4,</span><br><span class="line">        1159</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">trail_4 = [</span><br><span class="line">    [</span><br><span class="line">        9,</span><br><span class="line">        0,</span><br><span class="line">        136</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        14,</span><br><span class="line">        -1,</span><br><span class="line">        143</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        17,</span><br><span class="line">        -1,</span><br><span class="line">        152</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        22,</span><br><span class="line">        -2,</span><br><span class="line">        161</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        29,</span><br><span class="line">        -2,</span><br><span class="line">        169</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        35,</span><br><span class="line">        -2,</span><br><span class="line">        177</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        41,</span><br><span class="line">        -3,</span><br><span class="line">        186</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        51,</span><br><span class="line">        -3,</span><br><span class="line">        200</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        58,</span><br><span class="line">        -3,</span><br><span class="line">        206</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        69,</span><br><span class="line">        -4,</span><br><span class="line">        212</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        77,</span><br><span class="line">        -4,</span><br><span class="line">        220</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        87,</span><br><span class="line">        -4,</span><br><span class="line">        231</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        95,</span><br><span class="line">        -4,</span><br><span class="line">        237</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        105,</span><br><span class="line">        -4,</span><br><span class="line">        245</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        114,</span><br><span class="line">        -4,</span><br><span class="line">        254</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        120,</span><br><span class="line">        -4,</span><br><span class="line">        266</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        124,</span><br><span class="line">        -4,</span><br><span class="line">        271</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        128,</span><br><span class="line">        -4,</span><br><span class="line">        285</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        131,</span><br><span class="line">        -4,</span><br><span class="line">        295</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        133,</span><br><span class="line">        -4,</span><br><span class="line">        302</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        135,</span><br><span class="line">        -4,</span><br><span class="line">        308</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        136,</span><br><span class="line">        -4,</span><br><span class="line">        316</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        137,</span><br><span class="line">        -4,</span><br><span class="line">        324</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        138,</span><br><span class="line">        -4,</span><br><span class="line">        335</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        139,</span><br><span class="line">        -4,</span><br><span class="line">        340</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        141,</span><br><span class="line">        -4,</span><br><span class="line">        353</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        142,</span><br><span class="line">        -4,</span><br><span class="line">        362</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        143,</span><br><span class="line">        -4,</span><br><span class="line">        372</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        144,</span><br><span class="line">        -4,</span><br><span class="line">        387</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        145,</span><br><span class="line">        -4,</span><br><span class="line">        389</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        146,</span><br><span class="line">        -4,</span><br><span class="line">        406</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        147,</span><br><span class="line">        -4,</span><br><span class="line">        425</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        148,</span><br><span class="line">        -4,</span><br><span class="line">        455</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        149,</span><br><span class="line">        -4,</span><br><span class="line">        466</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        150,</span><br><span class="line">        -4,</span><br><span class="line">        483</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        150,</span><br><span class="line">        -5,</span><br><span class="line">        492</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        151,</span><br><span class="line">        -5,</span><br><span class="line">        499</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        150,</span><br><span class="line">        -5,</span><br><span class="line">        1202</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">trail_5 = [</span><br><span class="line">    [</span><br><span class="line">        8,</span><br><span class="line">        -1,</span><br><span class="line">        128</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        12,</span><br><span class="line">        -2,</span><br><span class="line">        137</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        15,</span><br><span class="line">        -2,</span><br><span class="line">        145</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        19,</span><br><span class="line">        -2,</span><br><span class="line">        156</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        22,</span><br><span class="line">        -4,</span><br><span class="line">        160</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        26,</span><br><span class="line">        -4,</span><br><span class="line">        174</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        29,</span><br><span class="line">        -5,</span><br><span class="line">        178</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        32,</span><br><span class="line">        -5,</span><br><span class="line">        187</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        35,</span><br><span class="line">        -5,</span><br><span class="line">        198</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        37,</span><br><span class="line">        -5,</span><br><span class="line">        207</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        38,</span><br><span class="line">        -6,</span><br><span class="line">        212</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        40,</span><br><span class="line">        -6,</span><br><span class="line">        222</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        43,</span><br><span class="line">        -7,</span><br><span class="line">        230</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        44,</span><br><span class="line">        -7,</span><br><span class="line">        240</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        48,</span><br><span class="line">        -8,</span><br><span class="line">        250</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        50,</span><br><span class="line">        -8,</span><br><span class="line">        256</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        53,</span><br><span class="line">        -8,</span><br><span class="line">        266</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        56,</span><br><span class="line">        -9,</span><br><span class="line">        274</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        60,</span><br><span class="line">        -9,</span><br><span class="line">        281</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        64,</span><br><span class="line">        -10,</span><br><span class="line">        292</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        69,</span><br><span class="line">        -10,</span><br><span class="line">        302</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        73,</span><br><span class="line">        -10,</span><br><span class="line">        310</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        78,</span><br><span class="line">        -11,</span><br><span class="line">        319</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        83,</span><br><span class="line">        -12,</span><br><span class="line">        327</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        88,</span><br><span class="line">        -12,</span><br><span class="line">        336</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        92,</span><br><span class="line">        -13,</span><br><span class="line">        343</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        97,</span><br><span class="line">        -13,</span><br><span class="line">        352</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        100,</span><br><span class="line">        -13,</span><br><span class="line">        359</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        103,</span><br><span class="line">        -13,</span><br><span class="line">        367</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        106,</span><br><span class="line">        -13,</span><br><span class="line">        375</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        108,</span><br><span class="line">        -13,</span><br><span class="line">        386</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        111,</span><br><span class="line">        -13,</span><br><span class="line">        393</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        112,</span><br><span class="line">        -13,</span><br><span class="line">        402</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        115,</span><br><span class="line">        -13,</span><br><span class="line">        411</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        117,</span><br><span class="line">        -13,</span><br><span class="line">        422</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        118,</span><br><span class="line">        -13,</span><br><span class="line">        428</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        120,</span><br><span class="line">        -13,</span><br><span class="line">        438</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        122,</span><br><span class="line">        -13,</span><br><span class="line">        444</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        123,</span><br><span class="line">        -13,</span><br><span class="line">        456</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        125,</span><br><span class="line">        -13,</span><br><span class="line">        465</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        126,</span><br><span class="line">        -13,</span><br><span class="line">        472</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        127,</span><br><span class="line">        -13,</span><br><span class="line">        479</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        129,</span><br><span class="line">        -13,</span><br><span class="line">        490</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        131,</span><br><span class="line">        -13,</span><br><span class="line">        501</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        133,</span><br><span class="line">        -13,</span><br><span class="line">        512</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        135,</span><br><span class="line">        -13,</span><br><span class="line">        524</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        137,</span><br><span class="line">        -13,</span><br><span class="line">        529</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        139,</span><br><span class="line">        -13,</span><br><span class="line">        541</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        140,</span><br><span class="line">        -13,</span><br><span class="line">        550</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        142,</span><br><span class="line">        -13,</span><br><span class="line">        562</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        143,</span><br><span class="line">        -13,</span><br><span class="line">        576</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        144,</span><br><span class="line">        -13,</span><br><span class="line">        589</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        145,</span><br><span class="line">        -13,</span><br><span class="line">        595</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        147,</span><br><span class="line">        -13,</span><br><span class="line">        608</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        148,</span><br><span class="line">        -13,</span><br><span class="line">        618</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        149,</span><br><span class="line">        -13,</span><br><span class="line">        631</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        151,</span><br><span class="line">        -14,</span><br><span class="line">        644</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        152,</span><br><span class="line">        -14,</span><br><span class="line">        664</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        153,</span><br><span class="line">        -14,</span><br><span class="line">        673</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        155,</span><br><span class="line">        -14,</span><br><span class="line">        694</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        156,</span><br><span class="line">        -14,</span><br><span class="line">        706</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        157,</span><br><span class="line">        -14,</span><br><span class="line">        721</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        158,</span><br><span class="line">        -14,</span><br><span class="line">        731</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        159,</span><br><span class="line">        -14,</span><br><span class="line">        742</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        160,</span><br><span class="line">        -14,</span><br><span class="line">        759</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        161,</span><br><span class="line">        -14,</span><br><span class="line">        774</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        162,</span><br><span class="line">        -14,</span><br><span class="line">        799</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        163,</span><br><span class="line">        -14,</span><br><span class="line">        815</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        164,</span><br><span class="line">        -14,</span><br><span class="line">        839</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        165,</span><br><span class="line">        -14,</span><br><span class="line">        853</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        166,</span><br><span class="line">        -14,</span><br><span class="line">        870</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        167,</span><br><span class="line">        -14,</span><br><span class="line">        899</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        168,</span><br><span class="line">        -14,</span><br><span class="line">        920</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        169,</span><br><span class="line">        -14,</span><br><span class="line">        940</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        170,</span><br><span class="line">        -14,</span><br><span class="line">        956</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        171,</span><br><span class="line">        -14,</span><br><span class="line">        977</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        172,</span><br><span class="line">        -14,</span><br><span class="line">        998</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        173,</span><br><span class="line">        -14,</span><br><span class="line">        1106</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        174,</span><br><span class="line">        -14,</span><br><span class="line">        1129</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        175,</span><br><span class="line">        -14,</span><br><span class="line">        1182</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        175,</span><br><span class="line">        -13,</span><br><span class="line">        1191</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def show_plt():</span><br><span class="line">    &quot;&quot;&quot;遍历并绘制五组轨迹数据&quot;&quot;&quot;</span><br><span class="line">    for i in range(1, 6):</span><br><span class="line">        trail_list = eval(f&quot;trail_&#123;i&#125;&quot;)  # 动态获取不同轨迹变量</span><br><span class="line">        print(f&quot;trail_&#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line">        # 初始化 X, Y, T 轴数据列表</span><br><span class="line">        x_trail = []</span><br><span class="line">        y_trail = []</span><br><span class="line">        t_trail = []</span><br><span class="line"></span><br><span class="line">        # 遍历单条轨迹中的所有点</span><br><span class="line">        for trail in trail_list:</span><br><span class="line">            x, y, t = trail  # 分别解包 x, y, t 坐标值</span><br><span class="line">            x_trail.append(x)</span><br><span class="line">            y_trail.append(y)</span><br><span class="line">            t_trail.append(t)</span><br><span class="line"></span><br><span class="line">        # 打印 X 轴变化差异</span><br><span class="line">        print(np.diff(x_trail))</span><br><span class="line">        plt.plot(t_trail, x_trail)  # 绘制 T-X 曲线</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"># show_plt()</span><br><span class="line"></span><br><span class="line">def easeOutQuint(x):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    缓动函数：用来生成平滑的运动曲线。</span><br><span class="line">    公式：f(x) = 1 - (1 - x)^5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return 1 - math.pow(1 - x, 5)</span><br><span class="line"></span><br><span class="line">def get_trail(move_distance, show=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据传入的距离生成模拟的轨迹数据。</span><br><span class="line">    :param move_distance: 运动的距离</span><br><span class="line">    :param show: 是否展示轨迹波动曲线</span><br><span class="line">    :return: 包含 [x, y, t] 坐标的轨迹列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __set_pt_time(_dist):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        计算每个轨迹点的时间，并随机生成运动和停止阶段的时间点。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if _dist &lt; 100:</span><br><span class="line">            __need_time = int(random.uniform(500, 1500))  # 短距离所需时间</span><br><span class="line">        else:</span><br><span class="line">            __need_time = int(random.uniform(1000, 2000))  # 长距离所需时间</span><br><span class="line"></span><br><span class="line">        __end_pt_time = []  # 结束阶段的时间点列表</span><br><span class="line">        __move_pt_time = []  # 运动阶段的时间点列表</span><br><span class="line">        __pos_z = []  # 所有时间点的最终列表</span><br><span class="line"></span><br><span class="line">        # 计算运动阶段所需时间</span><br><span class="line">        total_move_time = __need_time * random.uniform(0.8, 0.9)</span><br><span class="line">        start_point_time = random.uniform(110, 200)  # 起始点时间</span><br><span class="line">        __start_pt_time = [int(start_point_time)]  # 起始阶段时间列表</span><br><span class="line"></span><br><span class="line">        sum_move_time = 0  # 运动时间累计</span><br><span class="line"></span><br><span class="line">        _tmp_total_move_time = total_move_time</span><br><span class="line">        while True:</span><br><span class="line">            delta_time = random.uniform(15, 20)  # 随机时间间隔</span><br><span class="line">            if _tmp_total_move_time &lt; delta_time:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            sum_move_time += delta_time</span><br><span class="line">            _tmp_total_move_time -= delta_time</span><br><span class="line">            __move_pt_time.append(int(start_point_time + sum_move_time))</span><br><span class="line"></span><br><span class="line">        # 将剩余的运动时间添加为最后一个点时间</span><br><span class="line">        last_pt_time = __move_pt_time[-1]</span><br><span class="line">        __move_pt_time.append(int(last_pt_time + _tmp_total_move_time))</span><br><span class="line"></span><br><span class="line">        # 计算停止阶段的时间点</span><br><span class="line">        sum_end_time = start_point_time + total_move_time</span><br><span class="line">        other_point_time = __need_time - sum_end_time</span><br><span class="line">        end_first_ptime = other_point_time / 2</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            delta_time = random.uniform(110, 200)</span><br><span class="line">            if end_first_ptime - delta_time &lt;= 0:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            end_first_ptime -= delta_time</span><br><span class="line">            sum_end_time += delta_time</span><br><span class="line">            __end_pt_time.append(int(sum_end_time))</span><br><span class="line"></span><br><span class="line">        __end_pt_time.append(int(sum_end_time + (other_point_time / 2 + end_first_ptime)))</span><br><span class="line"></span><br><span class="line">        # 合并所有时间点</span><br><span class="line">        __pos_z.extend(__start_pt_time)</span><br><span class="line">        __pos_z.extend(__move_pt_time)</span><br><span class="line">        __pos_z.extend(__end_pt_time)</span><br><span class="line"></span><br><span class="line">        return __pos_z</span><br><span class="line"></span><br><span class="line">    def __get_pos_y(point_count):</span><br><span class="line">        &quot;&quot;&quot;生成 Y 轴的轨迹点，用于模拟垂直方向的随机运动&quot;&quot;&quot;</span><br><span class="line">        _pos_y = []</span><br><span class="line">        start_y = random.randint(-1, 1)  # 起始 Y 坐标</span><br><span class="line">        end_y = random.randint(-13, -5)  # 结束 Y 坐标</span><br><span class="line">        y_values = np.linspace(start_y, end_y, point_count)  # 在起始和结束之间均匀分布</span><br><span class="line"></span><br><span class="line">        for val in y_values:</span><br><span class="line">            _pos_y.append(int(val))</span><br><span class="line"></span><br><span class="line">        return _pos_y</span><br><span class="line"></span><br><span class="line">    # 获取时间列表和轨迹长度</span><br><span class="line">    time_list = __set_pt_time(move_distance)</span><br><span class="line">    trail_length = len(time_list)</span><br><span class="line"></span><br><span class="line">    # 根据缓动函数生成 X 轴轨迹</span><br><span class="line">    t = np.linspace(-0.5, 1, trail_length)  # 时间范围</span><br><span class="line">    mult = move_distance / 7.59375  # 距离缩放系数</span><br><span class="line">    x = [int(mult * (easeOutQuint(i) + 6.59375)) for i in t]  # 计算 X 坐标</span><br><span class="line"></span><br><span class="line">    # 生成 Y 轴轨迹</span><br><span class="line">    y = __get_pos_y(trail_length)</span><br><span class="line"></span><br><span class="line">    # 添加高斯噪声，模拟波动</span><br><span class="line">    delta_pt = abs(np.random.normal(scale=3, size=trail_length))</span><br><span class="line">    for index in range(len(delta_pt)):</span><br><span class="line">        change_x = int(x[index] + delta_pt[index])</span><br><span class="line">        if index + 1 &lt; trail_length and x[index + 1] &gt; change_x:</span><br><span class="line">            x[index] = change_x</span><br><span class="line"></span><br><span class="line">    # 如果需要展示轨迹波动图</span><br><span class="line">    if show:</span><br><span class="line">        delta_t = [i for i in range(trail_length)]</span><br><span class="line">        plt.plot(delta_t, delta_pt, color=&#x27;green&#x27;)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    # 打印轨迹的总位移</span><br><span class="line">    print(x[-1] - x[0])</span><br><span class="line"></span><br><span class="line">    # 返回轨迹结果 [x, y, t]</span><br><span class="line">    result = [[x[i], y[i], time_list[i]] for i in range(trail_length)]</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def showeaseOutQuint(distance):</span><br><span class="line">    &quot;&quot;&quot;绘制缓动函数曲线，展示距离随时间变化的轨迹&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def func(x):</span><br><span class="line">        return 1 - pow(1 - x, 5) + 6.59375</span><br><span class="line"></span><br><span class="line">    print(func(-0.5), func(1))  # 打印函数在边界点的值</span><br><span class="line"></span><br><span class="line">    # 生成曲线数据</span><br><span class="line">    x = np.linspace(-0.5, 1, 70)</span><br><span class="line">    y = [distance / 7.59375 * func(i) for i in x]</span><br><span class="line"></span><br><span class="line">    # 加入随机波动</span><br><span class="line">    delta_pt = abs(np.random.normal(scale=1.1, size=70))</span><br><span class="line">    for index in range(len(delta_pt)):</span><br><span class="line">        change_y = int(x[index] + delta_pt[index])</span><br><span class="line">        if index + 1 &lt; 70 and y[index + 1] &gt; change_y:</span><br><span class="line">            y[index] += change_y</span><br><span class="line"></span><br><span class="line">    # 绘制曲线</span><br><span class="line">    t = np.linspace(100, 1200, 70)</span><br><span class="line">    plt.plot(t, y)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 示例：生成随机距离的轨迹并打印</span><br><span class="line">    distance = 100</span><br><span class="line">    result = get_trail(random.randint(100, 200), False)</span><br><span class="line">    print(result)</span><br><span class="line">    &quot;&quot;&quot;        </span><br><span class="line">    1. 收集轨迹</span><br><span class="line">    2. 画出轨迹图像 找缓动函数相同形状</span><br><span class="line">    3. 绘制缓动函数 找到符合形状的作用域</span><br><span class="line">    4. 找到作用域内最大值 最小值 上下移动 *距离系数</span><br><span class="line">    5. 替换时间（t）轴为自己的</span><br><span class="line">    6. 高斯函数增加波动</span><br><span class="line">    7. 细节修改 x轴 t轴 np.diff对比</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>轨迹生成算法1：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def get_slide_track1(self, distance):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据滑动距离生成滑动轨迹</span><br><span class="line">    :param distance: 需要滑动的距离</span><br><span class="line">    :return: 滑动轨迹&lt;type &#x27;list&#x27;&gt;: [[x,y,t], ...]</span><br><span class="line">        x: 已滑动的横向距离</span><br><span class="line">        y: 已滑动的纵向距离, 除起点外, 均为0</span><br><span class="line">        t: 滑动过程消耗的时间, 单位: 毫秒</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __ease_out_expo(sep):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        缓动函数 easeOutExpo</span><br><span class="line">        参考：https://easings.net/zh-cn#easeOutExpo</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if sep == 1:</span><br><span class="line">            return 1</span><br><span class="line">        else:</span><br><span class="line">            return 1 - pow(2, -10 * sep)</span><br><span class="line"></span><br><span class="line">    if not isinstance(distance, int) or distance &lt; 0:</span><br><span class="line">        raise ValueError(f&quot;distance类型必须是大于等于0的整数: distance: &#123;distance&#125;, type: &#123;type(distance)&#125;&quot;)</span><br><span class="line">    # 初始化轨迹列表</span><br><span class="line">    slide_track = [</span><br><span class="line">        [random.randint(-50, -10), random.randint(-50, -10), 0],</span><br><span class="line">        [0, 0, 0],</span><br><span class="line">    ]</span><br><span class="line">    # 共记录count次滑块位置信息</span><br><span class="line">    count = 30 + int(distance / 2)</span><br><span class="line">    # 初始化滑动时间</span><br><span class="line">    t = random.randint(50, 100)</span><br><span class="line">    # 记录上一次滑动的距离</span><br><span class="line">    _x = 0</span><br><span class="line">    _y = 0</span><br><span class="line">    for i in range(count):</span><br><span class="line">        # 已滑动的横向距离</span><br><span class="line">        x = round(__ease_out_expo(i / count) * distance)</span><br><span class="line">        # 滑动过程消耗的时间</span><br><span class="line">        t += random.randint(10, 20)</span><br><span class="line">        if x == _x:</span><br><span class="line">            continue</span><br><span class="line">        slide_track.append([x, _y, t])</span><br><span class="line">        _x = x</span><br><span class="line">    slide_track.append(slide_track[-1])</span><br><span class="line"></span><br><span class="line">    logger.info(f&quot;生成轨迹：&#123;slide_track&#125;&quot;)</span><br><span class="line">    return slide_track</span><br></pre></td></tr></table></figure><ul><li><strong>轨迹生成算法2：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def get_slide_track2(self, x):</span><br><span class="line">    # 初始化轨迹列表</span><br><span class="line">    slide_track = [</span><br><span class="line">        [random.randint(-50, -20), random.randint(-50, -10), 0],</span><br><span class="line">        [0, 0, 0],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    if x &lt; 100:</span><br><span class="line">        move_section = 1  # 如果移动距离小于100 那么move次数为x加上 7到20之间的数</span><br><span class="line">    else:</span><br><span class="line">        move_section = 2  # 如果移动距离小于100 那么move次数为x加上 2乘 7到20之间的数</span><br><span class="line"></span><br><span class="line">    up_down = random.randint(0, 1)  # 确定一个方向 x大于0或x小于0</span><br><span class="line">    y = 0  # 数组的y值</span><br><span class="line">    time = random.randint(0, 10)  # 初始时间 即为第二个数组的时间  后续时间累加操作就可以了</span><br><span class="line">    count = 0</span><br><span class="line">    flag = 0</span><br><span class="line">    repetition = int(x / 4)  # 重复x出现的个数</span><br><span class="line">    frist_count = random.randint(6, 10)  # 前面y为0的数组个数</span><br><span class="line">    for i in range(x * random.randint(move_section * 7, move_section * 21)):  # move_section 在这里起作用</span><br><span class="line">        if i + 1 &gt; x:  # 如果i+1要等于x 或者小于x 但这里基本上都是等于x</span><br><span class="line">            break</span><br><span class="line">        if up_down == 0:  # up_down如果大于0 那么这个轨迹就是y增轨迹</span><br><span class="line">            if i &gt; frist_count:</span><br><span class="line">                if count == 0:</span><br><span class="line">                    y += random.randint(0, 1)</span><br><span class="line">                    count += 1</span><br><span class="line">                if flag &gt; random.randint(8, 10):</span><br><span class="line">                    count = 0</span><br><span class="line">                    flag = 0</span><br><span class="line">                if i + 1 &gt; int(x / 5) * 4:</span><br><span class="line">                    time += random.randint(20, 70)</span><br><span class="line">                elif i + 1 &gt; x - 3:</span><br><span class="line">                    time += random.randint(80, 180)</span><br><span class="line">                else:</span><br><span class="line">                    time += random.randint(0, 5)</span><br><span class="line">                slide_track.append([i + 1, y, time])</span><br><span class="line">                flag += 1</span><br><span class="line">                if random.randint(0, 1):</span><br><span class="line">                    if repetition:</span><br><span class="line">                        slide_track.append([i + 1, y, time + random.randint(0, 3)])</span><br><span class="line">                        flag += 1</span><br><span class="line">                        repetition -= 1</span><br><span class="line">            else:  # 前面几个数组y都为0</span><br><span class="line">                time += random.randint(0, 5)</span><br><span class="line">                slide_track.append([i + 1, y, time])</span><br><span class="line">                if random.randint(0, 1):</span><br><span class="line">                    if repetition:</span><br><span class="line">                        slide_track.append([i + 1, y, time + random.randint(0, 3)])</span><br><span class="line">                        repetition -= 1</span><br><span class="line"></span><br><span class="line">        if up_down == 1:  # up_down如果小于0 那么这个轨迹就是y减轨迹</span><br><span class="line">            if i &gt; frist_count:</span><br><span class="line">                if count == 0:</span><br><span class="line">                    y -= random.randint(0, 1)</span><br><span class="line">                    count += 1</span><br><span class="line">                if flag &gt; random.randint(8, 10):</span><br><span class="line">                    count = 0</span><br><span class="line">                    flag = 0</span><br><span class="line">                if i + 1 &gt; int(x / 5) * 4:</span><br><span class="line">                    time += random.randint(7, 40)</span><br><span class="line">                elif i + 1 &gt; x - 3:</span><br><span class="line">                    time += random.randint(80, 180)</span><br><span class="line">                else:</span><br><span class="line">                    time += random.randint(0, 5)</span><br><span class="line">                slide_track.append([i + 1, y, time])</span><br><span class="line">                flag += 1</span><br><span class="line">                if random.randint(0, 1):</span><br><span class="line">                    if repetition:</span><br><span class="line">                        slide_track.append([i + 1, y, time + random.randint(0, 3)])</span><br><span class="line">                        flag += 1</span><br><span class="line">                        repetition -= 1</span><br><span class="line">            else:</span><br><span class="line">                time += random.randint(0, 5)</span><br><span class="line">                slide_track.append([i + 1, y, time])</span><br><span class="line">                if random.randint(0, 1):</span><br><span class="line">                    if repetition:</span><br><span class="line">                        slide_track.append([i + 1, y, time + random.randint(0, 3)])</span><br><span class="line">                        repetition -= 1</span><br><span class="line"></span><br><span class="line">    print(f&quot;生成轨迹成功：&#123;slide_track&#125;\n&quot;)</span><br><span class="line">    return slide_track</span><br></pre></td></tr></table></figure><h3 id="7-验证码参数补环境思路"><a href="#7-验证码参数补环境思路" class="headerlink" title="7. 验证码参数补环境思路"></a>7. 验证码参数补环境思路</h3><blockquote><p><strong>验证码常规反反爬流程：</strong></p><ol><li>初始化一个对象</li><li>启动监听事件</li><li>滑动触发事件，执行监听事件的方法（例：往数组里 push 加密值）</li><li>滑动完将值导出</li></ol><p><strong>补环境核心思路：</strong>在定位至加密位置后，首先需要明确参数所属对象，根据参数所属对象，考虑两种黑盒调用方法</p><ol><li>直接通过 window.aaa 全局导出</li><li>通过<strong>参数所属对象</strong>导出方法，需要先定位对象开启监听鼠标事件的地方，找到对象声明的位置并断点，注入 hook 脚本 <code>Object = function()&#123;debugger;&#125;</code>（<strong>注入在方法声明之后，对象 new Object 之前</strong>），在 js 中执行监听鼠标事件代码从而开始补环境</li></ol></blockquote><ul><li><p><strong>关于 EventTarget 事件的环境：</strong></p><ul><li><p>代理器不仅仅只是可以用来代理浏览器内置对象，在补环境中遇到补对象时，想要看到对象上所需要或使用到的环境，可以直接使用代理器代理当前对象，即 <code>return new Proxy(&#123;&#125;, getObjhandler(params))</code>，以吐出当前对象身上的环境</p></li><li><p>当遇到 addEventListener、removeEventListener 和 dispatchEvent API 时，应该考虑在当前对象上补 EventTarget 原型，同时代理当前对象，即可吐出事件相关的环境（完整执行代码，即可在<strong>事件保存对象</strong>中获取到当前环境中监听的具体事件）</p></li><li><p>需要按照<strong>事件触发顺序</strong>进行模拟，在浏览器中通过手动对<strong>这一组事件</strong>添加监听事件，并触发事件，按照事件顺序在本地模拟事件对象，并进行代理后在对应对象上触发事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;mousedown&quot;, function (e) &#123; console.log(e.type) &#125;);</span><br><span class="line">document.addEventListener(&quot;mousemove&quot;, function (e) &#123; console.log(e.type) &#125;);</span><br><span class="line">document.addEventListener(&quot;mouseup&quot;, function (e) &#123; console.log(e.type) &#125;);</span><br><span class="line"></span><br><span class="line">var xxx1 = &#123;</span><br><span class="line">    type: &quot;mousedown&quot;,</span><br><span class="line">    clientX: 0,</span><br><span class="line">    clientY: 0</span><br><span class="line">&#125;</span><br><span class="line">var xxx2 = &#123;</span><br><span class="line">    type: &quot;mousemove&quot;,</span><br><span class="line">    clientX: 0,</span><br><span class="line">    clientY: 0</span><br><span class="line">&#125;</span><br><span class="line">var xxx3 = &#123;</span><br><span class="line">    type: &quot;mouseup&quot;,</span><br><span class="line">    clientX: 0,</span><br><span class="line">    clientY: 0</span><br><span class="line">&#125;</span><br><span class="line">xxx1 = new Proxy(xxx1, getObjhandler(&quot;mousedown&quot;))</span><br><span class="line">xxx2 = new Proxy(xxx2, getObjhandler(&quot;mousemove&quot;))</span><br><span class="line">xxx3 = new Proxy(xxx3, getObjhandler(&quot;mouseup&quot;))</span><br><span class="line">myslideVerify.dispatchEvent(xxx1)</span><br><span class="line">myslideVerify.dispatchEvent(xxx2)</span><br><span class="line">myslideVerify.dispatchEvent(xxx3)</span><br></pre></td></tr></table></figure></li><li><p>最后一步，校验完轨迹后面还会有其他环境监测，所以需要去浏览器拿一套真实轨迹，暂时模拟，<strong>循环触发在滑块对象上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// https://www.geetest.com/demo/slide-float.html</span><br><span class="line">dom = document.querySelector(&#x27;.geetest_slider_button&#x27;);</span><br><span class="line">track = [];</span><br><span class="line">dom.addEventListener(&quot;mousedown&quot;, function (e) &#123;</span><br><span class="line">    track.push(&#123;</span><br><span class="line">        type: e.type,</span><br><span class="line">        clientX: e.clientX,</span><br><span class="line">        clientY: e.clientY</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">dom.addEventListener(&quot;mousemove&quot;, function (e) &#123;</span><br><span class="line">    track.push(&#123;</span><br><span class="line">        type: e.type,</span><br><span class="line">        clientX: e.clientX,</span><br><span class="line">        clientY: e.clientY</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">dom.addEventListener(&quot;mouseup&quot;, function (e) &#123;</span><br><span class="line">    track.push(&#123;</span><br><span class="line">        type: e.type,</span><br><span class="line">        clientX: e.clientX,</span><br><span class="line">        clientY: e.clientY</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;获取轨迹数组:&quot;, track);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>时间间隔处理：</strong>在 dispatchEvent 触发事件前，通过 hook 修改 getTime 的返回值，在<strong>循环触发事件中的每次触发前</strong>加入随机时间间隔字符串并返回修改后的时间戳返回值，从而伪造出滑块滑动的时间间隔</p><ol><li><strong>new Date().getTime()</strong> 可以通过 hook Date 原型上的 getTime 函数：<code>batchHook(Date, [&#39;getTime&#39;])</code></li><li><strong>+ new Date()</strong> 可以通过 hook Date 原型上的 valueOf 函数：<code>batchHook(Date, [&#39;valueOf&#39;])</code></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var _getTime = Date.prototype.getTime;</span><br><span class="line">// Date.prototype.getTime = function () &#123;</span><br><span class="line">//   var result = _getTime.apply(this, arguments)</span><br><span class="line">//   console.log(result)</span><br><span class="line">//   return result</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">function dtaslide(trail) &#123;</span><br><span class="line">  let dtaslider = new DTASlider;</span><br><span class="line">  dtaslider.start();</span><br><span class="line">  let startTime = new Date().getTime();</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; trail.length; i++) &#123;</span><br><span class="line">    let mytime = trail[i].time</span><br><span class="line">    Date.prototype.getTime = function () &#123;</span><br><span class="line">      var result = startTime + mytime</span><br><span class="line">      console.log(result)</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">    sliderDiv.dispatchEvent(trail[i])</span><br><span class="line">  &#125;</span><br><span class="line">  Date.prototype.getTime = _getTime;</span><br><span class="line">  return window.result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、验证码逆向实战"><a href="#八、验证码逆向实战" class="headerlink" title="八、验证码逆向实战"></a>八、验证码逆向实战</h2><h3 id="1-极验3代滑块"><a href="#1-极验3代滑块" class="headerlink" title="1. 极验3代滑块"></a>1. 极验3代滑块</h3><blockquote><p><strong>请求接口逻辑分析（<a class="link"   href="https://www.geetest.com/demo/slide-float.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong></p><ol><li><strong>register-slide：</strong>携带时间戳，返回 challenge 和 gt 值</li><li><strong>gettype.php：</strong>携带 gt 值，返回一堆 js 文件地址</li><li><strong>get.php：</strong>携带 <strong>w1</strong>、challenge、gt 参数，返回带有 c 和 s 的数据</li><li><strong>ajax.php：</strong>携带 <strong>w2</strong>、challenge、gt 参数，返回滑块类型</li><li><strong>get.php：</strong>携带 challenge、gt 等多个参数，返回重要数据，包含新的 challenge、s 值和图片请求地址</li><li><strong>ajax.php：</strong>携带 <strong>w3</strong>、新challenge、gt 参数，返回验证成功数据</li></ol><p><strong>注意：极验必须严格按顺序请求每一次接口，哪怕返回的数据没有用，否则后续请求就会有响应错误的问题</strong></p><p><strong><span style="color:red;">逆向 w 值：极验 3 代中，需逆向的 w1 和 w2 参数，可置空，可固定，也可能要 js 生成，具体网站具体分析</span></strong></p></blockquote><ul><li><p><strong>突破策略：</strong></p><ol><li>验证码存在多个请求接口，<strong>在最终进行验证的接口载荷中通常存在一个需要逆向的加密验证 w 参数</strong>，可以通过启动器定位文件，搜索关键字 “w”，一般需要<strong>对源文件 AST 普通解混淆</strong>后替换文件，定位加密位置</li><li>逆向参数通常采用<strong>全扣代码补环境</strong>，<strong>所有方法都可以通过全局对象导出（不能直接导出的，可能是因为导出的对象小了，要往大里导，或者需要细扣代码）</strong>，也可能是因为<strong>存在环境检测</strong>，主要使用脚本补环境，因为环境不多，也可以使用 v_jstools 工具生成临时环境</li><li>其中 w3 参数中的滑块移动距离、轨迹加密参数，都是栈堆的上一帧传过来的，需要在上一个栈分析</li><li>对于携带 callback 载荷数据的接口返回的 jsonp 格式数据，<strong>一定不要为了方便获取 json 数据直接去掉 callback 参数，因为 callback 也是验证参数之一</strong>，使用正则表达式即可</li></ol></li><li><p><strong>细节避坑总结：</strong></p><ol><li><strong>关于 challenge 和 s 值：</strong>在第 2 次请求 get.php 接口后，响应会返回新的 challenge 值和 s 值，在后续请求 ajax.php 校验接口时，需要携带的 ch 值和逆向 w3 参数中所使用到的所有 ch 值，都必须是最新的</li><li><strong>关于 w3 中的 passtime 数据：</strong>不管是极验几代，逆向 w 时都有个 passtime 参与计算。这个值有两种情况：如果是滑块，则是滑动所用时间，即轨迹的最后一个时间值 **<code>track[track.length - 1][2]</code>**；除了滑块的其他情况，可以写死，也可以随机生成一个值  <strong><code>Math.floor((Math.random()*500) + 4000)</code></strong></li><li><strong>关于 w 中的随机变化字符串：</strong>不管是极验几代，都会有一个 16 位随机字符串参与了 w 的加密计算，这个随机字符串一般都会用到两次，这两次要保证是一样的才行</li><li><strong>关于缺口识别距离：</strong>滑块距离通常不是从最左边开始的，前面会有几个像素的空白距离，所以<strong>实际 distance &#x3D; 缺口识别距离 - 空白距离</strong>（要不要减去这个值、减去多少，具体网址具体分析）</li><li><strong>关于时间间隔：</strong>三代里面，整个流程走得太快了也不行，需要在生成 w 值之后，随机停留个 2 秒左右，例如三代的点选（文字点选、图标点选、语序点选、空间推理）</li><li><strong>关于 w2 中的 captcha_token 值：</strong>如果替换文件被检测出来，则返回的 captcha_token 是异常的，会导致一直验证失败</li></ol></li><li><p><strong>极验常见错误返回信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// challenge 不对</span><br><span class="line">geetest_xxxxxxxxxxxxx(&#123;&quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;illegal challenge&quot;, &quot;user_error&quot;: &quot;网络不给力&quot;, &quot;error_code&quot;: &quot;error_23&quot;&#125;)</span><br><span class="line">// w 生成不对</span><br><span class="line">geetest_xxxxxxxxxxxxx(&#123;&quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;param decrypt error&quot;, &quot;user_error&quot;: &quot;网络不给力&quot;, &quot;error_code&quot;: &quot;error_03&quot;&#125;)</span><br><span class="line">// 滑动验证没有轨迹</span><br><span class="line">geetest_xxxxxxxxxxxxx(&#123;&quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;not proof&quot;, &quot;user_error&quot;: &quot;网络不给力&quot;, &quot;error_code&quot;: &quot;error_21&quot;&#125;)</span><br><span class="line">// 轨迹、缺口距离、参数问题</span><br><span class="line">geetest_xxxxxxxxxxxxx(&#123;&quot;success&quot;: 0, &quot;message&quot;: &quot;fail&quot;&#125;)  // 缺口距离，轨迹生成问题</span><br><span class="line">geetest_xxxxxxxxxxxxx(&#123;&quot;success&quot;: 0, &quot;message&quot;: &quot;forbidden&quot;&#125;)  // 其余接口 w 参数问题</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-极验3代点选"><a href="#2-极验3代点选" class="headerlink" title="2. 极验3代点选"></a>2. 极验3代点选</h3><blockquote><p><strong>点选的请求接口逻辑：</strong>与滑块一致</p><p><strong>点选的核心处理逻辑：</strong></p><ol><li>通过云码识别验证码，得到文字坐标信息，并可以通过多组坐标变化数据，利用 chatgpt 生成坐标算法</li><li>w3 参数的逆向中，主要是对验证码图片中的文字坐标的验证，其余鼠标移动轨迹和鼠标点击的坐标信息均未验证，使用一组固定的真实数据模拟即可</li></ol><p><strong>确认点击的初始坐标位置：</strong>事件监听器断点 –&gt; 鼠标 –&gt; click，断点中 offsetX 和 offsetY 即为点击坐标信息</p></blockquote><ul><li><p><strong>细节避坑总结：</strong></p><ol><li><p><strong>关于时间间隔：</strong>三代里面，整个流程走得太快了也不行，需要在生成 w 值之后，随机停留个 2 秒左右，例如三代的点选（文字点选、图标点选、语序点选、空间推理），会返回以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geetest_xxxxxx(&#123;&quot;status&quot;: &quot;success&quot;, &quot;data&quot;: &#123;&quot;result&quot;: &quot;fail&quot;, &quot;msg&quot;: [&quot;duration short&quot;]&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="九、常用-Hook-脚本"><a href="#九、常用-Hook-脚本" class="headerlink" title="九、常用 Hook 脚本"></a>九、常用 Hook 脚本</h2><blockquote><p><strong>常用 Hook 脚本：<a class="link"   href="https://www.cnblogs.com/xiaoweigege/p/14954648.html"  target="_blank" rel="noopener">https://www.cnblogs.com/xiaoweigege/p/14954648.html<i class="fas fa-external-link-alt"></i></a></strong></p><p><strong>什么是Hook技术？</strong></p><ul><li>Hook（钩子）是一种软件开发中使用的技术，其目的是截获、修改或扩展程序或系统的行为，优点是可以在不修改原始代码的情况下改变程序的行为（<strong>js逆向中通过在关键点插入钩子，进行代码调试或分析</strong>）</li></ul><p><strong>Hook技术实现的必要条件：</strong></p><ol><li>客户端拥有 JavaScript 的最高解释权，可以控制 js 的执行环境，拥有运行时（动态）修改代码的能力</li><li>JavaScript 的弱类型特性，其中 <strong>类型间的隐式转换</strong> 和 <strong>变量重定义</strong> 的特性都为 Hook 提供了灵活性</li></ol><p><strong>注意：只有当被 Hook 函数和无限 debugger 在同一个作用域时，才能 Hook 成功并访问到函数的局部变量</strong></p><p><strong>作用（js 逆向中）：</strong>同DOM、XHR断点一样是用于确定加密位置，但使用 hook 调试可能得到的位置更近</p></blockquote><h3 id="1-hook-Storage"><a href="#1-hook-Storage" class="headerlink" title="1. hook Storage"></a>1. hook Storage</h3><ul><li><strong>对 Storage 对象的 setItem 方法进行 Hook：</strong>包括 localStorage 和 sessionStorage</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let old_setItem = Storage.prototype.setItem;</span><br><span class="line">Storage.prototype.setItem = function (key, value) &#123;</span><br><span class="line">    console.log(this, key, value);</span><br><span class="line">    debugger;</span><br><span class="line">    return old_setItem.call(this, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-hook-eval"><a href="#2-hook-eval" class="headerlink" title="2. hook eval"></a>2. hook eval</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let old_eval = eval;</span><br><span class="line">eval = function (code) &#123;</span><br><span class="line">    console.log(&quot;执行代码:&quot;, code);</span><br><span class="line">    debugger;</span><br><span class="line">    return old_eval(code);</span><br><span class="line">&#125;</span><br><span class="line">let oldtostr = Function.prototype.toString;</span><br><span class="line">Function.prototype.toString = function () &#123;</span><br><span class="line">    res = oldtostr.call(this);</span><br><span class="line">    if (this.name == &#x27;eval&#x27;) &#123;</span><br><span class="line">        console.log(&quot;原始：&quot; + this.name + &#x27; --&gt; toString：&#x27; + res);</span><br><span class="line">        return &quot;function eval() &#123; [native code] &#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-hook-全局属性"><a href="#3-hook-全局属性" class="headerlink" title="3. hook 全局属性"></a>3. hook 全局属性</h3><ul><li><strong>思路：</strong>对于一些将加密参数挂载到 window 全局对象上的属性，可以直接通过 hook 属性定义实现快速定位加密堆栈</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var _xxx = window.xxx;</span><br><span class="line">    Object.defineProperty(window, &#x27;xxx&#x27;, &#123;</span><br><span class="line">        set: function (new_xxx) &#123;</span><br><span class="line">            debugger;</span><br><span class="line">            _xxx = new_xxx;</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return _xxx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="4-hook-XHR-open"><a href="#4-hook-XHR-open" class="headerlink" title="4. hook XHR open"></a>4. hook XHR open</h3><ul><li><strong>拦截方法：<code>window.XMLHttpRequest.prototype.open(method, url, async)</code></strong><ul><li><strong>作用：</strong>是 XMLHttpRequest 对象的原型链上的方法之一，用于初始化一个 XMLHttpRequest 请求</li><li><strong>参数method：</strong>表示 HTTP 请求的方法，如 “GET”、”POST” 等</li><li><strong>参数url：</strong>请求的 URL 地址</li><li><strong>参数async：</strong>是否使用异步方式发送请求，默认为 true（即异步）</li></ul></li><li><strong>查询字符串参数被加密：</strong>由于查询字符串参数是网址 URL 的一部分，所以初始化 XMLHttpRequest 请求时，参数 url 中一定会包含这个被加密的查询字符串参数（<a class="link"   href="https://www.qimai.cn"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li><li><strong>apply作用：</strong>调用原始的 open 方法，并且确保在特定的上下文（window.XMLHttpRequest.prototype）中执行，即确保了调用的是期望的函数，是自己定义的open，而不是其他可能存在的同名方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var open = window.XMLHttpRequest.prototype.open;</span><br><span class="line">    window.XMLHttpRequest.prototype.open = function (method, url, async) &#123;</span><br><span class="line">        if (url.indexOf(&#x27;analysis&#x27;) != -1) &#123;</span><br><span class="line">            debugger</span><br><span class="line">        &#125;</span><br><span class="line">        return open.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="5-hook-json"><a href="#5-hook-json" class="headerlink" title="5. hook json"></a>5. hook json</h3><blockquote><p><strong>原理：在 HTTP 请求和响应中，数据通常以字符串的形式传输</strong></p><ul><li><p><strong>JSON.stringify()：</strong>将 JavaScript 对象转换为 JSON 字符串。对于 POST 请求而言，携带的参数通常会被转换为字符串，并放置在请求体中，将其作为请求体的一部分发送给服务器，这个过程被称为<strong>序列化</strong>，所以一定会<strong>在发送请求前</strong>将携带的参数对象转换为字符串</p></li><li><p><strong>JSON.parse()：</strong>将 JSON 字符串解析为 JavaScript 对象。<strong>服务器所返回是加密的字符串数据</strong>，所以一定需要<strong>在接受响应数据后</strong>对数据进行解密，再将解密后的字符串解析为 js 对象，目的是确保在客户端中以 js 对象的形式可用，以便在客户端中展示</p></li></ul></blockquote><ul><li><p><strong>拦截方法：<code>JSON.parse()</code>、<code>JSON.stringify()</code></strong></p></li><li><p><strong>响应数据被加密：</strong></p><ol><li>通过 Hook 技术拦截 <strong><code>JSON.parse</code></strong> 的调用，监视 <strong><code>JSON.parse()</code></strong> 的参数即加密数据的变化，<strong>既调试至明文数据出现时向上跟一个栈后分析代码，也可以调试至密文数据出现时向下调试</strong>（<a class="link"   href="https://fanyi.youdao.com/index.html#/"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li><li>通过 <strong>XHR 断点定位</strong>解密位置，原理是因为在 ajax 调用时，发送请求 send 之前，会通过 <strong>success: 、.then、done</strong> 方法设置请求成功后的回调函数，则可以定位到数据解密的位置（<a class="link"   href="https://www.endata.com.cn/BoxOffice/BO/Month/oneMonth.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li><li><strong>响应数据加密只可能通过对称加密算法或非对称加密算法，</strong>因为哈希算法是不可逆的，只有对称与非对称算法是可逆的，所以可以通过**搜索关键字 <code>decrypt</code>、<code>decrypt(</code>、<code>des</code> <strong>定位解密，</strong><code>encrypt</code>**定位加密</li></ol></li><li><p><strong>请求载荷参数加密：</strong>通过 Hook 技术拦截 <strong><code>JSON.stringify</code></strong> 的调用，监视 <strong><code>JSON.stringify()</code></strong> 的参数即加密数据的变化，向上跟栈找到参数加密的位置，<strong>在参数生成的位置打上断点调试</strong>（<a class="link"   href="https://www.hh1024.com/#/ranklist/ranklist"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var _parse = JSON.parse;</span><br><span class="line">    JSON.parse = function (params) &#123;</span><br><span class="line">        console.log(&quot;解析数据:&quot;, params);</span><br><span class="line">        // 这里可以添加其他逻辑比如 debugger</span><br><span class="line">        debugger</span><br><span class="line">        return _parse(params);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="6-hook-cookie"><a href="#6-hook-cookie" class="headerlink" title="6. hook cookie"></a>6. hook cookie</h3><blockquote><p><strong>注意：</strong>传统的 Hook Cookie 脚本是在 document 对象上定义 cookie 属性，<strong>但实际上 cookie 并不在 document 对象上</strong>，而是在其原型 <strong>Document.prototype</strong> 上，所以最好直接 hook 其原型上的 cookie，这样在检测 document 上的属性时不会被检测（<strong>但是这样又不能 hook 到直接在 document.cookie 上赋值的操作</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    // 保存原始的 cookie 属性描述符</span><br><span class="line">    const originalCookieDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, &#x27;cookie&#x27;);</span><br><span class="line"></span><br><span class="line">    // 重写 cookie 属性描述符</span><br><span class="line">    Object.defineProperty(Document.prototype, &#x27;cookie&#x27;, &#123;</span><br><span class="line">        configurable: true,</span><br><span class="line">        enumerable: true,</span><br><span class="line">        set: function (newCookie) &#123;</span><br><span class="line">            // 判断设置的 cookie 中是否存在目标值的键</span><br><span class="line">            debugger;</span><br><span class="line">            // 调用原始的 set 方法</span><br><span class="line">            originalCookieDescriptor.set.call(this, newCookie);</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            // 返回原始的 get 方法结果</span><br><span class="line">            return originalCookieDescriptor.get.call(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>拦截方法：<code>Object.defineProperty(obj, prop, descriptor)</code></strong><ul><li><strong>作用：</strong>用于定义或修改（替换）对象的属性，并返回此对象</li><li><strong>参数obj：</strong>目标对象</li><li><strong>参数prop：</strong>目标对象的要定义或修改的属性</li><li><strong>参数descriptor：</strong>描述符对象，可以指定属性的值、可写性等，还可以定义 setter 和 getter 方法</li></ul></li><li><strong>cookies被加密：</strong>注意 cookie 是属于 document 对象的属性，即 **<code>document.cookie</code>**。通过 Hook 技术拦截前需要先清除浏览器Cookie（<a class="link"   href="http://q.10jqka.com.cn/"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var cookie_data = document.cookie;</span><br><span class="line">    Object.defineProperty(document, &#x27;cookie&#x27;, &#123;</span><br><span class="line">        set: function (new_cookie) &#123;</span><br><span class="line">            // 判断设置的cookie中是否存在被加密值的键，存在返回下标，不存在返回-1</span><br><span class="line">            if (new_cookie.indexOf(&#x27;v&#x27;) != -1) &#123;</span><br><span class="line">                debugger</span><br><span class="line">            &#125;</span><br><span class="line">            cookie_data = new_cookie;</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return cookie_data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="7-hook-请求-响应拦截器"><a href="#7-hook-请求-响应拦截器" class="headerlink" title="7. hook 请求&#x2F;响应拦截器"></a>7. hook 请求&#x2F;响应拦截器</h3><blockquote><p><strong>引入：</strong>当通过 XHR open Hook 定位加密时，<strong>跟栈到了异步帧</strong>，此时则需要考虑通过寻找 拦截器 去定位加密</p><p><strong>调试思路：</strong></p><ol><li><strong>思路1 - 找响应拦截器：</strong>调试目的是寻找加密位置，而加密位置是在请求拦截器中，但请求拦截器又在异步中，<strong>通过 Hook XHR open 发起请求的 debugger 处开始调试，此时加密参数已经生成，说明是已经经过了请求拦截器，</strong>此时无法再通过调试进入异步代码中的请求拦截器了，但是可以根据请求拦截器和响应拦截器通常<strong>成对出现</strong>的规则，通过定位响应拦截器，从而找到请求拦截器（<strong>注意并不是所有网站都有拦截器的，但是只要有拦截器，那么 Hook XHR open 并往下调试一定会经过响应拦截器</strong>）</li><li><strong>思路2 - 找请求拦截器：</strong>从异步帧的上一帧开始往下调试，此时参数还没有被加密，所以只需一步步调试就可以进入到异步代码中的请求拦截器（<strong>调试过程中时刻观察数据值是否被加密，确定加密位置</strong>）</li></ol><p><strong>js加载执行方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载js --&gt; 触发请求接口(ajax) --&gt; 构造请求对象 --&gt;【请求拦截器】--&gt; 发送XHR请求(Hook XHR open) --&gt; 返回数据 --&gt;【响应拦截器】</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>请求拦截器：</strong>在实际请求被发送之前修改请求的配置，包括添加认证信息、修改请求头、请求参数<strong>加密</strong>等</p></li><li><p><strong>响应拦截器：</strong>在接收到服务器响应后，结果返回之前修改响应的数据，包括数据格式化处理、参数<strong>解密</strong>等</p></li><li><p><strong>注意：拦截器不是 Hook 代码段，而是通过请求的 XHR open Hook 进行 debugger 调试跟栈，定位拦截器</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var axios = require(&#x27;axios&#x27;)</span><br><span class="line"></span><br><span class="line">// 请求拦截器</span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">    console.log(&#x27;请求拦截器 成功&#x27;);</span><br><span class="line">    // 加密逻辑</span><br><span class="line">    config.headers[&#x27;sign&#x27;] = &#x27;fkehdjfsdjfiowhek&#x27;;</span><br><span class="line">    return config;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    console.log(&#x27;请求拦截器 失败&#x27;);</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 响应拦截器</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">    console.log(&#x27;响应拦截器 成功&#x27;);</span><br><span class="line">    // 解密逻辑</span><br><span class="line">    return response;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    console.log(&#x27;响应拦截器 失败&#x27;);</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//发送请求</span><br><span class="line">axios.get(&#x27;http://httpbin.org/get&#x27;).then(res =&gt; console.log(res))</span><br></pre></td></tr></table></figure><h3 id="8-hook-XHR-headers"><a href="#8-hook-XHR-headers" class="headerlink" title="8. hook XHR headers"></a>8. hook XHR headers</h3><ul><li><strong>拦截方法：<code>window.XMLHttpRequest.prototype.setRequestHeader(key, value)</code></strong><ul><li><strong>作用：</strong>是 XMLHttpRequest 对象的原型链上的方法之一，用于设置 HTTP 请求的头部信息</li><li><strong>参数key：</strong>表示要设置的 HTTP 头部的名称</li><li><strong>参数value：</strong>表示要设置的 HTTP 头部的值</li></ul></li><li><strong>headers参数值被加密：注意 setRequestHeader 方法是在 open 之后、send 之前调用的</strong>（<a class="link"   href="https://www.qimai.cn"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li><li><strong>headers参数键值都被加密：</strong>由于此时参数的键名也被加密了，所以无法通过 Hook 关键字定位了，只能直接 Hook setRequestHeader，但是这将会 Hook 到全部的参数信息，可以<strong>调试至加密参数出现后再跟栈定位</strong>（也可以通过<strong>XHR断点定位</strong>加密位置，因为 <strong>setRequestHeader 方法是在 open 之后、send 之前调用的</strong>，<a class="link"   href="https://www.qcc.com/web/search?key=%E4%B8%87%E8%BE%BE%E9%9B%86%E5%9B%A2"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var org = window.XMLHttpRequest.prototype.setRequestHeader;</span><br><span class="line">    window.XMLHttpRequest.prototype.setRequestHeader = function (key, value) &#123;</span><br><span class="line">        if (key == &#x27;&#x27;) &#123;</span><br><span class="line">            debugger</span><br><span class="line">        &#125;</span><br><span class="line">        return org.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="9-快速批量-hook-碰撞"><a href="#9-快速批量-hook-碰撞" class="headerlink" title="9. 快速批量 hook 碰撞"></a>9. 快速批量 hook 碰撞</h3><blockquote><ul><li><strong>完整框架：在快速 hook 框架的基础上，实现对某些 API 批量添加 hook 方法，可以指定白名单和黑名单：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// 保护伪造函数toString</span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">    const $toString = Function.toString</span><br><span class="line">    const random_toString_symbol = Symbol(&#x27;(&#x27;.concat(&#x27;&#x27;, &#x27;)_&#x27;, (Math.random()) + &#x27;&#x27;).toString(36))</span><br><span class="line">    const myToString = function () &#123;</span><br><span class="line">        return typeof this === &#x27;function&#x27; &amp;&amp; this[random_toString_symbol] || $toString.call(this)</span><br><span class="line">    &#125;</span><br><span class="line">    function set_native(func, key, value) &#123;</span><br><span class="line">        Object.defineProperty(func, key, &#123;</span><br><span class="line">            enumerable: false,</span><br><span class="line">            configurable: true,</span><br><span class="line">            writable: true,</span><br><span class="line">            value: value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    delete Function.prototype.toString</span><br><span class="line">    set_native(Function.prototype, &quot;toString&quot;, myToString)</span><br><span class="line">    set_native(Function.prototype.toString, random_toString_symbol, &quot;function toString() &#123; [native code] &#125;&quot;)</span><br><span class="line">    globalThis.func_set_native = (func) =&gt; &#123;</span><br><span class="line">        random_toString_symbol</span><br><span class="line">        set_native(func, random_toString_symbol, `function $&#123;func.name || &#x27;&#x27;&#125;() &#123; [native code] &#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).call(this);</span><br><span class="line"></span><br><span class="line">// hook 函数实现</span><br><span class="line">Function.prototype.hook = function (</span><br><span class="line">    context = globalThis,</span><br><span class="line">    functionName,  // 匿名函数需要指定和 上下文的调用对象 一样的名称</span><br><span class="line">    onEnter = (ctx, funcname, mythis) =&gt; console.log(`【$&#123;funcname&#125;】onEnter --&gt;`, mythis, ctx.args),</span><br><span class="line">    onLeave = (retval, funcname) =&gt; console.log(`【$&#123;funcname&#125;】onLeave --&gt;`, retval),</span><br><span class="line">) &#123;</span><br><span class="line">    const targetFunction = this;</span><br><span class="line">    const originalName = targetFunction.name || functionName;</span><br><span class="line">    if (!originalName) &#123;</span><br><span class="line">        console.error(&quot;hook function name is empty!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建 hook 封装函数</span><br><span class="line">    const hookedFunction = function (...args) &#123;</span><br><span class="line">        const ctx = &#123; args &#125;;  // 参数上下文</span><br><span class="line">        onEnter(ctx, originalName, this);</span><br><span class="line"></span><br><span class="line">        // 调用原始函数并捕获返回值，这里的 this -&gt; window 全局对象</span><br><span class="line">        const retval = targetFunction.apply(this, ctx.args);</span><br><span class="line">        return onLeave(retval, originalName) || retval;  // 调用离开钩子，并检查是否更改返回值</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 将原始函数伪装成原生格式</span><br><span class="line">    Object.defineProperty(hookedFunction, &quot;name&quot;, &#123; value: originalName &#125;);</span><br><span class="line">    func_set_native(hookedFunction);</span><br><span class="line"></span><br><span class="line">    // 将 hooked 函数绑定到指定上下文</span><br><span class="line">    context[originalName] = hookedFunction;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 实现黑名单、白名单，快速 Hook 框架</span><br><span class="line">function batchHook(HookObj, WhiteList = [], BlackList = []) &#123;</span><br><span class="line">    // 确保 BlackList 和 WhiteList 是数组</span><br><span class="line">    function startHook(Descriptors, HookObj) &#123;</span><br><span class="line">        for (const descriptorsKey in Descriptors) &#123;</span><br><span class="line">            let value = Descriptors[descriptorsKey]</span><br><span class="line">            let rawFunc = value[&quot;value&quot;]</span><br><span class="line">            if (</span><br><span class="line">                typeof rawFunc === &quot;function&quot;</span><br><span class="line">                &amp;&amp; value[&quot;writable&quot;]</span><br><span class="line">                &amp;&amp; !BlackList.includes(descriptorsKey)</span><br><span class="line">                &amp;&amp; (WhiteList.length ? WhiteList.includes(descriptorsKey) : true)</span><br><span class="line">            ) &#123;</span><br><span class="line">                console.log(descriptorsKey);</span><br><span class="line">                rawFunc.hook(HookObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let HookObjDescriptors = Object.getOwnPropertyDescriptors(HookObj);</span><br><span class="line">    startHook(HookObjDescriptors, HookObj);</span><br><span class="line"></span><br><span class="line">    // 如果对象有原型链，处理原型链上的方法</span><br><span class="line">    if (HookObj.prototype) &#123;</span><br><span class="line">        let HookObjPrototypeDescriptors = Object.getOwnPropertyDescriptors(HookObj.prototype);</span><br><span class="line">        startHook(HookObjPrototypeDescriptors, HookObj.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -------- 实例测试 --------</span><br><span class="line">// batchHook(String, [&quot;fromCharCode&quot;], [&quot;toString&quot;, &quot;concat&quot;]);</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>快速 hook 框架：</strong>快速调用 hook 方法实现 hook，同时伪造函数 toString：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">// 保护伪造函数toString</span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">    const $toString = Function.toString</span><br><span class="line">    const random_toString_symbol = Symbol(&#x27;(&#x27;.concat(&#x27;&#x27;, &#x27;)_&#x27;, (Math.random()) + &#x27;&#x27;).toString(36))</span><br><span class="line">    const myToString = function () &#123;</span><br><span class="line">        return typeof this === &#x27;function&#x27; &amp;&amp; this[random_toString_symbol] || $toString.call(this)</span><br><span class="line">    &#125;</span><br><span class="line">    function set_native(func, key, value) &#123;</span><br><span class="line">        Object.defineProperty(func, key, &#123;</span><br><span class="line">            enumerable: false,</span><br><span class="line">            configurable: true,</span><br><span class="line">            writable: true,</span><br><span class="line">            value: value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    delete Function.prototype.toString</span><br><span class="line">    set_native(Function.prototype, &quot;toString&quot;, myToString)</span><br><span class="line">    set_native(Function.prototype.toString, random_toString_symbol, &quot;function toString() &#123; [native code] &#125;&quot;)</span><br><span class="line">    globalThis.func_set_native = (func) =&gt; &#123;</span><br><span class="line">        random_toString_symbol</span><br><span class="line">        set_native(func, random_toString_symbol, `function $&#123;func.name || &#x27;&#x27;&#125;() &#123; [native code] &#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).call(this);</span><br><span class="line"></span><br><span class="line">// hook 函数实现</span><br><span class="line">Function.prototype.hook = function (</span><br><span class="line">    context = globalThis,</span><br><span class="line">    functionName,  // 匿名函数需要指定和 上下文的调用对象 一样的名称</span><br><span class="line">    onEnter = (ctx, funcname, mythis) =&gt; console.log(`【$&#123;funcname&#125;】onEnter --&gt;`, mythis, ctx.args),</span><br><span class="line">    onLeave = (retval, funcname) =&gt; console.log(`【$&#123;funcname&#125;】onLeave --&gt;`, retval),</span><br><span class="line">) &#123;</span><br><span class="line">    const targetFunction = this;</span><br><span class="line">    const originalName = targetFunction.name || functionName;</span><br><span class="line">    if (!originalName) &#123;</span><br><span class="line">        console.error(&quot;hook function name is empty!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建 hook 封装函数</span><br><span class="line">    const hookedFunction = function (...args) &#123;</span><br><span class="line">        const ctx = &#123; args &#125;;  // 参数上下文</span><br><span class="line">        onEnter(ctx, originalName, this);</span><br><span class="line"></span><br><span class="line">        // 调用原始函数并捕获返回值，这里的 this -&gt; window 全局对象</span><br><span class="line">        const retval = targetFunction.apply(this, ctx.args);</span><br><span class="line">        return onLeave(retval, originalName) || retval;  // 调用离开钩子，并检查是否更改返回值</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 将原始函数伪装成原生格式</span><br><span class="line">    Object.defineProperty(hookedFunction, &quot;name&quot;, &#123; value: originalName &#125;);</span><br><span class="line">    func_set_native(hookedFunction);</span><br><span class="line"></span><br><span class="line">    // 将 hooked 函数绑定到指定上下文</span><br><span class="line">    context[originalName] = hookedFunction;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ------------------ 测试代码 ------------------</span><br><span class="line">// btoa.hook(undefined, undefined, window);</span><br><span class="line">// btoa(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">// JSON.stringify.hook(undefined, undefined, JSON);</span><br><span class="line">// JSON.stringify(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// var bbb = &#123;&#125;;</span><br><span class="line">// bbb.b = function (s) &#123; return s + 1 &#125;;</span><br><span class="line">// bbb.b.hook(undefined, undefined, bbb, &quot;b&quot;);</span><br><span class="line">// bbb.b(123)</span><br><span class="line"></span><br><span class="line">// 在快速 hook 框架的基础上，实现对某些 API 批量添加 hook 方法</span><br><span class="line">let String_hook_Array = Object.getOwnPropertyDescriptors(String)</span><br><span class="line">let String_prototype_hook_Array = Object.getOwnPropertyDescriptors(String.prototype)</span><br><span class="line"></span><br><span class="line">for (const key in String_hook_Array) &#123;</span><br><span class="line">    let value = String_hook_Array[key]</span><br><span class="line">    if (value[&quot;writable&quot;] &amp;&amp; typeof value.value === &quot;function&quot;) &#123;</span><br><span class="line">        console.log(key);</span><br><span class="line">        value.value.hook(String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (const key in String_prototype_hook_Array) &#123;</span><br><span class="line">    let value = String_prototype_hook_Array[key]</span><br><span class="line">    if (value[&quot;writable&quot;] &amp;&amp; typeof value.value === &quot;function&quot;</span><br><span class="line">        &amp;&amp; key !== &quot;toString&quot; &amp;&amp; key !== &quot;concat&quot;</span><br><span class="line">    ) &#123;</span><br><span class="line">        console.log(key);</span><br><span class="line">        value.value.hook(String.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;enum hook start&quot;)</span><br></pre></td></tr></table></figure><h2 id="十、Hook-反调试绕过"><a href="#十、Hook-反调试绕过" class="headerlink" title="十、Hook 反调试绕过"></a>十、Hook 反调试绕过</h2><h3 id="1-保护-console-API"><a href="#1-保护-console-API" class="headerlink" title="1. 保护 console API"></a>1. 保护 console API</h3><blockquote><p><strong>防止反调试置空 console 相关 API：</strong>锁定 console 对象中的可写且可配置的属性，防止它们在运行时被修改</p><p>油猴脚本需要在最早时机进行注入：<code>// @run-at       document-start</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.clear = function () &#123; &#125;;</span><br><span class="line">Object.getOwnPropertyNames(console).forEach(key =&gt; &#123;</span><br><span class="line">    const descriptor = Object.getOwnPropertyDescriptor(console, key);</span><br><span class="line">    if (descriptor.writable &amp;&amp; descriptor.configurable) &#123;</span><br><span class="line">        Object.defineProperty(console, key, &#123;</span><br><span class="line">            value: console[key],</span><br><span class="line">            configurable: false,</span><br><span class="line">            writable: false,</span><br><span class="line">            enumerable: true</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-引入-Symbol-对象"><a href="#2-引入-Symbol-对象" class="headerlink" title="2. 引入 Symbol 对象"></a>2. 引入 Symbol 对象</h3><blockquote><p>Symbol 是 ES6 引入的一种基本数据类型，表示独一无二的标识符。与其他数据类型不同的是，Symbol 值是唯一的，不能与其他值相等，哪怕是两个具有相同描述的 Symbol（常用于在对象中添加私有属性或方法，以避免命名冲突）</p></blockquote><ul><li><p>Symbol 对象用法：</p><ol><li><p><strong>创建 Symbol：</strong>创建 Symbol 时，可以传入一个可选的字符串作为描述，便于调试时识别。每次创建的 Symbol 值都是独一无二的，即使描述相同，也不会相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&#x27;description&#x27;);</span><br><span class="line">const sym2 = Symbol(&#x27;description&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(sym1 === sym2); // false，每个 Symbol 都是唯一的</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Symbol 作为对象的键：</strong>Symbol 经常被用作对象的键，适合表示私有属性，因为它们不会在普通的对象遍历（如 for…in、Object.keys）中出现。由于 mySymbol 的唯一性，这种做法避免了与其他键名冲突的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mySymbol = Symbol(&#x27;myKey&#x27;);</span><br><span class="line">const obj = &#123;</span><br><span class="line">    [mySymbol]: &#x27;Symbol value&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj[mySymbol]); // &quot;Symbol value&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>全局 Symbol 注册表：</strong>通过<code>Symbol.for</code>和<code>Symbol.keyFor</code>，可以创建和使用全局注册的 Symbol。<code>Symbol.for</code>会先在全局注册表中查找是否已有该描述的 Symbol，如果有则返回这个已存在的 Symbol，否则创建一个新的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const globalSym1 = Symbol.for(&#x27;sharedKey&#x27;);</span><br><span class="line">const globalSym2 = Symbol.for(&#x27;sharedKey&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(globalSym1 === globalSym2); // true，共享全局 Symbol</span><br><span class="line">console.log(Symbol.keyFor(globalSym1)); // &#x27;sharedKey&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>内置 Symbol：</strong>js 提供了一些内置 Symbol，用于修改对象的默认行为。这些内置 Symbol 都存储在 Symbol 对象中</p><ul><li><strong>Symbol.iterator</strong>：使对象可被迭代</li><li><strong><span style="color:red;">Symbol.toStringTag：更改对象在 <code>Object.prototype.toString</code> 中的返回类型</span></strong></li><li><strong>Symbol.hasInstance</strong>：自定义 <code>instanceof</code> 行为</li><li><strong>Symbol.toPrimitive</strong>：自定义对象转换为原始类型值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用`Symbol.iterator`使对象可被`for...of`迭代</span><br><span class="line">const myIterable = &#123;</span><br><span class="line">    [Symbol.iterator]: function* () &#123;</span><br><span class="line">        yield 1;</span><br><span class="line">        yield 2;</span><br><span class="line">        yield 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (let value of myIterable) &#123;</span><br><span class="line">    console.log(value); // 1, 2, 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点和注意事项：</p><ul><li><strong>唯一性</strong>：每个 Symbol 值都是独一无二的</li><li><strong>不可隐式转换为字符串</strong>：Symbol 不能与字符串直接拼接</li><li><strong>不可枚举</strong>：Symbol 键的属性不会出现在普通的遍历（如<code>for...in</code>、<code>Object.keys</code>）中。可以使用 <code>Object.getOwnPropertySymbols</code> 来获取对象中的 Symbol 属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol(&#x27;desc&#x27;);</span><br><span class="line">console.log(&#x27;Symbol is &#x27; + sym); // 报错，不能隐式转换为字符串</span><br><span class="line">console.log(`Symbol is $&#123;String(sym)&#125;`); // 可以通过 String() 显式转换</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="3-伪造函数-toString"><a href="#3-伪造函数-toString" class="headerlink" title="3. 伪造函数 toString"></a>3. 伪造函数 toString</h3><blockquote><p>使用油猴脚本最好删除<strong>严格模式：</strong><code>&#39;use strict&#39;;</code></p><p><strong>Symbol.toStringTag：</strong>是一个特殊的内置 Symbol，在 js 中用于控制对象在 <strong><code>Object.prototype.toString.call()</code></strong> 中的显示标签。它允许你自定义对象的 <code>[object ...]</code> 格式，从而更改 <code>Object.prototype.toString()</code> 方法返回的对象类型描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(navigator); // &#x27;[object Navigator]&#x27;</span><br><span class="line">Navigator.prototype[Symbol.toStringTag]; // &#x27;Navigator&#x27;</span><br><span class="line"></span><br><span class="line">const myObject = &#123;</span><br><span class="line">[Symbol.toStringTag]: &#x27;MyCustomObject&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Object.prototype.toString.call(myObject)); // &quot;[object MyCustomObject]&quot;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Function 和 Object 的关系：</strong>Function 是 Object 的一个子类型，所有的函数实际上也是对象。这两种 toString 方法的不同之处在于，它们分别适用于不同类型的对象并且返回不同的格式</p><ol><li><p><strong><code>Function.prototype.toString</code>：</strong>用于<strong>函数对象</strong>，返回函数的源码字符串</p><ul><li>当一个函数调用时，会得到类似 <code>&quot;function funcnName() &#123; [native code] &#125;&quot;</code> 的字符串</li><li>Function.prototype.toString.call(Navigator) 返回的是 “function Navigator() { [native code] }”，表示 Navigator 是一个函数对象，并且其实现是<strong>原生代码</strong></li></ul></li></ol><ul><li><strong>注意：</strong>这个方法专门针对函数类型，如果你调用非函数对象，会抛出错误</li></ul><ol start="2"><li><strong><code>Object.prototype.toString</code>：</strong>是一种通用的类型检测方法，适用于所有对象类型，包括<strong>基本类型的包装对象</strong></li></ol><ul><li>调用时会返回 <code>&quot;[object Type]&quot;</code> 格式的字符串，Type 表示对象的类型</li><li>Object.prototype.toString.call(Navigator) 返回 “[object Function]”，说明 Navigator 是一个函数对象</li></ul></blockquote><ul><li><strong>使用 Symbol 和 Object.defineProperty 来伪装函数的原生 toString 实现（等价于 hook Function 绕过反 hook 的通用版）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 保护伪造函数 toString</span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">    // 1. 保存原始的 Function.toString 方法引用，确保在重新定义后依然可以调用原始方法</span><br><span class="line">    const $toString = Function.toString</span><br><span class="line"></span><br><span class="line">    // 2. 使用 Symbol 创建唯一标识符 myFunction_toString_symbol，用于标记伪装的 toString 输出</span><br><span class="line">    const myFunction_toString_symbol = Symbol(&#x27;(&#x27;.concat(&#x27;&#x27;, &#x27;)_&#x27;, (Math.random()) + &#x27;&#x27;).toString(36))</span><br><span class="line"></span><br><span class="line">    // 3. 定义自定义的 myToString 方法</span><br><span class="line">    const myToString = function () &#123;</span><br><span class="line">        // 如果 this 是一个函数且包含 myFunction_toString_symbol 属性，则返回伪装字符串</span><br><span class="line">        return typeof this === &#x27;function&#x27; &amp;&amp; this[myFunction_toString_symbol] || $toString.call(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4. 定义 set_native 方法，通过 Object.defineProperty 设置不可枚举的属性</span><br><span class="line">    function set_native(func, key, value) &#123;</span><br><span class="line">        Object.defineProperty(func, key, &#123;</span><br><span class="line">            enumerable: false,   // 不可枚举，外部代码无法轻易遍历到</span><br><span class="line">            configurable: true,  // 可配置，允许删除或修改</span><br><span class="line">            writable: true,      // 可写，允许重新赋值</span><br><span class="line">            value: value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5. 删除原有的 Function.prototype.toString 方法</span><br><span class="line">    delete Function.prototype.toString</span><br><span class="line"></span><br><span class="line">    // 6. 将自定义的 myToString 方法设为新的 Function.prototype.toString 方法</span><br><span class="line">    set_native(Function.prototype, &quot;toString&quot;, myToString)</span><br><span class="line"></span><br><span class="line">    // 7. 给 toString 方法设置 myFunction_toString_symbol 属性，伪装输出为“原生代码”样式</span><br><span class="line">    set_native(Function.prototype.toString, myFunction_toString_symbol, &quot;function toString() &#123; [native code] &#125;&quot;)</span><br><span class="line"></span><br><span class="line">    // 8. 定义辅助函数 func_set_native，用于动态设置任意函数的伪装 toString 输出</span><br><span class="line">    globalThis.func_set_native = (func) =&gt; &#123;</span><br><span class="line">        // 动态设置传入函数的 myFunction_toString_symbol 属性，使其 toString 输出伪装为“原生代码”样式</span><br><span class="line">        set_native(func, myFunction_toString_symbol, `function $&#123;func.name || &#x27;&#x27;&#125;() &#123; [native code] &#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).call(this)</span><br></pre></td></tr></table></figure><h3 id="4-定时器-debugger"><a href="#4-定时器-debugger" class="headerlink" title="4. 定时器 debugger"></a>4. 定时器 debugger</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// hook 定时器函数 替换debugger</span><br><span class="line">var teshu_setInterval = setInterval;</span><br><span class="line">var teshu_setTimeout = setTimeout;</span><br><span class="line"></span><br><span class="line">setInterval = function setInterval(code, time) &#123;</span><br><span class="line">    code = code.toString().replace(/debugger/, &quot;&quot;).replace(/function\s*\(\)/, &quot;function aaa()&quot;);</span><br><span class="line">    let result = teshu_setInterval(new Function(code), time);</span><br><span class="line">    console.log(&quot;setInterval: --&gt; &quot;, code, time, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout = function setTimeout(code, time) &#123;</span><br><span class="line">    code = code.toString().replace(/debugger/, &quot;&quot;).replace(/function\s*\(\)/, &quot;function aaa()&quot;);</span><br><span class="line">    let result = teshu_setTimeout(new Function(code), time);</span><br><span class="line">    console.log(&quot;setTimeout: --&gt; &quot;, code, time, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line">// 其中 result 就是定时器编号，在打印出定时器编号后，可以直接通过 clearTimeout 或 clearInterval 清除定时器</span><br><span class="line"></span><br><span class="line">// 保护伪造函数toString</span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">    const $toString = Function.toString</span><br><span class="line">    const random_toString_symbol = Symbol(&#x27;(&#x27;.concat(&#x27;&#x27;, &#x27;)_&#x27;, (Math.random()) + &#x27;&#x27;).toString(36))</span><br><span class="line">    const myToString = function () &#123;</span><br><span class="line">        return typeof this === &#x27;function&#x27; &amp;&amp; this[random_toString_symbol] || $toString.call(this)</span><br><span class="line">    &#125;</span><br><span class="line">    function set_native(func, key, value) &#123;</span><br><span class="line">        Object.defineProperty(func, key, &#123;</span><br><span class="line">            enumerable: false,</span><br><span class="line">            configurable: true,</span><br><span class="line">            writable: true,</span><br><span class="line">            value: value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    delete Function.prototype.toString</span><br><span class="line">    set_native(Function.prototype, &quot;toString&quot;, myToString)</span><br><span class="line">    set_native(Function.prototype.toString, random_toString_symbol, &quot;function toString() &#123; [native code] &#125;&quot;)</span><br><span class="line">    globalThis.func_set_native = (func) =&gt; &#123;</span><br><span class="line">        random_toString_symbol</span><br><span class="line">        set_native(func, random_toString_symbol, `function $&#123;func.name || &#x27;&#x27;&#125;() &#123; [native code] &#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).call(this);</span><br><span class="line"></span><br><span class="line">func_set_native(setInterval);</span><br><span class="line">func_set_native(setTimeout);</span><br></pre></td></tr></table></figure><h3 id="5-constructor-debugger"><a href="#5-constructor-debugger" class="headerlink" title="5. constructor debugger"></a>5. constructor debugger</h3><blockquote><p><strong>主要拦截 <code>new Function(&quot;debugger&quot;)</code> 这种方式的调用，即通过构造器无线动态构造 debugger 函数的情况</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let _constructor = constructor;</span><br><span class="line">Function.prototype.constructor = function (s) &#123;</span><br><span class="line">    if (s == &quot;debugger&quot;) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return _constructor(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-反-debugger-案例"><a href="#6-反-debugger-案例" class="headerlink" title="6. 反 debugger 案例"></a>6. 反 debugger 案例</h3><ul><li>检测网站：<a class="link"   href="https://blog.aepkill.com/demos/devtools-detector/"  target="_blank" rel="noopener">34d2d58d6573507b88bfe5df7d651599<i class="fas fa-external-link-alt"></i></a>，网站源码：<a class="link"   href="https://github.com/AEPKILL/devtools-detector/tree/master/src/checkers"  target="_blank" rel="noopener">1ffd91d5ec85d5e6d3ab008d32241280<i class="fas fa-external-link-alt"></i></a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 油猴脚本注入反定时器 debugger 脚本即可</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、JS-语法基础&quot;&gt;&lt;a href=&quot;#一、JS-语法基础&quot; class=&quot;headerlink&quot; title=&quot;一、JS 语法基础&quot;&gt;&lt;/a&gt;一、JS 语法基础&lt;/h2&gt;&lt;h3 id=&quot;1-基础语法&quot;&gt;&lt;a href=&quot;#1-基础语法&quot; class=&quot;head</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="JS逆向" scheme="http://example.com/tags/JS%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向_3_扣算法专题</title>
    <link href="http://example.com/2024/05/01/JS%E9%80%86%E5%90%91_3_%E6%89%A3%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2024/05/01/JS%E9%80%86%E5%90%91_3_%E6%89%A3%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/</id>
    <published>2024-04-30T16:00:00.000Z</published>
    <updated>2024-12-19T14:55:29.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Webpack专题"><a href="#一、Webpack专题" class="headerlink" title="一、Webpack专题"></a>一、Webpack专题</h2><blockquote><p><strong>Webpack：</strong>Webpack 是一个开源的 JavaScript 模块打包工具。它将应用程序的所有资源均视为模块，并通过依赖关系将它们打包成一个或多个最终的静态 js 资源文件，并且可以在浏览器中加载执行。Webpack的主要特点包括<strong>模块化</strong>、代码分割、<strong>加载器</strong>和插件系统等。</p><p><strong>加载器（loaders）：</strong>虽然 Webpack 以 JavaScript 为主要的处理对象，但在构建过程中，它会通过加载器处理和支持多种其他类型的文件，加载器可以将非 JavaScript 文件转换为 Webpack 可以理解的模块形式。</p><p><strong>页面特征：</strong>如果一个页面的 document 文档大多都是由 script 标签构成，那么大概率是 webpack 打包模式</p></blockquote><h3 id="1-加载器"><a href="#1-加载器" class="headerlink" title="1. 加载器"></a>1. 加载器</h3><blockquote><p><strong><a class="link"   href="https://36kr.com/"  target="_blank" rel="noopener">测试网站1<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://kuajing.pinduoduo.com/login"  target="_blank" rel="noopener">测试网站2<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://fse.agilestudio.cn/search?keyword=happy"  target="_blank" rel="noopener">测试网站3<i class="fas fa-external-link-alt"></i></a></strong></p></blockquote><ul><li><strong>基本格式：<code>!function(&quot;形参&quot;)&#123;&quot;加载器&quot;&#125;([&quot;实参模块&quot;]);</code></strong></li><li><strong>注意：</strong>加载器有时存在于 html 的 script 标签中，一样的提取，找到正确的 script 标签中的加载器即可</li><li><strong>核心代码：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var Func;</span><br><span class="line"></span><br><span class="line">// 自执行函数</span><br><span class="line">!function (e) &#123;</span><br><span class="line">    var c = &#123;&#125;; // 存储已加载的模块信息</span><br><span class="line"></span><br><span class="line">    // 用于加载和执行模块，形参 t 表示模块的索引</span><br><span class="line">    function n(t) &#123;</span><br><span class="line">        // 创建一个模块对象，用于存储模块信息和导出</span><br><span class="line">        var a = c[t] = &#123;</span><br><span class="line">            i: t,</span><br><span class="line">            l: !1,      // 模块是否已加载的标志，初始为false</span><br><span class="line">            exports: &#123;&#125; // 模块的导出对象</span><br><span class="line">        &#125;;</span><br><span class="line">        console.log(t); // 打印出所需要使用的所有模块的索引</span><br><span class="line"></span><br><span class="line">        // 调用模块对应的函数，传入模块对象和导出对象，并执行模块代码</span><br><span class="line">        return e[t].call(a.exports, a, a.exports, n),</span><br><span class="line">            a.l = !0,   // 将模块标记为已加载</span><br><span class="line">            a.exports   // 返回模块的导出对象</span><br><span class="line">    &#125;</span><br><span class="line">    Func = n;  // 提供给外部调用</span><br><span class="line"></span><br><span class="line">    n.m = e; // 存储模块源代码数组，在网页中包含所有的模块，包括动态加载的模块</span><br><span class="line"></span><br><span class="line">    // 主动加载并执行入口模块</span><br><span class="line">    n(0);</span><br><span class="line">&#125;([</span><br><span class="line">    // 需要的模块函数，数组形式</span><br><span class="line">    function () &#123;</span><br><span class="line">        console.log(&quot;hello&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function () &#123;</span><br><span class="line">        console.log(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">]); // 输出：0 111</span><br><span class="line"></span><br><span class="line">/* 对象格式</span><br><span class="line">&#123;</span><br><span class="line">    0: function () &#123;</span><br><span class="line">        console.log(111);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;1&#x27;: function () &#123;</span><br><span class="line">        console.log(222);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 外部调用，加载并执行模块</span><br><span class="line">Func(1)</span><br></pre></td></tr></table></figure><h3 id="2-动态加载模块"><a href="#2-动态加载模块" class="headerlink" title="2. 动态加载模块"></a>2. 动态加载模块</h3><ul><li><strong>动态加载原理：</strong><ol><li><strong>webpackJsonpCallback()：</strong>是 webpack 在运行时动态加载模块时的回调函数，用于动态加载模块</li><li><strong>定义 window.webpackJsonp 为全局变量：</strong>用于存储需要在运行时动态导入的模块</li><li><strong>重写 window.webpackJsonp.push() 方法：</strong>将数组的 push() 方法重写为 webpackJsonpCallback() 方法，这意味着实际运行时执行的是 webpackJsonpCallback() 方法</li></ol></li><li><strong>window[“webpackJsonp”].push() 的参数：</strong><ol><li><strong>参数1：</strong>模块的 ID，用于标识唯一的模块</li><li><strong>参数2：</strong>一个数组或者对象，其中定义了大量的函数，即<strong>动态加载的模块</strong></li><li><strong>参数3：</strong>要调用的函数，是可选的</li></ol></li><li><strong>遇到模块动态加载的处理方式（<a class="link"   href="https://jzsc.mohurd.gov.cn/data/company"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong><ol><li><strong>有加载器但无模块。</strong>全局搜索加载器中 window[“webpackJsonp”] 的 <strong>webpackJsonp 关键字</strong>，可能找到多个<strong>动态加载模块</strong>，在每一个中搜索需要的<strong>起始模块</strong>，存在则将<strong>参数2</strong>中的所有模块复制使用</li><li><strong>有模块但无加载器。</strong>全局搜索定义的用于存储动态导入模块的<strong>变量名</strong>，因为在加载器中需要动态导入模块，<strong>一定需要引用其值</strong>，将其 push 方法为新变量 bind，为加载器添加需要使用的模块</li><li><strong>参数2中的模块以数组的形式存在时</strong>。如果不想全扣，就可以<strong>通过 <code>页面调用加载器名称.m[模块编号]</code> 直接定位方法位置</strong>，但是断点作用域需要在某一个加载器调用处断点并刷新网页后的断点作用域才可以</li><li><strong>简单粗暴：找不到谁就直接在谁脸上打断点，刷新网页重新加载直接断住，加载器或者模块都能直接找到</strong></li></ol></li></ul><h2 id="二、OB混淆专题"><a href="#二、OB混淆专题" class="headerlink" title="二、OB混淆专题"></a>二、OB混淆专题</h2><blockquote><p><strong>混淆：</strong>混淆是一种通过修改代码结构、变量名和逻辑，使得源代码在保持原有功能的同时，变得难以阅读和理解的技术。混淆的目的是增加代码的复杂性，这有助于提高软件的安全性，防止恶意用户或恶意软件对程序进行逆向工程，获取敏感信息或发现潜在的漏洞。</p><p><strong>ob混淆（Obfuscation）的两个版本（<a class="link"   href="https://obfuscator.io/"  target="_blank" rel="noopener">官方网址<i class="fas fa-external-link-alt"></i></a>）：</strong></p><ol><li><strong>旧版的 ob 混淆：由一个 大数组 + 移位自执行函数 + 解密函数组成</strong><ul><li>_0x2755 是大数组变量名，它的元素<strong>全都是字面量</strong></li><li>它后面是一个自执行函数，其目的是<strong>改变各个元素的位置</strong></li><li>紧接着是一个<strong>解密函数</strong>，它调用的时候，元素位置已经改变，因此需要一起抠才能正常解密</li></ul></li><li><strong>新版的 ob 混淆：由一个 大数组函数 + 移位自执行函数 + 解密函数组成</strong><ul><li>a0_0x4bdb 是大数组函数名，它返回的是一个大数组，数组的元素<strong>全都是字面量</strong></li><li>紧接着是一个<strong>解密函数</strong>，它调用的时候，元素位置已经改变，因此需要一起抠才能正常解密</li><li>它后面是一个自执行函数，其目的是<strong>改变各个元素的位置</strong></li></ul></li></ol><p><strong>注意：某些自执行函数或解密函数包含了代码格式化检测，因此在运行的时候需要进行压缩处理，否则卡死</strong></p></blockquote><h3 id="1-ob混淆技术"><a href="#1-ob混淆技术" class="headerlink" title="1. ob混淆技术"></a>1. ob混淆技术</h3><ul><li><p><strong>代码压缩：</strong>移除代码中的空格、换行和注释，以减小文件大小。不仅减小加载时间，还增加代码的阅读难度</p></li><li><p><strong>变量混淆</strong>：将带有含意的变量名、方法名、常量名随机变为无意义的类乱码字符串，使其难以理解或追踪</p></li><li><p><strong>字符串混淆：</strong>将字符串阵列化集中放置，对字符串进行加密或编码，使代码中无明文字符串，避免搜索定位</p></li><li><p><strong>属性加密：</strong>针对 JavaScript 对象的属性进行加密转化，隐藏代码之间的调用关系</p></li><li><p><strong>控制流平坦化：</strong>改变程序的控制流结构，打乱函数原有代码执行流程及函数调用关系，使代码逻变得混乱无序</p></li><li><p><strong>僵尸代码：</strong>在程序中插入一些无实际作用的代码片段，不影响程序的正常执行，进一步使代码混乱</p></li><li><p><strong>调试保护：</strong>基于调试器特性对当前环境进行检验，加入强制 debugger 语句，使代码在调试模式下难以被分析</p></li><li><p><strong>多态变异：</strong>使得程序的相同功能在不同的执行时刻产生不同的形式，杜绝代码被动态分析调试</p></li><li><p><strong>锁定域名：</strong>一种反调试技术，通过检测程序是否在特定的域名下运行，以防止在非授权的环境中分析程序</p></li><li><p><strong>反格式化：</strong>如果对 JavaScript 代码进行格式化，则无法执行，导致浏览器或程序假死</p></li><li><p><strong>特殊编码：</strong>将代码完全编码为人不可读的代码，如特殊表情符号、重复相同单词、定制的编码算法等等</p></li></ul><h3 id="2-ob混淆结构"><a href="#2-ob混淆结构" class="headerlink" title="2. ob混淆结构"></a>2. ob混淆结构</h3><blockquote><p><strong>注意：ob混淆后的每个部分的顺序不一定按正常排序，并且也不是每个ob混淆的代码都包括完整的五部分</strong></p><p><strong>混淆特点总结：</strong></p><ol><li>一般由一个大数组或者含有大数组的函数、一个自执行函数、解密函数和加密后真实函数四部分组成</li><li>函数名和变量名通常以 <code>_0x</code> 或者 <code>0x</code> 开头，后接 1~6 位数字或字母组成</li><li>自执行函数，进行移位操作，有明显的 push、shift 关键字</li></ol></blockquote><ol><li><strong>定义一个数组：</strong><ul><li>定义一个包含混淆代码片段的数组，可能包含被混淆的变量、函数和其他代码元素。也可以再次混淆到看不出是一个数组，数组的位置不一定在第一行，复杂点的混淆会把这个数组放在比较隐藏的位置</li></ul></li><li><strong>重构数组：</strong><ul><li>混淆器可能会对数组进行重构，改变其中的元素顺序，增加数组的维度或者使用其他技术使得数组更难以直接理解。为了防止内存泄漏，<strong>不建议格式化这部分代码</strong></li></ul></li><li><strong>自解密函数：</strong><ul><li>此部分通常包含一个用于解密数组中的代码片段的函数。这个函数可能包括解密算法、控制流混淆等，以还原数组中的原始代码。为了防止内存泄漏，<strong>不建议格式化这部分代码</strong></li></ul></li><li><strong>真实代码：</strong><ul><li>整个ob混淆的难度取决于此部分，这是混淆后代码的真实功能实现。混淆器可能会将原始代码与混淆代码混合在一起，以增加分析者的困惑。<strong>分析代码就是为了找出这一部分</strong></li></ul></li><li><strong>可以删除的垃圾代码：</strong><ul><li>为增加混淆度，混淆器可能会在代码中插入一些无用的垃圾代码，主要由<strong>控制流平坦化+无限debugger自执行函数+死代码注入</strong>构成，一般不涉及业务逻辑，可以直接删除但也要具体分析后删除</li></ul></li></ol><h3 id="3-ob混淆实现"><a href="#3-ob混淆实现" class="headerlink" title="3. ob混淆实现"></a>3. ob混淆实现</h3><blockquote><p><strong>安装ob混淆库：<code>npm install javascript-obfuscator -s</code></strong></p></blockquote><ul><li><strong>JavaScript 实现 OB混淆（<a class="link"   href="https://bz.zzzmh.cn/index"  target="_blank" rel="noopener">测试网站1<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.spolicy.com/"  target="_blank" rel="noopener">测试网站2<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const OB = require(&#x27;javascript-obfuscator&#x27;);</span><br><span class="line"></span><br><span class="line">const sourceCode = `</span><br><span class="line">function hi() &#123;</span><br><span class="line">  console.log(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">hi();</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const options = &#123;</span><br><span class="line">    compact: true, // 启用压缩</span><br><span class="line">    controlFlowFlattening: true, // 控制流 平坦化</span><br><span class="line">    controlFlowFlatteningThreshold: 0.75, // 控制流平坦化阈值</span><br><span class="line">    deadCodeInjection: true, // 使死代码注入</span><br><span class="line">    deadCodeInjectionThreshold: 0.4, // 死代码注入阈值</span><br><span class="line">    identifierNamesGenerator: &#x27;hexadecimal&#x27;, // 生成标识符的方式</span><br><span class="line">    log: false, // 关闭日志</span><br><span class="line">    rotateStringArray: true, // 旋转字符串数组</span><br><span class="line">    selfDefending: true, // 启用自我防御</span><br><span class="line">    stringArray: true, // 启用字符串数组</span><br><span class="line">    stringArrayThreshold: 0.75, // 字符串数组阈值</span><br><span class="line">    // domainLock: [&#x27;example.com&#x27;], // 锁定域名</span><br><span class="line">    debugProtection: true, // 调试保护</span><br><span class="line">    disableConsoleOutput: true, // 禁用控制台输出</span><br><span class="line">    unicodeEscapeSequence: false, // 禁用 Unicode 转义序列</span><br><span class="line">    rotateUnicodeArray: true, // 旋转 Unicode 数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obCode = OB.obfuscate(sourceCode, options).getObfuscatedCode();</span><br><span class="line"></span><br><span class="line">console.log(obCode);</span><br></pre></td></tr></table></figure><h3 id="4-问题记录"><a href="#4-问题记录" class="headerlink" title="4. 问题记录"></a>4. 问题记录</h3><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1707204284-886a90804a72fc6.jpg"                                         ><ul><li><strong>问题：</strong>混淆代码格式化后报错</li><li><strong>解决：</strong>通过<a class="link"   href="https://www.jsjiami.com/jiemi.html"  target="_blank" rel="noopener">压缩网站<i class="fas fa-external-link-alt"></i></a>压缩代码</li></ul><h2 id="三、RPC技术专题"><a href="#三、RPC技术专题" class="headerlink" title="三、RPC技术专题"></a>三、RPC技术专题</h2><h3 id="1-websocket协议"><a href="#1-websocket协议" class="headerlink" title="1. websocket协议"></a>1. websocket协议</h3><blockquote><p><strong>WebSocket协议（WS）：</strong>是一种在客户端和服务器之间实现实时双向通信的网络协议，基于单个 TCP 连接进行双工通信。与传统的 HTTP 协议不同，WebSocket 提供了一个持久性的连接，避免了在每次通信时重新建立连接的开销。同时其允许服务器主动向客户端推送数据，而不需要客户端先发起请求。</p><p><strong>特点：</strong></p><ol><li><strong>全双工通信：</strong>允许在客户端和服务器之间进行双向实时通信，可以同时发送和接收数据</li><li><strong>持久连接：</strong>WebSocket 连接一旦建立，可以持续存在，而不需要在每次通信时重新建立连接</li><li><strong>低延迟：</strong>相较 HTTP 轮询和长轮询等传统技术，WebSocket 通信具有更低的延迟，因为连接是持久性的</li><li><strong>轻量级头部：</strong>WebSocket 头部相对较小，减少了通信时的数据开销</li></ol></blockquote><ul><li><strong>实现原理：</strong><ul><li><strong>握手阶段（Handshake）：</strong>客户端发送一个 HTTP 请求，其中包含 WebSocket 协议版本和一些附加信息.服务器接收请求后，如果支持 WebSocket，会回复一个 HTTP 101 状态码，表示协议切换。握手成功后，协议升级完成，连接从 HTTP 协议切换到 WebSocket 协议。</li><li><strong>数据帧（Frame）：</strong>WebSocket 通信使用数据帧来传输信息。数据帧可以是文本、二进制数据或控制帧（用于控制连接状态）。数据帧的结构包括帧头和帧数据，帧头包含了一些控制位和长度信息。</li><li><strong>保持连接：</strong>一旦 WebSocket 连接建立，客户端和服务器可以通过发送帧来保持连接状态。服务器可以主动向客户端发送数据，而不需要等待客户端的请求。</li><li><strong>关闭连接：</strong>通过特殊的控制帧可以实现连接的安全关闭。客户端或服务器可以发送帧来表示关闭连接的意图，对方收到后可以做出相应的处理。</li><li><strong>安全性：</strong>WebSocket 可以通过安全套接字层（WebSocket Secure，wss:&#x2F;&#x2F;）进行加密，类似于 HTTPS，这确保了通过 WebSockets 传输的数据的机密性和完整性。</li></ul></li><li><strong>客户端（浏览器js）实现：<a class="link"   href="https://jzsc.mohurd.gov.cn/data/company"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">!(function () &#123;</span><br><span class="line">    // 通过flag标记用来判断是否已创建套接字</span><br><span class="line">    if (window.flag) &#123;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 创建 WebSocket 实例连接到指定服务器地址</span><br><span class="line">        const websocket = new WebSocket(&#x27;ws://127.0.0.1:8080&#x27;)</span><br><span class="line">        window.flag = true;</span><br><span class="line">        // 接收到服务端数据的回调方法</span><br><span class="line">        websocket.onmessage = function (event) &#123;</span><br><span class="line">            let data = event.data;</span><br><span class="line">            // 对接收到的数据进行处理（解密）</span><br><span class="line">            let res = b(data)</span><br><span class="line">            // 发送处理后的数据回服务器</span><br><span class="line">            websocket.send(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><ul><li><strong>服务端（本地python）实现方式：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import websockets</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"># get_data函数，通过requests请求密文数据并返回</span><br><span class="line"></span><br><span class="line">async def echo(websocket):</span><br><span class="line">    for i in range(1, 3):</span><br><span class="line">        data = get_data(i)</span><br><span class="line">        await websocket.send(data)</span><br><span class="line"></span><br><span class="line">async def recv_msg(websocket):</span><br><span class="line">    while True:</span><br><span class="line">        res = await websocket.recv()</span><br><span class="line">        print(res)</span><br><span class="line"></span><br><span class="line">async def main_logic(websocket, path):</span><br><span class="line">    await echo(websocket)</span><br><span class="line">    await recv_msg(websocket)</span><br><span class="line"></span><br><span class="line">ws_server = websockets.serve(main_logic, &#x27;127.0.0.1&#x27;, 8080)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(ws_server)</span><br><span class="line">loop.run_forever()  # 用于运行一个异步事件循环，使其一直运行下去。实现保持长连接</span><br></pre></td></tr></table></figure><h3 id="2-RPC技术"><a href="#2-RPC技术" class="headerlink" title="2. RPC技术"></a>2. RPC技术</h3><blockquote><p><strong>RPC（Remote Procedure Call）：</strong>是一种用于实现远程通信的协议和编程模型。它允许在客户端调用远程服务器上的某个函数或过程时，不需要显式编写网络通信代码，由 RPC 框架负责处理网络通信的细节，包括序列化参数、发送请求、接收响应，处理异常等，就像调用本地过程一样调用远程过程。</p><p><strong>作用：</strong>在逆向中，将浏览器和本地视为客户端和服务器，二者通过 RPC 框架基于 websocket 协议通信，由 RPC 与浏览器通信实现加密，本地再与 RPC 通信得到加密结果。通过 RPC 技术在浏览器中将加密逻辑暴露，在本地直接调用浏览器中对应的加密函数，从而直接得到加密结果，省去大量逆向调试时间。</p><p><strong>注意：</strong>使用 RPC 也需要先定位加密位置，通过在加密处上面注入脚本、替换文件和刷新网页，使得脚本生效</p></blockquote><ul><li>**<a class="link"   href="https://sekiro.iinti.cn/sekiro-doc/"  target="_blank" rel="noopener">Sekiro-RPC<i class="fas fa-external-link-alt"></i></a>**：<ol><li>进入sekiro-open-demo文件夹，运行<code>bin/sekiro.sh</code>，注意需要 java 环境</li><li>客户端环境代码：<a class="link"   href="http://file.virjar.com/sekiro_web_client.js?_=123"  target="_blank" rel="noopener">http://file.virjar.com/sekiro_web_client.js?_&#x3D;123<i class="fas fa-external-link-alt"></i></a></li><li>查看分组列表API：<a class="link"   href="http://127.0.0.1:5612/business-demo/groupList"  target="_blank" rel="noopener">http://127.0.0.1:5612/business-demo/groupList<i class="fas fa-external-link-alt"></i></a></li><li>查看队列状态API：<a class="link"   href="http://127.0.0.1:5612/business-demo/clientQueue?group=rpc-test"  target="_blank" rel="noopener">http://127.0.0.1:5612/business-demo/clientQueue?group=rpc-test<i class="fas fa-external-link-alt"></i></a></li><li><strong>调用返回数据API：<code>http://127.0.0.1:5612/business-demo/invoke?group=&#123;&#125;&amp;action=&#123;&#125;</code></strong></li></ol></li><li><strong>客户端实现参数：</strong><ul><li><strong>group（业务类型）：</strong>表示业务的分类或接口组，可以根据业务类型将客户端划分到不同的组</li><li><strong>SekiroClient（服务提供者客户端）</strong>：创建客户端实例，负责将本地（浏览器）的方法注册为远程操作</li><li><strong>clientId：</strong>客户端的唯一标识符，以便服务端能够识别和跟踪不同的客户端</li><li><strong>registerAction（业务接口）：</strong>业务接口注册，客户端在指定的 group 下可注册不同的远程 Action 操作</li><li><strong>request：</strong>是服务端传递给远程操作的请求对象，包含了请求的参数信息等</li><li><strong>resolve：</strong>一个回调函数，用于在远程操作执行成功时将结果返回给客户端</li><li><strong>reject：</strong>一个回调函数，用于在远程操作执行失败时返回错误信息给客户端</li></ul></li></ul><h3 id="3-RPC逆向中实现"><a href="#3-RPC逆向中实现" class="headerlink" title="3. RPC逆向中实现"></a>3. RPC逆向中实现</h3><ul><li><strong>浏览器加密位置注入代码（注意提前开启RPC服务器）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">!(function () &#123;</span><br><span class="line">    // 客户端环境代码......</span><br><span class="line">    </span><br><span class="line">    if (window.flag) &#123;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        function guid() &#123;</span><br><span class="line">            function S4() &#123;</span><br><span class="line">                return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return (S4() + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + S4() + S4());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var client = new SekiroClient(&quot;ws://127.0.0.1:5612/business-demo/register?group=rpc-test&amp;clientId=&quot; + guid());</span><br><span class="line">        window.flag = true;</span><br><span class="line"></span><br><span class="line">        client.registerAction(&quot;test-1&quot;, function (request, resolve, reject) &#123;</span><br><span class="line">            data = request[&#x27;data&#x27;]</span><br><span class="line">            resolve(&#123;&#x27;decrypt_data&#x27;: b(data), &#x27;cookie&#x27;: document.cookie&#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ul><li><strong>本地python代码调用接口获取客户端数据：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    &quot;group&quot;: &quot;rpc-test&quot;,</span><br><span class="line">    &quot;action&quot;: &quot;test-1&quot;,</span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(&quot;http://127.0.0.1:5612/business-demo/invoke&quot;, data=data)</span><br><span class="line">print(response.json())</span><br></pre></td></tr></table></figure><ul><li><strong>客户端环境代码（<a class="link"   href="http://file.virjar.com/sekiro_web_client.js?_=123"  target="_blank" rel="noopener">http://file.virjar.com/sekiro_web_client.js?_&#x3D;123<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  Copyright (C) 2020 virjar &lt;virjar@virjar.com&gt; for https://github.com/virjar/sekiro</span><br><span class="line"></span><br><span class="line">  Redistribution and use in source and binary forms, with or without</span><br><span class="line">  modification, are permitted provided that the following conditions are met:</span><br><span class="line"></span><br><span class="line">    * Redistributions of source code must retain the above copyright</span><br><span class="line">      notice, this list of conditions and the following disclaimer.</span><br><span class="line">    * Redistributions in binary form must reproduce the above copyright</span><br><span class="line">      notice, this list of conditions and the following disclaimer in the</span><br><span class="line">      documentation and/or other materials provided with the distribution.</span><br><span class="line"></span><br><span class="line">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span><br><span class="line">  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span><br><span class="line">  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span><br><span class="line">  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY</span><br><span class="line">  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span><br><span class="line">  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span><br><span class="line">  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span><br><span class="line">  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span><br><span class="line">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span><br><span class="line">  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">function SekiroClient(wsURL) &#123;</span><br><span class="line">    this.wsURL = wsURL;</span><br><span class="line">    this.handlers = &#123;&#125;;</span><br><span class="line">    this.socket = &#123;&#125;;</span><br><span class="line">    this.base64 = false;</span><br><span class="line">    // check</span><br><span class="line">    if (!wsURL) &#123;</span><br><span class="line">        throw new Error(&#x27;wsURL can not be empty!!&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.webSocketFactory = this.resolveWebSocketFactory();</span><br><span class="line">    this.connect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.resolveWebSocketFactory = function () &#123;</span><br><span class="line">    if (typeof window === &#x27;object&#x27;) &#123;</span><br><span class="line">        var theWebSocket = window.WebSocket ? window.WebSocket : window.MozWebSocket;</span><br><span class="line">        return function (wsURL) &#123;</span><br><span class="line"></span><br><span class="line">            function WindowWebSocketWrapper(wsURL) &#123;</span><br><span class="line">                this.mSocket = new theWebSocket(wsURL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            WindowWebSocketWrapper.prototype.close = function () &#123;</span><br><span class="line">                this.mSocket.close();</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            WindowWebSocketWrapper.prototype.onmessage = function (onMessageFunction) &#123;</span><br><span class="line">                this.mSocket.onmessage = onMessageFunction;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            WindowWebSocketWrapper.prototype.onopen = function (onOpenFunction) &#123;</span><br><span class="line">                this.mSocket.onopen = onOpenFunction;</span><br><span class="line">            &#125;;</span><br><span class="line">            WindowWebSocketWrapper.prototype.onclose = function (onCloseFunction) &#123;</span><br><span class="line">                this.mSocket.onclose = onCloseFunction;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            WindowWebSocketWrapper.prototype.send = function (message) &#123;</span><br><span class="line">                this.mSocket.send(message);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            return new WindowWebSocketWrapper(wsURL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof weex === &#x27;object&#x27;) &#123;</span><br><span class="line">        // this is weex env : https://weex.apache.org/zh/docs/modules/websockets.html</span><br><span class="line">        try &#123;</span><br><span class="line">            console.log(&quot;test webSocket for weex&quot;);</span><br><span class="line">            var ws = weex.requireModule(&#x27;webSocket&#x27;);</span><br><span class="line">            console.log(&quot;find webSocket for weex:&quot; + ws);</span><br><span class="line">            return function (wsURL) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ws.close();</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                ws.WebSocket(wsURL, &#x27;&#x27;);</span><br><span class="line">                return ws;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            console.log(e);</span><br><span class="line">            //ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //TODO support ReactNative</span><br><span class="line">    if (typeof WebSocket === &#x27;object&#x27;) &#123;</span><br><span class="line">        return function (wsURL) &#123;</span><br><span class="line">            return new theWebSocket(wsURL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // weex 鍜� PC鐜鐨剋ebsocket API涓嶅畬鍏ㄤ竴鑷达紝鎵€浠ュ仛浜嗘娊璞″吋瀹�</span><br><span class="line">    throw new Error(&quot;the js environment do not support websocket&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.connect = function () &#123;</span><br><span class="line">    console.log(&#x27;sekiro: begin of connect to wsURL: &#x27; + this.wsURL);</span><br><span class="line">    var _this = this;</span><br><span class="line">    // 涓峜heck close锛岃</span><br><span class="line">    // if (this.socket &amp;&amp; this.socket.readyState === 1) &#123;</span><br><span class="line">    //     this.socket.close();</span><br><span class="line">    // &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.socket = this.webSocketFactory(this.wsURL);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        console.log(&quot;sekiro: create connection failed,reconnect after 2s&quot;);</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            _this.connect()</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.socket.onmessage(function (event) &#123;</span><br><span class="line">        _this.handleSekiroRequest(event.data)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this.socket.onopen(function (event) &#123;</span><br><span class="line">        console.log(&#x27;sekiro: open a sekiro client connection&#x27;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this.socket.onclose(function (event) &#123;</span><br><span class="line">        console.log(&#x27;sekiro: disconnected ,reconnection after 2s&#x27;);</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            _this.connect()</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.handleSekiroRequest = function (requestJson) &#123;</span><br><span class="line">    console.log(&quot;receive sekiro request: &quot; + requestJson);</span><br><span class="line">    var request = JSON.parse(requestJson);</span><br><span class="line">    var seq = request[&#x27;__sekiro_seq__&#x27;];</span><br><span class="line"></span><br><span class="line">    if (!request[&#x27;action&#x27;]) &#123;</span><br><span class="line">        this.sendFailed(seq, &#x27;need request param &#123;action&#125;&#x27;);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var action = request[&#x27;action&#x27;];</span><br><span class="line">    if (!this.handlers[action]) &#123;</span><br><span class="line">        this.sendFailed(seq, &#x27;no action handler: &#x27; + action + &#x27; defined&#x27;);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var theHandler = this.handlers[action];</span><br><span class="line">    var _this = this;</span><br><span class="line">    try &#123;</span><br><span class="line">        theHandler(request, function (response) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                _this.sendSuccess(seq, response)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                _this.sendFailed(seq, &quot;e:&quot; + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, function (errorMessage) &#123;</span><br><span class="line">            _this.sendFailed(seq, errorMessage)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        console.log(&quot;error: &quot; + e);</span><br><span class="line">        _this.sendFailed(seq, &quot;:&quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.sendSuccess = function (seq, response) &#123;</span><br><span class="line">    var responseJson;</span><br><span class="line">    if (typeof response == &#x27;string&#x27;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            responseJson = JSON.parse(response);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            responseJson = &#123;&#125;;</span><br><span class="line">            responseJson[&#x27;data&#x27;] = response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (typeof response == &#x27;object&#x27;) &#123;</span><br><span class="line">        responseJson = response;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        responseJson = &#123;&#125;;</span><br><span class="line">        responseJson[&#x27;data&#x27;] = response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (typeof response == &#x27;string&#x27;) &#123;</span><br><span class="line">        responseJson = &#123;&#125;;</span><br><span class="line">        responseJson[&#x27;data&#x27;] = response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(responseJson)) &#123;</span><br><span class="line">        responseJson = &#123;</span><br><span class="line">            data: responseJson,</span><br><span class="line">            code: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (responseJson[&#x27;code&#x27;]) &#123;</span><br><span class="line">        responseJson[&#x27;code&#x27;] = 0;</span><br><span class="line">    &#125; else if (responseJson[&#x27;status&#x27;]) &#123;</span><br><span class="line">        responseJson[&#x27;status&#x27;] = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        responseJson[&#x27;status&#x27;] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    responseJson[&#x27;__sekiro_seq__&#x27;] = seq;</span><br><span class="line">    var responseText = JSON.stringify(responseJson);</span><br><span class="line">    console.log(&quot;response :&quot; + responseText);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (responseText.length &lt; 1024 * 6) &#123;</span><br><span class="line">        this.socket.send(responseText);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.base64) &#123;</span><br><span class="line">        responseText = this.base64Encode(responseText)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //澶ф姤鏂囪鍒嗘浼犺緭</span><br><span class="line">    var segmentSize = 1024 * 5;</span><br><span class="line">    var i = 0, totalFrameIndex = Math.floor(responseText.length / segmentSize) + 1;</span><br><span class="line"></span><br><span class="line">    for (; i &lt; totalFrameIndex; i++) &#123;</span><br><span class="line">        var frameData = JSON.stringify(&#123;</span><br><span class="line">                __sekiro_frame_total: totalFrameIndex,</span><br><span class="line">                __sekiro_index: i,</span><br><span class="line">                __sekiro_seq__: seq,</span><br><span class="line">                __sekiro_base64: this.base64,</span><br><span class="line">                __sekiro_is_frame: true,</span><br><span class="line">                __sekiro_content: responseText.substring(i * segmentSize, (i + 1) * segmentSize)</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        console.log(&quot;frame: &quot; + frameData);</span><br><span class="line">        this.socket.send(frameData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.sendFailed = function (seq, errorMessage) &#123;</span><br><span class="line">    if (typeof errorMessage != &#x27;string&#x27;) &#123;</span><br><span class="line">        errorMessage = JSON.stringify(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    var responseJson = &#123;&#125;;</span><br><span class="line">    responseJson[&#x27;message&#x27;] = errorMessage;</span><br><span class="line">    responseJson[&#x27;status&#x27;] = -1;</span><br><span class="line">    responseJson[&#x27;__sekiro_seq__&#x27;] = seq;</span><br><span class="line">    var responseText = JSON.stringify(responseJson);</span><br><span class="line">    console.log(&quot;sekiro: response :&quot; + responseText);</span><br><span class="line">    this.socket.send(responseText)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.registerAction = function (action, handler) &#123;</span><br><span class="line">    if (typeof action !== &#x27;string&#x27;) &#123;</span><br><span class="line">        throw new Error(&quot;an action must be string&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof handler !== &#x27;function&#x27;) &#123;</span><br><span class="line">        throw new Error(&quot;a handler must be function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;sekiro: register action: &quot; + action);</span><br><span class="line">    this.handlers[action] = handler;</span><br><span class="line">    return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.encodeWithBase64 = function () &#123;</span><br><span class="line">    this.base64 = arguments &amp;&amp; arguments.length &gt; 0 &amp;&amp; arguments[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SekiroClient.prototype.base64Encode = function (s) &#123;</span><br><span class="line">    if (arguments.length !== 1) &#123;</span><br><span class="line">        throw &quot;SyntaxError: exactly one argument required&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = String(s);</span><br><span class="line">    if (s.length === 0) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _get_chars(ch, y) &#123;</span><br><span class="line">        if (ch &lt; 0x80) y.push(ch);</span><br><span class="line">        else if (ch &lt; 0x800) &#123;</span><br><span class="line">            y.push(0xc0 + ((ch &gt;&gt; 6) &amp; 0x1f));</span><br><span class="line">            y.push(0x80 + (ch &amp; 0x3f));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            y.push(0xe0 + ((ch &gt;&gt; 12) &amp; 0xf));</span><br><span class="line">            y.push(0x80 + ((ch &gt;&gt; 6) &amp; 0x3f));</span><br><span class="line">            y.push(0x80 + (ch &amp; 0x3f));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var _PADCHAR = &quot;=&quot;,</span><br><span class="line">        _ALPHA = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,</span><br><span class="line">        _VERSION = &quot;1.1&quot;;//Mr. Ruan fix to 1.1 to support asian char(utf8)</span><br><span class="line"></span><br><span class="line">    //s = _encode_utf8(s);</span><br><span class="line">    var i,</span><br><span class="line">        b10,</span><br><span class="line">        y = [],</span><br><span class="line">        x = [],</span><br><span class="line">        len = s.length;</span><br><span class="line">    i = 0;</span><br><span class="line">    while (i &lt; len) &#123;</span><br><span class="line">        _get_chars(s.charCodeAt(i), y);</span><br><span class="line">        while (y.length &gt;= 3) &#123;</span><br><span class="line">            var ch1 = y.shift();</span><br><span class="line">            var ch2 = y.shift();</span><br><span class="line">            var ch3 = y.shift();</span><br><span class="line">            b10 = (ch1 &lt;&lt; 16) | (ch2 &lt;&lt; 8) | ch3;</span><br><span class="line">            x.push(_ALPHA.charAt(b10 &gt;&gt; 18));</span><br><span class="line">            x.push(_ALPHA.charAt((b10 &gt;&gt; 12) &amp; 0x3F));</span><br><span class="line">            x.push(_ALPHA.charAt((b10 &gt;&gt; 6) &amp; 0x3f));</span><br><span class="line">            x.push(_ALPHA.charAt(b10 &amp; 0x3f));</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (y.length) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            var ch = y.shift();</span><br><span class="line">            b10 = ch &lt;&lt; 16;</span><br><span class="line">            x.push(_ALPHA.charAt(b10 &gt;&gt; 18) + _ALPHA.charAt((b10 &gt;&gt; 12) &amp; 0x3F) + _PADCHAR + _PADCHAR);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case 2:</span><br><span class="line">            var ch1 = y.shift();</span><br><span class="line">            var ch2 = y.shift();</span><br><span class="line">            b10 = (ch1 &lt;&lt; 16) | (ch2 &lt;&lt; 8);</span><br><span class="line">            x.push(_ALPHA.charAt(b10 &gt;&gt; 18) + _ALPHA.charAt((b10 &gt;&gt; 12) &amp; 0x3F) + _ALPHA.charAt((b10 &gt;&gt; 6) &amp; 0x3f) + _PADCHAR);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return x.join(&quot;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-油猴工具插件"><a href="#4-油猴工具插件" class="headerlink" title="4. 油猴工具插件"></a>4. 油猴工具插件</h3><blockquote><p><strong>Tampermonkey油猴：</strong>是一款浏览器扩展程序，用于管理和运行用户脚本。它最初是为Google Chrome设计的，但后来也支持了其他主流浏览器，如Mozilla Firefox、Microsoft Edge、Safari等。Tampermonkey的主要功能是允许用户自定义网页上的行为，通过运行脚本来修改、增强或自动化网页功能（<a class="link"   href="https://greasyfork.org/zh-CN"  target="_blank" rel="noopener">油猴脚本搜索<i class="fas fa-external-link-alt"></i></a>）</p><p><strong>注意：使用油猴注入脚本时，例如通过 RPC 技术逆向加密时，要注意导出的方法或属性必须是全局作用域的</strong></p></blockquote><ul><li><strong>@name：</strong><ul><li>作用：指定用户脚本的名称</li><li>示例：<code>@name My Awesome Script</code></li></ul></li><li><strong>@namespace：</strong><ul><li>作用：定义用户脚本的命名空间，确保脚本名称的唯一性</li><li>示例：<code>@namespace http://www.example.com/</code></li></ul></li><li><strong>@version：</strong><ul><li>作用：指定用户脚本的版本号，用于跟踪脚本的更新</li><li>示例：<code>@version 1.0</code></li></ul></li><li><strong>@description：</strong><ul><li>作用：提供用户脚本的简要描述，描述脚本的功能和用途</li><li>示例：<code>@description Adds a download button to images on example.com</code></li></ul></li><li><strong>@author：</strong><ul><li>作用：指定用户脚本的作者</li><li>示例：<code>@author Your Name</code></li></ul></li><li><strong>@match：</strong><ul><li>作用：定义用户脚本要运行的网页地址（URL匹配模式）。只有匹配的页面才会执行脚本</li><li>示例：<code>@match https://www.example.com/*</code></li></ul></li><li><strong>@include：</strong><ul><li>作用：类似于@match，定义用户脚本要运行的网页地址。可以使用通配符</li><li>示例：<code>@include https://www.example.com/*</code></li></ul></li><li><strong>@icon：</strong><ul><li>作用：指定用户脚本在 Tampermonkey 管理界面中显示的图标</li><li>示例：<code>@icon https://www.example.com/icon.png</code></li></ul></li><li><strong>@grant：</strong><ul><li>作用：定义用户脚本需要的权限。常见值包括 none、GM_addStyle、GM_xmlhttpRequest 等</li><li>示例：<code>@grant GM_addStyle</code></li></ul></li><li><strong>@require：</strong><ul><li>作用：声明用户脚本所依赖的外部 javascript 脚本。确保这些脚本在当前脚本执行之前加载</li><li>示例：<code>@require https://code.jquery.com/jquery-3.6.4.min.js</code></li></ul></li><li><strong>@run-at：</strong><ul><li>作用：指定用户脚本的执行时机。可选值包括 document-start、document-end 和 document-idle。</li><li>示例：<code>@run-at document-end</code></li></ul></li></ul><h2 id="四、JSVMP技术专题"><a href="#四、JSVMP技术专题" class="headerlink" title="四、JSVMP技术专题"></a>四、JSVMP技术专题</h2><blockquote><p><strong>JSVMP（Virtual Machine based code Protection for JavaScript）：</strong>在JavaScript代码保护过程中引入代码虚拟化思想，通过 JS 加密实现源代码的虚拟化过程，将目标代码通过 JS 加密转换成自定义的字节码，这些字节码只有特殊的解释器才能识别，从而隐藏目标代码的关键逻辑。</p><p><strong>JS虚拟化基本保护过程：</strong>JS虚拟化保护通常以二进制可执行程序为保护目标，其核心是用自定义的虚拟指令模拟替换目标程序指令，并编码成特殊的<strong>字节码</strong>和特殊的<strong>虚拟解释器</strong>嵌入到目标文件中，在运行时虚拟解释器调度特殊的解释程序，才能解释自定义字节码并最终还原源码的功能。由于虚拟化保护在带来高强度的保护效果的同时也会带来较大的性能开销，所以通常JS虚拟化主要用于保护关键代码段。</p><p><strong>JSVMP大致架构：</strong>服务器端读取 JavaScript 代码 —&gt; 词法分析 —&gt; 语法分析 —&gt; 生成AST语法树 —&gt; 生成私有指令 —&gt; 生成对应私有解释器，将私有指令加密与私有解释器发送给浏览器，然后一边解释，一边执行</p><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1710164925-69bb447e98dbb4b.png"                         style="width:80%;margin:0 auto;"                 ><p><strong>JSVMP的三种逆向方法：</strong>RPC远程调用，补环境，日志断点还原算法。其中日志断点也称为<strong>插桩</strong>，找到关键位置，输出关键参数的日志信息，从结果往上倒推生成逻辑，以达到算法还原的目的。</p></blockquote><h3 id="1-日志插桩原理"><a href="#1-日志插桩原理" class="headerlink" title="1. 日志插桩原理"></a>1. 日志插桩原理</h3><ul><li><strong>jsvmp 的程序运行逻辑：</strong><ol><li><strong>指令集和栈操作</strong>：**<span style="color:red;">jsvmp 的核心运行逻辑通过一系列指令来实现</span><strong>，每个指令对应特定的逻辑操作，</strong><span style="color:red;">主要通过栈（stack）操作来实现</span>**，这些指令组成一个指令集，用于执行 js 代码</li><li><strong>指令循环</strong>：由于有很多指令需要逐一执行，**<span style="color:red;">jsvmp 需要使用一个循环结构 ( for ) 来逐步执行每个指令</span>**。这意味着每个指令在循环中都会被处理和执行</li></ol></li><li><strong>细化指令执行过程：</strong><ul><li><strong>复杂性增加</strong>：<strong>jsvmp 会将每个操作细化到单独的指令</strong>。例如一个简单的字符串 “Drt342&#x3D;” 的生成过程，字符 D 可能需要运行 10 个指令（10条 if 语句）才可以生成。那就需要将这10个指令的逻辑反推出来，以理解和生成字符 D，以此类推，每个字符都需要详细分析和反推相应的指令逻辑</li></ul></li><li><strong>日志还原算法：</strong><ol><li><strong>日志输出和栈实现：</strong>在 jsvmp 中，**<span style="color:red;">日志通常指的是程序执行过程中的输出栈</span>**。这些栈是通常是通过 array 数组来实现的。在实际案例中，可以将每个 if-else 分支代码块视为一个指令，这些指令在栈中操作数组</li><li><strong>分支记录：</strong>通过记录每个 if-else 分支的执行情况，可以还原指令的执行过程。这有助于理解程序的执行逻辑和栈的变化情况</li></ol></li><li><strong>日志插桩技术：</strong><ol><li><strong>关键位置插桩：</strong>插桩一定是在所有循环中插桩，单个大循环则看其有几个大的 if 语句决定插桩个数，多个大循环则需在每个大循环中插桩，因为指令是基于循环运行的</li><li><strong>索引定位：</strong>仅仅输出数组内容可能不够精确，为了更好地定位每个指令的执行位置，需要在日志中打印一些索引值。这些索引值可以帮助定位特定指令的执行位置，从而更准确地分析和还原执行过程</li></ol></li></ul><h3 id="2-条件断点定位"><a href="#2-条件断点定位" class="headerlink" title="2. 条件断点定位"></a>2. 条件断点定位</h3><blockquote><p><strong>特点：条件断点和日志断点配合使用，是因为 jsvmp 通常是在一条语句反复无限生成结果值</strong></p><p><strong>在调试跟栈过程中：</strong></p><ol><li><strong>观察是否存在 jsvmp 结构（大量 if-else 分支，内部数组操作，外部嵌套循环）</strong></li><li><strong>如果是 jsvmp 结构，则考虑是否是在此处通过 jsvmp 指令生成的加密值</strong></li></ol></blockquote><ul><li><strong>分析过程：</strong><ol><li>先下日志断点，观察日志中是否有目标加密数据的生成，同时分析加密数据的特征、长度等</li><li>再下条件断点，根据加密数据的特征进行条件断点，便能在每次调试过程中精准定位具体加密位置</li></ol></li></ul><h3 id="3-jsvmp纯算实现"><a href="#3-jsvmp纯算实现" class="headerlink" title="3. jsvmp纯算实现"></a>3. jsvmp纯算实现</h3><blockquote><p><strong><span style="color:red;">日志插桩代码：</span>主要记录和分析栈（数组）的操作，每个 if-else 分支代码块可以视为一个独立的指令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;位置 1&quot;, &quot;索引m&quot;, m, &quot;索引r&quot;, r, &quot;值p: &quot;, JSON.stringify(p, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)</span><br><span class="line"></span><br><span class="line">&quot;位置 2&quot;, &quot;索引m&quot;, m, &quot;索引r&quot;, r, &quot;值p: &quot;, JSON.stringify(p, function(key, value) &#123;if (value == window) &#123;return undefined&#125; return value&#125;)</span><br></pre></td></tr></table></figure><p><strong><span style="color:red;">纯算法实现注意点（<a class="link"   href="https://www.douyin.com/"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</span></strong></p><ol><li>定位至加密位置，观察分析加密位置附近代码，<strong>是否存在大量的 if-else 语句或由<span style="color:red;">数组</span>推动的代码结构</strong>，合理考虑 jsvmp 情况，那么外层一定存在 for 循环用于逐步执行所有的 if-else 分支</li><li><strong>在加密位置向下调试走出当前 lf-else 分支，通常可以回到 for 循环推动指令执行的语句位置，其外层的函数便是 jsvmp 的虚拟解释器，函数实参便是被编码成的特殊字节码</strong></li><li>在正确位置日志插桩，若输出日志含有报错信息，首先在控制台输出加密位置对象中的加密值，然后复制其加密值在当前日志中搜索，如果存在则日志无误，右击另存为日志文件，在本地分析</li></ol></blockquote><ul><li><p><strong>JSVMP 特征：</strong></p><ol><li>定位至加密位置，观察分析加密位置附近代码，<strong>是否存在大量的 if-else 语句或由<span style="color:red;">数组</span>推动的代码结构</strong>，合理考虑 jsvmp 情况，那么外层一定存在 for 循环用于逐步执行所有的 if-else 分支（<a class="link"   href="https://www.douyin.com/"  target="_blank" rel="noopener">抖音<i class="fas fa-external-link-alt"></i></a>）</li><li>定位至加密位置，看堆栈是否存在连续多个 VM 文件帧，存在则定位至所有 VM 文件前一帧，一般是入口，在入口 jsvmp 大概率通过类似 eval 等函数执行，生成加密值（<a class="link"   href="https://hotels.ctrip.com/hotels/list?countryId=1&city=34&checkin=2024/06/06&checkout=2024/06/07&optionId=34&optionType=City&directSearch=0&display=%E6%98%86%E6%98%8E%2C%20%E4%BA%91%E5%8D%97%2C%20%E4%B8%AD%E5%9B%BD&crn=1&adult=1&children=0&searchBoxArg=t&travelPurpose=0&ctm_ref=ix_sb_dl&domestic=1&&highPrice=-1&barCurr=CNY&hotPoi=50%7C50%7C2467737&sort=1"  target="_blank" rel="noopener">携程<i class="fas fa-external-link-alt"></i></a>）</li></ol></li><li><p><strong>重点技巧：</strong></p><ol><li><strong>调试：</strong>日志断点和条件分析断点通常下在<strong>重点条件增改处</strong>，例如 i[r++]、switch(i[r++]) 处</li><li><strong>凡是涉及由 i[r++] 参与计算生成的值，一般都是固定的，可以观察同样索引位置以确定其是否变化。也存在特殊情况，例如连续有大段数据都是固定的，那么数据可能在很前面就已经生成过的，这种情况只能多注意，应该多多观察整体日志大概哪些位置输出了关于什么的值，有个基础印象才能更准确的还原</strong></li><li>如果一个数据，是在另一个数组里面取的，那说明定位的地方并不是数据生成的位置（<strong>思维误区：会认为需要去找这个数组中这个数据怎么生成的</strong>），应该直接搜索数据第一次出现的地方，才是数据生成的位置</li><li>对于有些数据中需要还原大量的单个数据，可以直接打印两份日志进行比对，从而分析出固定与动态数据（如果一组数据多次调试都是相同数据，那么直接拿下来即可）</li></ol></li><li><p><strong>重点思路：</strong></p><ol><li>使用固定的算法生成固定的数组，再用一定的算法打乱数组顺序，最后去取数组中的元素，那么这个数组的整个生成到使用过程都是固定的，则<strong>最好的处理就是以调用顺序手动还原为一个新数组</strong></li></ol></li></ul><h2 id="七、Cookie反爬专题"><a href="#七、Cookie反爬专题" class="headerlink" title="七、Cookie反爬专题"></a>七、Cookie反爬专题</h2><h3 id="1-服务器cookie响应"><a href="#1-服务器cookie响应" class="headerlink" title="1. 服务器cookie响应"></a>1. 服务器cookie响应</h3><blockquote><p><strong>加密原理：</strong>当第一次向服务器发送请求时，服务器可以在响应头部返回一个名为 “Set-Cookie” 的标头，以便在浏览器中设置 Cookie 信息。在后续请求时， 携带第一次服务器响应设置的 Cookie 信息，服务器就可以根据 Cookie 辨别用户身份或者其他相关信息，并作出正确的数据响应（<a class="link"   href="http://www.zjmazhang.gov.cn/hdjlpt/published?via=pc"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</p></blockquote><ul><li><strong>特点：</strong>HttpOnly 属性值均设置为 ture，此时浏览器将禁止 js 脚本访问该 Cookie，所以 document.cookie 值为空，同时无法通过 Hook 技术截停 Cookie 值的设置过程，因为 Cookie 信息是由服务器响应设置的</li><li><strong>策略：</strong>无需逆向，需要先请求一次（通常是首页），获取服务器响应设置的 Cookie 信息，再携带此 Cookie 信息进行后续请求，便可得到正确的响应数据</li></ul><h3 id="2-阿里系cookie逆向"><a href="#2-阿里系cookie逆向" class="headerlink" title="2. 阿里系cookie逆向"></a>2. 阿里系cookie逆向</h3><blockquote><p><strong>加密原理：</strong>服务器返回一段 js 代码，在浏览器端解析并执行该代码以生成并加密 Cookie 信息（<a class="link"   href="https://xueqiu.com/today"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</p></blockquote><ul><li><strong>特点：</strong>Cookie 信息中包含 <code>acw_sc__v2</code>、<code>acw_tc</code> 等键</li><li><strong>策略：</strong>利用油猴 Hook cookie 跟栈分析，清除 Cookie 值后有无限 debugger，注入清除 debugger 脚本即可</li></ul><h3 id="3-加速乐cookie逆向"><a href="#3-加速乐cookie逆向" class="headerlink" title="3. 加速乐cookie逆向"></a>3. 加速乐cookie逆向</h3><blockquote><p><strong>加密原理：</strong>服务器返回一段 js 代码，在浏览器端解析并执行该代码以生成并加密 Cookie 信息（<a class="link"   href="https://www.mafengwo.cn/i/5376978.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</p></blockquote><ul><li><p><strong>调用 go 函数的传参：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go(JSON.stringify(&#123;</span><br><span class="line">    &quot;bts&quot;: [&quot;1711334369.448|0|yZ3&quot;, &quot;EP4CKCu%2F8NldIzY3skErDc%3D&quot;],</span><br><span class="line">    &quot;chars&quot;: &quot;RGIskbUPRtOQFuGagnFfMv&quot;,</span><br><span class="line">    &quot;ct&quot;: &quot;d7d6440c2122453ff8cced0b6f90de01402adf19&quot;,</span><br><span class="line">    &quot;ha&quot;: &quot;sha1&quot;,</span><br><span class="line">    &quot;is&quot;: true,</span><br><span class="line">    &quot;tn&quot;: &quot;__jsl_clearance_s&quot;,</span><br><span class="line">    &quot;vt&quot;: &quot;3600&quot;,</span><br><span class="line">    &quot;wt&quot;: &quot;1500&quot;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ol><li>Cookie 信息中包含 <code>jsl</code>、<code>__jsl_clearance_s</code> 等键（<strong>注意调试前别忘记清空 Cookie 先</strong>）</li><li>在网络面板中打开<strong>保留日志</strong>，观察<strong>文档</strong>接口，会发现首页共请求 3 次，请求的前两次的<strong>状态码是 521</strong></li><li>前两次请求在 Google 浏览器中无法看到响应代码，但是 <strong>Hook 调试状态时可以</strong>，或<strong>切换浏览器直接查看</strong></li><li><strong>加速乐的 Cookie 变化是由调用 go 函数的传参决定的，</strong>参数校验存在于 bts 与 ct 参数之间，先对 bts 参数进行简单转换，并通过 ha 参数对应的加密类型对其加密，之后与 ct 参数值进行比较判断而完成校验</li><li><strong>ha 参数对应的加密类型有 3 种：MD5、SHA1 和 SHA256</strong></li></ol></li><li><p><strong>策略：</strong></p><ol><li>清除 Cookie 值，利用油猴 Hook cookie 跟栈分析（<strong>对应加速乐的请求次数进行 3 次请求</strong>）</li><li>每次请求都有服务器响应的 Cookie 信息，直接<strong>使用 session 会话</strong>进行请求，可自动携带此 Cookie 信息</li><li>对于 3 次请求，第一次得到响应代码通过 <code>execjs.eval</code> 生成初始的 Cookie 值，第二次携带此 Cookie 值请求得到响应代码，提取 go 函数的传参，逆向生成动态 Cookie 值，第三次携带此动态 Cookie 即可</li><li>对应 3 种加密类型，则不能用网页单一的 hash 函数，而是<strong>对不同的 ha 参数值调用不同的哈希函数</strong></li></ol></li></ul><h2 id="八、瑞数rs安全产品"><a href="#八、瑞数rs安全产品" class="headerlink" title="八、瑞数rs安全产品"></a>八、瑞数rs安全产品</h2><blockquote><p><strong>瑞数动态安全 Botgate（机器人防火墙）：</strong>以动态安全技术为核心，通过动态封装、动态验证、动态混淆、动态令牌等技术对服务器网页底层代码持续动态变换，增加服务器行为的不可预测性，实现了从用户端到服务器端的全方位主动防护，为各类 Web、HTML5 提供强大的安全保护，多用于政企、金融、运营商行业。</p></blockquote><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1711359593-18b9dfd620dbeee.webp"                         style="width:80%;margin:0 auto;"                 ><h3 id="1-瑞数rs4"><a href="#1-瑞数rs4" class="headerlink" title="1. 瑞数rs4"></a>1. 瑞数rs4</h3><blockquote><p><strong>加密逻辑：</strong>第一次 202 响应码的请求返回一段 HTML 代码，由其中的自执行函数对外链引入的 js 文件中的乱码进行解析，还原成后续瑞数入口中执行的 1w+ 行的正常代码，创建多个 VM 文件动态生成 Cookie 值，同时 meat 标签中的 content 内容也会在环境中用到（**使用补环境逆向生成 Cookie 信息，<a class="link"   href="http://www.fangdi.com.cn/index.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>**）</p><p><strong>瑞数检测：瑞数会检测调用的 js 文件的地址，即 __dirname 和 __filename 字段，错误则<span style="color:red;">响应 400 状态码</span></strong></p><p><strong>解决方案：在逆向瑞数的本地 js 文件中，直接删除这两个字段，加上此前缀</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete __dirname</span><br><span class="line">delete __filename</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>第一次响应的 HTML 文件的结构：</strong><ol><li><strong>动态生成的 meat 标签：</strong>标签内 content 内容每次都是变化的</li><li><strong>固定引用的外链 js 文件：</strong>同一个网站同一个页面里的引用 js 内容一般是固定不会变的</li><li><strong>动态生成的 js 自执行函数：</strong>自执行代码每次变化的只是变量名，整体逻辑不变</li></ol></li><li><strong>特点：</strong><ol><li><strong>2 次无限 debugger：</strong>可直接右键<strong>一律不在此处暂停</strong>，也可以注入 Hook 脚本过掉</li><li><strong>3 次请求：</strong>首次请求首页<strong>响应码是 202（瑞数3、4代）</strong>，接着<strong>单独请求一个 js 文件</strong>，然后再次请求首页响应码是 <strong>200</strong>。在 XHR 请求中，后缀都带有 <strong><code>MeEwMD=4xxx</code></strong> 关键字，其中<strong>后缀值的第一个数字即为瑞数的版本</strong>，这是由 js 生成的（<strong>不打开网络面板的保留日志，正好可以看到响应码 202 请求的响应数据</strong>）</li><li><strong>2 个特殊 Cookie：<code>FSSBBIl1UgzbN7N80S</code> 和 <code>FSSBBIl1UgzbN7N80T</code>，</strong>以 S 结尾的是第一次请求首页响应设置的 Cookie，以 T 结尾的是由第一次请求首页返回的 HTML 中的 js 代码生成的动态 Cookie。T 和 S 前面的数字是 http 协议的默认端口号，后面<strong>值的第一位数字表示瑞数的版本</strong></li><li><strong>瑞数的入口：浏览器中 VM 文件是由 call、eavl 执行创建的，</strong>在 Hook Cookie 后跟栈会有大量的 VM 文件，所以在所有 VM 文件的上一帧便是瑞数生成 Cookie 的入口。此处 3、4 代瑞数可见关键字 eval、call，关键字可能被混淆，4 代会多一个 <strong>ret</strong> 关键字</li></ol></li><li><strong>策略与技巧：</strong><ol><li><strong>吐环境脚本，</strong>并不一定是最后一个环境不存在导致的报错，而是<strong>首要根据报错内容在网页分析</strong>，因为可能是因为存在 if 判断或 try 捕获一场，由于其上一个环境不足，导致走了这个环境而吐出这个环境</li><li><strong>补环境原则：</strong>需要什么补什么，需要补的环境<strong>先补上再看报错</strong>，不一定要一次性补全。其中删除方法可以不返回或返回空对象，创建方法则看网页创建的什么对应创建空对象或其他</li><li><strong>补环境技巧：</strong>报具体错误就进入网页调试，有调用就补方法；下一层才调用就补对象，对象里面再补方法；不报具体错误就无法进入网页调试，那就不知道是对象还是方法，可以都试一下。其中参数进行日志打印，打印后对应网页情况使用 if 针对参数补环境（<strong>根据网页的返回值，网页返回什么本地就返回什么</strong>）</li><li><strong>注意：</strong>补环境完成后，即不报错也不继续吐环境了，但数据不对，则<strong>需要观察在补环境过程中打印的日志</strong>，有没有再次被调用而传递了新参数，但是新参数的环境并没有补的情况</li></ol></li></ul><h3 id="2-瑞数rs5"><a href="#2-瑞数rs5" class="headerlink" title="2. 瑞数rs5"></a>2. 瑞数rs5</h3><blockquote><p><strong>注意：</strong>瑞数 5 代的加密逻辑、检测、文件结构、策略、补环境技巧与瑞数 4 代一模一样，唯二不同的便是其<strong>第一次请求首页的响应状态码是 412</strong> 和 <strong>Cookie信息中不包含 http 端口号了</strong>（**<a class="link"   href="https://sugh.szu.edu.cn/Html/News/Columns/6/Index.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>**）</p></blockquote><ul><li><p><strong>2 个特殊 Cookie：<code>ihkYnttrQXfVO</code> 和 <code>ihkYnttrQXfVP</code>，</strong>以 O 结尾的是第一次请求首页响应设置的 Cookie，以 P 结尾的是由第一次请求首页返回的 HTML 中的 js 代码生成的动态 Cookie，<strong>两个 Cookie 信息的值首位数字为 5 代表瑞数的版本</strong></p></li><li><p><strong>补环境中的标签补法，从第二个标签开始，没有具体报错信息：</strong>此时可以在浏览器的控制台中，直接执行混淆对应的具体实现代码，根据返回值先补即可，如果没有完整会报错的</p></li><li><p><strong>遇到一种特殊报错，补环境方式：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 【吐环境】：方法：get   获取属性：document.documentElement   属性值类型: undefined</span><br><span class="line">// 【报错】：TypeError: Cannot read properties of undefined (reading &#x27;addEventListener&#x27;)</span><br><span class="line">// 【补环境】：</span><br><span class="line">document = &#123;</span><br><span class="line">    documentElement: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 【吐环境】：方法：get   获取属性：document.documentElement   属性值类型: object</span><br><span class="line">// 【报错】：TypeError: _$6T[_$Zx[794]] is not a function</span><br><span class="line">// 【补环境】：</span><br><span class="line">document = &#123;</span><br><span class="line">    documentElement: &#123;</span><br><span class="line">        addEventListener: function (res) &#123;</span><br><span class="line">            console.log(&quot;document.documentElement.addEventListener的参数：&quot;, res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-瑞数rs6"><a href="#3-瑞数rs6" class="headerlink" title="3. 瑞数rs6"></a>3. 瑞数rs6</h3><blockquote><p><strong>注意：</strong>瑞数 6 代与瑞数 4、5 代最大的差异，就是其首次<strong>响应返回的 Html 文件的结构不同</strong>，瑞数 6 将原本动态加载的<strong>自执行函数</strong>转变为固定引入的<strong>外链 js 文件</strong>，而将原本固定引入的外链 js 文件转变为了动态加载在 script 标签内的代码，<strong>相当于将两者加载方式调换</strong>，另 meta 标签的 content 数据依然是动态的（**<a class="link"   href="https://kscd.zking.com/app/vehicle/proposal/commonlogin"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>**）</p><p><strong>其余关键特点：</strong>与瑞数 5 代的 <strong>412+200 响应状态码</strong>、加密逻辑、检测、策略、补环境技巧几乎一致</p></blockquote><ul><li><strong>2 个特殊 Cookie：<code>hvAJjymUYBa3O</code> 和 <code>hvAJjymUYBa3P</code>，</strong>以 O 结尾的是第一次请求首页响应设置的 Cookie，<strong>其值首位数字一般为 6 代表瑞数的版本</strong>，以 P 结尾的是由第一次请求首页返回的 HTML 中的 js 代码生成的动态 Cookie，<strong>其值首位数字一般为 0 是瑞数 6 的特点</strong></li><li><strong>面对复杂环境，调试时有多个调试处，可以直接 Hook拦截其调用（断在调用 call 时进行 Hook 并执行）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var originalcreateElement = window.callPhantom;</span><br><span class="line">    window.callPhantom = function (res) &#123;</span><br><span class="line">        // 在这里插入您的调试代码</span><br><span class="line">        console.log(&quot;参数：&quot;, res);</span><br><span class="line">        debugger;</span><br><span class="line">        return originalcreateElement.apply(this, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li><p><strong>瑞数 6 的技巧：</strong></p><ol><li><strong>在网页中复制 ts&#x2F;ss 文件代码和 js 自执行函数代码时都不要格式化，会有检测，左下角取消格式化后复制</strong></li><li><strong>报错 TypeError: _$xx[_$xx[x]] is not a function：</strong>非常常见的错误，要考虑多方面因素补环境，一是可以根据网页内容调试异常代码补环境，二是要根据吐的环境分析，如果吐的环境一眼能看出是对象，那么可能异常并不是因为吐的环境不存在而抛出的，此时需要观察其余环境是否补完整（<strong>参考瑞数 5 异常</strong>）</li></ol></li><li><p><strong>瑞数 6 注意的问题：</strong></p><ol><li><p><strong>吐环境脚本运行时被卡住，类似定时器：</strong>考虑了置空定时器的方式，还有压缩混淆代码的方式，但是都没有用，此时应该直接<strong>补上已吐出的 undefined 未定义属性的环境</strong></p></li><li><p><strong>补 window.localStorage 和 sessionStorage 的环境：</strong>最好在 Hook Cookie 时输出，此时环境最完整</p></li><li><p><strong>瑞数 6 调用 document.getElementsByTagName 的参数 script 标签<span style="color:red;">必须</span>直接补空数组，不检测</strong></p></li><li><p><strong>瑞数 6 的 window 环境不宜补多，一般只补以下环境（navigator也可能不检测，重点在document）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.top = window;</span><br><span class="line">window.self = window;</span><br><span class="line">window.CollectGarbage = function () &#123;&#125;</span><br><span class="line">window.ActiveXObject = function () &#123;&#125;  // 瑞数5、6都检测了</span><br><span class="line">window.addEventListener = function () &#123;&#125;</span><br><span class="line">window.attachEvent = function () &#123;&#125;</span><br><span class="line">window.HTMLFormElement = function () &#123;&#125;</span><br><span class="line">// window.localStorage</span><br><span class="line">// window.sessionStorage</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="九、国外系列产品"><a href="#九、国外系列产品" class="headerlink" title="九、国外系列产品"></a>九、国外系列产品</h2><h3 id="0-代理相关"><a href="#0-代理相关" class="headerlink" title="0. 代理相关"></a>0. 代理相关</h3><ul><li><p><strong>代理片段：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def generate_random_string(length=8):</span><br><span class="line">    characters = string.ascii_letters + string.digits</span><br><span class="line">    random_string = &#x27;&#x27;.join(random.choice(characters) for _ in range(length))</span><br><span class="line">    return random_string</span><br><span class="line"></span><br><span class="line">def set_proxy():</span><br><span class="line">    username = &#x27;astoip3305&#x27;</span><br><span class="line">    password = &#x27;ZUOPGEE-CNJYIFI-TDJECSC-AJGS2TC-STK0IZ0-Y57LNII-UY3FEGD&#x27;</span><br><span class="line">    proxy_host = &quot;209.205.219.18&quot;</span><br><span class="line">    proxy_port = random.choice(range(9001, 9050))</span><br><span class="line"></span><br><span class="line">    proxy = f&quot;http://&#123;username&#125;:&#123;password&#125;@&#123;proxy_host&#125;:&#123;proxy_port&#125;&quot;</span><br><span class="line">    proxies = &#123;</span><br><span class="line">        &quot;http&quot;: proxy,</span><br><span class="line">        &quot;https&quot;: proxy</span><br><span class="line">    &#125;</span><br><span class="line">    return proxies</span><br></pre></td></tr></table></figure></li><li><p><strong>代理相关配置：</strong></p><ol><li><p><strong>requests 库 proxies 的设置：</strong>其中键名 http 和 https 是代表请求自动选择协议，而后面的链接则是代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy = &#x27;43.159.26.218:19396&#x27;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    &#x27;http&#x27;: f&#x27;http://&#123;proxy&#125;&#x27;,</span><br><span class="line">    &#x27;https&#x27;: f&#x27;http://&#123;proxy&#125;&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Postman 的技巧：</strong>import 直接导入 curl 请求，自动生成请求，进行 send 发包，在右上角 code 中可以转换为 python 请求代码（Proxyman 抓包可以直接在抓包中生成复制 python 代码）</p></li><li><p><strong>浏览器代理插件 Proxy SwitchyOmega：</strong>固定浏览器代理，适用于需要测试浏览器代理与 python 代码的代理需一致的情况，同时可以测试出代理是否生效（而不需要复杂的配置浏览器代理，检查 ip 问题）</p></li></ol></li></ul><h3 id="1-TLS指纹"><a href="#1-TLS指纹" class="headerlink" title="1. TLS指纹"></a>1. TLS指纹</h3><blockquote><p><strong>TLS&#x2F;JA3指纹：</strong>TLS 指纹是用来识别和跟踪 TLS（传输层安全）连接的一种方法。TLS 指纹的基本思想是通过识别 TLS 握手过程中使用的加密算法和其他参数来确定特定连接的唯一标识。这种唯一标识可以用于识别特定的应用程序、设备或者用户。TLS 握手是 TLS 连接建立的过程，包括客户端和服务器之间的通信，以确保双方都能够安全地通信。在握手过程中，客户端和服务器会协商使用的加密算法、密钥长度等参数。TLS 指纹就是根据这些参数的组合来识别连接的。</p><p><strong>导致后果：</strong>Requests 库是基于 urllib3 进行底层的HTTP通信，因此在通信时也会生成对应的指纹。那么服务器就可以通过检测指纹是否来自合法的客户端，而决定是否返回正确的数据（**特点响应 500、403、302，<a class="link"   href="https://ascii2d.net/"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://www.twayair.com/app/booking/chooseItinerary"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>**）</p><p><strong>响应 500：</strong>是说明此次请求的构建就是存在问题的，大概率是请求参数 data 的问题。还有一个点，也可能是需要前后文呼应，需要先请求一些必要的接口再请求此接口才可以响应成功</p><blockquote><p>谷歌缓存访问：<code>https://webcache.googleusercontent.com/search?q=cache:https://xfblog.cn</code></p></blockquote></blockquote><ul><li><p><strong>绕过检测解决方案（curl_cffi 比 tls_client 速度快，curl_cffi 处理 http2 有 bug）：</strong></p><ol><li><p><strong><a class="link"   href="https://github.com/yifeikong/curl_cffi"  target="_blank" rel="noopener">curl_cffi 库<i class="fas fa-external-link-alt"></i></a>：</strong>支持 JA3&#x2F;TLS 和 http2 指纹模拟，包括最近的浏览器和自定义指纹，比 request&#x2F;httpx 快得多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from curl_cffi import requests</span><br><span class="line"></span><br><span class="line">r = requests.get(&quot;https://tools.scrapfly.io/api/fp/ja3&quot;, impersonate=&quot;chrome&quot;)  # 使用最新版本 Chrome</span><br><span class="line"></span><br><span class="line">s = requests.Session()  # 创建一个 Session 对象，在多个请求之间保持状态的信息（如登录会话）</span><br></pre></td></tr></table></figure></li><li><p><strong><a class="link"   href="https://github.com/FlorianREGAZ/Python-Tls-Client"  target="_blank" rel="noopener">tls-client 库<i class="fas fa-external-link-alt"></i></a>：</strong>一个基于 requests 和 tls-client 的高级 HTTP 库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import  </span><br><span class="line"></span><br><span class="line">session = tls_client.Session(random_tls_extension_order=True)</span><br><span class="line">r = session.get(&quot;https://tools.scrapfly.io/api/fp/ja3&quot;)  # 使用最新版本 Chrome</span><br></pre></td></tr></table></figure></li><li><p><strong><a class="link"   href="https://github.com/encode/httpx"  target="_blank" rel="noopener">httpx 库<i class="fas fa-external-link-alt"></i></a>：</strong>功能齐全的 HTTP 客户端库，包括一个集成的命令行客户端，支持<strong>HTTP&#x2F;1.1 和 HTTP&#x2F;2</strong>，并提供同步和异步 API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 用法之一：强制使用 TLS1.2 协议的场景</span><br><span class="line">import httpx</span><br><span class="line"></span><br><span class="line">r = httpx.get(&quot;https://tools.scrapfly.io/api/fp/ja3&quot;)</span><br><span class="line"></span><br><span class="line">session = httpx.Client()  # 会话机制</span><br></pre></td></tr></table></figure></li></ol></li><li><p>查看TLS指纹：<a class="link"   href="https://tls.browserleaks.com/json"  target="_blank" rel="noopener">416ca8550ccbff6ccaf4c8ce90b50a56<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tls = &#123;</span><br><span class="line">    &quot;user_agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36&quot;,</span><br><span class="line"></span><br><span class="line">    # JA3是一种基于TLS客户端hello消息中的加密算法和其他参数生成的指纹。</span><br><span class="line">    # 用于识别TLS连接的指纹，ja3_hash是JA3指纹的哈希值，ja3_text是原始的JA3指纹文本。</span><br><span class="line">    &quot;ja3_hash&quot;: &quot;2199eaa5f6183940450f0cfb5eaec221&quot;,</span><br><span class="line">    &quot;ja3_text&quot;: &quot;771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,18-13-11-27-35-10-0-65281-23-51-45-65037-17513-16-5-43,29-23-24,0&quot;,</span><br><span class="line"></span><br><span class="line">    # JA3n是JA3指纹的一个变体，用于在不同的TLS版本中识别相同的TLS配置。</span><br><span class="line">    # 与ja3_hash和ja3_text类似，ja3n_hash是JA3指纹的哈希值，ja3n_text是原始的JA3指纹文本。</span><br><span class="line">    &quot;ja3n_hash&quot;: &quot;473f0e7c0b6a0f7b049072f4e683068b&quot;,</span><br><span class="line">    &quot;ja3n_text&quot;: &quot;771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,0-5-10-11-13-16-18-23-27-35-43-45-51-17513-65037-65281,29-23-24,0&quot;,</span><br><span class="line"></span><br><span class="line">    # Akamai是一个内容传递网络（CDN）服务提供商，</span><br><span class="line">    # akamai_hash和akamai_text是对请求经过Akamai网络时的一些特征进行哈希和文本表示的结果。</span><br><span class="line">    # 用于识别请求是否经过Akamai网络服务的指纹。</span><br><span class="line">    &quot;akamai_hash&quot;: &quot;52d84b11737d980aef856699f885ca86&quot;,</span><br><span class="line">    &quot;akamai_text&quot;: &quot;1:65536;2:0;4:6291456;6:262144|15663105|0|m,a,s,p&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Akamai"><a href="#2-Akamai" class="headerlink" title="2. Akamai"></a>2. Akamai</h3><blockquote><p><strong>Akamai：</strong>Akamai是一家全球性的内容传递网络（CDN）和云服务提供商。主要服务是通过在全球范围内分布的服务器网络来加速互联网上的内容传输。简单来说，Akamai通过将网站、应用程序和其他数字内容存储在离用户更近的服务器上，从而提高了内容的交付速度和性能（<strong>其中 Akamai Cookie 加密的传递明文数据的是 1.75 版本，传递编码过后的数据是 2 版本</strong>）</p><p><strong>Akamai Cookie加密逻辑：</strong></p><ol><li>请求首页，响应 Set-Cookie 值为 <del>-1</del> 的 _abck 信息，并包含用于生成 Cookie 信息的外链的 js 文件</li><li>对外链的 js 文件先发送一次 GET 请求，携带首次响应设置的 Cookie 信息，响应设置新的 _abck 信息</li><li>**再对外链 js 文件发送一次 POST 请求，携带刚刚 GET 请求响应新设置的 _abck 值和其余 Cookie 信息，同时需要逆向载荷中的 <code>sensor_data</code> 参数，最终响应设置正确的值为 <del>0</del> 的 <code>_abck</code> 信息（<a class="link"   href="https://www.dhl.com/cn-zh/home.html?locale=true"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>**）</li></ol></blockquote><ul><li><strong>Akamai的解析思路：</strong><ol><li>先扣代码，再补环境，因为有大量的风控，只有扣一次代码才知道需要补哪些环境</li><li>最重要的是一个 58 位的数组需要解析，存在大量的风控</li><li>期间存在大量的控制平坦流，解决办法就是找返回值，在所有 case 语句的 return 处打断点，走进则对</li></ol></li><li><strong>风控（Anti-Fraud）</strong>：<ul><li><strong>行为分析</strong>：通过分析访问模式、用户行为等数据，来识别异常或可疑的访问</li><li><strong>设备指纹</strong>：对访问者的设备进行指纹识别，包括浏览器指纹、IP地址、操作系统等信息，以便追踪和识别恶意访问</li><li><strong>验证码</strong>：在认为访问行为异常或可疑时，可能会触发验证码验证，以确保访问者是真实的用户</li><li><strong>黑名单&#x2F;白名单</strong>：维护一份黑名单，记录已知的恶意IP地址或用户，并阻止它们的访问。同时，也会维护一份白名单，允许特定的用户或IP地址绕过风控机制</li></ul></li></ul><h3 id="3-5s盾"><a href="#3-5s盾" class="headerlink" title="3. 5s盾"></a>3. 5s盾</h3><blockquote><p><strong>最详细 5s 盾逆向分析：<a class="link"   href="https://blog.csdn.net/Ig_thehao/article/details/122966953"  target="_blank" rel="noopener">034a6eaf7a07233a456637e56db702a8<i class="fas fa-external-link-alt"></i></a></strong></p><p><strong>Cookie 的生成是与 IP 绑定的！！！</strong></p><p><strong>5s 盾的核心反爬机制：</strong></p><ol><li><strong>请求速率限制：</strong>5s 盾最主要的机制就是 IP 封锁，限制同一 IP 在短时间内发送的请求数量，如果一个 IP 地址的请求频率过高，可能会被临时或永久封禁，<strong>特征是请求响应 429 状态码</strong></li><li><strong>IP 全过程绑定：</strong>在整个 5s 盾流程中，IP 需要保持唯一，不可在过程中更换，否则后续请求响应异常</li><li><strong>TLS 指纹校验：</strong>请求需保持 TLS、UA、IP、Cookie 四者一致，针对 TLS 指纹可以通过 curl_cffi 库绕过检测，而部分网站存在强制使用 TLS1.2 协议的场景，<strong>响应 403 状态码，可以直接使用 httpx 库请求解决</strong></li></ol></blockquote><ul><li><strong>总结经验：</strong><ol><li><strong>调试方法学习：</strong>不要拿到一个网站直接在本地模拟代码要先在网页跑通整个流程，再用代码去跑，可以直接在网页复制接口请求，以 fetch 方式复制请求可以直接在网页请求，测试好后，再在本地模拟协议</li><li><strong>模拟协议：</strong>协议模拟后响应 200，但数据错误并提示会话过期等信息，那么可能是存在有漏了协议没有请求，需要抓包测试哪些接口有用，右键屏蔽某些接口，测试是否能获取数据，或弹出一样的会话过期信息</li></ol></li><li><strong>DrissionPage 浏览器过 5s 盾注意重点：</strong><ol><li>一定要注意 ua、ip、cookies 一致，自动化过完五秒盾，保存 redis 设计需要是 ip+cookies 格式</li><li>注意使用的代理 ip，如果代理 ip 只能在境外环境使用，那么注意即使三要素一致，协议请求时也会 403</li><li>测试三要素是否一致时，可以借助浏览器代理插件固定浏览器代理，代码代理也一致即可测试</li></ol></li></ul><h3 id="4-reese84"><a href="#4-reese84" class="headerlink" title="4. reese84"></a>4. reese84</h3><blockquote><p><strong>reesee84 cookie 生成逻辑：</strong></p><ol><li>请求动态算法以及动态 K 值的 js 文件</li><li>通过收集浏览器指纹通过动态算法生成数据提交服务器生成 token</li></ol></blockquote><ul><li><strong>调试细节总结：</strong><ol><li>生成 token 过程中以及使用 token 过程中必须保持 IP 不变</li><li>同一个 ip 尽量保持单个 token 使用，不然容易封杀 tls</li><li>单个 token 正常使用，可以多次长时间使用至失效</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">document.body.addBehavior = undefined</span><br><span class="line">window.openDatabase = function () &#123; &#125;</span><br><span class="line"></span><br><span class="line">fillRect = function () &#123; &#125;</span><br><span class="line">fillText = function () &#123; &#125;</span><br><span class="line">beginPath = function () &#123; &#125;</span><br><span class="line">closePath = function () &#123; &#125;</span><br><span class="line">fill = function () &#123; &#125;</span><br><span class="line">arc = function () &#123; &#125;</span><br><span class="line">getImageData = function () &#123; return ImageData_obj &#125;</span><br><span class="line">toDataURL = function () &#123; return &#125;</span><br><span class="line"></span><br><span class="line">canvas_two = document[&quot;createElement&quot;](&quot;canvas&quot;);</span><br><span class="line">canvas_two.toDataURL = function () &#123; return &quot;data:image/webpdwadwadwadwadwa&quot; &#125;; //带上&quot;data:image/webp&quot;放在首位即可</span><br><span class="line"></span><br><span class="line">canvas_three = document[&quot;createElement&quot;](&quot;canvas&quot;);</span><br><span class="line">CanvasRenderingContext2D_two = canvas_three[&quot;getContext&quot;](&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">canvas_four = document[&quot;createElement&quot;](&quot;canvas&quot;);</span><br><span class="line">CanvasRenderingContext2D_three = canvas_four[&quot;getContext&quot;](&quot;2d&quot;);</span><br><span class="line">CanvasRenderingContext2D_three.putImageData = function () &#123; &#125;</span><br><span class="line">canvas_four.toDataURL = function () &#123; return &#125;</span><br><span class="line"></span><br><span class="line">canvas_five = document[&quot;createElement&quot;](&quot;canvas&quot;);</span><br><span class="line">WebGLRenderingContext_one = canvas_five[&quot;getContext&quot;](&quot;webgl&quot;) || er[&quot;getContext&quot;](&quot;experimental-webgl&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebGLBuffer_one = WebGLRenderingContext_one[&quot;createBuffer&quot;] &amp;&amp; WebGLRenderingContext_one[&quot;createBuffer&quot;]();</span><br><span class="line">WebGLRenderingContext_one.bindBuffer = function</span><br><span class="line">.bufferData = function</span><br><span class="line">.createProgram = function</span><br><span class="line">.createShader = function</span><br><span class="line">.shaderSource</span><br><span class="line">        .compileShader</span><br><span class="line">        .attachShader</span><br><span class="line">        .linkProgram</span><br><span class="line">        .useProgram</span><br><span class="line">        .getAttribLocation = function () &#123; return ???&#125;</span><br><span class="line">            .getUniformLocation</span><br><span class="line">            .enableVertexAttribArray</span><br><span class="line">            .vertexAttribPointer</span><br><span class="line">            .uniform2f</span><br><span class="line">            .drawArrays</span><br><span class="line">            .canvas = &#123;</span><br><span class="line">                toDataURL: function () &#123; return &quot;&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                .readPixels = function () &#123; &#125;</span><br><span class="line"></span><br><span class="line">canvas_six = document[&quot;createElement&quot;](&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">CanvasRenderingContext2D_canvas_six = canvas_six[&quot;getContext&quot;](&quot;2d&quot;);</span><br><span class="line">CanvasRenderingContext2D_canvas_six.createImageData = function () &#123;</span><br><span class="line">    return ImageDataOBj]</span><br><span class="line">    CanvasRenderingContext2D_canvas_six.putImageData = function () &#123; &#125;</span><br><span class="line">    ImageDataOBj = &#123;</span><br><span class="line">        data: &#123;      //Uint8ClampedArray</span><br><span class="line">            set: function () &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas_six.toDataURL = function () &#123; return &quot;&quot; &#125;</span><br><span class="line"></span><br><span class="line">    WebGLRenderingContext_one.getSupportedExtensions = function () &#123; return [] &#125;</span><br><span class="line">        .getParameter = function () &#123; &#125;        &quot;ALIASED_LINE_WIDTH_RANGE&quot; / &quot;ALIASED_POINT_SIZE_RANGE&quot; / &quot;ALPHA_BITS&quot;</span><br><span class="line">            .getContextAttributes = function() &#123; return obj = &#123; antialias: true &#125; &#125;</span><br><span class="line">    &quot;BLUE_BITS&quot; / &quot;DEPTH_BITS&quot; / &quot;GREEN_BITS&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    window[&quot;WebGLRenderingContext&quot;][&quot;prototype&quot;][&quot;getParameter&quot;][&quot;name&quot;];</span><br><span class="line">    toString检测</span><br><span class="line">    navigator.maxTouchPoints</span><br><span class="line">    document[&quot;createElement&quot;](&quot;video&quot;);  = object = &#123;</span><br><span class="line">        canPlayType: function () &#123; return &quot;probably&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    document[&quot;createElement&quot;](&quot;audio&quot;);</span><br><span class="line">===&gt; &#123;</span><br><span class="line">        canPlayType: function () &#123; return &quot;probably&quot; &#125;      参数：&quot;audio/x-m4a;&quot;  返回maybe / 参数：[]  返回nope</span><br><span class="line">    &#125;</span><br><span class="line">    navigator.vendor</span><br><span class="line">        .product</span><br><span class="line">        .productSub</span><br><span class="line">    window.chrome = &#123;</span><br><span class="line">        loadTimes: function () &#123; &#125; // toString()检测，</span><br><span class="line">    app: &#123;</span><br><span class="line">            获取app下属性的描述符，</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    navigator.appName</span><br><span class="line">        .webdriver = false</span><br><span class="line">        [&quot;connection&quot;][&quot;rtt&quot;] = 100</span><br><span class="line"></span><br><span class="line">    window.history.length = 12</span><br><span class="line">    navigator.hardwareConcurrency = 12</span><br><span class="line"></span><br><span class="line">    window[&quot;self&quot;] !== window[&quot;top&quot;];</span><br><span class="line">    window[&quot;navigator&quot;][&quot;getBattery&quot;] 函数 toString检测</span><br><span class="line"></span><br><span class="line">    window[&quot;console&quot;][&quot;debug&quot;][&quot;name&quot;]; toString检测</span><br><span class="line">    window.PERSISTENT / TEMPORARY / PerformanceObserver.supportedEntryTypes</span><br><span class="line"></span><br><span class="line">    location.protocol</span><br><span class="line">    CanvasRenderingContext2D_十三 = document[&quot;createElement&quot;](&quot;canvas&quot;)[&quot;getContext&quot;](&quot;2d&quot;);</span><br><span class="line">.measureText = function () &#123; return &#123;&#125; &#125; ???????????????</span><br><span class="line"></span><br><span class="line">        twoelement = window[&quot;document&quot;][&quot;documentElement&quot;][&quot;children&quot;];</span><br><span class="line">    twoelement[0][&quot;tagName&quot;][&quot;toUpperCase&quot;]()</span><br><span class="line"></span><br><span class="line">    window.visualViewport.width / height / scale</span><br><span class="line"></span><br><span class="line">    document[&quot;createAttribute&quot;, &quot;createElement&quot;, &quot;createElementNS&quot;]; 三个函数</span><br><span class="line">    document[&quot;implementation&quot;][&quot;createHTMLDocument&quot;](&quot;&quot;);</span><br></pre></td></tr></table></figure><h3 id="5-reCaptcha"><a href="#5-reCaptcha" class="headerlink" title="5. reCaptcha"></a>5. reCaptcha</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function findRecaptchaClients() &#123;</span><br><span class="line">    // eslint-disable-next-line camelcase</span><br><span class="line">    if (typeof (___grecaptcha_cfg) !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">        // eslint-disable-next-line camelcase, no-undef</span><br><span class="line">        return Object.entries(___grecaptcha_cfg.clients).map(([cid, client]) =&gt; &#123;</span><br><span class="line">            const data = &#123; id: cid, version: cid &gt;= 10000 ? &#x27;V3&#x27; : &#x27;V2&#x27; &#125;;</span><br><span class="line">            const objects = Object.entries(client).filter(([_, value]) =&gt; value &amp;&amp; typeof value === &#x27;object&#x27;);</span><br><span class="line"></span><br><span class="line">            objects.forEach(([toplevelKey, toplevel]) =&gt; &#123;</span><br><span class="line">                const found = Object.entries(toplevel).find(([_, value]) =&gt; (</span><br><span class="line">                    value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; &#x27;sitekey&#x27; in value &amp;&amp; &#x27;size&#x27; in value</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">                if (typeof toplevel === &#x27;object&#x27; &amp;&amp; toplevel instanceof HTMLElement &amp;&amp; toplevel[&#x27;tagName&#x27;] === &#x27;DIV&#x27;) &#123;</span><br><span class="line">                    data.pageurl = toplevel.baseURI;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (found) &#123;</span><br><span class="line">                    const [sublevelKey, sublevel] = found;</span><br><span class="line"></span><br><span class="line">                    data.sitekey = sublevel.sitekey;</span><br><span class="line">                    const callbackKey = data.version === &#x27;V2&#x27; ? &#x27;callback&#x27; : &#x27;promise-callback&#x27;;</span><br><span class="line">                    const callback = sublevel[callbackKey];</span><br><span class="line">                    if (!callback) &#123;</span><br><span class="line">                        data.callback = null;</span><br><span class="line">                        data.function = null;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        data.function = callback;</span><br><span class="line">                        const keys = [cid, toplevelKey, sublevelKey, callbackKey].map((key) =&gt; `[&#x27;$&#123;key&#125;&#x27;]`).join(&#x27;&#x27;);</span><br><span class="line">                        data.callback = `___grecaptcha_cfg.clients$&#123;keys&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return data;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [];</span><br><span class="line">&#125;</span><br><span class="line">findRecaptchaClients()</span><br></pre></td></tr></table></figure><h2 id="十一、高难度逆向案例"><a href="#十一、高难度逆向案例" class="headerlink" title="十一、高难度逆向案例"></a>十一、高难度逆向案例</h2><h3 id="1-攻防世界逆向"><a href="#1-攻防世界逆向" class="headerlink" title="1. 攻防世界逆向"></a>1. 攻防世界逆向</h3><blockquote><p><strong>变异瑞数：</strong>全扣补环境后，无法从 document.cookie 获取到 cookie 值，则补好环境后一样要去扣生成代码</p><p><strong>总结特殊扣法（有点适用 OB 混淆）：先全扣补环境，补好环境后扣代码，或者直接全局导出调用方法</strong></p><p><strong><span style="color:red;">瑞数特点补充：Cookie 是通过瑞数加密的网站，发送 XHR 请求所携带的载荷可以是明文，因为瑞数不检测</span></strong></p></blockquote><ul><li><p><strong>打开开发者工具就有无限 debugger：</strong>首要考虑是瑞数的可能性</p></li><li><p><strong>吐环境脚本不吐环境：</strong>可能是 console.log 被置空，可以将其在吐环境脚本中赋值给其他变量，并替换使用</p></li><li><p><strong>反调试 –&gt; 每次刷新重新生成 js 文件 –&gt; 断点被清空：</strong>启用事件监听器中的脚本断点，首次加载即可进入断点</p></li><li><p><strong>异常 TypeError: MutationObserver is not a constructor：</strong>补对象错误，应该补函数或类</p></li><li><p><strong>异常 TypeError: this[“MutationObserver”].observe is not a function：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MutationObserver = function () &#123;</span><br><span class="line">    this.observe = function (res) &#123;</span><br><span class="line">        log(&quot;MutationObserver.observe的参数：&quot;,res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-猿人学反混淆攻防"><a href="#2-猿人学反混淆攻防" class="headerlink" title="2. 猿人学反混淆攻防"></a>2. 猿人学反混淆攻防</h3><blockquote><ol><li><p><strong>Chaeles 抓包工具：</strong>截获完整的数据包，且数据包的顺序严格与网站一致；同时 charles 还可以截获爬虫模拟请求的数据包，通过观察爬虫模拟的数据包与网站数据包的区别，便可以知道数据有误时问题所在</p></li><li><p><strong>Requests库 的 headers 处理机制：</strong></p><ul><li><strong>传入对象的要求：</strong>Requests 库要求传入的 headers 参数最终应该是一个字典形式的数据</li><li><strong>处理流程：</strong>检查传入的 headers 参数是否是一个字典，如果不是字典，但有 items 方法，Requests 库会调用 items 方法，将返回的键值对作为字典来处理</li><li><strong>源码分析：</strong>在 requests.models.py 中的 prepare_headers 方法中，具体处理 headers 的过程如下</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def prepare_headers(self, headers):</span><br><span class="line">    self.headers = CaseInsensitiveDict()  # 自定义字典类，作用是使 headers 键名不区分大小写</span><br><span class="line">    if headers:</span><br><span class="line">        for header in headers.items():</span><br><span class="line">            check_header_validity(header)</span><br><span class="line">            name, value = header</span><br><span class="line">            self.headers[to_native_string(name)] = value</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>第一题（js 混淆 - 源码乱码）：</strong></p><ol><li>由一个 <strong>返回值为空的特殊函数</strong> + <strong>全局属性 window[‘x’]</strong> 生成值，那么全局属性大概率是通过函数生成的</li><li>在扣具体加密值处的函数时，<strong>应重点关注函数返回值</strong>，有些值结果是固定的，就无需全扣又去生成固定值</li></ol></li><li><p><strong>第二题（js 混淆 - 动态cookie1）：</strong></p><ol><li>使用 AST 解混淆后，需手动删除剩余冗余代码，<strong>其中有操作符相关的代码一般是和加密相关的，不能删</strong></li><li><strong>冗余代码：</strong>无调用解密函数、移位自执行函数、大数组函数、无用自执行函数、包含 constructor 和 debugger 的、try 和 if 语句的不走逻辑、eval 函数（关注 eval 执行代码，可用浏览器执行结果后判断）</li></ol></li><li><p><strong>第三题（访问逻辑 - 推心置腹）：</strong></p><ol><li><strong>一些服务器会验证 HTTP 请求头的顺序：</strong>在 Python 3.6 之前字典的顺序是不可预测的；而从 3.7 开始字典的插入顺序被正式保留。<strong>而 Requests 库在给 headers 参数时，会自动对头字段进行一定排序或处理</strong></li><li><strong>重点：</strong>模拟请求需针对多个接口，<strong>需严格按顺序请求每一次接口，哪怕返回的数据没有用，但环环相扣</strong></li><li><strong>解决方案：</strong><ul><li>以 Charles 截获数据包中的请求原始数据构建请求头，通过 session 设置 headers 信息，因为其底层实现于 OrderedDict 数据结构，确保了发送请求时，请求头的顺序与添加的顺序保持一致</li><li>在模拟请求多个接口时，每次请求所携带请求头都可能不同，除了 session 实现请求头有序，也可以通过创建类定义 items 类方法返回元组列表，利用元组有序、不可变的特点确保请求头的顺序不变</li></ul></li></ol></li><li><p><strong>第四题（雪碧图、样式干扰）：</strong></p><ol><li>在分析接口时，尽管整个数据包、响应数据等都很简单，整个接口中无任何加密，但在这个过程中只要发现有任何一小点数据与浏览器不一致，都应该从 send 发送请求处仔细分析，其中自有奥秘</li><li><strong>Base64 编码与解码（btoa 和 atob 是 window 对象的两个函数）：</strong><ul><li><strong>btoa（binary to ASCII）：</strong>用于将二进制数据 b’str’ 编码为 Base64 格式的 ASCII 字符串</li><li><strong>atob（ASCII to binary）：</strong>用于将 Base64 格式的 ASCII 字符串解码为原始的 b’str’ 二进制数据</li><li><strong>python 实现 Base64 编码：</strong><code>base64.b64encode(&#39;str&#39;.encode()).decode()</code></li></ul></li><li><strong>在某些数据无法具体还原或还原复杂度较高时，可以考虑使用映射关系将数据写死，但前提是其变化不大</strong></li></ol></li><li><p><strong>第五题（js 混淆 - 乱码增强）：</strong></p><ol><li>Hook cookie 使用油猴不起作用，则使用 v_tools，<code>copy(_$UH.map(String))</code></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Webpack专题&quot;&gt;&lt;a href=&quot;#一、Webpack专题&quot; class=&quot;headerlink&quot; title=&quot;一、Webpack专题&quot;&gt;&lt;/a&gt;一、Webpack专题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Webpack：&lt;/str</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="JS逆向" scheme="http://example.com/tags/JS%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向_2_加密算法</title>
    <link href="http://example.com/2024/03/01/JS%E9%80%86%E5%90%91_2_%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2024/03/01/JS%E9%80%86%E5%90%91_2_%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2024-02-29T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法总结图"><a href="#算法总结图" class="headerlink" title="算法总结图"></a>算法总结图</h2><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705927789-ee046979a73c226.png"                         style="width:100%;margin:0 auto;"                 ><h2 id="一、哈希摘要算法"><a href="#一、哈希摘要算法" class="headerlink" title="一、哈希摘要算法"></a>一、哈希摘要算法</h2><blockquote><p><strong>哈希摘要：是一种通过将数据应用哈希函数来生成固定长度的数据摘要的过程</strong></p><p><strong>哈希摘要算法的基本特点包括：</strong></p><ol><li><strong>不可逆性：</strong>数据不能被逆向还原，即无法从散列值（哈希摘要）反推出原始数据</li><li><strong>固定长度输出：</strong>不同输入长度的数据都生成相同长度的摘要</li><li><strong>唯一性：</strong>不同的输入数据应生成唯一的摘要，但碰撞是理论上可能的，即两个不同的输入生成相同的摘要</li><li><strong>快速计算：</strong>对于给定输入，摘要的生成应该是高效的</li></ol></blockquote><h3 id="1-MD5"><a href="#1-MD5" class="headerlink" title="1. MD5"></a>1. MD5</h3><blockquote><p><strong>MD5（Message-Digest Algorithm）：</strong>是一种广泛使用的哈希算法（密码散列函数），可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</p><p><strong>MD5特征：32长度、十六进制</strong></p><p><strong>md5应用领域：</strong></p><ol><li><strong>密码保护：</strong>前端后端密码对比，不怕数据库数据丢失</li><li><strong>文件完整性校验：</strong>确保文件传递的前后一致</li><li><strong>数字签名：</strong>防止发布的软件被篡改</li><li><strong>云盘秒传：</strong>云盘有时并不会把全部的数据上传，而是拿到数据加密之后的md5去文件数据库对比</li></ol></blockquote><ul><li><strong>JavaScript 实现 MD5（<a class="link"   href="https://www.mytokencap.com/"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// **在 Node.js 中安装算法库：`npm install crypto-js -S`**</span><br><span class="line">var crypto = require(&#x27;crypto-js&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(crypto.MD5(&#x27;abc&#x27;));</span><br><span class="line">/* MD5 哈希值的内部表示形式</span><br><span class="line">&#123;</span><br><span class="line">  words: [ -1936743598, -1629270706, 1772141231, -1224303197 ],</span><br><span class="line">  sigBytes: 16</span><br><span class="line">&#125;</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">console.log(crypto.MD5(&#x27;abc&#x27;).toString());</span><br><span class="line">// 8c8fa3529ee34d4e69a0baafb7069da3</span><br></pre></td></tr></table></figure><ul><li><strong>Python 实现 MD5：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># 字符串是无法直接进行加密的，需要进行encode编码</span><br><span class="line">data = hashlib.md5(&#x27;abc&#x27;.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">print(data)  # 8c8fa3529ee34d4e69a0baafb7069da3</span><br></pre></td></tr></table></figure><h3 id="2-SHA"><a href="#2-SHA" class="headerlink" title="2. SHA"></a>2. SHA</h3><blockquote><p><strong>SHA（Secure Hash Algorithm）：</strong>是由美国国家标准与技术研究院（NIST）制定的一系列哈希算法标准，包括 SHA-1、SHA-256、SHA-384、SHA-512 等。旨在产生一种固定长度的哈希值，通常以<strong>十六进制</strong>表示。SHA 算法家族被广泛用于数字签名、数据完整性验证等安全应用。</p><p><strong>SHA家族的特征（版本越强，密文越长，代价是速度越慢）：</strong></p><ol><li><strong>SHA-1：20字节，40长度</strong></li><li><strong>SHA-224：28字节，56长度</strong></li><li><strong>SHA-256：32字节，64长度</strong></li><li><strong>SHA-384：48字节，96长度</strong></li><li><strong>SHA-512：64字节，128长度</strong></li></ol></blockquote><ul><li><strong>JavaScript 实现 SHA（<a class="link"   href="https://www.hh1024.com/#/ranklist/ranklist"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var crypto = require(&#x27;crypto-js&#x27;);</span><br><span class="line"></span><br><span class="line">// SHA哈希值的内部表示形式</span><br><span class="line">console.log(crypto.SHA1(&#x27;abc&#x27;));  // sigBytes: 20</span><br><span class="line">console.log(crypto.SHA1(&#x27;abc&#x27;).toString());  // 哈希值</span><br><span class="line"></span><br><span class="line">console.log(crypto.SHA224(&#x27;abc&#x27;));  // sigBytes: 28</span><br><span class="line">console.log(crypto.SHA224(&#x27;abc&#x27;).toString());</span><br><span class="line"></span><br><span class="line">console.log(crypto.SHA256(&#x27;abc&#x27;));  // sigBytes: 32</span><br><span class="line">console.log(crypto.SHA256(&#x27;abc&#x27;).toString());</span><br><span class="line"></span><br><span class="line">console.log(crypto.SHA384(&#x27;abc&#x27;));  // sigBytes: 48</span><br><span class="line">console.log(crypto.SHA384(&#x27;abc&#x27;).toString());</span><br><span class="line"></span><br><span class="line">console.log(crypto.SHA512(&#x27;abc&#x27;));  // sigBytes: 64</span><br><span class="line">console.log(crypto.SHA512(&#x27;abc&#x27;).toString());</span><br></pre></td></tr></table></figure><ul><li><strong>Python 实现 SHA：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># 字符串是无法直接进行加密的，需要进行encode编码</span><br><span class="line">data1 = hashlib.sha1(&#x27;abc&#x27;.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">data2 = hashlib.sha224(&#x27;abc&#x27;.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">data3 = hashlib.sha256(&#x27;abc&#x27;.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">data4 = hashlib.sha384(&#x27;abc&#x27;.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">data5 = hashlib.sha512(&#x27;abc&#x27;.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br></pre></td></tr></table></figure><h3 id="3-HMAC"><a href="#3-HMAC" class="headerlink" title="3. HMAC"></a>3. HMAC</h3><blockquote><p><strong>HMAC（Hash-based Message Authentication Code）：</strong>是一种基于哈希函数的消息认证码算法，结合了哈希函数和密钥以提供消息完整性和真实性的验证。于1996年提出，并于1997年作为 RFC2104 被公布。</p><p><strong>HMAC的基本思想：</strong>通过将消息和密钥混合在一起，并将其输入到哈希函数中，生成一个固定长度的摘要。这个摘要（HMAC）随着消息一起传递，并在接收端使用相同的密钥和哈希函数重新计算，但<strong>同样是不可逆的</strong>，以验证消息的完整性（<strong>可以与各种哈希算法捆绑使用，并拥有相同的特点</strong>）</p></blockquote><ul><li><strong>JavaScript 实现 HMAC（<a class="link"   href="https://www.qcc.com/"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var crypto = require(&#x27;crypto-js&#x27;);</span><br><span class="line"></span><br><span class="line">var text = &quot;I love python&quot;;</span><br><span class="line">var key = &quot;xxxxxx&quot;;</span><br><span class="line"></span><br><span class="line">console.log(crypto.HmacMD5(text, key).toString())</span><br><span class="line">console.log(crypto.HmacSHA512(text, key).toString())</span><br></pre></td></tr></table></figure><ul><li><strong>Python 实现 HMAC：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import hmac  # 导入hmac模块，hmac是单独的模块，而不是hashlib</span><br><span class="line"></span><br><span class="line">def hmac_md5():</span><br><span class="line">    text = &#x27;I love python&#x27;</span><br><span class="line">    key = b&quot;xxxxxx&quot;</span><br><span class="line">    return hmac.new(text.encode(), key, digestmod=&#x27;MD5&#x27;).hexdigest()</span><br><span class="line"></span><br><span class="line">def hmac_sha256():</span><br><span class="line">    text = &#x27;I love python&#x27;</span><br><span class="line">    key = b&quot;xxxxxx&quot;</span><br><span class="line">    sha256 = hmac.new(key, digestmod=&#x27;sha256&#x27;)</span><br><span class="line">    sha256.update(&#x27;I love &#x27;.encode(&#x27;utf8&#x27;))</span><br><span class="line">    sha256.update(&#x27;Python&#x27;.encode(&#x27;utf8&#x27;))</span><br><span class="line">    data1 = sha256.hexdigest()</span><br><span class="line">    data2 = hmac.new(text.encode(), key, digestmod=&#x27;sha256&#x27;).hexdigest()</span><br><span class="line">    return data1, data2  # 分开加密是不同的</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(hmac_md5())  # b119f6355b6e1dfdbb35b44851e3e731</span><br><span class="line">    print(hmac_sha256())  # ......</span><br></pre></td></tr></table></figure><h2 id="二、对称加密算法"><a href="#二、对称加密算法" class="headerlink" title="二、对称加密算法"></a>二、对称加密算法</h2><blockquote><p><strong>对称加密算法的基本思想</strong>：使用相同的密钥（也被称为秘密密钥）同时执行加密和解密操作，也就是说加密和解密用的是同一个算法。这意味着在通信的两端，发送方和接收方都必须共享相同的密钥。对称加密算法通过这个共享的密钥来隐藏和还原原始数据，确保只有持有密钥的人能够解密和访问数据。</p><p><strong>常见的对称加密算法：DES、AES（Advanced Encryption Standard*）、3DES、RC4、IDEA</strong></p><p><strong>对称加密的特点：可逆性、密钥共享、高效性、适用于随机访问</strong></p></blockquote><h3 id="1-算法工作模式"><a href="#1-算法工作模式" class="headerlink" title="1. 算法工作模式"></a>1. 算法工作模式</h3><ul><li><strong>ECB模式（电子密码本模式）：</strong><ul><li><strong>基本思想：</strong>将明文切分成固定大小的块，然后对每个块独立进行加密。每个块使用相同的密钥进行加密，且每个块的加密是独立的，不依赖于其他块，最后将每一组加密的结果进行拼接得到密文（<strong>最简单</strong>）</li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705231325-f38b501dbc480ff.png"                         style="width:80%;margin:0 auto;"                 ><ul><li><p><strong>CBC模式（密码分组链接模式）：</strong></p><ul><li><strong>基本思想：</strong>引入了<strong>初始化向量 IV</strong>，在第一个块中先让 IV 与明文进行异或操作，再进行加密生成密文，此时将密文又作为下一个块的 IV 与下一个块的明文加密生成下一个块的密文，以此类推（<strong>使用最多</strong>）</li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705231326-b0efd28804fe12e.png"                         style="width:80%;margin:0 auto;"                 ><ul><li><strong>CFB模式（密码反馈模式）：</strong><ul><li><strong>基本思想：</strong>吸收了<strong>流加密</strong>的特点，可以理解为在CBC模式中实现了流加密。<strong>加密关键</strong>是使用前一次加密的输出作为下一次加密的输入。将前一个密文块输入（反馈）到加密函数中，产生一个伪随机流，将伪随机流与当前块的明文异或，得到密文，再将密文进行位移处理后作为下一块的输入，以此类推</li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705231327-64e40d496f31ff7.png"                         style="width:80%;margin:0 auto;"                 ><ul><li><strong>OFB模式（输出反馈模式）：</strong><ul><li><strong>基本思想：</strong>类似于CFB，但反馈的是加密函数的输出，使用上一个块的加密函数的输出与当前块的明文进行异或操作，得到密文</li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705231327-9bf75a8a2cc240b.png"                         style="width:80%;margin:0 auto;"                 ><ul><li><strong>CTR模式（计数器模式）：</strong><ul><li><strong>基本思想：</strong>与CFB、OFB模式为同一类，但<strong>加密关键</strong>是使用计数器和密钥生成的伪随机数流与明文进行异或操作，得到密文。计数器的值逐块递增，每个块都使用不同的计数器值进行加密，适用于流加密，支持并行处理（可以代替CFB、OFB模式）</li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705231328-18e363d5cef7d65.png"                         style="width:80%;margin:0 auto;"                 ><h3 id="2-DES"><a href="#2-DES" class="headerlink" title="2. DES"></a>2. DES</h3><blockquote><p><strong>DES（Data Encryption Standard）：</strong>是一种对称加密算法，最早由IBM于1977年提出并被美国国家标准局（NIST）采纳为联邦信息处理标准（FIPS）。由于DES密钥较短，在1999年被AES（高级加密标准）取代。</p><p><strong>加密原理：</strong>DES属于对称密码算法中的<strong>分组加密算法（块加密）</strong>，原理是将明文分成n个64位的字节块，分别进行加密，当明文块不足64位时会通过双方统一的填充方案进行<strong>填充（PKCS5Padding）</strong>。密钥长度64位，56位参与运算，8位校验位。每个明文数据块都经过 des 加密后，所有密文块串联在一起形成完整的密文。</p></blockquote><ul><li><p><strong>DES加密算法的主要步骤：</strong></p><ol><li><strong>密钥生成：</strong><ul><li>DES使用56位的密钥，但实际上是使用64位的密钥，其中有8位是奇偶校验位。这样实际有效的密钥长度为56位</li><li>密钥被分为16个子密钥，每个子密钥包含48位</li></ul></li><li><strong>初始置换（IP置换）：</strong><ul><li>明文（64位）被初始置换，即重新排列其位，产生一个初始置换的数据块</li></ul></li><li><strong>分为左右两半：</strong><ul><li>初始置换后的数据块分为左右两个32位的半块</li></ul></li><li><strong>DES采用Feistel网络结构。每一轮的右半块通过一个轮函数进行处理，这个轮函数包括：</strong><ul><li><strong>扩展（Expansion）：</strong> 将右半块的32位扩展为48位</li><li><strong>密钥混合（Key Mixing）：</strong> 将扩展后的右半块与子密钥进行异或运算</li><li><strong>S盒代替（S-box Substitution）：</strong> 将48位的数据分成8组，每组6位，通过8个S盒进行代替，每个S盒将6位输入映射到4位输出</li><li><strong>P盒置换（Permutation）：</strong> 对S盒输出进行置换，得到最终的32位输出</li></ul></li><li><strong>左右交换：</strong><ul><li>经过轮函数处理后，左半块与右半块进行异或运算，然后交换位置</li></ul></li><li><strong>重复16轮：</strong><ul><li>上述的轮函数过程重复16轮</li></ul></li><li><strong>逆初始置换（Final Permutation）：</strong><ul><li>最后一轮处理完后，左右两半进行逆初始置换，得到最终的密文</li></ul></li></ol></li><li><p><strong>DES加密过程的伪代码：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 64位明文，56位密钥</span><br><span class="line">Output: 64位密文</span><br><span class="line"></span><br><span class="line">1. 生成子密钥</span><br><span class="line">2. 初始置换</span><br><span class="line">3. 分为左右两半</span><br><span class="line">4. 16轮循环：</span><br><span class="line">   a. 右半块经过轮函数处理</span><br><span class="line">   b. 左右半块异或并交换位置</span><br><span class="line">5. 逆初始置换</span><br></pre></td></tr></table></figure><ul><li><strong>JavaScript 实现 DES（<a class="link"   href="https://www.endata.com.cn/BoxOffice/BO/Month/oneMonth.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong><ul><li><strong>注意：</strong>在 js 逆向中不适合使用 python 实现算法，不同语言使用的库和版本不同，同样的加密算法在不同的语言中加密的结果可能不一致，所以在逆向中最好使用 node 加密数据</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var crypto = require(&#x27;crypto-js&#x27;)</span><br><span class="line"></span><br><span class="line">// 加密</span><br><span class="line">function desencrypt(text, key, iv) &#123;</span><br><span class="line">    key = crypto.enc.Utf8.parse(key);</span><br><span class="line">    iv = crypto.enc.Utf8.parse(iv);</span><br><span class="line">    text = crypto.enc.Utf8.parse(text);</span><br><span class="line">    // CBC 加密模式，Pkcs7 填充方式</span><br><span class="line">    let encrypted = crypto.DES.encrypt(text, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: crypto.mode.CBC,</span><br><span class="line">        padding: crypto.pad.Pkcs7</span><br><span class="line">    &#125;);</span><br><span class="line">    return encrypted.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解密</span><br><span class="line">function desdecrypt(destext, key, iv) &#123;</span><br><span class="line">    key = crypto.enc.Utf8.parse(key);</span><br><span class="line">    iv = crypto.enc.Utf8.parse(iv);</span><br><span class="line">    // CBC 加密模式，Pkcs7 填充方式</span><br><span class="line">    let decrypted = crypto.DES.decrypt(destext, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: crypto.mode.CBC,</span><br><span class="line">        padding: crypto.pad.Pkcs7</span><br><span class="line">    &#125;);</span><br><span class="line">    return decrypted.toString(crypto.enc.Utf8);  // 指定解密后的编码格式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var text = &quot;I love Python!&quot;  // 待加密对象</span><br><span class="line">var desKey = &quot;12345678&quot;  // 密钥，64位，8字节</span><br><span class="line">var desIv = &quot;0123456789ABCDEF&quot;  // 初始向量</span><br><span class="line"></span><br><span class="line">var encryptedData = desencrypt(text, desKey, desIv)</span><br><span class="line">var decryptedData = desdecrypt(encryptedData, desKey, desIv)</span><br><span class="line"></span><br><span class="line">console.log(&quot;加密字符串: &quot;, encryptedData)  // 4rg1YxfRM2tIPSuriHtDQA==</span><br><span class="line">console.log(&quot;解密字符串: &quot;, decryptedData)  // I love Python!</span><br></pre></td></tr></table></figure><h3 id="3-AES"><a href="#3-AES" class="headerlink" title="3. AES"></a>3. AES</h3><blockquote><p><strong>AES（Advanced Encryption Standard）：</strong>全称高级加密标准，在密码学中又称 Rijndael 加密法，由美国国家标准与技术研究院 （NIST）于 2001 年发布，并在 2002 年成为有效的标准，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，支持多种密钥长度，包括128位、192位和256位，目前已成为对称密钥加密中最安全、最流行的算法之一。</p><p><strong>加密原理：</strong>AES属于对称密码算法中的<strong>分组加密算法（块加密）</strong>，原理是将明文分成n个128位的字节块，分别进行加密，当明文块不足128位时会通过双方统一的填充方案进行<strong>填充（PKCS5Padding）</strong>。密钥的长度可以是128位、192位和256位。每个明文数据块都经过 aes 加密后，所有密文块串联在一起形成完整的密文。</p></blockquote><ul><li><p><strong>AES加密算法的主要步骤：</strong></p><ol><li><strong>轮密钥生成（Key Expansion）：</strong><ul><li>根据输入的密钥长度（128位、192位或256位），生成扩展密钥。这些扩展密钥将在后续的轮函数中使用。</li></ul></li><li><strong>初始轮（Initial Round）：</strong><ul><li>将明文与扩展密钥进行初始轮的加法运算。</li></ul></li><li><strong>AES的核心是多轮处理（Rounds），每一轮包括以下四个步骤：</strong><ul><li><strong>字节替代（SubBytes）：</strong> 使用一个固定的8x8的替代盒（S盒），将每个字节替换为另一个字节。</li><li><strong>行移位（ShiftRows）：</strong> 对状态矩阵的每一行进行循环左移。第一行不移动，第二行左移一个字节，第三行左移两个字节，第四行左移三个字节。</li><li><strong>列混淆（MixColumns）：</strong> 利用矩阵运算对状态矩阵的每一列进行混淆。</li><li><strong>轮密钥加（AddRoundKey）：</strong> 将当前轮的轮密钥与状态矩阵进行按位异或运算。</li></ul></li><li><strong>最终轮（Final Round）：</strong><ul><li>在最后一轮中，省略MixColumns步骤，只执行SubBytes、ShiftRows和AddRoundKey。</li></ul></li><li><strong>逆操作（Inverse Operations）：</strong><ul><li>为了实现解密，需要对加密过程中的每个步骤进行逆操作。逆操作包括逆字节替代、逆行移位、逆列混淆和逆轮密钥加。</li></ul></li></ol></li><li><p><strong>注意：AES在不同的密钥长度下有不同的轮数</strong></p><ul><li>10轮（128位密钥）</li><li>12轮（192位密钥）</li><li>14轮（256位密钥）</li></ul></li><li><p><strong>AES加密过程的伪代码：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: 明文块，密钥（128位、192位或256位）</span><br><span class="line">Output: 密文块</span><br><span class="line"></span><br><span class="line">1. 轮密钥生成</span><br><span class="line">2. 初始轮：明文块与扩展密钥进行初始轮的加法运算</span><br><span class="line">3. 多轮处理（Rounds）：</span><br><span class="line">   a. 字节替代</span><br><span class="line">   b. 行移位</span><br><span class="line">   c. 列混淆（除了最后一轮）</span><br><span class="line">   d. 轮密钥加</span><br><span class="line">4. 最终轮：字节替代、行移位、轮密钥加</span><br></pre></td></tr></table></figure><ul><li><strong>JavaScript 实现 AES（<a class="link"   href="https://jzsc.mohurd.gov.cn/data/company"  target="_blank" rel="noopener">测试网站1<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://www.kanzhun.com/search/?query=python%E7%88%AC%E8%99%AB&type=0"  target="_blank" rel="noopener">测试网站2<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var crypto = require(&#x27;crypto-js&#x27;)</span><br><span class="line"></span><br><span class="line">// 加密</span><br><span class="line">function desencrypt(text, key, iv) &#123;</span><br><span class="line">    key = crypto.enc.Utf8.parse(key);</span><br><span class="line">    iv = crypto.enc.Utf8.parse(iv);</span><br><span class="line">    text = crypto.enc.Utf8.parse(text);</span><br><span class="line">    // CBC 加密模式，Pkcs7 填充方式</span><br><span class="line">    let encrypted = crypto.AES.encrypt(text, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: crypto.mode.CBC,</span><br><span class="line">        padding: crypto.pad.Pkcs7</span><br><span class="line">    &#125;);</span><br><span class="line">    return encrypted.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解密</span><br><span class="line">function desdecrypt(destext, key, iv) &#123;</span><br><span class="line">    key = crypto.enc.Utf8.parse(key);</span><br><span class="line">    iv = crypto.enc.Utf8.parse(iv);</span><br><span class="line">    // CBC 加密模式，Pkcs7 填充方式</span><br><span class="line">    let decrypted = crypto.AES.decrypt(destext, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: crypto.mode.CBC,</span><br><span class="line">        padding: crypto.pad.Pkcs7</span><br><span class="line">    &#125;);</span><br><span class="line">    return decrypted.toString(crypto.enc.Utf8);  // 指定解密后的编码格式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var text = &quot;I love Python!&quot;  // 待加密对象</span><br><span class="line">var desKey = &quot;12345678&quot;  // 密钥，64位，8字节</span><br><span class="line">var desIv = &quot;0123456789ABCDEF&quot;  // 初始向量</span><br><span class="line"></span><br><span class="line">var encryptedData = desencrypt(text, desKey, desIv)</span><br><span class="line">var decryptedData = desdecrypt(encryptedData, desKey, desIv)</span><br><span class="line"></span><br><span class="line">console.log(&quot;加密字符串: &quot;, encryptedData)  // SDP09JftXrC4ox/qrhMqCA==</span><br><span class="line">console.log(&quot;解密字符串: &quot;, decryptedData)  // I love Python!</span><br></pre></td></tr></table></figure><h3 id="4-问题记录"><a href="#4-问题记录" class="headerlink" title="4. 问题记录"></a>4. 问题记录</h3><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705305792-d589788b4e3e049.png"                                         ><ul><li><strong>问题：</strong>解密后的数据不符合预期的 UTF-8 编码格式，导致解析失败</li><li><strong>可能原因：</strong><ol><li>密文 text 是否是通过正确的加密过程生成的</li><li>密钥 key 和初始向量 iv 在加密和解密过程中是否保持一致</li></ol></li><li><strong>解决：</strong>查看代码中是否有其他地方对 text、key 或 iv 参数进行了赋值修改，因为 js 是可以在同一作用域的不同位置对同一数据进行多次赋值的</li></ul><h2 id="三、魔改算法"><a href="#三、魔改算法" class="headerlink" title="三、魔改算法"></a>三、魔改算法</h2><blockquote><p><strong>魔改（魔改算法）：</strong>通常是指对已有的算法进行修改或改进的过程。这个过程可能包括调整参数、改变某些步骤、添加新的元素，或者以其他方式对算法进行修改，以满足特定的需求或优化特定的性能指标。</p></blockquote><ul><li><strong>判断是否是魔改算法：</strong>观察算法库对象中的有没有一系列常用的标准算法，大致可以推断出是否是魔改算法，<strong>是则需要将与魔改算法库对象定义相关的所有代码都要扣下来，包括自执行方法（<a class="link"   href="https://www.aigei.com/sound/class/role#resContainer"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</strong></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705416451-06c29a72f2c50f6.png"                         style="width:80%;margin:0 auto;"                 ><h2 id="四、非对称加密算法"><a href="#四、非对称加密算法" class="headerlink" title="四、非对称加密算法"></a>四、非对称加密算法</h2><blockquote><p><strong>非对称加密算法的基本思想：</strong>对称加密使用相同的密钥进行加密和解密，而非对称加密使用一对密钥，包括公钥和私钥，分别用于加密和解密。如果用公钥加密信息，只有用私钥才能解密。反之亦然，用私钥加密的信息只能用对应的公钥进行解密。这种关系使得公钥可以安全地分享给其他人，而私钥则必须保持秘密。</p><p><strong>常见的非对称加密算法：RSA（Rivest-Shamir-Adleman*）、DSA、ECC（椭圆曲线密码学）</strong></p><p><strong>可用于数字签名领域：</strong>验证消息的完整性和来源。发送方使用私钥对消息进行签名，而接收方可以使用发送方的公钥来验证签名。这确保了消息在传输过程中没有被篡改，并且确定是由私钥持有者生成的。</p></blockquote><h3 id="1-RSA"><a href="#1-RSA" class="headerlink" title="1. RSA"></a>1. RSA</h3><blockquote><p><strong>RSA（Rivest-Shamir-Adleman）：</strong>是一种非对称加密算法，于1977年提出。RSA算法基于数论的难题，特别是大数分解的难度，其安全性依赖于质数因子分解的困难性。在RSA中，<strong>相同的明文每次生成的密文值都是不一样的</strong>，每次加密都会采用不同的填充和随机数，以确保生成的密文在统计上看起来是随机的。</p></blockquote><ul><li><p><strong>RSA加密算法的主要步骤：</strong></p><ol><li><p><strong>密钥生成：</strong></p><ul><li><strong>选择两个大质数p和q：</strong>这两个质数越大，破解RSA就越困难。</li><li><strong>计算n：</strong>计算n &#x3D; p * q，n是两个质数的乘积。</li><li><strong>计算欧拉函数φ(n)：</strong>计算φ(n) &#x3D; (p-1)(q-1)。</li><li><strong>选择公钥e：</strong>选择一个满足1 &lt; e &lt; φ(n)且与φ(n)互质的数，通常选择65537。</li><li><strong>计算私钥d：</strong>计算满足(e * d) mod φ(n) &#x3D; 1的私钥d。</li></ul><p>公钥是(n, e)，私钥是(n, d)。公钥可以公开，私钥必须保密。</p></li><li><p><strong>加密过程：</strong></p><ul><li>Alice拥有Bob的公钥(n, e)。</li><li>Alice将明文M转换为整数m，确保0 &lt; m &lt; n。</li><li>Alice计算密文C，其中C ≡ m^e (mod n)。</li><li>Alice将密文C发送给Bob。</li></ul><p>加密过程利用了模幂运算，即将明文的整数形式m，通过取e次方并对n取模得到密文C。这个操作使得只有私钥持有者才能轻松解密消息。</p></li><li><p><strong>解密过程：</strong></p><ul><li>Bob使用私钥(n, d)。</li><li>Bob计算明文m，其中m ≡ C^d (mod n)。</li><li>Bob将整数m转换为明文M。</li></ul><p>解密过程利用了模幂运算，与加密过程相反，通过将密文的整数形式C，取d次方并对n取模得到原始的明文。</p></li><li><p><strong>安全性基础：</strong></p><ul><li>RSA的安全性建立在大整数分解的困难性基础上，即将n分解为其两个大质因数p和q。</li><li>当n足够大时，对n进行分解变得非常耗时，因此使得破解RSA成为一项艰巨的任务。</li></ul></li><li><p><strong>性能注意事项：</strong></p><ul><li>由于RSA的加密和解密操作相对耗时，通常不直接用于加密大量数据。通常，RSA用于安全地交换对称密钥，而对称密钥用于实际的数据加密。</li></ul></li></ol></li><li><p><strong>RSE加密过程的伪代码：</strong></p><ol><li><p><strong>密钥生成：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 选择两个大素数 p 和 q</span><br><span class="line"># generate_large_prime 是生成大素数的函数</span><br><span class="line">p = generate_large_prime()</span><br><span class="line">q = generate_large_prime()</span><br><span class="line"></span><br><span class="line"># 计算 n = p * q</span><br><span class="line">n = p * q</span><br><span class="line"></span><br><span class="line"># 计算欧拉函数 φ(n) = (p-1) * (q-1)</span><br><span class="line">phi_n = (p - 1) * (q - 1)</span><br><span class="line"></span><br><span class="line"># 选择一个与 φ(n) 互质的整数 e（公钥）</span><br><span class="line"># choose_coprime 是选择与另一个数互质的函数</span><br><span class="line">e = choose_coprime(phi_n)</span><br><span class="line"></span><br><span class="line"># 计算 e 对于 φ(n) 的模反元素 d（私钥）</span><br><span class="line"># modular_inverse 是计算模反元素的函数</span><br><span class="line">d = modular_inverse(e, phi_n)</span><br><span class="line"></span><br><span class="line"># 返回公钥 (n, e) 和私钥 (n, d)</span><br></pre></td></tr></table></figure></li><li><p><strong>加密：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 接收公钥 (n, e) 和明文消息 M</span><br><span class="line"># 将明文消息 M 转换为整数 m，确保 m &lt; n</span><br><span class="line"></span><br><span class="line"># 计算密文 C = m^e mod n</span><br><span class="line"># modular_pow 是计算模幂的函数</span><br><span class="line">ciphertext = modular_pow(m, e, n)</span><br><span class="line"></span><br><span class="line"># 返回密文 C</span><br></pre></td></tr></table></figure></li><li><p><strong>解密：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 接收私钥 (n, d) 和密文消息 C</span><br><span class="line"></span><br><span class="line"># 计算明文消息 M = C^d mod n</span><br><span class="line">plaintext = modular_pow(ciphertext, d, n)</span><br><span class="line"></span><br><span class="line"># 返回明文消息 M</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="2-JS-实现-RSA"><a href="#2-JS-实现-RSA" class="headerlink" title="2. JS 实现 RSA"></a>2. JS 实现 RSA</h3><blockquote><p><strong>RSA算法 js 调试技巧（<a class="link"   href="https://login.10086.cn/html/login/email_login.html"  target="_blank" rel="noopener">测试网站1<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://passport.suning.com/ids/login"  target="_blank" rel="noopener">测试网站2<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://birdreport.cn/home/activity/page.html"  target="_blank" rel="noopener">测试网站3<i class="fas fa-external-link-alt"></i></a>）：</strong></p><ol><li>观察密文长度是否为 88、172、344 的特殊长度（密文值变化，但长度固定），以判断是否是RSA算法</li><li>网页一般会使用 <strong>jsencrypt</strong> 库，node 中也有 <strong>jsencrypt</strong> 库，不同于 <strong>node-rsa</strong> 库，<strong>搜索关键字</strong> <code>JSEncrypt(</code>、<code>new JSEncrypt()</code>、<code>setPublicKey</code>、<code>setPrivateKey</code>、<code>setkey</code>、<code>getPublicKey</code></li></ol><table><thead><tr><th>私钥长度</th><th>公钥长度</th><th>明文长度</th><th>密文长度</th></tr></thead><tbody><tr><td>428</td><td>128</td><td>1~53</td><td>88</td></tr><tr><td>812</td><td>216</td><td>1~117</td><td>172</td></tr><tr><td>1588</td><td>392</td><td>1~245</td><td>344</td></tr></tbody></table></blockquote><ul><li><strong>JavaScript 实现 RSA：</strong><ul><li><strong><code>const JSEncrypt = require(&#39;jsencrypt&#39;);</code></strong></li><li><strong><code>const NodeRSA = require(&#39;node-rsa&#39;);</code></strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 引用 node-rsa 加密模块（npm install node-rsa --save）</span><br><span class="line">var NodeRSA = require(&#x27;node-rsa&#x27;);</span><br><span class="line"></span><br><span class="line">function rsaEncrypt() &#123;</span><br><span class="line">    pubKey = new NodeRSA(publicKey, &#x27;pkcs8-public&#x27;);</span><br><span class="line">    var encryptedData = pubKey.encrypt(text, &#x27;base64&#x27;, &#x27;utf8&#x27;);</span><br><span class="line">    return encryptedData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rsaDecrypt() &#123;</span><br><span class="line">    priKey = new NodeRSA(privatekey, &#x27;pkcs8-private&#x27;);</span><br><span class="line">    var decryptedData = priKey.decrypt(encryptedData, &#x27;utf8&#x27;);</span><br><span class="line">    return decryptedData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var key = new NodeRSA(&#123;b: 512&#125;);                    //生成512位秘钥</span><br><span class="line">var publicKey = key.exportKey(&#x27;pkcs8-public&#x27;);    //导出公钥</span><br><span class="line">var privatekey = key.exportKey(&#x27;pkcs8-private&#x27;);  //导出私钥</span><br><span class="line">var text = &quot;I love Python!&quot;</span><br><span class="line"></span><br><span class="line">var encryptedData = rsaEncrypt()</span><br><span class="line">var decryptedData = rsaDecrypt()</span><br><span class="line"></span><br><span class="line">console.log(&quot;公钥:\n&quot;, publicKey)</span><br><span class="line">console.log(&quot;私钥:\n&quot;, privatekey)</span><br><span class="line">console.log(&quot;加密字符串: &quot;, encryptedData)</span><br><span class="line">console.log(&quot;解密字符串: &quot;, decryptedData)</span><br></pre></td></tr></table></figure><ul><li><strong>Python 实现 RSA：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import rsa</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">def rsa_encrypt(pu_key, t):</span><br><span class="line">    # 公钥加密</span><br><span class="line">    rsas = rsa.encrypt(t.encode(&quot;utf-8&quot;), pu_key)</span><br><span class="line">    return base64.b64encode(rsas)</span><br><span class="line"></span><br><span class="line">def rsa_decrypt(pr_key, t):</span><br><span class="line">    # 私钥解密</span><br><span class="line">    rsas = rsa.decrypt(base64.b64decode(t), pr_key).decode(&quot;utf-8&quot;)</span><br><span class="line">    return rsas</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    public_key, private_key = rsa.newkeys(512)  # 生成公钥、私钥</span><br><span class="line">    print(&#x27;公钥：&#x27;, public_key)</span><br><span class="line">    print(&#x27;私钥：&#x27;, private_key)</span><br><span class="line">    text = &#x27;I love Python!&#x27;  # 加密对象</span><br><span class="line">    encrypted_str = rsa_encrypt(public_key, text)</span><br><span class="line">    print(&#x27;加密字符串：&#x27;, encrypted_str)</span><br><span class="line">    decrypted_str = rsa_decrypt(private_key, encrypted_str)</span><br><span class="line">    print(&#x27;解密字符串：&#x27;, decrypted_str)</span><br></pre></td></tr></table></figure><h2 id="五、SM国密系列算法"><a href="#五、SM国密系列算法" class="headerlink" title="五、SM国密系列算法"></a>五、SM国密系列算法</h2><blockquote><p><strong>SM国密：</strong>SM国密算法系列是中国国家密码管理局（State Cryptography Administration，简称SCA）发布的一系列密码算法标准，旨在保障信息安全和国家安全。这一系列算法包括对称加密算法、非对称加密算法、数字签名算法等多个方面，其中SM2、SM3和SM4是其中最为重要的代表。</p></blockquote><h3 id="1-SM2"><a href="#1-SM2" class="headerlink" title="1. SM2"></a>1. SM2</h3><blockquote><p><strong>SM2（椭圆曲线公钥密码算法）：</strong>SM2是一种<strong>非对称加密算法</strong>，基于椭圆曲线密码学，采用了椭圆曲线数字签名算法（ECDSA）的变种，适用于数字签名、密钥交换等场景。<strong>SM2提供的安全性相当于RSA算法</strong>，该算法采用椭圆曲线上的点运算，计算速度更快，且使用了更短的密钥长度，提高了加密和解密的效率。</p><p><strong>算法流程：</strong></p><ol><li>密钥生成：生成公私钥对</li><li>签名：利用私钥对消息进行签名</li><li>验证：利用公钥验证签名的合法性</li><li>密钥协商：两方利用各自的私钥和对方的公钥协商出共享密钥</li></ol></blockquote><ul><li><strong>JavaScript 实现 SM2（<a class="link"   href="https://fuwu.nhsa.gov.cn/nationalHallSt/#/search/medical?code=90000&flag=false&gbFlag=true"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// npm install sm-crypto --save</span><br><span class="line">const sm2 = require(&#x27;sm-crypto&#x27;).sm2</span><br><span class="line"></span><br><span class="line">// SM2非对称加密的结果由`C1、C2、C3`三部分组成，</span><br><span class="line">// C1是生成随机数的计算出的椭圆曲线点，C2是密文数据，C3是 SM3 的摘要值；</span><br><span class="line">// sm-crypto支持设置cipherMode，即`C1、C2、C3`的排列顺序，</span><br><span class="line">// 默认为1，对应C1C3C2（新标准）；0对应C1C2C3（旧标准）</span><br><span class="line">const cipherMode = 1</span><br><span class="line"></span><br><span class="line">// 获取密钥对</span><br><span class="line">let keypair = sm2.generateKeyPairHex()</span><br><span class="line">let publicKey = keypair.publicKey   // 公钥</span><br><span class="line">let privateKey = keypair.privateKey // 私钥</span><br><span class="line"></span><br><span class="line">let msgString = &quot;this is the data to be encrypted&quot;</span><br><span class="line">let encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode)    // 加密结果</span><br><span class="line">let decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode) // 解密结果</span><br><span class="line"></span><br><span class="line">console.log(&quot;encryptData: &quot;, encryptData)</span><br><span class="line">console.log(&quot;decryptData: &quot;, decryptData)</span><br></pre></td></tr></table></figure><ul><li><strong>Python 实现 SM2：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from gmssl import sm2</span><br><span class="line"></span><br><span class="line"># 16 进制的公钥和私钥</span><br><span class="line">private_key = &#x27;00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5&#x27;</span><br><span class="line">public_key = &#x27;B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207&#x27;</span><br><span class="line">sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)</span><br><span class="line"></span><br><span class="line"># 待加密数据和加密后数据为 bytes 类型</span><br><span class="line">data = b&quot;this is the data to be encrypted&quot;</span><br><span class="line">enc_data = sm2_crypt.encrypt(data)</span><br><span class="line">dec_data = sm2_crypt.decrypt(enc_data)</span><br><span class="line"></span><br><span class="line">print(&#x27;enc_data: &#x27;, enc_data.hex())</span><br><span class="line">print(&#x27;dec_data: &#x27;, dec_data)</span><br></pre></td></tr></table></figure><h3 id="2-SM3"><a href="#2-SM3" class="headerlink" title="2. SM3"></a>2. SM3</h3><blockquote><p><strong>SM3（密码杂凑算法）：</strong>SM3是一种<strong>哈希算法</strong>，用于生成固定长度256位的消息摘要，适用于数字签名、消息认证码等场景。<strong>SM3提供的安全性相当于SHA-256算法</strong>，输出长度为32字节即<strong>64长度</strong>，该算法在性能上更有优势，同时具有抗碰撞特性，保证了足够的安全性。</p><p><strong>算法流程：</strong></p><ol><li>填充：将消息填充到满足特定要求的长度</li><li>消息扩展：将填充后的消息划分成512比特的消息块，并进行消息扩展</li><li>压缩：通过迭代压缩函数，对消息块进行处理</li><li>输出：最终得到256比特的消息摘要</li></ol></blockquote><ul><li><strong>JavaScript 实现 SM3：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const sm3 = require(&#x27;sm-crypto&#x27;).sm3;</span><br><span class="line"></span><br><span class="line">const data = &#x27;Hello, SM3!&#x27;;</span><br><span class="line">const hash = sm3(data);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;SM3 Hash:&#x27;, hash);</span><br></pre></td></tr></table></figure><ul><li><strong>Python 实现 SM3：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from gmssl import sm3, func</span><br><span class="line"></span><br><span class="line">def sm3_hash(message):</span><br><span class="line">    # python实现需要把编码数据转换成列表</span><br><span class="line">    hash_hex = sm3.sm3_hash(func.bytes_to_list(message))</span><br><span class="line">    print(hash_hex)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    message = b&quot;123&quot;  # bytes类型</span><br><span class="line">    sm3_hash(message)</span><br></pre></td></tr></table></figure><h3 id="3-SM4"><a href="#3-SM4" class="headerlink" title="3. SM4"></a>3. SM4</h3><blockquote><p><strong>SM4（分组密码算法）：</strong>SM4是一种<strong>对称加密算法</strong>，采用32位分组长度和128位密钥长度，用于块加密和流加密，适用于数据加密、数据完整性验证等场景。<strong>SM4提供的安全性相当于AES算法</strong>，该算法的设计参考了现代分组密码的设计原则，采用了Feistel网络结构，结合替代-置换网络（SPN）结构，使其在安全性和性能之间取得了良好的平衡，同时实现了相对高的加密和解密速度。</p><p><strong>算法流程：</strong></p><ol><li>密钥扩展：生成轮密钥</li><li>初始置换：对输入数据进行初步置换</li><li>轮函数：采用非线性的S盒替代、线性的P盒变换等操作</li><li>轮运算：通过32轮迭代，实现加密或解密操作</li><li>逆初始置换：对输出数据进行逆置换，得到最终结果</li></ol></blockquote><ul><li><strong>JavaScript 实现 SM4（<a class="link"   href="https://fuwu.nhsa.gov.cn/nationalHallSt/#/search/medical?code=90000&flag=false&gbFlag=true"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const sm4 = require(&#x27;sm-crypto&#x27;).sm4;</span><br><span class="line"></span><br><span class="line">// 设置SM4密钥（128位，16字节）</span><br><span class="line">const key = &#x27;0123456789ABCDEF0123456789ABCDEF&#x27;;</span><br><span class="line">// 设置SM4加解密模式（ecb、cbc、ctr等）</span><br><span class="line">const mode = &#x27;ecb&#x27;;</span><br><span class="line"></span><br><span class="line">// 加密数据</span><br><span class="line">const plaintext = &#x27;Hello, SM4!&#x27;;</span><br><span class="line">const ciphertext = sm4.encrypt(plaintext, key, &#123;mode&#125;);</span><br><span class="line">console.log(&#x27;Encrypted:&#x27;, ciphertext);</span><br><span class="line"></span><br><span class="line">// 解密数据</span><br><span class="line">const decryptedText = sm4.decrypt(ciphertext, key, &#123;mode&#125;);</span><br><span class="line">console.log(&#x27;Decrypted:&#x27;, decryptedText);</span><br></pre></td></tr></table></figure><ul><li><strong>Python 实现 SM4：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from gmssl import sm4, func</span><br><span class="line"></span><br><span class="line"># 创建SM4加密对象</span><br><span class="line">sm4_crypt = sm4.CryptSM4()</span><br><span class="line"></span><br><span class="line">data = b&quot;Hello, SM4!&quot;  # 加密数据</span><br><span class="line">key = b&#x27;0123456789ABCDEF0123456789ABCDEF&#x27;  # 密钥</span><br><span class="line"></span><br><span class="line"># 加密数据</span><br><span class="line">sm4_crypt.set_key(key, sm4.SM4_ENCRYPT)  # 设置加密密钥</span><br><span class="line">ciphertext = sm4_crypt.crypt_ecb(func.bytes_to_list(data))</span><br><span class="line">encrypted_data = bytes(func.list_to_bytes(ciphertext))</span><br><span class="line"></span><br><span class="line"># 解密数据</span><br><span class="line">sm4_crypt.set_key(key, sm4.SM4_DECRYPT)  # 设置解密密钥</span><br><span class="line">decrypted_data = sm4_crypt.crypt_ecb(ciphertext)</span><br><span class="line">decrypted_data = bytes(func.list_to_bytes(decrypted_data))</span><br><span class="line"></span><br><span class="line">print(&quot;原始数据:&quot;, data.decode(&quot;utf-8&quot;))</span><br><span class="line">print(&quot;加密后的数据:&quot;, encrypted_data.hex())</span><br><span class="line">print(&quot;解密后的数据:&quot;, decrypted_data.decode(&quot;utf-8&quot;))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法总结图&quot;&gt;&lt;a href=&quot;#算法总结图&quot; class=&quot;headerlink&quot; title=&quot;算法总结图&quot;&gt;&lt;/a&gt;算法总结图&lt;/h2&gt;&lt;img    
                       lazyload
                    </summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="JS逆向" scheme="http://example.com/tags/JS%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向_1_基础入门</title>
    <link href="http://example.com/2024/01/01/JS%E9%80%86%E5%90%91_1_%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2024/01/01/JS%E9%80%86%E5%90%91_1_%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2023-12-31T16:00:00.000Z</published>
    <updated>2025-01-15T09:53:53.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JS调试技巧"><a href="#一、JS调试技巧" class="headerlink" title="一、JS调试技巧"></a>一、JS调试技巧</h2><blockquote><p>在页面中右击 dom 元素标签 –&gt; 存储为全局变量 –&gt; dir(temp1) –&gt; 即可快速查看标签的一些属性（js 对象属性）</p></blockquote><h3 id="1-浏览器开发者工具"><a href="#1-浏览器开发者工具" class="headerlink" title="1. 浏览器开发者工具"></a>1. 浏览器开发者工具</h3><blockquote><p>控制台窗口有个细节，当打印一个对象的属性时，<code>dir(document)</code> 得到的结果中<strong>粗体属性是自身的</strong>，细字体属性是原型的</p></blockquote><ul><li><strong>设置：</strong>偏好设置 –&gt; 开启 “源代码&#x2F;来源” 下的 <strong>“在匿名和内容脚本中搜索”</strong></li><li><strong>应用面板：</strong>可以查看和删除 Cookie 信息</li><li><strong>源代码面板：</strong><ol><li><strong>网页：</strong>当前网站加载的源代码位置</li><li><strong>替换：</strong>替换网站源代码，实现访问网站时不走服务器所返回的文件，而是直接走自己替换的本地文件</li><li><strong>替换步骤：</strong>网络面板 –&gt; 选择加载的源代码文件右击 –&gt; <strong>在”来源”面板中打开</strong> –&gt; 右击文件 –&gt; <strong>替换内容</strong> –&gt; 授权 –&gt; 更改代码 –&gt; 保存刷新网页</li><li><strong>代码段：</strong>可以编写多段测试代码</li></ol></li></ul><h3 id="2-断点定位"><a href="#2-断点定位" class="headerlink" title="2. 断点定位"></a>2. 断点定位</h3><blockquote><p><strong>普通断点调试按钮：</strong></p><ol><li>暂停&#x2F;继续执行脚本</li><li>不进入函数内部</li><li>进入函数内部</li><li>跳出当前函数</li><li>单步调试，适用于异步</li><li>关闭&#x2F;启动断点（关闭后XHR断点处还是会停住）</li></ol><p><strong>日志断点：</strong>用于输出每一次经过断点时的某些数据，只输出数据，不截停代码。使用时不需要输出语句，直接写变量或字符串，多个用逗号隔开</p><p><strong>条件断点：</strong>用于只断住某个数据在某个条件下的代码</p></blockquote><ul><li><p><strong>DOM事件断点定位加密：</strong></p><ul><li>已有事件断点：元素面板 –&gt; 选择元素 –&gt; 右侧”事件监听器” –&gt; 选择事件定位js文件 –&gt; 断点并调试（<a class="link"   href="https://oauth.d.cn/auth/goLogin.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li><li>添加元素断点：元素面板 –&gt; 选择元素 –&gt; 右击元素代码 –&gt; “发生中断的条件” –&gt; 选择事件</li></ul></li><li><p><strong>XHR请求断点定位加密：</strong></p><ul><li>网络面板 –&gt; 确认数据接口url –&gt; 源代码&#x2F;来源面板 –&gt; 右侧”XHR&#x2F;提取断点” –&gt; <strong>添加url域名后参数前的部分</strong> –&gt; 断点并调试（<a class="link"   href="https://oauth.d.cn/auth/goLogin.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li></ul></li><li><p><strong>网站加载时间轴：</strong></p></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705233309-ee68c835172c1b4.png"                                         ><h3 id="3-方法栈（调用堆栈）"><a href="#3-方法栈（调用堆栈）" class="headerlink" title="3. 方法栈（调用堆栈）"></a>3. 方法栈（调用堆栈）</h3><ul><li><p><strong>方法栈：</strong>当 JavaScript 执行函数时，会在方法栈中创建一个新的帧（frame），表示该函数的执行上下文。<strong>方法栈就是由一系列帧组成的</strong>，每个帧对应一个函数的执行上下文，帧的数量取决于当前代码中函数的调用深度，这些帧按照函数调用的顺序排列，即<strong>先进后出</strong>，构成了调用堆栈</p></li><li><p><strong>解释：</strong>当一个函数被调用时，一个新的帧被推入方法栈的顶部，该帧包含了函数的执行上下文信息，例如局部变量、参数、返回地址等。当函数执行完毕时，对应的帧从方法栈中弹出，控制流回到调用该函数的地方</p></li><li><p><strong>错误追踪：</strong>当 js 代码执行过程中发生错误时，错误信息中会包含一个<strong>堆栈跟踪（stack trace）</strong>，它显示了错误发生时方法栈的状态，其包括了函数调用的顺序，以及错误发生的地方</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 简单代码说明：在调用aa处打上断点，单步调试，可以观察调用堆栈</span><br><span class="line">function cc(a, b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">    console.log(&#x27;调用的cc函数&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bb(a, b) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">    cc()</span><br><span class="line">    console.log(&#x27;调用的bb函数&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function aa(a, b) &#123;</span><br><span class="line">    bb(a, b)</span><br><span class="line">    console.log(&#x27;调用的aa函数&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aa(1, 2)</span><br></pre></td></tr></table></figure><h3 id="4-debugger-反调"><a href="#4-debugger-反调" class="headerlink" title="4. debugger 反调"></a>4. debugger 反调</h3><blockquote><p><strong>反调手段：</strong></p><ol><li><strong>无限debugger：</strong>使用无限 debugger 阻止爬虫工具的正常操作，会导致浏览器调试器无法正常工作</li><li><strong>防止格式化：</strong>代码必须压缩成一行，通过 RegExp + toString() 检测代码是否被格式化</li><li><strong>死代码注入：</strong>在检测到代码被格式化后，造成卡死的情况就是通过死代码注入实现的</li><li><strong>Web Worker 技术：</strong>加载 authProxy.html 页面执行 js 脚本用于禁止断点调试 <code>&lt;html debug=&quot;false&quot;&gt;</code></li></ol></blockquote><ul><li><p><strong>无限debugger解决办法（跟栈分析，置空栈底方法为主）：</strong></p><ol><li><p><strong>浏览器自带：</strong>右击 debugger 处 –&gt; “一律不在此处暂停” &#x2F; “添加条件断点”（false）</p></li><li><p><strong>置空调用方法：</strong>跟栈分析，找到源头的 debugger 方法是如何生成的，置空传入或调用的 debugger 方法</p></li><li><p><strong>替换文件</strong>：把 js 文件保存到本地修改，修改范围主要是将 debugger 相关的代码删除或者改写</p></li><li><p><strong>注入代码（Hook，特点是无限创造VM文件，造成浏览器卡死）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var _constructor = constructor;</span><br><span class="line">Function.prototype.constructor = function (s) &#123;</span><br><span class="line">    if (s == &quot;debugger&quot;) &#123;</span><br><span class="line">        console.log(s);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return _constructor(s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var _Function = Function;</span><br><span class="line">Function = function (s) &#123;</span><br><span class="line">    if (s == &quot;debugger&quot;) &#123;</span><br><span class="line">        console.log(s);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return _Function(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>防止格式化解决办法：</strong></p><ul><li><strong>原理：</strong>一般是<strong>通过 RegExp正则匹配 + toString() 检测某些函数</strong>，是否有换行等格式化操作，返回布尔值</li><li><strong>解决办法：</strong>替换文件，将正则的处理逻辑修改为 true 值</li></ul></li><li><p><strong>死代码注入解决办法：</strong></p><ul><li><strong>原理：</strong>通过两个函数互相无限制调用，或者直接通过 while 写死循环，即 while (!![]) {}</li><li><strong>解决办法：</strong>在正则检测返回为 false 时，继续往下调试，可以定位死代码注入的逻辑</li></ul></li></ul><h3 id="5-搜索关键字"><a href="#5-搜索关键字" class="headerlink" title="5. 搜索关键字"></a>5. 搜索关键字</h3><blockquote><p>搜索关键字时不使用放大镜搜索，因为放大镜搜索是在所有请求接口里面搜索的；而是使用右上角三个点中的搜索（<strong>command+⌥+F</strong>），这个搜索是<strong>在源代码里面搜索</strong>的（<a class="link"   href="http://birdreport.cn/home/activity/page.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>请求头的 <code>Requestid</code> 参数）</p><p><strong>技巧：</strong>搜索关键字定位一般配合<strong>启动器-请求调用堆栈</strong>定位至关键文件，再定位其中的关键字</p></blockquote><ul><li><p><strong>注意：关键字搜索一般是最里层的具体加密位置，通常需要看上几帧的栈，才是调用的位置</strong></p></li><li><p><strong>常用关键字：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Requestid、Requestid=、Requestid:、Requestid&#x27;、Requestid&quot;</span><br><span class="line">// setRequestHeader(&#x27;Requestid&#x27;,&#x27;xxx&#x27;)</span><br><span class="line">2. decrypt(、encrypt(</span><br></pre></td></tr></table></figure></li><li><p><strong>搜索不到的原因：</strong>代码混淆、关键字做拼接</p></li></ul><h3 id="6-启动器定位"><a href="#6-启动器定位" class="headerlink" title="6. 启动器定位"></a>6. 启动器定位</h3><ul><li><strong>使用：</strong>通过数据api接口的启动器定位加密，不常用，运气成分太大，概率太小，范围太大（<a class="link"   href="https://oauth.d.cn/auth/goLogin.html"  target="_blank" rel="noopener">测试网站<i class="fas fa-external-link-alt"></i></a>）</li></ul><h2 id="二、补环境"><a href="#二、补环境" class="headerlink" title="二、补环境"></a>二、补环境</h2><h3 id="1-基础补环境"><a href="#1-基础补环境" class="headerlink" title="1. 基础补环境"></a>1. 基础补环境</h3><blockquote><p><strong>补环境重点之导出关键方法为全局方法：通过 window.aaa 直接将方法赋值全局对象，后续可直接调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">!(function getEnvironment(proxyArray) &#123;</span><br><span class="line">window = global;</span><br><span class="line">// 解决基本环境检测</span><br><span class="line">// delete global;</span><br><span class="line">// delete Buffer;</span><br><span class="line">exports = undefined;</span><br><span class="line">nullfunc = function (res) &#123; console.log(&quot;当前调用函数&quot;, &quot;参数为:&quot;, res); &#125;;</span><br><span class="line">// 脚本仅帮助补了大致环境，需要在此处补其余缺失环境</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; proxyArray.length; i++) &#123;</span><br><span class="line">  var proxyName = proxyArray[i];</span><br><span class="line">  var handler = `</span><br><span class="line">      &#123;</span><br><span class="line">          get: function(target, property, receiver) &#123;</span><br><span class="line">              console.log(&quot;方法：get&quot;, &quot;  $&#123;proxyName&#125;&quot;+&quot;.&quot;+String(property), &quot;  属性值类型:&quot;, typeof target[property]);</span><br><span class="line">              return target[property];</span><br><span class="line">          &#125;,</span><br><span class="line">          set: function(target, property, value, receiver) &#123;</span><br><span class="line">              console.log(&quot;方法：SET&quot;, &quot;  $&#123;proxyName&#125;&quot;+&quot;.&quot;+String(property), &quot;  属性值类型:&quot;, typeof value);</span><br><span class="line">              return Reflect.set(...arguments);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  `;</span><br><span class="line">  eval(`$&#123;proxyName&#125; = (function () &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          $&#123;proxyName&#125;;</span><br><span class="line">          return new Proxy($&#123;proxyName&#125;, $&#123;handler&#125;);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">          $&#123;proxyName&#125; = &#123;&#125;;</span><br><span class="line">          return new Proxy($&#123;proxyName&#125;, $&#123;handler&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)()`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)([&#x27;window&#x27;, &#x27;document&#x27;, &#x27;location&#x27;, &#x27;navigator&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;]);</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>常见环境检测：</strong></p><ol><li>exports 对象：在 Node.js 中 exports 是一个用于模块导出的对象，而在浏览器中是undefined</li><li>全局对象：在浏览器中的全局对象是 window，而在 Node.js 中的全局对象是 global</li></ol></li><li><p><strong>常见环境检测的方法：</strong></p><ul><li><strong>通过 IF 判断语句走错误环境逻辑：</strong>使代码在 node 环境下走与浏览器不一致的逻辑分支，从而返回误差数据（<strong>解决：补完整环境，或者分析网页走的逻辑，与网页保持一致</strong>）</li><li><strong>通过 try 异常捕获不存在的环境：</strong>使代码缺少环境也不报错，从而逆向结果错误，返回错误数据（<strong>解决：直接输出异常的内容，根据异常补完整环境，或者直接把异常捕获的代码删除，将错误暴露出来</strong>）</li></ul></li><li><p><strong>jsdom 补环境：</strong>jsdom 是一个 js 库，用于在 node.js 环境中模拟类似于浏览器环境中的 DOM API（文档对象模型）</p><ul><li>**环境安装：<code>npm install jsdom --save</code>、<code>npm install canvas --save</code>**（可能安装错误，<a class="link"   href="https://github.com/jsdom/jsdom/wiki/jsdom-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3"  target="_blank" rel="noopener">官网下载<i class="fas fa-external-link-alt"></i></a>）</li><li>基本使用：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const jsdom = require(&quot;jsdom&quot;);</span><br><span class="line">const &#123;JSDOM&#125; = jsdom;</span><br><span class="line">const dom = new JSDOM();</span><br><span class="line">window = global;</span><br><span class="line">location = dom.window.location;</span><br><span class="line">navigator = dom.window.navigator;</span><br><span class="line">document = dom.window.document;</span><br><span class="line">location.href = &#x27;https://www.toutiao.com/&#x27;</span><br><span class="line">location.protocol = &#x27;https:&#x27;</span><br><span class="line">document.cookie=&#x27;......&#x27;</span><br></pre></td></tr></table></figure><ul><li><strong>selenium 补环境：</strong>创建一个本地 html 文件，将 js 代码写入，同时将需要调用的方法通过 window 对象导出为全局的，之后使用 selenium 请求此文件地址，并返回浏览器对象，再通过浏览器对象执行 js 代码调用方法即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">PRO_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line">def driver_sig(html_file):</span><br><span class="line">    option = webdriver.ChromeOptions()</span><br><span class="line">    option.add_argument(&#x27;--disable-blink-features=AutomationControlled&#x27;)</span><br><span class="line">    option.add_argument(&#x27;headless&#x27;)</span><br><span class="line">    driver = webdriver.Chrome(executable_path=&#x27;/Users/xfblog/Downloads/chrome-mac-arm64&#x27;, options=option)</span><br><span class="line">    driver.get(PRO_DIR + &#x27;\\&#x27; + html_file)</span><br><span class="line"></span><br><span class="line">    return driver</span><br><span class="line"></span><br><span class="line">html_file = &#x27;index.html&#x27;</span><br><span class="line">driv = driver_sig(html_file)</span><br><span class="line"></span><br><span class="line">print(driv.execute_script(&#x27;return window.aaa()&#x27;))</span><br></pre></td></tr></table></figure><ul><li><strong>flask 实现接口：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import os</span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">PRO_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line">def driver_sig(html_file):</span><br><span class="line">    option = webdriver.ChromeOptions()</span><br><span class="line">    option.add_argument(&#x27;--disable-blink-features=AutomationControlled&#x27;)</span><br><span class="line">    option.add_argument(&#x27;headless&#x27;)</span><br><span class="line">    driver = webdriver.Chrome(options=option)</span><br><span class="line">    driver.get(PRO_DIR + &#x27;\\&#x27; + html_file)</span><br><span class="line"></span><br><span class="line">    return driver</span><br><span class="line"></span><br><span class="line">html_file = &#x27;index.html&#x27;</span><br><span class="line">driv = driver_sig(html_file)</span><br><span class="line"></span><br><span class="line"># 创建 Flask 应用实例</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># 定义路由和视图函数（指定了该路由能够处理来自&#x27;/&#x27;路径的GET和POST请求）</span><br><span class="line">@app.route(&#x27;/&#x27;, methods=[&#x27;get&#x27;, &#x27;post&#x27;])</span><br><span class="line">def hello():</span><br><span class="line">    context = &#123;</span><br><span class="line">        # 加载本地地址 生成cookie值</span><br><span class="line">        &#x27;v&#x27;: driv.execute_script(&#x27;return window.aaa()&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    # 返回cookie值（jsonify函数用于将Python对象转换为JSON格式的响应）</span><br><span class="line">    return jsonify(context=context)</span><br><span class="line"></span><br><span class="line"># 启动应用</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h3 id="2-VM2-框架补环境"><a href="#2-VM2-框架补环境" class="headerlink" title="2. VM2 框架补环境"></a>2. VM2 框架补环境</h3><blockquote><p><strong>vm2框架：</strong>VM2 是一个基于 Node.js 的 JavaScript 沙箱库，用于在一个安全的环境中执行 JavaScript 代码，提供了一种隔离 JavaScript 代码执行的方式，可以防止恶意代码对系统造成损害。</p><p><strong>作用：</strong>vm2 提供了一个干净独立的沙盒环境，提供测试，打造了一个真实的浏览器环境，可以用于逆向环境</p><p><strong>框架配置：</strong></p><ol><li><code>npm install vm2</code></li><li><code>arch -arm64 brew install pkg-config cairo pango jpeg giflib librsvg</code></li><li><code>npm install canvas</code></li></ol></blockquote><ul><li><strong>vm2框架使用教程：</strong><ol><li><strong>run&#x2F;run.js：</strong>需要补环境的代码，即逆向代码（<strong>其中需要导出关键方法为 window 全局方法</strong>）</li><li><strong>run&#x2F;lastDeal.js：</strong>调用 window 全局方法</li><li><strong>config&#x2F;config.js：</strong>全局对象的某些基础属性配置（location.href、navigator.userAgent、cookie等）</li><li><strong>&#x2F;main.js：</strong>主函数调用，保证逆向代码 run.js 文件路径配置正确</li><li><strong>tools&#x2F;printLog.js（可选）</strong>：日志文件路径 filePath 配置（<strong>可以在 run&#x2F;log.txt 查看吐的环境</strong>）</li></ol></li></ul><h2 id="三、Python-与-JS-互调"><a href="#三、Python-与-JS-互调" class="headerlink" title="三、Python 与 JS 互调"></a>三、Python 与 JS 互调</h2><h3 id="1-pyexecjs-直接执行-js"><a href="#1-pyexecjs-直接执行-js" class="headerlink" title="1. pyexecjs 直接执行 js"></a>1. pyexecjs 直接执行 js</h3><blockquote><p><strong>简介：</strong>PyExecJS 是一个用于在 Python 中执行 js 代码的库。它的设计目标是在不需要绑定到特定 JavaScript 引擎的情况下提供灵活性，直接利用系统中已经安装的 JavaScript 运行时，如 Node.js、Rhino 等（<code>pip install PyExecJS</code>）</p></blockquote><ul><li><p><strong>execjs.get()：</strong></p><ul><li><p><strong>作用：</strong>用于获取系统中可用的 JavaScript 运行时环境</p></li><li><p><strong>返回值：</strong>返回一个 Runtime 对象，可以使用这个运行时环境对象来编译和执行 JavaScript 代码</p></li></ul></li><li><p><strong>Runtime.compile(source)：</strong></p><ul><li><strong>作用：</strong>用于编译 JavaScript 代码，接受字符串参数 source 表示要执行的 JavaScript 代码</li><li><strong>返回值：</strong>返回一个 Context 对象，表示一个 JavaScript 上下文</li></ul></li><li><p><strong>Context.call(name, *args)：</strong></p><ul><li><strong>作用：</strong>用于在 JavaScript 上下文中调用函数，接受一个函数名 name 和任意数量的参数 *args</li><li><strong>返回值：</strong>返回被调用函数的返回值</li></ul></li><li><p><strong>Context.eval(source)：</strong>用于在 JavaScript 上下文中执行一段 JavaScript 代码，并返回执行结果</p></li><li><p><strong>链式调用：<code>result = execjs.compile(open(&#39;./ceshi.js&#39;).read()).call(&#39;add&#39;, 1, 2)</code></strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import execjs  # 注意，导入的库是execjs，而不是PyExecJS</span><br><span class="line"></span><br><span class="line"># 获取系统中可用的js运行时环境：node.js</span><br><span class="line">runtime = execjs.get()  # ExternalRuntime(Node.js (V8))</span><br><span class="line"></span><br><span class="line"># 编译js代码，返回Context对象</span><br><span class="line">context = runtime.compile(open(&#x27;./ceshi.js&#x27;).read())</span><br><span class="line"></span><br><span class="line"># 调用js函数</span><br><span class="line">print(context.call(&#x27;add&#x27;, 1, 2))  # 3，接受多个参数，指定函数名并传入函数参数</span><br><span class="line">print(context.eval(&quot;add(3, 4)&quot;))  # 7，接受一个参数，整个函数调用包含在字符串内</span><br></pre></td></tr></table></figure><h3 id="2-express-启动-node-服务"><a href="#2-express-启动-node-服务" class="headerlink" title="2. express 启动 node 服务"></a>2. express 启动 node 服务</h3><blockquote><p><strong>为什么使用 express：</strong></p><ul><li>在浏览器环境中，process 对象是 undefined 的，而 process 是 nodejs 特有的系统级 API，用于访问与操作系统和当前运行环境相关的信息，<strong>在补环境时，如果需要检测需要定义为 undefined，此时如果使用 execjs 则会报错 <code>execjs._exceptions</code></strong></li></ul><p><strong>简介：</strong>Express.js 是一个流行的、基于 Node.js 的 Web 应用程序框架，简化了在 Node.js 中构建 Web 应用程序和 API 的过程</p><p><strong>应用场景：</strong>客户只需要一个API接口，用于返回数据，而不需要项目的源代码</p><p><strong>安装：<code>npm install express -S</code>（将Express安装为项目的生产环境依赖，即安装在项目这个局部）</strong></p></blockquote><ul><li><strong>路由：</strong>Express通过路由将HTTP请求与特定的处理函数关联起来，可以根据不同的URL路径将不同的请求映射到相应的处理函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// boss.js</span><br><span class="line"></span><br><span class="line">function get_cookie(seed, ts, code) &#123;</span><br><span class="line">    // 在这里实现生成 cookie 的逻辑</span><br><span class="line">    return &#123;</span><br><span class="line">        seed: seed,</span><br><span class="line">        ts: ts,</span><br><span class="line">        code: code,</span><br><span class="line">        cookie: &quot;这是一个生成的cookie&quot; // 这里只是一个示例，替换为实际逻辑</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 module.exports 导出</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    get_cookie</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;)</span><br><span class="line">var app = express()</span><br><span class="line">var cook = require(&#x27;./boss.js&#x27;)  // 导入 boss.js 模块（补环境脚本）</span><br><span class="line">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class="line"></span><br><span class="line">// 调整参数大小限制，否则会提示参数过大</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;limit: &#x27;50mb&#x27;, extended: true&#125;));</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/get_cookie&#x27;, function (req, res) &#123;</span><br><span class="line">    let ip = req.headers[&#x27;x-real-ip&#x27;] ? req.headers[&#x27;x-real-ip&#x27;] : req.ip.replace(/::ffff:/, &#x27;&#x27;);</span><br><span class="line">    let time = new Date().toString().replace(/\+0800.*/, &#x27;&#x27;);</span><br><span class="line">    console.log(&#x27;INFO:&#x27;, time, ip, req.method, req.originalUrl, &#x27;200 OK!&#x27;);</span><br><span class="line">    // 获取POST请求的formdata</span><br><span class="line">    let result = req.body;</span><br><span class="line">    let code = result.code;</span><br><span class="line">    let seed = result.seed;</span><br><span class="line">    let ts = result.ts;</span><br><span class="line"></span><br><span class="line">    // 调用 boss 模块中的 get_cookie 方法，该方法需要提前 module.exports 导出</span><br><span class="line">    let cookie = cook.get_cookie(seed, ts, code);</span><br><span class="line">    // 设置响应头，如果不设置，通过 asyncio_requests 请求的 res.json() 会报错，因为它是根据响应头解析 json 数据</span><br><span class="line">    // 而 requests 可以直接使用 res.json() 解析，因为它是根据响应信息解析</span><br><span class="line">    res.set(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)</span><br><span class="line">    res.send(JSON.stringify(cookie));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(5001, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;开启服务，端口 5001&quot;, new Date().toString().replace(/\+0800.*/, &#x27;&#x27;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="四、字体反爬专题"><a href="#四、字体反爬专题" class="headerlink" title="四、字体反爬专题"></a>四、字体反爬专题</h2><blockquote><p><strong>字体反爬工作原理：</strong></p><ol><li><strong>字体文件替代字符映射：</strong>网页使用自定义字体文件，将常规的字符映射到不同的字形。例如，字母”A”在字体文件中可能被映射为一个特定的符号，而不是标准的字母形状。这样，即使在HTML源代码中看到了字母”A”，实际显示的可能是另一种字符。</li><li><strong>动态生成字体文件：</strong>有些网站会在每次加载页面时动态生成字体文件，使得每次访问页面时，字体文件都会有所变化。这增加了破解字体映射的难度，因为爬虫需要每次重新分析字体文件。</li></ol></blockquote><h3 id="1-字体文件格式"><a href="#1-字体文件格式" class="headerlink" title="1. 字体文件格式"></a>1. 字体文件格式</h3><ul><li><strong>常见字体文件格式：</strong><ul><li><strong>TTF：</strong>一种矢量字体格式，支持轮廓字形和平滑的曲线。用于 windows 操作系统、桌面应用程序和网页</li><li><strong>OTF：</strong>一种可扩展的字体格式，TTF的改进版，支持 unicode 字符集。常用于印刷、出版和网页设计</li><li><strong>FON：</strong>通常用于存储位图字体，不支持矢量图形，将每个字符表示为像素图。用于早期的 windows 系统</li><li><strong>TTC：</strong>是 TrueType 字体的集合格式，包含多个字体文件。常用于节省空间，以便同时提供多个字体样式</li><li><strong>SHX：</strong>一种 AutoCAD 使用的字体文件格式。常用于图形设计和 CAD 软件中，支持矢量图形和线框字形</li><li><strong>EOT：</strong>由 Microsoft 开发的一种字体格式，支持字体子集化和压缩。主要用于早期浏览器中网页字体嵌入</li><li><strong>WOFF：</strong>为 Web 优化的字体格式，是 TTF 和 OTF 的包装版，支持压缩和元数据。主要用于网页嵌入字体</li></ul></li></ul><h3 id="2-字体文件处理"><a href="#2-字体文件处理" class="headerlink" title="2. 字体文件处理"></a>2. 字体文件处理</h3><blockquote><p><strong>定位：</strong>一般通过 @font-face 定位字体映射文件的下载地址</p><p><strong>解析：</strong>通过**<a class="link"   href="https://font.qqe2.com/"  target="_blank" rel="noopener">在线字体解析<i class="fas fa-external-link-alt"></i></a>**，将文件直接拖入解析，查看字体映射关系</p><p><strong>分析：</strong>根据在线字体解析出的映射关系，分析<strong>网页源代码</strong>字体与文件映射关系的一一对应</p></blockquote><ul><li><strong>反反爬策略：</strong><ol><li>检查网页控件的字体名称，即 class 样式名称（对应 @font-face 中 font-family 的值）</li><li>通过首页源码 @font-face 搜索、Network-Font面板、全局搜索 class 样式进行调试分析获取字体地址</li><li>通过在线字体解析网站查看字体的映射关系，配合<strong>网页源代码</strong>分析</li><li>通过页面刷新、下载查看字体，判断字体文件是否动态生成</li><li>使用依赖库 fonttools 解析字体，根据元素内容生成新的键值对，对响应结果根据键值对进行内容替换</li></ol></li><li><strong>工具库 fonttools 的使用：</strong><ul><li><strong>cmap - 字符到字形映射：</strong>建立字符码和字形索引之间的映射，将文本字符映射到字体文件中的字形</li><li><strong>glyf - 字形数据：</strong>包含了字体中每个字形的轮廓和其他相关数据。轮廓数据描述了字体中每个字符的形状</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from fontTools.ttLib import TTFont</span><br><span class="line"></span><br><span class="line"># 加载字体文件</span><br><span class="line">font = TTFont(&#x27;file.woff&#x27;)</span><br><span class="line"># 保存为XML文件，包含了字体的结构和数据，方便进行查看和分析</span><br><span class="line">font.saveXML(&#x27;font.xml&#x27;)</span><br><span class="line"># 获取字体表键值，返回字体对象中包含的字体表的键值列表</span><br><span class="line">kv = font.keys()</span><br><span class="line">print(kv)  # [&#x27;GlyphOrder&#x27;, &#x27;head&#x27;, &#x27;hhea&#x27;, &#x27;maxp&#x27;, &#x27;OS/2&#x27;, &#x27;hmtx&#x27;, &#x27;cmap&#x27;, &#x27;loca&#x27;, &#x27;glyf&#x27;, &#x27;name&#x27;, &#x27;post&#x27;, &#x27;GSUB&#x27;]</span><br><span class="line"></span><br><span class="line"># 获取字符到字形映射表（code-&gt;name），即 Unicode 编码到字形索引的映射</span><br><span class="line">cmap = font.getBestCmap()</span><br><span class="line">print(cmap)  # &#123;57420: &#x27;uni77&#x27;, ......, 63673: &#x27;uni53&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># 获取字形 uni30 的坐标信息，coordinates 属性返回字形的轮廓坐标</span><br><span class="line">print(font[&#x27;glyf&#x27;][&#x27;uni30&#x27;].coordinates)</span><br></pre></td></tr></table></figure><h2 id="五、微信小程序专题"><a href="#五、微信小程序专题" class="headerlink" title="五、微信小程序专题"></a>五、微信小程序专题</h2><blockquote><p><strong>微信小程序强制开启开发者工具：<a class="link"   href="https://github.com/JaveleyQAQ/WeChatOpenDevTools-Python"  target="_blank" rel="noopener">WeChatOpenDevTools-Python<i class="fas fa-external-link-alt"></i></a></strong></p><p><strong>注意：只能在 windows 操作系统上使用！</strong></p></blockquote><ul><li><strong>使用：</strong>根据工具教程，下载对应 vx 和小程序版本，运行 exe 可执行文件，登录 vx 后打开小程序即可抓包</li></ul><h2 id="六、逆向技巧专题"><a href="#六、逆向技巧专题" class="headerlink" title="六、逆向技巧专题"></a>六、逆向技巧专题</h2><blockquote><p><strong>基础爬虫知识：</strong></p><ul><li>通过浏览器直接访问的方式无法发送 get 以外的请求</li><li>实现 post 请求时，参数 data 和 headers 尽量都使用关键字实参，如果 data 中携带的某一字段值为空，则需使用空字符串””代替，而不是 None</li><li>请求移动端获取的数据接口时，请求头的 user-agent 也一定要用移动端的</li></ul><p><strong>请求参数最终是以 Content-Type 字段确定参数类型的：</strong></p><ul><li><strong>get请求[查询字符串参数]：</strong>显现的，需要通过 request.get() 方法中的 params 参数传递，可以不完整</li><li><strong>post请求[表单数据]：</strong>隐藏的，需要通过 request.post() 方法中的 data 参数传递，必须完整</li><li><strong>post请求[请求载荷]：</strong>隐藏的，需要通过 request.post() 方法中的 json 参数传递，必须完整</li><li><strong>post请求[请求载荷] + <code>&quot;Content-Type&quot;: &quot;application/octet-stream&quot;</code>：</strong>需要 request.post() 方法的 data 参数<strong>传递 bytes 类型数据</strong></li></ul><p><strong><span style="color:red;">查询字符串参数构建（url 后缀）：</span></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">urllib.parse.urlencode(params)  # key1=value1&amp;key2=value2&amp;key3=value3</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-特殊逆向代码"><a href="#1-特殊逆向代码" class="headerlink" title="1. 特殊逆向代码"></a>1. 特殊逆向代码</h3><ul><li><p><strong>逗号表达式（最后一个逗号的值）：</strong></p><ul><li><strong>用法：</strong>逗号分隔，按照从左到右的顺序执行其中的每个子表达式，但返回值是最后一个子表达式的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0, i[jt])((0, i[qt])(a, d))  // 等价于i[jt](i[qt](a, d))</span><br></pre></td></tr></table></figure></li><li><p><strong>导出模块中的默认成员（对象、函数、类等）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这里 export default 导出了一个包含两个方法的对象</span><br><span class="line">// 由于 js 的特性，第二个 newGuid 的定义会覆盖第一个，因为它们都使用相同的名称</span><br><span class="line">// 这个方法接受一个名为 format 的参数</span><br><span class="line">export default &#123;</span><br><span class="line">    newGuid()&#123;</span><br><span class="line">        return Guid.NewGuid().ToString(&#x27;N&#x27;).toUpperCase();</span><br><span class="line">    &#125;,</span><br><span class="line">    newGuid(format)&#123;</span><br><span class="line">        return Guid.NewGuid().ToString(format);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数return的是逗号表达式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var s, u = (s = null, function () &#123;</span><br><span class="line">        return s || (s = function () &#123;</span><br><span class="line">            var e, t, n, r, i = null;</span><br><span class="line">            return i || (t = new RegExp(&quot;\\u200c&quot;, &quot;g&quot;),</span><br><span class="line">                n = new RegExp(&quot;\\u200d&quot;, &quot;g&quot;),</span><br><span class="line">                r = new RegExp(&quot;.&#123;8&#125;&quot;, &quot;g&quot;),</span><br><span class="line">                e = &quot;asdasdasd&quot;,</span><br><span class="line">                i = &#123;key: o.enc.Utf8.parse(e)&#125;),</span><br><span class="line">                i  // 逗号表达式</span><br><span class="line">        &#125;()),</span><br><span class="line">            s  // 逗号表达式</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>return另一个对象，直接赋值此对象即可：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;</span><br><span class="line">    return new d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>自执行入口模块的webpack（全自执行）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var protobuf_min = &#123;</span><br><span class="line">    exports: &#123;&#125;  // 创建一个对象用于存储模块的导出内容</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(function (module) &#123;</span><br><span class="line">    // 定义一个立即执行函数，传入一个参数 module</span><br><span class="line"></span><br><span class="line">    !function (g) &#123;</span><br><span class="line">        var r, e, t, i;</span><br><span class="line"></span><br><span class="line">        r = &#123;  // webpack的模块</span><br><span class="line">            1: [&#x27;&#x27;],</span><br><span class="line">            2: [&#x27;&#x27;],</span><br><span class="line">            3: [&#x27;&#x27;],</span><br><span class="line">            // ......</span><br><span class="line">            39: [&#x27;&#x27;]</span><br><span class="line">        &#125;,</span><br><span class="line">            e = &#123;&#125;,</span><br><span class="line">            t = [16],</span><br><span class="line"></span><br><span class="line">            i = function t(n) &#123;</span><br><span class="line">                // 定义一个递归函数 i，接受一个参数 n</span><br><span class="line">                var o = e[n];</span><br><span class="line">                // 从 e 对象中获取键为 n 的值</span><br><span class="line">                return o || r[n][0].call(o = e[n] = &#123;</span><br><span class="line">                    exports: &#123;&#125;</span><br><span class="line">                &#125;, t, o, o.exports),</span><br><span class="line">                    // 如果 o 不存在，调用 r[n][0] 函数，并将其返回值赋给 o</span><br><span class="line">                    o.exports</span><br><span class="line">                // 返回 o 对象的 exports 属性</span><br><span class="line">            &#125;(t[0]),</span><br><span class="line">            // 调用 i 函数，传入参数 t[0]，并将结果赋给 i</span><br><span class="line"></span><br><span class="line">            i.util.global.protobuf = i,</span><br><span class="line">            // 将 i 对象赋给 i.util.global.protobuf 属性</span><br><span class="line"></span><br><span class="line">        module &amp;&amp; module.exports &amp;&amp; (module.exports = i);</span><br><span class="line">        // 如果 module 和 module.exports 存在，则将 i 对象赋给 module.exports</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">&#125;)(protobuf_min);  // 将 protobuf_min 作为参数传入外层的立即执行函数</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-定位加密总结"><a href="#2-定位加密总结" class="headerlink" title="2. 定位加密总结"></a>2. 定位加密总结</h3><blockquote><p><strong>注意：调试时需要调试至需要逆向的参数或数据对应的密文数据出现时，即正确的密文出现时再跟栈</strong></p><ul><li>其中<strong>响应数据加密：</strong>可以调试至明文数据出现时<strong>向上跟一个栈后分析代码，解密逻辑一般在 JSON.parse 附近或里面</strong>。也可以调试至密文数据出现时<strong>向下调试</strong>（不建议），观察数据什么时候变成明文</li><li><strong>注意：不能调试至明文数据出现时，不向上跟栈而直接向下调试</strong>，因为这可能存在解密后的数据重新复制给了加密变量的情况，导致无法观察到密文数据，也就无法判断解密逻辑存在于哪里</li><li>其中<strong>参数加密：</strong>如果参数被赋值给了另一个变量，那么应该去找那个变量的赋值位置，例 **<code>wo=&quot;X-Tingyun&quot;</code>**，则需要找 wo 的赋值位置即是 X-Tingyun 的赋值位置 <strong><code>t.addHeader(wo, i)</code></strong></li></ul></blockquote><ul><li><strong><span style="color:red;">根据加密数据分析+搜索关键字定位：</span></strong></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1705927789-ee046979a73c226.png"                         style="width:80%;margin:0 auto;"                 ><ul><li><strong><span style="color:red;">响应数据加密：</span></strong><ol><li><strong>Hook JSON.parse(parmas)：</strong>监视参数 parmas 的变化</li><li><strong>XHR 断点</strong>：ajax 调用时会通过 <strong>success、then、done</strong> 设置处理（解密）响应数据的回调函数</li></ol></li><li><strong><span style="color:red;">查询字符串参数加密：</span></strong><ol><li><strong>Hook XHR open</strong>：open 方法的参数 url 中包含被加密的查询字符串参数</li></ol></li><li><strong><span style="color:red;">表单数据&#x2F;请求载荷参数加密：</span></strong><ol><li><strong>Hook JSON.stringify(parmas)：</strong>监视参数 parmas 的变化，<strong>调试至正确的密文数据出现时跟栈</strong></li></ol></li><li><strong><span style="color:red;">请求头headers中参数加密：</span></strong><ol><li><strong>Hook XHR setRequestHeader：</strong>setRequestHeader是在 open 方法之后、send 方法之前调用的</li><li><strong><span style="color:red;">参数的key和value都被加密：</span><strong>此时无法再 Hook 关键字了，只能直接 Hook 整个 setRequestHeader，但是这将会 Hook 到全部的参数信息，可以</strong>调试至需要的密文数据出现后再跟栈</strong></li><li><strong>XHR断点：</strong>setRequestHeader 方法是在 open 之后、send 之前调用的</li></ol></li><li><strong><span style="color:red;">cookies加密：</span></strong><ol><li><strong>Hook Object.defineProperty：</strong>Hook 前需要先清除浏览器Cookie</li></ol></li></ul><h3 id="3-调试问题记录"><a href="#3-调试问题记录" class="headerlink" title="3. 调试问题记录"></a>3. 调试问题记录</h3><ul><li><strong>代码在 js 中调用正常，在 python 调用异常：</strong><ol><li><strong>考虑是否是 python 获取的数据有问题</strong>，可以将数据拿到 js 代码运行一下，如果有问题可以跟网页上的数据对比一下，看看是否是因为被反爬了服务器返回了假数据</li><li><strong>考虑是否是传递的参数格式有问题：</strong>同样是将对象转换成字符串，<strong>最大的区别就是 JSON.stringify 不会对非 ASCII 字符进行编码处理；而 json.dumps 会使用 ASCII 编码来处理非ASCII字符（如汉字）</strong>。在通过 python 调用 js 并传递请求参数过去加密时，应该在 python 中通过 json.dumps 方法进行转换后再传递；而不是直接传递过去，再在 js 中通过 JSON.stringify 方法进行转换，这样才能保证最终在 python 中对数据 api 发起请求时所携带的请求参数格式和加密的请求参数格式一致</li><li><strong>考虑是否是传递数据的字符串两端有引号： <code>json.dumps(params).strip(&#39;&quot;&#39;)</code></strong></li><li><strong>考虑是否是传递数据的字符串中有”美化”空格：<code>json.dumps(params).replace(&#39; &#39;, &#39;&#39;)</code></strong></li><li><strong>确保在 js 代码中使用的数据是对象而不是字符串：</strong>直接在加密逻辑的函数内部进行 <strong><code>JSON.parse</code></strong> 转换</li></ol></li><li><strong>解决无法正常使用开发者工具：</strong><ol><li>观察页面特征：页面跳转对应关键字<code>window.location</code>，页面关闭对应关键字<code>window.close()</code></li><li>观察控制台面板特征：输出”控制台数据已被清除”或 “undefine”，对应关键字<code>console.clear()</code></li><li><strong>解决：</strong>使用无痕浏览器打开网站（<strong>避免插件 js 文件过多</strong>），开启 “<strong>源代码&#x2F;来源</strong>“ 面板右侧 “<strong>事件监听器断点</strong>“ 的 “<strong>脚本</strong>“，这可以断住网站加载执行的每一个 js 脚本，进行调试和搜索特征对应的关键字，定位到位置后进行”<strong>替换内容</strong>“</li><li><strong>如果网站通过页面大小尺寸检测开发者工具是否打开：</strong>可以直接抽离开发者工具</li></ol></li></ul><h3 id="4-代码调试专题"><a href="#4-代码调试专题" class="headerlink" title="4. 代码调试专题"></a>4. 代码调试专题</h3><blockquote><p><strong>明确：</strong>首先一定要先明确自己需要加密或解密的数据，在跟栈过程中要时刻观察数据值的变化以确定位置</p><p><strong>分析：分析加密时一定要先去校验这个参数是否需要逆向，可能不携带也能请求成功（通常指请求头参数）</strong></p><p><strong>注意：<span style="color:red;">JavaScript 中的对象是动态的，可以先定义后逐步赋值</span></strong></p></blockquote><ul><li><strong>调试技巧：</strong><ol><li><strong>栈堆的帧对应代码作用域，必须确保使用 Hook 时和无限 debugger 在同一个作用域</strong>，才能 Hook 成功</li><li>断点调试时，断点的位置非常重要，<strong>不要断在还没有调用的函数中</strong>，函数内部要断在一定会走的逻辑</li><li>调试方法时<strong>先看返回值</strong>，逻辑代码中要分析出无效逻辑，只读代码走的部分，<strong>补代码时与网页保持一致</strong></li><li><strong>考虑一长串数据是不是固定值</strong>，先直接搜索数据确定是否是写死数据，搜不到则需要找到数据生成位置，打上断点进行调试，如果走不进断点，则说明数据是<strong>页面刷新时生成的</strong>，且只生成一次。如果是常量，则可以直接写死，不影响加密结果；如果是对象（<strong>webpack</strong>），则可以直接将整个对象（<strong>加载器</strong>）拿下来</li><li><strong>在调试至异步栈的上一帧观察数据时</strong>，需要先观察数据是否是在异步栈之前就已经被加密过了，而不是在异步中加密的，<strong>此时不能直接观察</strong>，而是打上断点重新请求调试观察，避免作用域问题导致数据不准确</li><li>在 XHR 断点定位调试中，如果要找 ajax 的回调函数，那么在跟栈时<strong>注意观察在调用 ajax 的帧的附近的一两个栈</strong>，避免找错真正调用 ajax 的栈</li><li><strong>观察接口的启动器中是否有异步的代码</strong>，如果没有异步，那么通过XHR断点是方便跟栈定位到加密位置的</li><li>在对称加密算法中，<strong>key 和 iv 一定是固定的</strong>，因为对称加密算法加密和解密必须使用相同的密钥</li><li>在 RSA 非对称加密中，<strong>公钥</strong>也有可能不是直接写死在代码中，而是<strong>从请求另一个接口的响应中获取</strong></li></ol></li><li><strong>补代码技巧：</strong><ol><li>遇到非 window 对象调用方法，或者在 <strong>new</strong> 一个非 window 对象时，并且进入被调用方法内部看到 <strong>this</strong> 调用，此时可以将整个”类”对象的定义扣下来，而不单独扣某个函数，<strong>包括附近用到这个”类”的所有自执行方法，自执行方法也可以为对象<span style="color:red;">动态赋值</span></strong></li><li>遵守从里到外逐层加密的原则，贴着函数找数据生成的位置，如果<strong>和实际生成的数据的不一致</strong>，那可能是在函数外面的下面进行了二次**<span style="color:red;">动态赋值</span><strong>，而函数调用在赋值之后导致的（</strong>在数据生成位置打断点调试**）</li><li><strong>自执行方法为形参赋值</strong>，导致找不到对象e的生成位置，例 <strong><code>(function(e)&#123;&#125;).call(this, n(&quot;b639&quot;))</code></strong></li><li>补代码时<strong>无效逻辑代码和异常捕获代码都要删除，补的每段代码的位置一定要和浏览器保持一致</strong></li><li>找到网站的加密算法，<strong>一定要对比它是不是一个标准的加密算法</strong>，可以加密同样的值进行对比</li><li><strong>时间戳：</strong>要确保各参数使用的时间戳一致，还要确保 python 和 js 使用的是同一时间戳（<strong>注意长度相同</strong>）</li><li><strong>遇到 <code>window.属性</code> 赋值位置找不到（常量）</strong>，可以在源代码搜索，大概率存在于<strong>首页</strong> document 文档中</li><li><strong>遇到 <code>window.方法</code> 在环境中报错（方法）</strong>，直接补环境，也可能是 node 中本身就有的方法（<strong>atob</strong>）</li><li><strong>遇到 window 中的环境在 node 中没有</strong>，可以直接让包含环境的那块代码的结果与浏览器保持一致即可</li></ol></li></ul><h3 id="5-Webpack专题"><a href="#5-Webpack专题" class="headerlink" title="5. Webpack专题"></a>5. Webpack专题</h3><ol><li>如果遇到 <strong>obj.func</strong> 的代码，但是<strong>方法的属性 name 值与 func 不一致</strong>，这可能是因为 webpack 打包后改变了函数调用的名称，此时可以先找一下 obj 的生成。或者直接进入函数，看函数是否是在 webpack 打包后的模块（**<code>function(e, t, n)&#123;&#125;</code>**）中，此时也应该找 obj 的生成，不建议直接扣函数</li><li><strong>就算方法的 name 值与 func 一致</strong>，由于 webpack 常见，也应该注意 obj 的生成是否是 webpack 格式</li><li><strong>加载器和模块都补完的情况下代码仍然报 call 错误，</strong>可能是由于加载器没有接受模块形参，需要手动补上</li><li><strong>加载器执行模块后程序无法退出，</strong>可能是因为加载器内使用了定时器无限执行，可以<strong>置空定时器方法</strong>解决</li><li>在导出加载器时，<strong>一定要注释掉加载器自己调用的模块</strong>，否则会调用很多无用模块</li></ol><h3 id="6-OB混淆专题"><a href="#6-OB混淆专题" class="headerlink" title="6. OB混淆专题"></a>6. OB混淆专题</h3><ol><li>扣代码时，后面跟括号的则是方法，<strong>中括号内的属性可以直接还原</strong>，而外层的整体的方法需要扣</li><li><strong>请求头中 Content-Type 值为 octet-stream，表示请求携带的数据类型是通用的二进制流媒体类型，需post请求传递 bytes 类型数据，即<code>requests.post(url..., data=bytes(b_data[&#39;data&#39;])</code></strong></li><li>补混淆代码时，其结果生成的数据与网页不一致，那么说明补代码时，<strong>缺少了重构数组的自执行方法</strong></li><li><strong>代码阻塞不执行：</strong>有两种可能，说明存在检测代码格式化，<strong>需要压缩混淆代码</strong>，也有可能是存在定时器</li></ol><h3 id="7-jsvmp技术专题"><a href="#7-jsvmp技术专题" class="headerlink" title="7. jsvmp技术专题"></a>7. jsvmp技术专题</h3><ol><li><strong>jsvmp代码一般采用全扣，通过日志断点（插桩）或者条件断点调试代码，从而补环境还原算法</strong></li><li><strong>断点调试：</strong>jsvmp代码只在页面刷新时加载一次，调试时需要刷新网页才能走进断点（<strong>当断点无法进入时，第一要考虑是否是断点位置错误，一行中有多个断点位置的可能，可能断点的位置逻辑并没有走；第二要考虑是否断点位置的数据已经生成了，需要刷新网页重新生成</strong>）</li><li><strong>补环境后无报错，但数据不对（1）：</strong>在调用解释器识别字节码时，往往<strong>在字节码参数后面，还会跟上环境检测的代码参数</strong>，此时需要修改检测条件模拟浏览器环境（例 exports、module）</li></ol><h3 id="8-补环境专题"><a href="#8-补环境专题" class="headerlink" title="8. 补环境专题"></a>8. 补环境专题</h3><ol><li><strong>吐环境脚本不吐环境：</strong>可能是 console.log 被置空，可以将其在吐环境脚本中赋值给其他变量，并替换使用</li><li><strong>吐环境脚本使用：</strong>全局导出数据时，<strong>get 总发生在 set 之前</strong>，说明可能在 set 时<strong>存在定时器</strong>，去掉定时器即可</li><li><strong>导出方法技巧：如果方法不好导出，那就调试，与浏览器同步调试，看哪个参数或返回值与浏览器不一致</strong></li><li><strong>遇到异常报错 ReferenceError: xxx is not defined：</strong>最重要的是和网页保持一致，先确定 xxx 在网页中是什么，是对象则补空对象，是函数则补空函数（补空的前提是对整体代码，对数据无影响）</li><li><strong>遇到异常报错 TypeError: Cannot read properties of undefined (reading ‘xxx’)：</strong>无法读取未定义的属性或方法。如果是 js 内置属性，那么则需要补调用它的对象值；如果是环境属性不存在，则直接补对应网页一致的属性值；如果是解密方法不存在，且环境已经补好，则说明还存在环境检测没有处理</li><li><strong>遇到异常报错 TypeError: Cannot set properties of undefined (setting ‘display’)：</strong>无法设置属性值 display，在 css 中通过 style 样式设置其属性，所以补环境 <code>&#123;return &#123;style: &#123;display: &#123;&#125;&#125;&#125;&#125;</code></li><li><strong>补环境后无报错，但数据不对（2）：</strong>对于吐环境脚本中属性值类型为 undefined 的环境，可能还需要进一步与网页环境值保持一致。其中对于关键环境，例如 cookie、userAgent 等，可能存在在代码中对环境值进行置空或修改的情况，此时可以打印具体环境值进行确定，并通过在所有代码后方补关键环境解决</li><li><strong>补环境后无报错，但数据不对（3）：</strong>可能存在环境检测中的 toString 检测，可搜索 <code>native code</code> 或 <code>toString</code> 关键字确定代码中是否有 toString 检测</li></ol><h3 id="9-Cookie反爬专题"><a href="#9-Cookie反爬专题" class="headerlink" title="9. Cookie反爬专题"></a>9. Cookie反爬专题</h3><blockquote><p><strong>重点：<span style="color:red;">Cookie反爬中，生成 Cookie 的代码文件是动态的，每一次请求所返回的代码都不一样，下断点后刷新网页，断点便不再是原始代码位置，此时可以替换文件下断点解决问题</span></strong></p></blockquote><ol><li><strong>在每一次断点调试前，一定要清空 Cookie 值，因为如果 Cookie 一直不失效，可能就一直进入无法断点</strong></li><li><strong>HttpOnly属性：</strong>当服务器在设置 Cookie 时将 HTTPOnly 属性设为 true 时，意味着该 Cookie 将不能被 JavaScript 脚本访问，仅能在 HTTP 请求中被发送到服务器端（<strong>即该 Cookie 只能在服务器响应中设置</strong>）</li><li>网络面板的 Cookie 日志中，<strong>请求 Cookie</strong> 对应请求头中携带的 Cookie，<strong>响应 Cookie</strong> 对应服务器响应设置的 Cookie 或服务器响应的 js 代码生成的 Cookie</li><li><strong>在测试补瑞数环境时，meat 标签 content 属性、自执行 js 函数，外链 js 代码，都必须实时，且缺一不可</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、JS调试技巧&quot;&gt;&lt;a href=&quot;#一、JS调试技巧&quot; class=&quot;headerlink&quot; title=&quot;一、JS调试技巧&quot;&gt;&lt;/a&gt;一、JS调试技巧&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在页面中右击 dom 元素标签 –&amp;gt; 存储为全局变量 –&amp;g</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="JS逆向" scheme="http://example.com/tags/JS%E9%80%86%E5%90%91/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>爬虫_3_Ubuntu安装配置</title>
    <link href="http://example.com/2023/11/01/%E7%88%AC%E8%99%AB_3_Ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/11/01/%E7%88%AC%E8%99%AB_3_Ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2023-10-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ubuntu-18-04-6安装"><a href="#一、ubuntu-18-04-6安装" class="headerlink" title="一、ubuntu-18.04.6安装"></a>一、ubuntu-18.04.6安装</h2><blockquote><p> <strong>在m1芯片的MacBook上使用UTM虚拟机安装ubuntu-18.04.6（关键步骤）：</strong></p><ol><li><strong>阿里云镜像站 ubuntu-18.04.6 下载链接：</strong><a class="link"   href="https://mirrors.aliyun.com/ubuntu-cdimage/releases/bionic/release/ubuntu-18.04.6-server-arm64.iso"  target="_blank" rel="noopener">ubuntu-18.04.6-server-arm64.iso<i class="fas fa-external-link-alt"></i></a></li><li><strong>一键配置系统源：<code>wget http://fishros.com/install -O fishros &amp;&amp; . fishros</code> &gt;&gt; 5 &gt;&gt; 2 &gt;&gt; 0</strong> </li><li><strong>安装ubuntu桌面：<code>sudo apt install tasksel</code> &gt;&gt; <code>sudo tasksel install ubuntu-desktop</code></strong></li><li><strong>查询可用网卡：<code>ifconfig -a</code></strong></li><li><strong>配置可用网卡：<code>sudo vim /etc/netplan/01-netcfg.yaml</code> &gt;&gt; <code>netplan apply</code> &gt;&gt; <code>reboot</code></strong></li><li><strong>查看本机ip地址：<code>ifconfig</code></strong></li></ol></blockquote><h2 id="二、MySQL安装配置"><a href="#二、MySQL安装配置" class="headerlink" title="二、MySQL安装配置"></a>二、MySQL安装配置</h2><blockquote><p><strong>安装：<code>sudo apt install mysql-server</code></strong></p></blockquote><ul><li><p><strong>查看MySQL中的默认用户和密码：<code>sudo cat /etc/mysql/debian.cnf</code>（client配置为主）</strong></p></li><li><p><strong>使用client配置中的user和password登录MySQL：<code>mysql -udebian-sys-maint -pXXXXXX(密码)</code></strong></p><ol><li><strong>选择mysql数据库：</strong><code>use mysql;</code></li><li><strong>创建新用户xiaofu密码123456：</strong><code>CREATE USER &#39;xiaofu&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></li><li><strong>查看当前MySQL中所有的用户：</strong><code>select user,host from mysql.user;</code></li><li><strong>赋予权限：</strong><code>grant all on*.*to xiaofu@localhost;</code></li></ol></li><li><p><strong>配置远程访问权限：<code>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></strong></p><ol><li><strong>注释代码：</strong><code>#bind-address = 127.0.0.1</code></li><li><strong>重启mysql服务：</strong><code>sudo service mysql restart</code></li></ol></li></ul><h2 id="三、Redis安装配置"><a href="#三、Redis安装配置" class="headerlink" title="三、Redis安装配置"></a>三、Redis安装配置</h2><blockquote><p><strong>安装：<code>sudo apt install redis-server</code></strong></p></blockquote><ul><li><strong>配置远程访问权限：<code>sudo vim /etc/redis/redis.conf</code></strong><ol><li><strong>注释代码：</strong><code>#bind 127.0.0.1 ::1</code></li><li><strong>关闭保护模式：</strong><code>protected-mode no</code></li><li><strong>重启redis服务：</strong><code>sudo service redis-server restart</code></li></ol></li></ul><h2 id="四、MongoDB安装配置"><a href="#四、MongoDB安装配置" class="headerlink" title="四、MongoDB安装配置"></a>四、MongoDB安装配置</h2><blockquote><p><strong>安装：<code>sudo apt install mongodb</code></strong></p></blockquote><ul><li><strong>配置远程访问权限：<code>sudo vim /etc/mongodb.conf</code></strong><ol><li><strong>注释代码：</strong><code>#bind_ip = 127.0.0.1</code></li><li><strong>重启mongodb服务：</strong><code>sudo service mongodb restart</code></li></ol></li></ul><h2 id="五、miniconda安装配置"><a href="#五、miniconda安装配置" class="headerlink" title="五、miniconda安装配置"></a>五、miniconda安装配置</h2><blockquote><p><strong>访问官网：<a class="link"   href="https://docs.conda.io/projects/miniconda/en/latest/index.html" >https://docs.conda.io/projects/miniconda/en/latest/index.html<i class="fas fa-external-link-alt"></i></a> 下载对应版本</strong></p><p><strong>安装miniconda：<code>sh ./Miniconda3-latest-Linux-aarch64.sh</code></strong></p></blockquote><h2 id="六、ssh远程连接配置"><a href="#六、ssh远程连接配置" class="headerlink" title="六、ssh远程连接配置"></a>六、ssh远程连接配置</h2><blockquote><p><strong>安装：<code>sudo apt install openssh-server</code></strong></p></blockquote><ul><li><p><strong>ssh远程连接：</strong></p><ul><li><p><strong>ubuntu启动ssh服务：</strong><code>sudo service ssh start</code></p></li><li><p><strong>mac主机访问：</strong><code>ssh xiaofu@192.168.64.12</code></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ubuntu-18-04-6安装&quot;&gt;&lt;a href=&quot;#一、ubuntu-18-04-6安装&quot; class=&quot;headerlink&quot; title=&quot;一、ubuntu-18.04.6安装&quot;&gt;&lt;/a&gt;一、ubuntu-18.04.6安装&lt;/h2&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>爬虫_2_Scrapy框架</title>
    <link href="http://example.com/2023/10/01/%E7%88%AC%E8%99%AB_2_Scrapy%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2023/10/01/%E7%88%AC%E8%99%AB_2_Scrapy%E6%A1%86%E6%9E%B6/</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、了解Scrapy框架"><a href="#一、了解Scrapy框架" class="headerlink" title="一、了解Scrapy框架"></a>一、了解Scrapy框架</h2><blockquote><p><strong>什么是 Scrapy ？</strong></p><p><strong>Scrapy是一个用于爬取网站内容，提取结构性数据而编写的 Python 开源爬虫应用框架。它提供了一套基础结构，使得用户能够轻松地定义如何从网站中提取数据，以及如何存储和处理这些数据，具有高度的可定制性和可扩展性（<a class="link"   href="https://docs.scrapy.org/en/latest/index.html"  target="_blank" rel="noopener">官方文档<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://www.osgeo.cn/scrapy/intro/install.html"  target="_blank" rel="noopener">中文官方文档<i class="fas fa-external-link-alt"></i></a>）</strong></p><p><strong>Event-driven networking（支持异步）：</strong>Scrapy 是异步爬虫框架，它使用 Twisted 库实现异步操作。虽然 <strong>Scrapy 的默认配置是单线程的，但它通过 Twisted 提供的事件循环机制实现了异步并发</strong>，这使得 Scrapy 能够在单个进程中高效地处理并发请求</p></blockquote><h3 id="1-scrapy的工作原理"><a href="#1-scrapy的工作原理" class="headerlink" title="1. scrapy的工作原理"></a>1. scrapy的工作原理</h3><ul><li><strong>引擎（Scrapy Engine）：</strong>Scrapy引擎是整个框架的核心，负责控制系统所有组件之间的数据流，并在发生特定动作时触发事件</li><li><strong>调度器（Scheduler）：</strong>调度器接收来自引擎的请求，并将其排队，同时去除重复的网址，以供稍后引擎请求它们时使用，用户可以根据自己的需求定制调度器</li><li><strong>下载器（Downloader）：</strong>下载器是所有组件中负担最大的，它用于高速地下载网络上的资源，负责获取网页并将其提供给引擎，引擎然后将其提供给Spiders爬虫</li><li><strong>爬虫（Spiders）：</strong>爬虫是由用户编写的自定义类，用于解析响应并从中提取数据信息（所谓的实体Item）或其他要跟踪的请求</li><li><strong>实体管道（Item Pipeline）：</strong>实体管道用于接收爬虫传过来的数据，负责在爬虫提取数据后对其进行处理，包括清理、验证和持久化存储</li><li><strong>中间件（Middleware）：</strong>中间件相当于过滤器，夹在不同部分之间（<strong>下载器中间件</strong>位于引擎和下载器之间，<strong>爬虫中间件</strong>位于引擎和爬虫之间）截获数据流，并进行特殊的加工处理</li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1701832575-05e785c7a0438d6.webp"                         style="width:80%;margin:0 auto;"                 ><ul><li><strong>scrapy的工作流程：</strong><ol><li>由爬虫将起始的 URL 构造成 Requests 对象 ⇒ 爬虫中间件 ⇒ 引擎 ⇒ 调度器</li><li>调度器把 Requests 对象 ⇒ 引擎 ⇒ 下载中间件 ⇒ 下载器</li><li>下载器发送请求，获取 Responses 响应 ⇒ 下载中间件 ⇒ 引擎 ⇒ 爬虫中间件 ⇒ 爬虫</li><li>爬虫提取 URL 地址，组装成 Requests 对象 ⇒ 爬虫中间件 ⇒ 引擎 ⇒ 调度器（重复步骤2）</li><li>爬虫提取数据 ⇒ 引擎 ⇒ 实体管道处理和保存数据</li></ol></li><li><strong>工作流程概述：</strong>首先由爬虫从 URL 起始队列中取出待请求 URL 并将它传递给调度器，然后引擎从调度器的待爬队列中取待爬 URL 并会经下载中间件交给下载器进行数据下载，随后将获取的数据经爬虫中间件交给爬虫模块进行分析并提取出目标数据和新 URL，最后将新 URL 传递给调度器的同时把解析的目标数据交给持久化模块进行处理。此外，在数据流动过程中能够配置各种中间件，进行必要的功能扩展。</li></ul><h3 id="2-scrapy的项目初识"><a href="#2-scrapy的项目初识" class="headerlink" title="2. scrapy的项目初识"></a>2. scrapy的项目初识</h3><blockquote><p><strong>Scrapy安装：<code>pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple</code></strong></p></blockquote><ul><li><strong>scrapy的使用流程：</strong><ol><li><strong>创建scrapy项目</strong>：scrapy startproject 项目名字</li><li><strong>进入scrapy项目文件夹</strong>：cd 项目名字</li><li><strong>创建爬虫脚本</strong>：scrapy genspider 爬虫名 允许爬取的域名</li><li><strong>运行scrapy爬虫</strong>：scrapy crawl 爬虫名字</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy import cmdline  # 运行指令的工具</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">创建scrapy项目：scrapy startproject &lt;project_name&gt;</span><br><span class="line">进入scrapy项目文件夹：cd &lt;project_name&gt;</span><br><span class="line">创建爬虫脚本：scrapy genspider &lt;spider_name&gt; &lt;spider_url&gt;</span><br><span class="line">运行scrapy项目（一定要在项目目录下）：scrapy crawl &lt;spider_name&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">class BaiduSpider(scrapy.Spider):</span><br><span class="line">    # 爬虫脚本名称（在一个项目中，可能有多个爬虫，通过名称可以区分它们）</span><br><span class="line">    name = &quot;xfblog&quot;</span><br><span class="line">    # 允许爬取的域名列表（限制爬虫只能爬取指定域名下的页面，避免爬虫无意间爬取到其他域名的内容）</span><br><span class="line">    allowed_domains = [&quot;xfblog.cn&quot;]</span><br><span class="line">    # 定义爬虫启动时要访问的起始URL列表（爬虫将从这些URL开始请求页面并调用parse方法处理响应）</span><br><span class="line">    start_urls = [&quot;http://xfblog.cn/&quot;]</span><br><span class="line"></span><br><span class="line">    # 指定response参数的类型为HtmlResponse，可以使用使用HtmlResponse提供的方法来方便地进行HTML解析</span><br><span class="line">    def parse(self, response: HtmlResponse, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;对start_urls中的URL爬取之后，回调的函数&quot;&quot;&quot;</span><br><span class="line">        print(f&quot;响应对象的url地址：&#123;response.url&#125;&quot;)</span><br><span class="line">        print(f&quot;响应对象的响应头：&#123;response.headers&#125;&quot;)</span><br><span class="line">        print(f&quot;响应对象对应的请求url地址：&#123;response.request.url&#125;&quot;)</span><br><span class="line">        print(f&quot;响应对象对应的请求头：&#123;response.request.headers&#125;&quot;)</span><br><span class="line">        print(f&quot;响应对象的状态码：&#123;response.status&#125;&quot;)</span><br><span class="line">        print(f&quot;响应对象的二进制数据（content）：&#123;response.body&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 使用cmdline.execute()方法来执行启动命令，默认打印日志信息</span><br><span class="line">    cmdline.execute(&#x27;scrapy crawl xfblog&#x27;.split())</span><br><span class="line">    # cmdline.execute(&quot;scrapy crawl xfblog --nolog&quot;.split())  # 设置日志的最低级别</span><br></pre></td></tr></table></figure><h3 id="3-scrapy的断点续爬"><a href="#3-scrapy的断点续爬" class="headerlink" title="3. scrapy的断点续爬"></a>3. scrapy的断点续爬</h3><blockquote><p><strong>Scrapy 中的暂停和恢复爬取的功能通常被称为”断点续爬”（Resuming Crawls）</strong></p><p><strong>使用：</strong>断点续爬允许在爬取过程中暂停爬虫，然后在之后的某个时间点或在不同的机器上继续爬取。这对于大规模的爬取任务和长时间运行的爬虫来说非常有用，因为它们可能会因为各种原因中断，例如网络问题、程序崩溃等</p></blockquote><ul><li><p><strong>断点续爬过程：</strong></p><ul><li><strong>启动爬虫（支持暂停恢复的命令）：<code>scrapy crawl 爬虫名 -s JOBDIR=缓存scrapy信息的路径</code></strong></li><li><strong>暂停爬虫：在终端里按下一次 <code>ctrl+c</code>（只能一次）</strong></li><li><strong>恢复爬虫（与启动相同的命令）：<code>scrapy crawl 爬虫名 -s JOBDIR=缓存scrapy信息的路径</code></strong></li></ul></li><li><p><strong>注意：</strong>如果有多个爬虫脚本，那么一定要分别指定缓存路径，不能使用同一个缓存路径</p></li></ul><h3 id="4-scrapy的遍历算法"><a href="#4-scrapy的遍历算法" class="headerlink" title="4. scrapy的遍历算法"></a>4. scrapy的遍历算法</h3><blockquote><p>这里介绍了两种图遍历算法，在后续的使用中也可以看出scrapy所使用的是<strong>深度优先搜索（DFS）</strong></p></blockquote><ul><li><strong>深度优先搜索（DFS）</strong>：<ul><li><strong>策略：</strong>从起始节点开始，尽可能深入到图中的某一分支，直到不能再深入为止，然后回溯到上一层，再继续深入另一个分支。这个过程递归进行，直到遍历完整个图</li><li><strong>实现方式：</strong>通常使用递归或栈来实现。在递归实现中，每访问一个节点时，递归调用会不断深入到下一层</li><li><strong>特点：</strong>深度优先搜索常用于解决路径问题，例如查找图中的路径、解决迷宫等。在树的深度优先搜索中，它可以用来遍历所有节点</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个用于标记已访问节点的集合</span><br><span class="line">visited = set()</span><br><span class="line"></span><br><span class="line"># 节点图</span><br><span class="line">graph = &#123;</span><br><span class="line">    &#x27;A&#x27;: [&#x27;B&#x27;, &#x27;C&#x27;],</span><br><span class="line">    &#x27;B&#x27;: [&#x27;D&#x27;, &#x27;E&#x27;],</span><br><span class="line">    &#x27;C&#x27;: [&#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;],</span><br><span class="line">    &#x27;D&#x27;: [],</span><br><span class="line">    &#x27;E&#x27;: [&#x27;I&#x27;],</span><br><span class="line">    &#x27;F&#x27;: [],</span><br><span class="line">    &#x27;G&#x27;: [],</span><br><span class="line">    &#x27;H&#x27;: [],</span><br><span class="line">    &#x27;I&#x27;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 通过递归的方式实现深度优先遍历函数</span><br><span class="line">def dfs_recursion(graph, node):</span><br><span class="line">    # 将当前节点标记为已访问，并输出节点值</span><br><span class="line">    visited.add(node)</span><br><span class="line">    print(node, end=&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">    # 遍历当前节点的所有邻居节点</span><br><span class="line">    for neighbor in graph[node]:</span><br><span class="line">        # 如果邻居节点未被访问，则递归调用自己遍历邻居的邻居节点</span><br><span class="line">        if neighbor not in visited:</span><br><span class="line">            dfs_recursion(graph, neighbor)</span><br><span class="line"></span><br><span class="line">dfs_recursion(graph, &#x27;A&#x27;)  # A B D E I C F G H</span><br></pre></td></tr></table></figure><ul><li><strong>广度优先搜索（BFS）</strong>：<ul><li><strong>策略：</strong>从起始节点开始，先访问当前节点的所有相邻节点，然后依次访问这些相邻节点的相邻节点，依此类推（这个过程使用队列来实现）</li><li><strong>实现方式：</strong>使用队列来保存待访问的节点，每次从队列中取出一个节点访问，然后将其所有未访问的相邻节点加入队列</li><li><strong>特点：</strong>广度优先搜索常用于解决最短路径问题，例如查找两个节点之间的最短路径。在树的广度优先搜索中，它可以用来层序遍历所有节点</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"># 节点图</span><br><span class="line">graph = &#123;</span><br><span class="line">    &#x27;A&#x27;: [&#x27;B&#x27;, &#x27;C&#x27;],</span><br><span class="line">    &#x27;B&#x27;: [&#x27;D&#x27;, &#x27;E&#x27;],</span><br><span class="line">    &#x27;C&#x27;: [&#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;],</span><br><span class="line">    &#x27;D&#x27;: [],</span><br><span class="line">    &#x27;E&#x27;: [&#x27;I&#x27;],</span><br><span class="line">    &#x27;F&#x27;: [],</span><br><span class="line">    &#x27;G&#x27;: [],</span><br><span class="line">    &#x27;H&#x27;: [],</span><br><span class="line">    &#x27;I&#x27;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用deque队列实现的广度优先遍历函数</span><br><span class="line">def bfs(graph, start):</span><br><span class="line">    # 创建一个队列，用于存储需要遍历的节点</span><br><span class="line">    queue = deque([start])</span><br><span class="line">    # 创建一个列表，用于存储已经遍历过的节点</span><br><span class="line">    visited = list()</span><br><span class="line"></span><br><span class="line">    while queue:</span><br><span class="line">        # 取出队列的第一个节点，并将其标记为已访问</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        visited.append(node)</span><br><span class="line"></span><br><span class="line">        # 遍历当前节点的所有邻居节点</span><br><span class="line">        for neighbor in graph[node]:</span><br><span class="line">            # 如果该邻居节点还未被访问，则将其加入队列</span><br><span class="line">            if neighbor not in visited:</span><br><span class="line">                queue.append(neighbor)</span><br><span class="line"></span><br><span class="line">    return visited</span><br><span class="line"></span><br><span class="line">print(bfs(graph, &#x27;A&#x27;))  # [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;]</span><br></pre></td></tr></table></figure><h3 id="5-scrapy的日志级别"><a href="#5-scrapy的日志级别" class="headerlink" title="5. scrapy的日志级别"></a>5. scrapy的日志级别</h3><blockquote><p>Scrapy框架提供了强大的日志功能，基于Python的内置 logging 模块，用于记录和处理在爬取过程中发生的错误，并且有不同的日志级别（<strong>默认为DEBUG级别</strong>）：</p><ul><li><strong>日志配置：在配置文件settings.py中可以通过LOG_LEVEL参数调整日志级别</strong></li><li>**日志使用：由 scrapy.Spider 类提供了用于记录日志的属性 <code>self.logger.日志级别(&quot;&quot;)</code> **</li><li><strong>日志级别（按照严重程度排序）： DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</strong></li></ul></blockquote><ul><li><strong>DEBUG（调试）:</strong><ul><li><strong>含义：</strong> 用于详细和调试信息。通常在开发和调试阶段使用，记录程序内部状态、变量值等详细信息。</li><li><strong>示例：</strong> <code>self.logger.debug(&quot;这是调试信息&quot;)</code></li></ul></li><li><strong>INFO（信息）:</strong><ul><li><strong>含义：</strong> 用于一般性的信息记录，用于表明应用程序的正常运行情况。通常是在生产环境中记录的级别。</li><li><strong>示例：</strong> <code>self.logger.info(&quot;应用程序成功启动&quot;)</code></li></ul></li><li><strong>WARNING（警告）:</strong><ul><li><strong>含义：</strong> 用于表示潜在的问题，不影响程序正常运行，但可能需要注意。通常用于警告可能会导致错误的情况。</li><li><strong>示例：</strong> <code>self.logger.warning(&quot;文件未找到，使用默认设置&quot;)</code></li></ul></li><li><strong>ERROR（错误）:</strong><ul><li><strong>含义：</strong> 用于表示错误情况，但程序仍然可以继续运行。通常用于记录捕获到的异常或其他导致程序不能正常工作的错误。</li><li><strong>示例：</strong> <code>self.logger.error(&quot;处理请求时发生错误&quot;)</code></li></ul></li><li><strong>CRITICAL（严重错误）:</strong><ul><li><strong>含义：</strong> 用于表示严重错误，可能导致程序无法继续运行。通常用于记录不可恢复的错误情况。</li><li><strong>示例：</strong> <code>self.logger.critical(&quot;严重错误：无法连接到数据库&quot;)</code></li></ul></li></ul><h2 id="二、Spider爬虫模块"><a href="#二、Spider爬虫模块" class="headerlink" title="二、Spider爬虫模块"></a>二、Spider爬虫模块</h2><blockquote><p><strong>dont_filter参数：</strong></p><ul><li><strong>作用：</strong>用于告诉框架在进行请求去重时是否忽略对该请求的去重检查</li><li><strong>用法：</strong>可以通过设置 <code>dont_filter=True</code> 来禁用请求 url 过滤</li><li><strong>默认值：</strong>在 scrapy.Request 请求方法中，默认 dont_filter&#x3D;False（<strong>默认开启过滤</strong>）</li></ul></blockquote><h3 id="1-重要函数"><a href="#1-重要函数" class="headerlink" title="1. 重要函数"></a>1. 重要函数</h3><blockquote><p><strong>需要重写 start_requests 方法的场景：</strong></p><ol><li>如果 start_urls 中的 url 是需要登录后才能访问的网页，则需重写此方法重新发起请求并手动添加cookie</li><li>如果需要开启请求 url 过滤，则需要重写此方法重新发起 scrapy.Request 请求，此请求默认开启过滤（因为 start_urls 中的 url 在被生成 Request 对象时，默认设置为关闭过滤，即 <code>dont_filter=True</code>）</li><li>如果 start_urls 中的 url 需要使用 POST 请求，则需要重写此方法使用 scrapy.FormRequest 发起请求</li></ol></blockquote><ul><li><p><strong>start_requests 函数：</strong></p><ul><li><p><strong>作用：</strong>用于生成初始请求，若不重写此函数，则默认从 start_urls 中生成初始请求</p></li><li><p><strong>回调函数：</strong>生成的请求默认使用 parse 作为回调函数，也可以指定回调函数，根据不同的条件，执行不同的回调解析函数</p></li></ul></li><li><p><strong>parse 函数：</strong></p><ul><li><strong>作用：</strong>是 Scrapy 爬虫中用于处理响应数据的默认回调函数，可以提取所需的信息，或跟进其他链接生成更多请求</li></ul></li><li><p><strong>注意：parse函数中可以使用yield语句生成多个请求或数据项，但只能是 BaseItem、Request、dict 和None 四种类型对象</strong></p><ul><li><strong>BaseItem：</strong>通过 yield 返回的 BaseItem 对象将被传递给 Item Pipeline 进行处理</li><li><strong>Request：</strong>通过 yield Request(…) 的方式，爬虫可以在解析函数中发起新的请求，继续爬取其他页面</li><li><strong>dict：</strong>通过 yield 返回字典对象，可以将提取到的数据传递给后续的解析函数或 Item Pipeline 进行处理</li><li><strong>None：</strong>yield None 通常用于结束当前解析函数的执行</li></ul></li><li><p><strong>response.xpath() 方法：</strong>接受一个 XPath 表达式作为参数，返回一个包含选定节点的 SelectorList 对象</p><ul><li><strong>extract()：</strong>用于获取 SelectorList 中所有匹配的节点的文本内容，返回一个包含所有文本内容的列表</li><li><strong>extract_first()：</strong>用于获取 SelectorList 中第一个匹配的节点的文本内容，如果没有匹配的节点，则返回 None</li></ul></li><li><p><strong>response.urljoin() 方法：</strong>作用是将相对URL转换为绝对URL</p></li></ul><h3 id="2-数据提取、跟进链接"><a href="#2-数据提取、跟进链接" class="headerlink" title="2. 数据提取、跟进链接"></a>2. 数据提取、跟进链接</h3><blockquote><p>案例1：豆瓣电影top250（<code>https://movie.douban.com/top250</code>）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy import cmdline</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line">import redis</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">class Top250Spider(scrapy.Spider):</span><br><span class="line">    name = &quot;top250&quot;</span><br><span class="line">    allowed_domains = [&quot;movie.douban.com&quot;, &quot;doubanio.com&quot;]</span><br><span class="line"></span><br><span class="line">    # start_urls = [&quot;https://movie.douban.com/top250&quot;]</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.redis_cli = redis.Redis()</span><br><span class="line"></span><br><span class="line">    # 程序退出时关闭redis连接</span><br><span class="line">    def __del__(self):</span><br><span class="line">        self.redis_cli.close()</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        url = &quot;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&quot;</span><br><span class="line">        for page in range(0, 226, 25):</span><br><span class="line">            url_md5 = hashlib.md5(str(url.format(page)).encode()).hexdigest()</span><br><span class="line">            if self.redis_cli.sismember(&#x27;douban:tx_work_url_filter&#x27;, url_md5):</span><br><span class="line">                print(&quot;url重复...&quot;)</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                self.redis_cli.sadd(&#x27;douban:tx_work_url_filter&#x27;, url_md5)</span><br><span class="line">            yield scrapy.Request(url=url.format(page))</span><br><span class="line"></span><br><span class="line">    def parse(self, response: HtmlResponse, **kwargs):</span><br><span class="line">        li_list = response.xpath(&quot;//div[@id=&#x27;content&#x27;]//ol[@class=&#x27;grid_view&#x27;]/li&quot;)</span><br><span class="line">        for item in li_list:</span><br><span class="line">            info = dict()</span><br><span class="line">            info[&#x27;type_&#x27;] = &#x27;info&#x27;</span><br><span class="line">            info[&#x27;img_url&#x27;] = item.xpath(&quot;.//img/@src&quot;).extract_first()</span><br><span class="line">            info[&#x27;title&#x27;] = item.xpath(&quot;.//div[@class=&#x27;hd&#x27;]/a/span/text()&quot;).extract_first()</span><br><span class="line">            info[&#x27;star&#x27;] = item.xpath(&quot;.//span[@class=&#x27;rating_num&#x27;]/text()&quot;).extract_first()</span><br><span class="line">            # info[&#x27;comment&#x27;] = item.xpath(&quot;.//div[@class=&#x27;star&#x27;]/span[last()]/text()&quot;).extract_first()</span><br><span class="line">            yield info</span><br><span class="line">            yield scrapy.Request(url=info[&#x27;img_url&#x27;], callback=self.img_parse, cb_kwargs=&#123;&quot;title&quot;: info[&#x27;title&#x27;]&#125;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def img_parse(response: HtmlResponse, title):</span><br><span class="line">        yield &#123;</span><br><span class="line">            &quot;type_&quot;: &#x27;image&#x27;,</span><br><span class="line">            &quot;img_name&quot;: title + &#x27;.png&#x27;,</span><br><span class="line">            &quot;img_content&quot;: response.body</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    cmdline.execute(&#x27;scrapy crawl top250&#x27;.split())</span><br></pre></td></tr></table></figure><h3 id="3-请求post携带表单"><a href="#3-请求post携带表单" class="headerlink" title="3. 请求post携带表单"></a>3. 请求post携带表单</h3><blockquote><p>案例：巨潮资讯网（<code>http://www.cninfo.com.cn/new/commonUrl?url=disclosure/list/notice#szse</code>）</p></blockquote><ul><li>对于携带表单数据的post请求，通过 <strong>scrapy.FormRequest()</strong> 发起</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy import cmdline</span><br><span class="line"></span><br><span class="line">class CninfoSpider(scrapy.Spider):</span><br><span class="line">    name = &quot;cninfo&quot;</span><br><span class="line">    allowed_domains = [&quot;www.cninfo.com.cn&quot;]</span><br><span class="line"></span><br><span class="line">    # start_urls = [&quot;http://www.cninfo.com.cn/new/index&quot;]</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        url = &quot;http://www.cninfo.com.cn/new/disclosure&quot;</span><br><span class="line">        for page in range(1, 26):</span><br><span class="line">            data = &#123;</span><br><span class="line">                &quot;column&quot;: &quot;szse_latest&quot;,</span><br><span class="line">                &quot;pageNum&quot;: str(page),</span><br><span class="line">                &quot;pageSize&quot;: &quot;30&quot;,</span><br><span class="line">                &quot;sortName&quot;: &quot;&quot;,</span><br><span class="line">                &quot;sortType&quot;: &quot;&quot;,</span><br><span class="line">                &quot;clusterFlag&quot;: &quot;true&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            yield scrapy.FormRequest(url=url, formdata=data)</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        print(response)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    cmdline.execute(&quot;scrapy crawl cninfo&quot;.split())</span><br></pre></td></tr></table></figure><h3 id="4-请求post携带json"><a href="#4-请求post携带json" class="headerlink" title="4. 请求post携带json"></a>4. 请求post携带json</h3><blockquote><p>案例：网易招聘（<code>https://hr.163.com/job-list.html</code>）</p></blockquote><ul><li>对于携带json数据的post请求，通过 <strong>scrapy.http.JsonRequest()</strong> 发起</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy import cmdline</span><br><span class="line">from scrapy.http import JsonRequest, HtmlResponse</span><br><span class="line"></span><br><span class="line">class WorkinfoSpider(scrapy.Spider):</span><br><span class="line">    name = &quot;workinfo&quot;</span><br><span class="line">    allowed_domains = [&quot;hr.163.com&quot;]</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        url = &quot;https://hr.163.com/api/hr163/position/queryPage&quot;</span><br><span class="line">        json_params = &#123;</span><br><span class="line">            &quot;currentPage&quot;: 1,</span><br><span class="line">            &quot;pageSize&quot;: 10</span><br><span class="line">        &#125;</span><br><span class="line">        yield JsonRequest(url=url, data=json_params)</span><br><span class="line"></span><br><span class="line">    def parse(self, response: HtmlResponse, **kwargs):</span><br><span class="line">        print(response.json())</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    cmdline.execute(&quot;scrapy crawl workinfo --nolog&quot;.split())</span><br></pre></td></tr></table></figure><h2 id="三、Middleware和Extension"><a href="#三、Middleware和Extension" class="headerlink" title="三、Middleware和Extension"></a>三、Middleware和Extension</h2><blockquote><p><strong>Middleware：</strong>中间件主要有<strong>下载器中间件</strong>和<strong>爬虫中间件</strong>，在Scrapy默认的情况下，两种中间件都在 middlewares.py 一个文件中，但由于两种中间件使用方法相同和功能重复，所以<strong>常使用下载器中间件</strong></p><p><strong>付费IP代理：</strong><a class="link"   href="https://www.kuaidaili.com/doc/dev/sdk_http/#proxy_python-scrapy"  target="_blank" rel="noopener">快代理开发配置文档<i class="fas fa-external-link-alt"></i></a></p><p><strong>扩展（Extension）：</strong>是一种机制，允许开发者通过添加自定义功能来扩展或修改Scrapy框架在运行过程中的行为，以满足特定需求或执行额外的任务</p><p><strong>注意：有一个思维误区，就是将”通过selenium获取到登录后的cookies”的行为使用扩展实现，保证全局只执行一次，但是扩展一般是根据爬虫的启动而启动的，如果要在start_reqests中使用此扩展，那么此时爬虫还没有启动，扩展也就自然无法运行，拿不到cookies；而如果要在parse函数中使用此扩展，虽然确实可以拿到登录后的cookies，但是这意味着每一次请求的每一次响应都将获取一次cookies，这是没有必要的</strong></p><p><strong>解决：将”通过selenium获取到登录后的cookies”的逻辑在spider爬虫模块的start_requests方法中实现</strong>（即保证了在爬虫启动前执行，拿到登录后的cookies，又保证了只执行一次）</p></blockquote><h3 id="1-重要函数-1"><a href="#1-重要函数-1" class="headerlink" title="1. 重要函数"></a>1. 重要函数</h3><ul><li><p><strong>from_crawler 函数：</strong></p><ul><li><strong>作用：</strong>是一个特殊的类方法，用于在中间件实例化之前设置一些配置</li><li><strong>参数crawler：</strong>是一个Scrapy的 Crawler 对象，包含了当前爬虫的配置信息</li><li><strong>用法：</strong>通常被用来从配置中获取一些值，并将它们传递给中间件的实例。这使得中间件可以根据爬虫的配置动态地调整其行为</li></ul></li><li><p><strong>process_request 函数：</strong></p><ul><li><strong>返回None：</strong>将该Request对象传递给下载器，或通过引擎传递给其他权重更低的下载中间件的process_request方法（函数没有return也是返回None）</li><li><strong>返回Response对象：</strong>不再请求，把response返回给引擎</li><li><strong>返回Request对象：</strong>把request对象通过引擎再次交给调度器，此时将不通过其他权重低的process_request方法</li></ul></li><li><p><strong>process_response 函数：</strong></p><ul><li><strong>返回Resposne对象：</strong>将该Resposne对象传递给爬虫处理，或通过引擎传递给其他权重更低的下载中间件的process_response方法</li><li><strong>返回Request对象：</strong>通过引擎再次交给调取器进行请求，再次通过当前下载中间件的process_request方法，而不会通过其他权重低的process_request方法</li></ul></li></ul><h3 id="2-指纹去重中间件"><a href="#2-指纹去重中间件" class="headerlink" title="2. 指纹去重中间件"></a>2. 指纹去重中间件</h3><ul><li><strong>Js 逆向结合 Scrapy 框架</strong>：如果 POST 请求携带的数据是经过 js 加密且每次生成不一样，则在分布式中就无法通过请求对象的指纹完成去重，而需要自定义一个可以用于去重的参数生成指纹（例如加密前的明文参数）</li><li><strong>注意配置 scrapy_redis 去重器：</strong><code>DUPEFILTER_CLASS = &quot;myproject.middlewares.MyDupeFilter&quot;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 自定义的 Scrapy 去重中间件</span><br><span class="line">from scrapy_redis.dupefilter import RFPDupeFilter</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># 定义自定义的去重过滤器类 MyDupeFilter，继承自 RFPDupeFilter</span><br><span class="line">class MyDupeFilter(RFPDupeFilter):</span><br><span class="line">    def __init__(self, server, key, debug=False):</span><br><span class="line">        # 调用父类的构造方法，传递参数 server, key, debug</span><br><span class="line">        super(MyDupeFilter, self).__init__(server, key, debug)</span><br><span class="line">        # 初始化一个集合用于存储指纹信息，确保请求的唯一性</span><br><span class="line">        self.fingerprints = set()</span><br><span class="line">        # 将传递的 key 作为指纹的键值</span><br><span class="line">        self.fingerprint_key = key</span><br><span class="line"></span><br><span class="line">    def request_seen(self, request):</span><br><span class="line">        # 从请求的 meta 中提取关键信息，例如 &#x27;unique_key&#x27;（例如加密前的明文参数）</span><br><span class="line">        unique_key = request.meta.get(&#x27;unique_key&#x27;)</span><br><span class="line">        # 使用 SHA-1 哈希算法对关键信息进行哈希，生成指纹</span><br><span class="line">        fp = hashlib.sha1(unique_key.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">        # 如果指纹已存在于集合中，表示请求重复</span><br><span class="line">        if fp in self.fingerprints:</span><br><span class="line">            return True</span><br><span class="line">        # 将新的指纹添加到集合中</span><br><span class="line">        self.fingerprints.add(fp)</span><br><span class="line"></span><br><span class="line">        # 如果设置了 fingerprint_key，将指纹添加到 Redis 中，以确保分布式去重</span><br><span class="line">        if self.fingerprint_key:</span><br><span class="line">            self.server.sadd(self.fingerprint_key, fp)</span><br><span class="line"></span><br><span class="line">        # 返回 False 表示请求不重复</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="2-付费代理ip扩展"><a href="#2-付费代理ip扩展" class="headerlink" title="2. 付费代理ip扩展"></a>2. 付费代理ip扩展</h3><blockquote><p>案例1：豆瓣电影top250（<code>https://movie.douban.com/top250</code>）</p></blockquote><ul><li>自定义快代理的scrapy扩展（<strong>extend_ip.py</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line">import requests</span><br><span class="line">from scrapy import signals</span><br><span class="line"></span><br><span class="line"># 提取代理IP的api，一次提取10个（生成链接：https://www.kuaidaili.com/dps/genapiurl/）</span><br><span class="line">api_url = &#x27;https://dps.kdlapi.com/api/getdps/?secret_id=o88cwu0sh49ls75kntwt&amp;num=1&amp;signature=dtb4yamicu504fub6llgx7mjabckit83&amp;pt=1&amp;format=json&amp;sep=1&#x27;</span><br><span class="line">foo = True</span><br><span class="line"></span><br><span class="line">class Proxy:</span><br><span class="line">    def __init__(self, ):</span><br><span class="line">        self._proxy_list = requests.get(api_url).json().get(&#x27;data&#x27;).get(&#x27;proxy_list&#x27;)</span><br><span class="line"></span><br><span class="line">    @property  # p.proxy_list：自动执行此方法，并获取方法的返回值</span><br><span class="line">    def proxy_list(self):</span><br><span class="line">        return self._proxy_list</span><br><span class="line"></span><br><span class="line">    @proxy_list.setter  # p.proxy_list=&#x27;abc&#x27;：自动执行此方法，并将&#x27;abc&#x27;赋值给list参数</span><br><span class="line">    def proxy_list(self, list):</span><br><span class="line">        self._proxy_list = list</span><br><span class="line"></span><br><span class="line">pro = Proxy()</span><br><span class="line"></span><br><span class="line">class MyExtend:</span><br><span class="line">    def __init__(self, crawler):</span><br><span class="line">        self.crawler = crawler</span><br><span class="line">        # 将自定义方法绑定到scrapy信号上，使程序与spider引擎同步启动与关闭</span><br><span class="line">        crawler.signals.connect(self.start, signals.engine_started)</span><br><span class="line">        crawler.signals.connect(self.close, signals.spider_closed)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(crawler)</span><br><span class="line"></span><br><span class="line">    def start(self):</span><br><span class="line">        t = threading.Thread(target=self.extract_proxy)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    def extract_proxy(self):</span><br><span class="line">        while foo:</span><br><span class="line">            pro.proxy_list = requests.get(api_url).json().get(&#x27;data&#x27;).get(&#x27;proxy_list&#x27;)</span><br><span class="line">            # 设置每一分钟提取一次ip，更新proxy_list列表中的ip，保证都是有效ip</span><br><span class="line">            time.sleep(60)</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        global foo</span><br><span class="line">        foo = False</span><br></pre></td></tr></table></figure><h3 id="3-付费代理中间件"><a href="#3-付费代理中间件" class="headerlink" title="3. 付费代理中间件"></a>3. 付费代理中间件</h3><blockquote><p>案例1：豆瓣电影top250（<code>https://movie.douban.com/top250</code>）</p></blockquote><ul><li>自定义HeadersDownloaderMiddleware中间件（<strong>middlewares.py</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line">from .extend_ip import pro</span><br><span class="line"></span><br><span class="line">class HeadersDownloaderMiddleware:</span><br><span class="line">    def __init__(self, user_agent_list=None):</span><br><span class="line">        self.user_agent_list = user_agent_list</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        # 从settings配置中获取user_agent值</span><br><span class="line">        user_agent_list = crawler.settings.get(&#x27;USER_AGENTS_LIST&#x27;)</span><br><span class="line">        # 创建中间件实例并传递配置值</span><br><span class="line">        return cls(user_agent_list)</span><br><span class="line"></span><br><span class="line">    def process_request(self, request: HtmlResponse, spider):</span><br><span class="line">        &quot;&quot;&quot;每一个request通过下载器中间件，此方法都会运行一次，方法process_response同理&quot;&quot;&quot;</span><br><span class="line">        # print(&quot;下载中间件---------process_request---------&quot;)</span><br><span class="line">        request.headers[&#x27;User-Agent&#x27;] = random.choice(self.user_agent_list)</span><br><span class="line"></span><br><span class="line">        # 设置免费代理</span><br><span class="line">        # request.meta[&#x27;proxy&#x27;] = &#x27;http://127.0.0.1:7890&#x27;</span><br><span class="line"></span><br><span class="line">        # 设置付费代理，需要在settings.py中激活extend_ip扩展</span><br><span class="line">        username = &quot;d4550779926&quot;</span><br><span class="line">        password = &quot;kzsel6pa&quot;</span><br><span class="line">        # 如果当前ip不可用，那么process_response重试，这里会在代理池中重新选择一个代理ip</span><br><span class="line">        proxy = random.choice(pro.proxy_list)</span><br><span class="line">        # print(f&quot;当前请求使用的代理ip：&#123;proxy&#125;&quot;)</span><br><span class="line">        request.meta[&#x27;proxy&#x27;] = f&quot;http://&#123;username&#125;:&#123;password&#125;@&#123;proxy&#125;/&quot;</span><br><span class="line"></span><br><span class="line">        # 不写returen：默认返回None</span><br><span class="line"></span><br><span class="line">    def process_response(self, request, response: HtmlResponse, spider):</span><br><span class="line">        # print(&quot;下载中间件---------process_response---------&quot;)</span><br><span class="line">        # print(request.headers)  # 通过request.headers直接拿到请求头</span><br><span class="line">        if not response.status == 200:</span><br><span class="line">            request.dont_filter = True  # 使重复发送的请求对象能够再次进入调度器的队列</span><br><span class="line">            return request</span><br><span class="line">        return response  # 最后必须将处理后的响应返回给引擎</span><br></pre></td></tr></table></figure><h3 id="4-中间件selenium配置"><a href="#4-中间件selenium配置" class="headerlink" title="4. 中间件selenium配置"></a>4. 中间件selenium配置</h3><blockquote><p>案例2：腾讯招聘（<code>https://careers.tencent.com/search.html?keyword=python</code>）</p><p><strong>注意：这里选择在下载中间件的process_request方法中配置selenium，是因为这里的爬取逻辑</strong></p><ul><li><strong>爬取逻辑：先在spider模块的start_requests方法中构造循环发起多个翻页请求，然后每一个scrapy.Request()都在经过下载中间件时被开启selenium获取了网页源代码，并且将响应返回给了引擎，这样其实每一个请求都没有走到downloader下载器，就已经获取到响应返回了</strong></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from scrapy import signals</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">class SeleniumDownloaderMiddleware:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        s = cls()</span><br><span class="line">        # 检测爬虫状态，如果爬虫关闭则调用spider_closed方法</span><br><span class="line">        crawler.signals.connect(s.spider_closed, signal=signals.spider_closed)</span><br><span class="line">        return s</span><br><span class="line"></span><br><span class="line">    def spider_closed(self):</span><br><span class="line">        self.browser.quit()</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        self.browser.get(request.url)</span><br><span class="line">        wait_ob = WebDriverWait(self.browser, timeout=10)</span><br><span class="line">        # 等待所有工作信息存在（加载完毕）</span><br><span class="line">        wait_ob.until(EC.presence_of_all_elements_located((By.XPATH, &#x27;//div[@class=&quot;recruit-list&quot;]&#x27;)))</span><br><span class="line">        body = self.browser.page_source  # 获取网页源代码</span><br><span class="line"></span><br><span class="line">        # 这种做法将不会经过下载器进行请求，通过selenium直接将获取到的body打包成响应返回给引擎</span><br><span class="line">        return HtmlResponse(body=body, url=request.url, request=request, encoding=&#x27;utf-8&#x27;)</span><br></pre></td></tr></table></figure><h2 id="四、Item实体模块"><a href="#四、Item实体模块" class="headerlink" title="四、Item实体模块"></a>四、Item实体模块</h2><h3 id="1-重要知识点"><a href="#1-重要知识点" class="headerlink" title="1. 重要知识点"></a>1. 重要知识点</h3><ul><li><p><strong>Item模块：</strong>用于定义数据模型，即在爬取过程中需要提取的数据的结构。模块中定义了 Scrapy Item 类，描述了爬取到的数据应该包含哪些字段以及它们的数据类型，可以在多个爬虫中重复使用</p></li><li><p><strong>ItemLoader工具：</strong>用于加载和处理爬取到的数据并填充到 Item 对象中，在Item的填充过程中可以应用多个处理器，进行数据清洗、转换、预处理等操作</p><ul><li><strong>input_processor：</strong>应用于从<strong>网页中提取的原始数据</strong>的处理器，用于在将数据填充到 <strong>ItemLoader 之前</strong>对其进行清理、转换或其他操作（<strong>清理文本、转换格式等</strong>）</li><li><strong>output_processor：</strong>应用于从 <strong>ItemLoader 加载的数据</strong>的处理器，用于在数据填充到 <strong>Item 之前</strong>对其进行清理、转换或其他操作（<strong>取第一个非空值、拼接字符串等</strong>）</li></ul></li><li><p><strong>itemloaders.processors 模块中提供了一系列用于数据处理的类：</strong></p><ul><li><strong>TakeFirst：</strong>从处理器返回的结果中取第一个非空值，常用于获取单一数据项</li><li><strong>MapCompose：</strong>对一个可迭代对象中的每个元素应用一个或多个处理器</li><li><strong>Compose：</strong>将多个处理器组合在一起，按照顺序应用</li><li><strong>Join：</strong>将列表中的字符串连接成单个字符串，默认连接符为””（空字符串）</li><li><strong>Identity：</strong>返回输入的原始值，即不做任何处理直接返回输入数据本身</li></ul></li><li><p><strong>注意：这些处理器类可以单独使用，也可以组合在一起形成处理器链，通常用在 ItemLoader 的 input_processor 和 output_processor 参数中</strong></p></li><li><p><strong>add_xpath() 方法：</strong></p><ul><li><strong>作用：</strong>在spider爬虫中创建ItemLoader实例，并使用 add_xpath 方法将数据填充到 ItemLoader 中，最后yield生成item对象</li></ul><ul><li><strong>返回值：</strong>在填充数据时，xpath若匹配成功则返回一个列表，匹配失败则返回None</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    # 创建一个 ItemLoader 实例，并指定要加载的 Item 类</span><br><span class="line">    loader = ItemLoader(item=MyItem(), response=response)</span><br><span class="line"></span><br><span class="line">    # 使用 add_xpath 方法添加数据，第一个参数是Item的字段名，第二个参数是XPath表达式</span><br><span class="line">    loader.add_xpath(&#x27;title&#x27;, &#x27;//h1/text()&#x27;)</span><br><span class="line">    loader.add_xpath(&#x27;description&#x27;, &#x27;//div[@class=&quot;description&quot;]/text()&#x27;)</span><br><span class="line"></span><br><span class="line">    # 完成加载并生成 Item 对象</span><br><span class="line">    yield loader.load_item()</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、Pipline管道模块"><a href="#五、Pipline管道模块" class="headerlink" title="五、Pipline管道模块"></a>五、Pipline管道模块</h2><h3 id="1-重要函数-2"><a href="#1-重要函数-2" class="headerlink" title="1. 重要函数"></a>1. 重要函数</h3><ul><li><p><strong>from_settings(cls, settings) 类方法：</strong></p><ul><li><strong>作用：</strong>是 Scrapy 中的一个约定，用于从配置文件中读取设置并初始化相关对象，通常在 Pipeline 中使用，但在其他模块组件中也可以使用</li><li><strong>参数settings：</strong>是一个字典，可以直接通过 key 获取到 setting.py 配置文件中的配置项</li></ul></li><li><p><strong>process_item(self, item, spider)函数：</strong></p><ul><li><strong>作用：</strong>用于处理从爬虫中传递过来的 Item 对象，如数据清洗、持久化存储等（<strong>此函数不可省略</strong>）</li><li><strong>参数item：</strong>爬虫传递过来的 Item 对象，是一个字典或类似字典的对象，包含了爬虫抓取到的数据</li><li><strong>参数spider：</strong>爬虫实例，可以通过 spider.name 获取爬虫名称</li></ul></li><li><p><strong>process_item返回值：</strong></p><ul><li><strong>返回 Item 对象：</strong>则该对象将继续在后续的 Pipeline 中进行处理</li><li><strong>返回 None 对象：</strong>表示该 Item 的处理过程将停止，不再传递给其他 Pipeline，<strong>但是后续权重更低的 pipeline 的 process_item 方法接受到的 item 将会是None</strong></li><li><strong>返回 DropItem 异常：</strong>表示丢弃该 Item（**<code>raise DropItem(&quot;&quot;)</code>**）</li></ul></li><li><p><strong>open_spider函数：</strong></p><ul><li><strong>作用：</strong>在爬虫启动时被调用，用于执行一些初始化操作，如链接数据库、准备文件句柄等（<strong>只执行一次</strong>）</li></ul></li><li><p><strong>close_spider函数：</strong></p><ul><li><strong>作用：</strong>在爬虫关闭时被调用，用于执行一些清理工作，如关闭数据库连接、关闭文件等（<strong>只执行一次</strong>）</li></ul></li></ul><h3 id="2-多个管道item传递"><a href="#2-多个管道item传递" class="headerlink" title="2. 多个管道item传递"></a>2. 多个管道item传递</h3><blockquote><p>案例1：豆瓣电影top250（<code>https://movie.douban.com/top250</code>）</p></blockquote><ul><li><strong>注意：虽然当一个 Item 被返回 None 时，该 Item 将不再被传递给后续的 Pipeline，但在 Scrapy 中，由于异步处理，某些情况下可能会出现 None 被传递到下一个 Pipeline 的情况，此时则需添加判断处理</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line">import os</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">class DoubanImgPipeline:</span><br><span class="line">    &quot;&quot;&quot;保存图片数据&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        # 可能存在多个爬虫脚本，可以通过爬虫名称指定目标脚本</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            if item[&#x27;type_&#x27;] == &#x27;image&#x27;:</span><br><span class="line">                images_path = os.path.dirname(os.getcwd()) + &#x27;/download/&#x27;</span><br><span class="line">                if not os.path.exists(images_path):</span><br><span class="line">                    os.mkdir(images_path)</span><br><span class="line">                with open(images_path + item[&#x27;img_name&#x27;], &#x27;wb&#x27;) as fp:</span><br><span class="line">                    fp.write(item[&#x27;img_content&#x27;])</span><br><span class="line">                    print(f&quot;下载图片&#123;item[&#x27;img_name&#x27;]&#125;成功。。。&quot;)</span><br><span class="line">                # 返回None，表示该Item不再传递给后续Pipeline</span><br><span class="line">                return None</span><br><span class="line">            else:</span><br><span class="line">                # 将图片以外的数据（Item）传递给其它pipline管道，进行其余保存处理</span><br><span class="line">                return item</span><br><span class="line"></span><br><span class="line">class DoubanFilePipeline:</span><br><span class="line">    &quot;&quot;&quot;保存电影信息为文件&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            # 检查item是否为 None，如果是则不处理</span><br><span class="line">            if item is not None:</span><br><span class="line">                self.fp.write(json.dumps(item, ensure_ascii=False, indent=4))</span><br><span class="line">                print(f&quot;保存文件&#123;item[&#x27;title&#x27;]&#125;成功。。。&quot;)</span><br><span class="line">                return item</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            self.fp = open(&#x27;json.text&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            self.fp.close()</span><br><span class="line"></span><br><span class="line">class DoubanMongoPipeline:</span><br><span class="line">    &quot;&quot;&quot;保存电影信息到mongo数据库中&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            # 检查item是否为 None，如果是则不处理</span><br><span class="line">            if item is not None:</span><br><span class="line">                self.collection.insert_one(item)</span><br><span class="line">                print(f&quot;存储数据库&#123;item[&#x27;title&#x27;]&#125;成功。。。&quot;)</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            self.mongo_cli = pymongo.MongoClient()</span><br><span class="line">            self.collection = self.mongo_cli[&#x27;py_spider&#x27;][&#x27;douban_top250&#x27;]</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            self.mongo_cli.close()</span><br></pre></td></tr></table></figure><h3 id="3-数据存储去重"><a href="#3-数据存储去重" class="headerlink" title="3. 数据存储去重"></a>3. 数据存储去重</h3><blockquote><p>案例1：豆瓣电影top250（<code>https://movie.douban.com/top250</code>）</p></blockquote><ul><li>在管道pipline中<strong>判断数据是否存储过</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class DoubanCheckPipeline:</span><br><span class="line">    &quot;&quot;&quot;对数据进行去重&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            # 创建一个新的字典，将 img_content 字段剔除，转为字符串并加密成 md5 值</span><br><span class="line">            # 原因：bytes对象不是可 JSON 序列化的对象，会序列化失败抛出异常</span><br><span class="line">            item_copy = &#123;key: value for key, value in item.items() if key != &#x27;img_content&#x27;&#125;</span><br><span class="line">            item_md5 = hashlib.md5(json.dumps(item_copy).encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">            # 使用redis中set集合的 sismember 方法检查成员是否存在</span><br><span class="line">            if self.redis_cli.sismember(&#x27;douban:tx_work_item_filter&#x27;, item_md5):</span><br><span class="line">                # 抛出 DropItem 异常，表示丢弃该Item</span><br><span class="line">                raise DropItem(&#x27;数据已存在。。。&#x27;)</span><br><span class="line">            else:</span><br><span class="line">                self.redis_cli.sadd(&#x27;douban:tx_work_item_filter&#x27;, item_md5)</span><br><span class="line">            return item</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            self.redis_cli = redis.Redis()</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        if spider.name == &#x27;top250&#x27;:</span><br><span class="line">            self.redis_cli.close()</span><br></pre></td></tr></table></figure><h3 id="4-请求url地址去重"><a href="#4-请求url地址去重" class="headerlink" title="4. 请求url地址去重"></a>4. 请求url地址去重</h3><blockquote><p>案例1：豆瓣电影top250（<code>https://movie.douban.com/top250</code>）</p></blockquote><ul><li>在爬虫spider或爬虫中间件中<strong>判断URL是否请求过</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy import cmdline</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line">import redis</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">class Top250Spider(scrapy.Spider):</span><br><span class="line">    name = &quot;top250&quot;</span><br><span class="line">    allowed_domains = [&quot;movie.douban.com&quot;, &quot;doubanio.com&quot;]</span><br><span class="line"></span><br><span class="line">    # start_urls = [&quot;https://movie.douban.com/top250&quot;]</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.redis_cli = redis.Redis()</span><br><span class="line"></span><br><span class="line">    # 程序退出时关闭redis连接</span><br><span class="line">    def __del__(self):</span><br><span class="line">        self.redis_cli.close()</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        url = &quot;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&quot;</span><br><span class="line">        for page in range(0, 226, 25):</span><br><span class="line">            url_md5 = hashlib.md5(str(url.format(page)).encode()).hexdigest()</span><br><span class="line">            if self.redis_cli.sismember(&#x27;douban:tx_work_url_filter&#x27;, url_md5):</span><br><span class="line">                print(&quot;url重复...&quot;)</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                self.redis_cli.sadd(&#x27;douban:tx_work_url_filter&#x27;, url_md5)</span><br><span class="line">            yield scrapy.Request(url=url.format(page))</span><br></pre></td></tr></table></figure><h3 id="5-adbapi异步数据库接口"><a href="#5-adbapi异步数据库接口" class="headerlink" title="5. adbapi异步数据库接口"></a>5. adbapi异步数据库接口</h3><blockquote><p><strong>twisted中的adbapi：</strong></p><p>数据库pymysql的commit()和execute()在提交数据时，都是同步提交至数据库，由于scrapy框架数据的解析和异步多线程的，所以scrapy的数据解析速度要远高于数据的写入数据库的速度。如果数据写入过慢，会造成数据库写入的阻塞，影响数据库写入的效率。 使用<code>twisted</code>异步IO框架，实现数据的异步写入，通过多线程异步的形式对数据进行写入，可以提高数据的写入速度</p></blockquote><ul><li><strong>adbapi.ConnectionPool 类：</strong>创建一个数据库连接池对象，其中包括多个连接对象，每个连接对象在独立的线程中工作。adbapi只是提供了异步访问数据库的编程框架，再其内部依然使用<code>pymysql</code>这类库访问数据库</li><li><strong>dbpool.runInteraction(do_insert, item) 方法：</strong>异步调用do_insert函数，<code>dbpool</code>会选择连接池中的一个连接对象在独立线程中调用insert_db，其中参数item会被传给do_insert的第二个参数，传给do_insert的第一个参数是一个<code>Transaction</code>对象，其接口与<code>cursor</code>对象类似，可以调用<code>execute</code>方法执行SQL语句，do_insert执行后，不需要调用commit方法提交事务，<code>adbapi</code>会自动处理<strong>所有</strong>数据库事务</li><li><strong>query.addErrback(self.handle_error) 方法：</strong>addErrback方法是<code>Twisted</code>框架中用于处理<code>Deferred</code>对象中发生错误的回调方法。当在<code>runInteraction</code>中执行的操作发生异常时，该异常会被包装为一个<code>Failure</code>对象，然后通过addErrback指定的回调函数进行处理。<code>handle_error</code>方法中的参数<code>failure</code>就是包含了异常信息的<code>Failure</code>对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class MysqlTwistedPipeline:</span><br><span class="line">    def __init__(self, dbpool):</span><br><span class="line">        self.dbpool = dbpool</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line">        dbparms = dict(</span><br><span class="line">            host=settings[&quot;MYSQL_HOST&quot;],</span><br><span class="line">            db=settings[&quot;MYSQL_DBNAME&quot;],</span><br><span class="line">            user=settings[&quot;MYSQL_USER&quot;],</span><br><span class="line">            passwd=settings[&quot;MYSQL_PASSWORD&quot;],</span><br><span class="line">            charset=&quot;utf8&quot;,  # 字符集必须是utf8更规范，utf-8会报错</span><br><span class="line">            cursorclass=pymysql.cursors.DictCursor,  # 指定了在执行查询时返回的结果集的游标类型</span><br><span class="line">            use_unicode=True,  # 使用Unicode编码，更好地支持包含非ASCII字符的数据</span><br><span class="line">        )</span><br><span class="line">        dbpool = adbapi.ConnectionPool(&#x27;pymysql&#x27;, **dbparms)</span><br><span class="line"></span><br><span class="line">        # 在创建连接池的时候异步执行创建表的逻辑</span><br><span class="line">        cls.create_table(dbpool)</span><br><span class="line"></span><br><span class="line">        return cls(dbpool)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def create_table(cls, dbpool):</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            create table if not exists table_name(</span><br><span class="line">                </span><br><span class="line">            );</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 异步方式执行创建表的sql语句</span><br><span class="line">        dbpool.runInteraction(cls._create_table, sql)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def _create_table(cursor, sql):</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        # 异步调用do_insert函数，执行sql语句，并传入item参数</span><br><span class="line">        query = self.dbpool.runInteraction(self.do_insert, item)</span><br><span class="line">        # 在runInteraction中执行的操作发生异常时，回调handle_error函数处理异常</span><br><span class="line">        query.addErrback(self.handle_error)</span><br><span class="line"></span><br><span class="line">    def do_insert(self, cursor, item):</span><br><span class="line">        &quot;&quot;&quot;注意：在构造sql语句时，最好使用参数化占位符来解决这个问题，</span><br><span class="line">        而不是直接在sql查询中插入值，这种方法可以避免sql注入的问题，并更容易处理特殊字符</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # `ON DUPLICATE KEY UPDATE`语法在插入数据时如果主键冲突，则可以指定字段进行更新的操作</span><br><span class="line">        sql = f&quot;&quot;&quot;</span><br><span class="line">            insert into cnblogs_news values (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)</span><br><span class="line">            ON DUPLICATE KEY UPDATE totalview=VALUES(totalview);</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # 需要保证进入数据库的每个值都是str或者int类型的</span><br><span class="line">        params = []</span><br><span class="line">        cursor.execute(sql, params)  # 参数2接受列表或元组</span><br><span class="line"></span><br><span class="line">    def handle_error(self, failure):</span><br><span class="line">        print(f&quot;mysql处理错误：&#123;failure&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="六、Settings配置模块"><a href="#六、Settings配置模块" class="headerlink" title="六、Settings配置模块"></a>六、Settings配置模块</h2><h3 id="1-配置下载延迟"><a href="#1-配置下载延迟" class="headerlink" title="1. 配置下载延迟"></a>1. 配置下载延迟</h3><ul><li><strong>DOWNLOAD_DELAY：限制的是每个请求之间的延迟，而不是每组并发请求之前</strong></li><li><strong>注意：</strong>限制并发请求的数量是为了控制爬虫对目标网站的访问频率，防止对服务器造成过大的负担。即使设置了 DOWNLOAD_DELAY，如果并发请求数量过高，仍然可能在短时间内向服务器发送大量请求，这可能导致服务器拒绝服务、IP被封禁等问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 下载延迟，每个请求间的下载延迟，单位为秒(default: 0，默认是针对同一域名的每个请求延迟)</span><br><span class="line">DOWNLOAD_DELAY = 2</span><br><span class="line"># 随机下载延迟，范围是0.5到1.5倍DOWNLOAD_DELAY(default: True)</span><br><span class="line">DOWNLOAD_DELAY_RANDOMIZE = True</span><br><span class="line"></span><br><span class="line"># 全局限制，配置执行的最大并发请求数(default: 16)</span><br><span class="line"># CONCURRENT_REQUESTS = 4</span><br><span class="line"># 注意：CONCURRENT_REQUESTS &gt;= CONCURRENT_REQUESTS_PER_DOMAIN + CONCURRENT_REQUESTS_PER_IP</span><br><span class="line"></span><br><span class="line"># 下载延迟设置将仅支持以下其中一项：</span><br><span class="line"># CONCURRENT_REQUESTS_PER_DOMAIN = 2  # 同一域名下的并发请求数量(default: 8)</span><br><span class="line"># CONCURRENT_REQUESTS_PER_IP = 2  # 同一IP下的并发请求数量(default: 0，则优先级高于域名限制)</span><br></pre></td></tr></table></figure><h3 id="2-全部配置"><a href="#2-全部配置" class="headerlink" title="2. 全部配置"></a>2. 全部配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">BOT_NAME = &quot;project&quot;  # 表示Scrapy项目的名称</span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [&quot;project.spiders&quot;]  # 表示Scrapy项目中包含爬虫代码的Python模块，是一个列表</span><br><span class="line">NEWSPIDER_MODULE = &quot;project.spiders&quot;  # 表示创建新爬虫时的脚本文件放置的默认模块</span><br><span class="line"></span><br><span class="line"># Obey robots.txt rules</span><br><span class="line">ROBOTSTXT_OBEY = True  # 用于指定是否遵循网站的 robots.txt 规则</span><br><span class="line"></span><br><span class="line"># Configure maximum concurrent requests performed by Scrapy (default: 16)</span><br><span class="line">CONCURRENT_REQUESTS = 32  # 用于指定在任何给定时间点同时执行的最大请求数量</span><br><span class="line"></span><br><span class="line"># 默认情况下，RANDOMIZE_DOWNLOAD_DELAY = True，用于控制是否随机化DOWNLOAD_DELAY</span><br><span class="line"># 实际延迟时间：[0.5 * DOWNLOAD_DELAY, 1.5 * DOWNLOAD_DELAY]，即0.5到1.5倍之间</span><br><span class="line">DOWNLOAD_DELAY = 1</span><br><span class="line"># 下载延迟设置只会受到CONCURRENT_REQUESTS_PER_DOMAIN或CONCURRENT_REQUESTS_PER_IP中的一个影响</span><br><span class="line"># CONCURRENT_REQUESTS_PER_DOMAIN = 16  # 控制对于同一域名的并发请求数量</span><br><span class="line"># CONCURRENT_REQUESTS_PER_IP = 16  # 控制对于同一 IP 地址的并发请求数量</span><br><span class="line"></span><br><span class="line"># Disable cookies (enabled by default)</span><br><span class="line"># COOKIES_ENABLED = False  # 用于控制是否启用cookies（默认 cookies 是启用的）</span><br><span class="line"></span><br><span class="line"># 用于设置默认的请求头信息</span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;  </span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 用于启用或禁用爬虫中间件（数字越小，优先级越高）</span><br><span class="line"># SPIDER_MIDDLEWARES = &#123;</span><br><span class="line">#    &quot;project.middlewares.ProjectSpiderMiddleware&quot;: 543,</span><br><span class="line"># &#125;</span><br><span class="line"></span><br><span class="line"># 用于启用或禁用下载器中间件（数字越小，优先级越高）</span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    &quot;project.middlewares.IpDownloaderMiddleware&quot;: 543,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 用于启用或禁用扩展（数字越小，优先级越高）</span><br><span class="line">EXTENSIONS = &#123;</span><br><span class="line">    &quot;project.extend_ip.MyExtend&quot;: 300,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 用于指定数据处理的管道的设置，按照优先级顺序，依次将 Item 经过这些 Pipeline 进行处理</span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    &quot;project.pipelines.JsonExporterPipeline&quot;: 300,</span><br><span class="line">    &quot;project.pipelines.ScrapyJsonExporterPipeline&quot;: 301,</span><br><span class="line">    # &quot;scrapy.pipelines.images.ImagesPipeline&quot;: 1,  # 使用scrapy默认的下载图片pipeline，优先级为1</span><br><span class="line">    &quot;project.pipelines.MyImagesPipeline&quot;: 1,</span><br><span class="line">    &quot;project.pipelines.MysqlTwistedPipeline&quot;: 302,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Enable and configure the AutoThrottle extension (disabled by default)</span><br><span class="line"># See https://docs.scrapy.org/en/latest/topics/autothrottle.html</span><br><span class="line"># AUTOTHROTTLE_ENABLED = True  # 启用或禁用自动限速扩展，默认是禁用的</span><br><span class="line"># The initial download delay</span><br><span class="line"># AUTOTHROTTLE_START_DELAY = 5  # 初始下载延迟，表示在 Scrapy 发送第一个请求之前等待的时间，默认为5秒</span><br><span class="line"># The maximum download delay to be set in case of high latencies</span><br><span class="line"># AUTOTHROTTLE_MAX_DELAY = 60  # 最大下载延迟，表示自动限速的最大等待时间</span><br><span class="line"># The average number of requests Scrapy should be sending in parallel to</span><br><span class="line"># each remote server</span><br><span class="line"># AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0  # 每个远程服务器平均并行发送的请求数量，默认为 1.0</span><br><span class="line"># Enable showing throttling stats for every response received:</span><br><span class="line"># AUTOTHROTTLE_DEBUG = False  # 启用或禁用自动限速的调试模式，默认是禁用的，开启调试会记录更多有关信息</span><br><span class="line"></span><br><span class="line"># Enable and configure HTTP caching (disabled by default)</span><br><span class="line"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings</span><br><span class="line"># HTTPCACHE_ENABLED = True  # 启用或禁用HTTP缓存，默认是禁用的</span><br><span class="line"># HTTPCACHE_EXPIRATION_SECS = 0  # 指定缓存响应的过期时间（秒），过期后将发送新请求到服务器</span><br><span class="line"># HTTPCACHE_DIR = &quot;httpcache&quot;  # 定义缓存响应的存储目录</span><br><span class="line"># HTTPCACHE_IGNORE_HTTP_CODES = []  # 定义在缓存时应该忽略的HTTP状态码列表</span><br><span class="line"># HTTPCACHE_STORAGE = &quot;scrapy.extensions.httpcache.FilesystemCacheStorage&quot;  # 存储缓存的引擎</span><br><span class="line"></span><br><span class="line"># Set settings whose default value is deprecated to a future-proof value</span><br><span class="line"># 这些设置的作用是确保在将来的Scrapy版本中仍然能够正常运行，因为某些默认值已被弃用</span><br><span class="line">REQUEST_FINGERPRINTER_IMPLEMENTATION = &quot;2.7&quot;</span><br><span class="line">TWISTED_REACTOR = &quot;twisted.internet.asyncioreactor.AsyncioSelectorReactor&quot;</span><br><span class="line">FEED_EXPORT_ENCODING = &quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line"># 处理图像下载的设置字段</span><br><span class="line">IMAGES_URLS_FIELD = &#x27;front_image_url&#x27;  # 用于指定 Item 对象中包含图像 URL 的字段名称</span><br><span class="line"># 如果路径以斜杠/开头，就是绝对路径；没有以斜杠开头，就是相对于当前工作目录的相对路径</span><br><span class="line">IMAGES_STORE = os.path.dirname(os.getcwd()) + &#x27;/images/&#x27;</span><br><span class="line"></span><br><span class="line"># MySQL相关配置</span><br><span class="line">MYSQL_HOST = &quot;127.0.0.1&quot;</span><br><span class="line">MYSQL_USER = &quot;root&quot;</span><br><span class="line">MYSQL_PASSWORD = &quot;123456&quot;</span><br><span class="line">MYSQL_DBNAME = &quot;py_spider&quot;</span><br></pre></td></tr></table></figure><h2 id="七、cnblogs项目实战"><a href="#七、cnblogs项目实战" class="headerlink" title="七、cnblogs项目实战"></a>七、cnblogs项目实战</h2><h3 id="1-spiders-cnblogs-py"><a href="#1-spiders-cnblogs-py" class="headerlink" title="1. spiders&#x2F;cnblogs.py"></a>1. spiders&#x2F;cnblogs.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy import cmdline</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">import hashlib</span><br><span class="line">from urllib import parse</span><br><span class="line"></span><br><span class="line">from scrapy.loader import ItemLoader</span><br><span class="line">from bkyuan.items import DefaultItemLoader</span><br><span class="line">from bkyuan.items import CnblogsArticleItem</span><br><span class="line"></span><br><span class="line">class CnblogsSpider(scrapy.Spider):</span><br><span class="line">    name = &quot;cnblogs&quot;</span><br><span class="line">    allowed_domains = [&quot;news.cnblogs.com&quot;, &quot;cnblogs.com&quot;]</span><br><span class="line">    start_urls = [&quot;https://news.cnblogs.com/&quot;]</span><br><span class="line"></span><br><span class="line">    options = webdriver.ChromeOptions()</span><br><span class="line">    # 禁用Chrome的Blink渲染引擎中相关的自动化特性，目的是减少被自动化工具检测到的概率</span><br><span class="line">    options.add_argument(&#x27;--disable-blink-features=AutomationControlled&#x27;)</span><br><span class="line">    options.add_argument(&#x27;--headless&#x27;)  # 无头模式</span><br><span class="line">    options.page_load_strategy = &quot;eager&quot;  # 更改页面加载策略为eager</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.browser = webdriver.Chrome(options=self.options)</span><br><span class="line">        self.wait_bro = WebDriverWait(self.browser, 5)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        self.browser.quit()</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        self.browser.get(&quot;https://account.cnblogs.com/signin&quot;)</span><br><span class="line">        username = self.wait_bro.until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, &#x27;//input[@formcontrolname=&quot;username&quot;]&#x27;)))</span><br><span class="line">        password = self.wait_bro.until(</span><br><span class="line">            EC.presence_of_element_located((By.XPATH, &#x27;//input[@formcontrolname=&quot;password&quot;]&#x27;)))</span><br><span class="line">        login_btn = self.wait_bro.until(</span><br><span class="line">            EC.element_to_be_clickable((By.XPATH, &#x27;//button[contains(@class,&quot;mat-flat-button&quot;)]&#x27;)))</span><br><span class="line">        username.send_keys(&quot;小傅xfblog&quot;)</span><br><span class="line">        password.send_keys(&quot;zhangjie789&quot;)</span><br><span class="line">        login_btn.click()</span><br><span class="line">        check_btn = self.wait_bro.until(EC.element_to_be_clickable((By.XPATH, &#x27;//div[@id=&quot;rectMask&quot;]&#x27;)))</span><br><span class="line">        check_btn.click()</span><br><span class="line">        # 登录成功后，首先跳转新闻页，然后随机访问一篇文章，获取其cookies以供后续爬取文章详情页携带</span><br><span class="line">        time.sleep(2)  # 登录成功后不能点击太快，否则会又跳转至登录页面</span><br><span class="line">        self.browser.get(&quot;https://news.cnblogs.com/&quot;)</span><br><span class="line">        article_a = self.wait_bro.until(</span><br><span class="line">            EC.element_to_be_clickable((By.XPATH, &#x27;//div[@class=&quot;news_block&quot;][1]//h2/a&#x27;)))</span><br><span class="line">        article_a.click()</span><br><span class="line">        cookies = self.browser.get_cookies()</span><br><span class="line">        cookie_dict = &#123;item[&#x27;name&#x27;]: item[&#x27;value&#x27;] for item in cookies&#125;</span><br><span class="line"></span><br><span class="line">        url = &quot;https://news.cnblogs.com/n/page/&#123;&#125;/&quot;</span><br><span class="line">        for page in range(1, 101):</span><br><span class="line">            yield scrapy.Request(url=url.format(page), cookies=cookie_dict, meta=&#123;&#x27;cookies&#x27;: cookie_dict&#125;)</span><br><span class="line"></span><br><span class="line">    def parse(self, response: HtmlResponse, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;parse函数主要完成两个功能：</span><br><span class="line">        1. 获取这页中的每条新闻的封面图片，存为元数据</span><br><span class="line">        2. 获取新闻详情页的url，并交给scrapy进行下载后调用相应的解析方法</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        news_list = response.xpath(&quot;//div[@id=&#x27;news_list&#x27;]/div[@class=&#x27;news_block&#x27;]&quot;)</span><br><span class="line">        for news in news_list:</span><br><span class="line">            image_url = news.xpath(&quot;.//img/@src&quot;).extract_first()</span><br><span class="line">            # 这里有些文章没有封面图片。有些以//开头，所以需要处理为完整url</span><br><span class="line">            if image_url and image_url.startswith(&quot;//&quot;):</span><br><span class="line">                image_url = &quot;https:&quot; + image_url</span><br><span class="line">            article_url = news.xpath(&quot;.//h2[@class=&#x27;news_entry&#x27;]/a/@href&quot;).extract_first()</span><br><span class="line"></span><br><span class="line">            # 使用response.urljoin()方法将相对url转换为绝对url</span><br><span class="line">            article_url = response.urljoin(article_url)</span><br><span class="line">            yield scrapy.Request(url=article_url, cookies=response.meta.get(&quot;cookies&quot;, &quot;&quot;),</span><br><span class="line">                                 meta=&#123;&#x27;front_image_url&#x27;: image_url&#125;, callback=self.parse_article)</span><br><span class="line"></span><br><span class="line">    def parse_article(self, response: HtmlResponse):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        分析得知：后续文章详情的评论数、阅读量等数据，是通过数据api返回的，所以需要得到文章id，</span><br><span class="line">        构造请求url：https://news.cnblogs.com/NewsAjax/GetAjaxNewsInfo?contentId=&#123;&#125;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        article_id = re.findall(r&#x27;.*?(\d&#123;6,&#125;?)&#x27;, response.url)[0]</span><br><span class="line">        url_md5 = hashlib.md5(str(response.url).encode()).hexdigest()</span><br><span class="line">        # 日志打印请求元数据</span><br><span class="line">        self.logger.warning(response.request.meta)</span><br><span class="line">        if article_id:</span><br><span class="line">            # 创建一个 ItemLoader 实例，并指定要加载的 Item 类</span><br><span class="line">            item_info = DefaultItemLoader(item=CnblogsArticleItem(), response=response)</span><br><span class="line">            item_info.add_xpath(&quot;title&quot;, &#x27;//*[@id=&quot;news_title&quot;]/a/text()&#x27;)</span><br><span class="line">            item_info.add_xpath(&quot;create_date&quot;, &#x27;//*[@id=&quot;news_info&quot;]//*[@class=&quot;time&quot;]/text()&#x27;)</span><br><span class="line">            item_info.add_xpath(&quot;tags&quot;, &#x27;//*[@id=&quot;news_more_info&quot;]//a/text()&#x27;)</span><br><span class="line">            item_info.add_value(&quot;url&quot;, response.url)</span><br><span class="line">            item_info.add_value(&quot;url_md5_id&quot;, url_md5)</span><br><span class="line">            # 下载图片需要在settings中配置 IMAGES_URLS_FIELD 和 IMAGES_STORE 字段</span><br><span class="line">            # 一定要确保图片 url 值是有效的，否则会抛出异常 ValueError：Missing scheme in request url</span><br><span class="line">            if response.meta.get(&quot;front_image_url&quot;, &quot;&quot;):</span><br><span class="line">                item_info.add_value(&quot;front_image_url&quot;, response.meta.get(&quot;front_image_url&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line">            # 由于是带着cookies在进行详情页请求，此时response.url已经变了，所以不再使用response.urljoin()</span><br><span class="line">            # 可以使用 urllib.parse 包中的 urljoin() 方法，手动控制 url 前缀</span><br><span class="line">            api_url = parse.urljoin(&quot;https://news.cnblogs.com/&quot;, f&quot;/NewsAjax/GetAjaxNewsInfo?contentId=&#123;article_id&#125;&quot;)</span><br><span class="line">            yield scrapy.Request(url=api_url, meta=&#123;&#x27;item_info&#x27;: item_info&#125;, callback=self.parse_api)</span><br><span class="line"></span><br><span class="line">    def parse_api(self, response: HtmlResponse):</span><br><span class="line">        data = response.json()</span><br><span class="line">        item_info = response.meta.get(&quot;item_info&quot;, &quot;&quot;)</span><br><span class="line">        # 注意 item 中和这里定义字段的大小写，区分大小写！</span><br><span class="line">        item_info.add_value(&quot;commentcount&quot;, data.get(&quot;CommentCount&quot;, 0))  # 评论数</span><br><span class="line">        item_info.add_value(&quot;totalview&quot;, data.get(&quot;TotalView&quot;, 0))  # 阅读量</span><br><span class="line">        item_info.add_value(&quot;diggcount&quot;, data.get(&quot;DiggCount&quot;, 0))  # 推荐数量</span><br><span class="line">        item_info.add_value(&quot;burycount&quot;, data.get(&quot;BuryCount&quot;, 0))  # 不推荐数量</span><br><span class="line"></span><br><span class="line">        # 完成加载并生成 Item 对象</span><br><span class="line">        yield item_info.load_item()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    cmdline.execute(&quot;scrapy crawl cnblogs&quot;.split())</span><br></pre></td></tr></table></figure><h3 id="2-extend-ip-py"><a href="#2-extend-ip-py" class="headerlink" title="2. extend_ip.py"></a>2. extend_ip.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line">import requests</span><br><span class="line">from scrapy import signals</span><br><span class="line"></span><br><span class="line"># 提取代理IP的api，一次提取10个（生成链接：https://www.kuaidaili.com/dps/genapiurl/）</span><br><span class="line">api_url = &#x27;https://dps.kdlapi.com/api/getdps/?secret_id=o88cwu0sh49ls75kntwt&amp;num=1&amp;signature=dtb4yamicu504fub6llgx7mjabckit83&amp;pt=1&amp;format=json&amp;sep=1&#x27;</span><br><span class="line">foo = True</span><br><span class="line"></span><br><span class="line">class Proxy:</span><br><span class="line">    def __init__(self, ):</span><br><span class="line">        self._proxy_list = requests.get(api_url).json().get(&#x27;data&#x27;).get(&#x27;proxy_list&#x27;)</span><br><span class="line"></span><br><span class="line">    @property  # p.proxy_list：自动执行此方法，并获取方法的返回值</span><br><span class="line">    def proxy_list(self):</span><br><span class="line">        return self._proxy_list</span><br><span class="line"></span><br><span class="line">    @proxy_list.setter  # p.proxy_list=&#x27;abc&#x27;：自动执行此方法，并将&#x27;abc&#x27;赋值给list参数</span><br><span class="line">    def proxy_list(self, list):</span><br><span class="line">        self._proxy_list = list</span><br><span class="line"></span><br><span class="line">pro = Proxy()</span><br><span class="line"></span><br><span class="line">class MyExtend:</span><br><span class="line">    def __init__(self, crawler):</span><br><span class="line">        self.crawler = crawler</span><br><span class="line">        # 将自定义方法绑定到scrapy信号上，使程序与spider引擎同步启动与关闭</span><br><span class="line">        crawler.signals.connect(self.start, signals.engine_started)</span><br><span class="line">        crawler.signals.connect(self.close, signals.spider_closed)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(crawler)</span><br><span class="line"></span><br><span class="line">    def start(self):</span><br><span class="line">        t = threading.Thread(target=self.extract_proxy)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    def extract_proxy(self):</span><br><span class="line">        while foo:</span><br><span class="line">            pro.proxy_list = requests.get(api_url).json().get(&#x27;data&#x27;).get(&#x27;proxy_list&#x27;)</span><br><span class="line">            # 设置每一分钟提取一次ip，更新proxy_list列表中的ip，保证都是有效ip</span><br><span class="line">            time.sleep(60)</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        global foo</span><br><span class="line">        foo = False</span><br></pre></td></tr></table></figure><h3 id="3-middlewares-py"><a href="#3-middlewares-py" class="headerlink" title="3. middlewares.py"></a>3. middlewares.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from scrapy import signals</span><br><span class="line">import random</span><br><span class="line">from .extend_ip import pro</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line"></span><br><span class="line">class IpDownloaderMiddleware:</span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        username = &quot;d4550779926&quot;</span><br><span class="line">        password = &quot;kzsel6pa&quot;</span><br><span class="line">        # 如果当前ip不可用，那么process_response重试，这里会在代理池中重新选择一个代理ip</span><br><span class="line">        proxy = random.choice(pro.proxy_list)</span><br><span class="line">        request.meta[&#x27;proxy&#x27;] = f&quot;http://&#123;username&#125;:&#123;password&#125;@&#123;proxy&#125;/&quot;</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    def process_response(self, request, response: HtmlResponse, spider):</span><br><span class="line">        if not response.status == 200:</span><br><span class="line">            request.dont_filter = True</span><br><span class="line">            return request</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure><h3 id="4-items-py"><a href="#4-items-py" class="headerlink" title="4. items.py"></a>4. items.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from itemloaders.processors import TakeFirst, Identity, Join, Compose, MapCompose</span><br><span class="line">from scrapy.loader import ItemLoader</span><br><span class="line"></span><br><span class="line">def date_convert(date):</span><br><span class="line">    # 这里处理字段一定不能只处理不对的，要将正确的也return回去</span><br><span class="line">    return &quot;1970-07-01&quot; if not date else date</span><br><span class="line">    </span><br><span class="line">class DefaultItemLoader(ItemLoader):</span><br><span class="line">    # 配置默认的输出字段格式，因为在获取数据时，add_xpath方法获取的都是列表</span><br><span class="line">    default_output_processor = TakeFirst()  # 取出列表第一个非空值</span><br><span class="line"></span><br><span class="line">class CnblogsArticleItem(scrapy.Item):</span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    create_date = scrapy.Field(</span><br><span class="line">        # 常配合spider中的add_value进行处理器调用，用于在将数据填充到ItemLoader之前对其进行处理</span><br><span class="line">        input_processor=Compose(date_convert)  # 如果获取的日期为空，则赋值&quot;1970-07-01&quot;</span><br><span class="line">    )</span><br><span class="line">    tags = scrapy.Field(</span><br><span class="line">        # 由于标签tags不止一个，而TakeFirst()只取第一个，所以可以使用Join将多个拼接为字符串</span><br><span class="line">        output_processor=Join(&quot;,&quot;)</span><br><span class="line">    )</span><br><span class="line">    url = scrapy.Field()</span><br><span class="line">    url_md5_id = scrapy.Field()</span><br><span class="line"></span><br><span class="line">    front_image_url = scrapy.Field(</span><br><span class="line">        # 图片下载字段的值必须是一个列表，列表中包含正确的图片url地址</span><br><span class="line">        # DefaultItemLoader将图片字段输出为了字符串，所以这里需要输出原始数据，即列表</span><br><span class="line">        output_processor=Identity()</span><br><span class="line">    )</span><br><span class="line">    front_image_path = scrapy.Field()</span><br><span class="line"></span><br><span class="line">    commentcount = scrapy.Field()</span><br><span class="line">    totalview = scrapy.Field()</span><br><span class="line">    diggcount = scrapy.Field()</span><br><span class="line">    burycount = scrapy.Field()</span><br></pre></td></tr></table></figure><h3 id="5-piplines-py"><a href="#5-piplines-py" class="headerlink" title="5. piplines.py"></a>5. piplines.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">import json</span><br><span class="line">from scrapy.exporters import JsonLinesItemExporter</span><br><span class="line">from scrapy.pipelines.images import ImagesPipeline</span><br><span class="line">from twisted.enterprise import adbapi</span><br><span class="line">import pymysql.cursors</span><br><span class="line"></span><br><span class="line"># 自定义json数据的导出模式，所有的item都会在内存中被处理并最终写入文件，可能导致内存消耗较高</span><br><span class="line">class JsonExporterPipeline:</span><br><span class="line">    &quot;&quot;&quot;关于初始化文件对象的问题：</span><br><span class="line">    1、如果想要在爬虫启动时创建文件，在关闭时关闭文件，使用 open_spider 和 close_spider 是很好的选择</span><br><span class="line">    2、如果想要在整个爬虫运行期间保持文件打开状态，那么使用 __init__ 和 spider_closed 的写法也是可以的</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        if spider.name == &quot;cnblogs&quot;:</span><br><span class="line">            # 为了确保使整个文件成为一个 JSON 数组，方便后续调用，只需加上换行即可自动生成</span><br><span class="line">            self.fp.write(json.dumps(dict(item), ensure_ascii=False) + &quot;,\n&quot;)</span><br><span class="line">            return item</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        if spider.name == &quot;cnblogs&quot;:</span><br><span class="line">            # 使用默认的 JSON 编码器无法处理自定义对象，无法将 Item 对象转换为字典</span><br><span class="line">            self.fp = open(&quot;article1.json&quot;, &quot;w&quot;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">            self.fp.write(&quot;[\n&quot;)</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        if spider.name == &quot;cnblogs&quot;:</span><br><span class="line">            self.fp.write(&quot;]\n&quot;)</span><br><span class="line">            self.fp.close()</span><br><span class="line"></span><br><span class="line"># Scrapy官方的json数据导出模式，每次parse函数yield的item经过处理直接写入json文件，不占内存</span><br><span class="line">class ScrapyJsonExporterPipeline:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 以二进制模式打开文件时不应该指定编码参数，因为文件是以字节形式读取和写入的，而不是字符</span><br><span class="line">        self.fp = open(&quot;article2.json&quot;, &quot;wb&quot;)</span><br><span class="line">        self.exporter = JsonLinesItemExporter(self.fp, encoding=&quot;utf-8&quot;, ensure_ascii=False)</span><br><span class="line">        self.exporter.start_exporting()</span><br><span class="line">        self.fp.write(b&quot;[&quot;)</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        # 注意：export_item方法中只接受字节数据，所以上面文件应该以二进制模式wb打开</span><br><span class="line">        self.exporter.export_item(item)</span><br><span class="line">        self.fp.write(b&quot;,&quot;)</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.exporter.finish_exporting()</span><br><span class="line">        self.fp.write(b&quot;]&quot;)</span><br><span class="line">        self.fp.close()</span><br><span class="line"></span><br><span class="line"># 自定义下载图片管道，遍历下载结果，获取图片保存的路径并添加到item中，最后返回处理后的item</span><br><span class="line">class MyImagesPipeline(ImagesPipeline):</span><br><span class="line">    def item_completed(self, results, item, info):</span><br><span class="line">        if &#x27;front_image_url&#x27; in item:</span><br><span class="line">            for ok, value in results:</span><br><span class="line">                front_image_path = value[&#x27;path&#x27;]</span><br><span class="line">                item[&#x27;front_image_path&#x27;] = front_image_path</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line"># 自定义异步mysql存储管道</span><br><span class="line">class MysqlTwistedPipeline:</span><br><span class="line">    def __init__(self, dbpool):</span><br><span class="line">        self.dbpool = dbpool</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line">        dbparms = dict(</span><br><span class="line">            host=settings[&quot;MYSQL_HOST&quot;],</span><br><span class="line">            db=settings[&quot;MYSQL_DBNAME&quot;],</span><br><span class="line">            user=settings[&quot;MYSQL_USER&quot;],</span><br><span class="line">            passwd=settings[&quot;MYSQL_PASSWORD&quot;],</span><br><span class="line">            charset=&quot;utf8&quot;,  # 字符集必须是utf8更规范，utf-8会报错</span><br><span class="line">            cursorclass=pymysql.cursors.DictCursor,  # 指定了在执行查询时返回的结果集的游标类型</span><br><span class="line">            use_unicode=True,  # 使用Unicode编码，更好地支持包含非ASCII字符的数据</span><br><span class="line">        )</span><br><span class="line">        dbpool = adbapi.ConnectionPool(&#x27;pymysql&#x27;, **dbparms)</span><br><span class="line"></span><br><span class="line">        # 在创建连接池的时候异步执行创建表的逻辑</span><br><span class="line">        cls.create_table(dbpool)</span><br><span class="line"></span><br><span class="line">        return cls(dbpool)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def create_table(cls, dbpool):</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            create table if not exists cnblogs_news(</span><br><span class="line">                url_md5_id char(32) primary key,</span><br><span class="line">                title varchar(255),</span><br><span class="line">                tags varchar(50),</span><br><span class="line">                create_date timestamp,</span><br><span class="line">                url varchar(255),</span><br><span class="line">                front_image_url varchar(255),</span><br><span class="line">                front_image_path varchar(255),</span><br><span class="line">                commentcount int,</span><br><span class="line">                totalview int,</span><br><span class="line">                diggcount int,</span><br><span class="line">                burycount int</span><br><span class="line">            );</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 异步方式执行创建表的sql语句</span><br><span class="line">        dbpool.runInteraction(cls._create_table, sql)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def _create_table(cursor, sql):</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        # 异步调用do_insert函数，执行sql语句，并传入item参数</span><br><span class="line">        query = self.dbpool.runInteraction(self.do_insert, item)</span><br><span class="line">        # 在runInteraction中执行的操作发生异常时，回调handle_error函数处理异常</span><br><span class="line">        query.addErrback(self.handle_error)</span><br><span class="line"></span><br><span class="line">    def do_insert(self, cursor, item):</span><br><span class="line">        &quot;&quot;&quot;注意：在构造sql语句时，最好使用参数化占位符来解决这个问题，</span><br><span class="line">        而不是直接在sql查询中插入值，这种方法可以避免sql注入的问题，并更容易处理特殊字符</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # `ON DUPLICATE KEY UPDATE`语法在插入数据时如果主键冲突，则指定一个字段进行更新的操作</span><br><span class="line">        sql = f&quot;&quot;&quot;</span><br><span class="line">            insert into cnblogs_news values (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)</span><br><span class="line">            ON DUPLICATE KEY UPDATE totalview=VALUES(totalview);</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        params = [</span><br><span class="line">            item.get(&quot;url_md5_id&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;title&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;tags&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;create_date&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;url&quot;, &quot;&quot;),</span><br><span class="line">            # 保证进入数据库的每个值都是str或者int类型的</span><br><span class="line">            &quot;,&quot;.join(item.get(&quot;front_image_url&quot;, [])),</span><br><span class="line">            item.get(&quot;front_image_path&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;commentcount&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;totalview&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;diggcount&quot;, &quot;&quot;),</span><br><span class="line">            item.get(&quot;burycount&quot;, &quot;&quot;)</span><br><span class="line">        ]</span><br><span class="line">        cursor.execute(sql, params)  # 参数2接受列表或元组</span><br><span class="line"></span><br><span class="line">    def handle_error(self, failure):</span><br><span class="line">        print(f&quot;mysql处理错误：&#123;failure&#125;&quot;)</span><br></pre></td></tr></table></figure><h3 id="6-settings-py"><a href="#6-settings-py" class="headerlink" title="6. settings.py"></a>6. settings.py</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">BOT_NAME = &quot;bkyuan&quot;</span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [&quot;bkyuan.spiders&quot;]</span><br><span class="line">NEWSPIDER_MODULE = &quot;bkyuan.spiders&quot;</span><br><span class="line"></span><br><span class="line"># Obey robots.txt rules</span><br><span class="line">ROBOTSTXT_OBEY = False</span><br><span class="line"></span><br><span class="line"># Override the default request headers:</span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Enable or disable downloader middlewares</span><br><span class="line"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    &quot;bkyuan.middlewares.IpDownloaderMiddleware&quot;: 543,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Enable or disable extensions</span><br><span class="line"># See https://docs.scrapy.org/en/latest/topics/extensions.html</span><br><span class="line">EXTENSIONS = &#123;</span><br><span class="line">    &quot;bkyuan.extend_ip.MyExtend&quot;: 300,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Configure item pipelines</span><br><span class="line"># See https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    &quot;bkyuan.pipelines.JsonExporterPipeline&quot;: 300,</span><br><span class="line">    &quot;bkyuan.pipelines.ScrapyJsonExporterPipeline&quot;: 301,</span><br><span class="line">    # &quot;scrapy.pipelines.images.ImagesPipeline&quot;: 1,  # 使用scrapy默认的下载图片pipeline，优先级为1</span><br><span class="line">    &quot;bkyuan.pipelines.MyImagesPipeline&quot;: 1,</span><br><span class="line">    &quot;bkyuan.pipelines.MysqlTwistedPipeline&quot;: 302,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Set settings whose default value is deprecated to a future-proof value</span><br><span class="line">REQUEST_FINGERPRINTER_IMPLEMENTATION = &quot;2.7&quot;</span><br><span class="line">TWISTED_REACTOR = &quot;twisted.internet.asyncioreactor.AsyncioSelectorReactor&quot;</span><br><span class="line">FEED_EXPORT_ENCODING = &quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line"># 处理图像下载的设置字段</span><br><span class="line">IMAGES_URLS_FIELD = &#x27;front_image_url&#x27;  # 用于指定 Item 对象中包含图像 URL 的字段名称</span><br><span class="line"># 如果路径以斜杠/开头，就是绝对路径；没有以斜杠开头，就是相对于当前工作目录的相对路径</span><br><span class="line">IMAGES_STORE = os.path.dirname(os.getcwd()) + &#x27;/images/&#x27;</span><br><span class="line"></span><br><span class="line"># MySQL相关配置</span><br><span class="line">MYSQL_HOST = &quot;127.0.0.1&quot;</span><br><span class="line">MYSQL_USER = &quot;root&quot;</span><br><span class="line">MYSQL_PASSWORD = &quot;123456&quot;</span><br><span class="line">MYSQL_DBNAME = &quot;py_spider&quot;</span><br></pre></td></tr></table></figure><h2 id="八、Scrapy-Redis增量爬虫"><a href="#八、Scrapy-Redis增量爬虫" class="headerlink" title="八、Scrapy_Redis增量爬虫"></a>八、Scrapy_Redis增量爬虫</h2><blockquote><p><strong>引入：</strong>前面所提到的<code>scrapy的断点续爬</code>和<code>请求url地址去重</code>就是在原生实现增量爬虫，虽然有效，但却无法从<code>JOBDIR</code>指定的路径中看到爬取的情况，而 <strong>scrapy_redis</strong> 则是将两者融合并完美实现，不仅可以以同样的方式 <strong>ctrl+c</strong> 实现暂停，以启动命令实现断点续爬，还可以在redis数据库中通过 <strong>dupfilter</strong> 和 <strong>requests</strong> 字段得知爬取情况，其中<strong>dupfilter对应已爬取的指纹</strong>，而<strong>requests对应还没爬取的</strong>，以实现增量爬虫</p><p><strong>什么是增量爬虫？</strong></p><p>在Scrapy中，增量爬虫（Incremental Crawling）是指只爬取自上次爬取以来发生变化的数据，而不是重新爬取整个网站或数据集。这样可以节省时间和资源，特别是在处理大规模的网站或数据集时</p><p><strong>scrapy_redis 扩展：</strong>scrapy_redis允许在分布式环境中使用Scrapy，并且可以单独利用此插件实现增量爬虫，通过在Redis中存储爬取状态来避免重复爬取相同的数据</p><p><strong>注意：使用scrapy-redis之前最好将scrapy版本保持在2.8.0版本，以免有兼容性问题</strong></p><ul><li><strong><code>pip install scrapy==2.8.0</code></strong></li><li><strong><code>pip install scrapy-redis</code></strong></li></ul></blockquote><ul><li><strong>增量爬虫 settings.py 文件新增配置：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot; scrapy-redis配置 &quot;&quot;&quot;</span><br><span class="line"># （使用 scrapy_redis 调度器）指定用于管理请求调度的类</span><br><span class="line">SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"># （使用 scrapy_redis 去重器）指定用于管理重复请求的类</span><br><span class="line">DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line">&quot;&quot;&quot;可以替换成布隆过滤器：</span><br><span class="line">pip install scrapy-redis-bloomfilter</span><br><span class="line">from scrapy_redis_bloomfilter.dupefilter import RFPDupeFilter</span><br><span class="line">DUPEFILTER_CLASS = &#x27;scrapy_redis_bloomfilter.dupefilter.RFPDupeFilter&#x27;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># （调度器持久化）是否在关闭时候保留原来的调度器和去重记录，True=保留，False=清空</span><br><span class="line">SCHEDULER_PERSIST = True</span><br><span class="line"># （设置 redis 连接信息）这里表示 Redis 运行在本地机器上，使用默认端口 6379 和数据库0</span><br><span class="line">REDIS_URL = &quot;redis://127.0.0.1:6379/0&quot;</span><br><span class="line"></span><br><span class="line"># （调度器队列类）指定用于管理优先级队列的类</span><br><span class="line">SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.PriorityQueue&#x27;  # （优先级队列）</span><br><span class="line"># SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.FifoQueue&#x27;  # （先进先出队列）</span><br><span class="line"># SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.LifoQueue&#x27;  # （先进后出/后进先出队列）</span><br><span class="line"></span><br><span class="line"># （启动时清空调度器）默认为False，True表示调度器将在启动时清空所有待处理的请求和去重过滤器，一般不配置</span><br><span class="line"># SCHEDULER_FLUSH_ON_START = True</span><br></pre></td></tr></table></figure><h2 id="九、Scrapy-Redis分布式爬虫"><a href="#九、Scrapy-Redis分布式爬虫" class="headerlink" title="九、Scrapy_Redis分布式爬虫"></a>九、Scrapy_Redis分布式爬虫</h2><blockquote><p>**注意：学习使用 ubuntu-18.04.6 版本虚拟机模拟实现分布式爬虫（<a class="link"   href="https://xfblog.cn/2023/11/01/%E7%88%AC%E8%99%AB_3_Ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"  target="_blank" rel="noopener">ubuntu-18.04.6安装配置<i class="fas fa-external-link-alt"></i></a>**）</p><p><strong>引入：为什么要使用 scrapy_redis 做分布式爬虫？</strong></p><ul><li>在单机爬虫中，所有请求对象 requests 都是直接存放在内存中的，除主机外的其他电脑是不可能访问到主机的内存的，所以借助 scrapy_redis 将原本存储在内存中的数据放到了 Redis 队列中，利用 Redis 高效和支持网络访问的特性，便可以实现多台电脑读取同一个 Redis 队列中的数据，从而实现分布式爬虫</li></ul></blockquote><h3 id="1-scrapy-redis工作流程"><a href="#1-scrapy-redis工作流程" class="headerlink" title="1. scrapy_redis工作流程"></a>1. scrapy_redis工作流程</h3><ul><li><strong>scrapy_redis的实现原理：</strong><ul><li><strong>替换调度器和去重器：</strong>scrapy_redis 替换了 Scrapy 框架中的默认调度器和去重器，将 Redis 作为中心化的任务调度和去重的数据存储</li><li><strong>任务队列的使用：</strong>scrapy_redis 使用 Redis 数据库作为任务队列，将爬虫需要爬取的 URL 存储在 Redis 的列表或者集合中。每个爬虫节点都可以从这个 Redis 队列中获取待爬取的 URL，实现了任务的分发</li><li><strong>分布式去重：</strong>scrapy_redis 通过使用 Redis 数据结构的去重特性，即 <code>RFPDupeFilter</code>，来实现分布式环境下的 URL 去重。当一个 URL 被加入到 Redis 中时，系统会检查是否已经存在于 Redis 中，以实现去重</li><li><strong>任务调度和分配：</strong>scrapy_redis 的调度器负责从 Redis 队列中获取待爬取的 URL，并将其分配给不同的爬虫节点。这样，不同的节点可以并行地爬取不同的 URL，提高了整个系统的效率</li></ul></li><li><strong>scrapy_redis的工作流程：</strong><ol><li>在scrapy_redis中，所有待抓取的 request 对象和去重的 request 对象指纹都存在共用的 redis 队列中</li><li>所有的服务器中的 scrapy 进程共用同一个 redis 中的 request 对象的队列</li><li>所有的 request 对象存入 redis 前，都会通过 redis 中的 request 指纹集合进行判断是否存入过（去重）</li></ol></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1703165509-14b9d3416aa3a54.png"                         style="width:80%;margin:0 auto;"                 ><h3 id="2-RedisPipeline的使用"><a href="#2-RedisPipeline的使用" class="headerlink" title="2. RedisPipeline的使用"></a>2. RedisPipeline的使用</h3><blockquote><p><strong>开启RedisPipeline管道：<code>&quot;scrapy_redis.pipelines.RedisPipeline&quot;: 301</code>（将所有数据存入redis中）</strong></p></blockquote><ul><li><p><strong>关于数据存储问题：</strong>分布式爬虫中，每一台电脑上只存储这台电脑所爬取的数据，与其他设备所爬取的数据互不相通也不重复，所以解决数据统一存储便成为问题。<strong>开启RedisPipeline管道</strong>，那么则可以实现所有数据都存储在Redis数据库中，但前提是所有设备都开启，否则设备之间数据也互不相通</p></li><li><p><strong>关于Redis中数据的问题：</strong>在RedisPipeline管道存储数据时，不支持存储二进制数据，需要将二进制数据进行 Base64 编码，并将结果解码为字符串后再存储（<strong>注意：由于在传递item时将图片数据进行了 Base64 编码，那么在 pipline 其他管道中保存数据时，就一定要将数据进行 Base64 解码，才能正确保存</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># spider.py：将二进制数据进行 Base64 编码，并将结果解码为字符串，才能正确传递</span><br><span class="line">img_data = base64.b64encode(response.body).decode()</span><br><span class="line">yield &#123;</span><br><span class="line">    &quot;type_&quot;: &#x27;image&#x27;,</span><br><span class="line">    &quot;img_name&quot;: title + &#x27;.png&#x27;,</span><br><span class="line">    &quot;img_content&quot;: img_data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># piplines.py：将数据进行 Base64 解码，才能正确保存</span><br><span class="line">with open(images_path + item[&#x27;img_name&#x27;], &#x27;wb&#x27;) as fp:</span><br><span class="line">    img_data = base64.b64decode(item[&#x27;img_content&#x27;])</span><br><span class="line">    fp.write(img_data)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-实现GET请求"><a href="#3-实现GET请求" class="headerlink" title="3. 实现GET请求"></a>3. 实现GET请求</h3><blockquote><p><strong>scrapy_redis 的使用注意：</strong></p><ol><li><strong>不能使用 start_urls 属性：</strong>RedisSpider 类是为分布式爬虫设计的，它使用 Redis 作为任务队列，所以如果爬虫类继承了 RedisSpider 类，便不能使用此属性了</li><li><strong>不能重写 start_requests 方法：</strong>RedisSpider 类与 scrapy.Spider 类中的 start_requests 方法底层实现不一样，所以如果爬虫类继承了 RedisSpider 类，便不能重写此方法了</li></ol></blockquote><ul><li><p><strong>scrapy_redis项目配置：</strong></p><ol><li><p><strong>将爬虫类继承自 RedisSpider 类：</strong>并指定 <strong><code>redis_key</code></strong> 属性，即从 Redis 队列中获取起始 URL 的键名</p></li><li><p><strong>添加 scrapy_redis 配置（settings文件）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot; scrapy-redis配置 &quot;&quot;&quot;</span><br><span class="line"># 配置scrapy_redis调度器</span><br><span class="line">SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"># 配置scrapy_redis去重器</span><br><span class="line">DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line"># 调度器持久化，True=保留，False=清空</span><br><span class="line">SCHEDULER_PERSIST = True</span><br><span class="line"># 配置redis连接信息</span><br><span class="line">REDIS_URL = &quot;redis://127.0.0.1:6379/0&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行保存 start_url 的脚本：</strong>由于 scrapy_redis 不再通过 start_urls 属性读取起始url，而是通过 <strong><code>redis_key</code></strong> 属性从 Redis 队列中获取起始 URL 的键名，所以需要先将起始 start_url 保存到 Redis 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">res = redis.Redis(host=&quot;192.168.64.12&quot;, port=6379)</span><br><span class="line">res.lpush(&#x27;dd_book:start_url&#x27;, &#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;)</span><br><span class="line">res.close()</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="4-实现POST请求"><a href="#4-实现POST请求" class="headerlink" title="4. 实现POST请求"></a>4. 实现POST请求</h3><blockquote><p><strong>使用 scrapy_redis 实现 POST 请求携带表单数据：</strong></p><ul><li>进行 post 请求时，通常通过携带的表单数据进行翻页等操作，此时 url 固定，所以 Redis 中存储的应该是表单数据，只需携带不同表单数据便可发起不同 post 请求</li></ul></blockquote><ul><li><p><strong>scrapy_redis项目配置：</strong></p><ol><li><p><strong>将爬虫类继承自 RedisSpider 类：</strong>并指定 <strong><code>redis_key</code></strong> 属性，即从 Redis 队列中获取起始 URL 的键名</p></li><li><p><strong>添加 scrapy_redis 配置（settings文件）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot; scrapy-redis配置 &quot;&quot;&quot;</span><br><span class="line"># 配置scrapy_redis调度器</span><br><span class="line">SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"># 配置scrapy_redis去重器</span><br><span class="line">DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line"># 调度器持久化，True=保留，False=清空</span><br><span class="line">SCHEDULER_PERSIST = True</span><br><span class="line"># 配置redis连接信息</span><br><span class="line">REDIS_URL = &quot;redis://127.0.0.1:6379/0&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>重写 make_request_from_data 方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def make_request_from_data(self, data):</span><br><span class="line">    # 参数data：&#123;&#x27;url&#x27;: url, &#x27;from_data&#x27;: fromdata, &#x27;meta&#x27;: meta&#125;</span><br><span class="line">    # 即存储在redis中的起始form_data表单数据，一般通过手动执行脚本插入</span><br><span class="line">    data = json.loads(data)</span><br><span class="line">    form_data = data.get(&quot;from_data&quot;)</span><br><span class="line"></span><br><span class="line">    # 由于post请求只需通过改变表单数据控制翻页，所以url可以写死</span><br><span class="line">    url = &quot;http://www.cninfo.com.cn/new/disclosure&quot;</span><br><span class="line">    return FormRequest(url=url, formdata=form_data)  # 必须使用return返回请求</span><br></pre></td></tr></table></figure></li><li><p><strong>执行保存 form_data 的脚本：</strong>与get请求不同的是，get请求中直接通过请求不同的 url 地址控制翻页，而 post 请求中通过携带不同的 form_data 表单数据进行控制翻页，所以 post 请求中存储在 Redis 队列中的是 form_data 表单数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">def push_start_url(db, request_obj):</span><br><span class="line">    # 参数request_obj：&#123;&#x27;url&#x27;: url, &#x27;from_data&#x27;: fromdata, &#x27;meta&#x27;: meta&#125;</span><br><span class="line">    db.lpush(&#x27;jc:start_urls&#x27;, json.dumps(request_obj))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    redis_cli = redis.Redis()</span><br><span class="line">    for page in range(1, 21):</span><br><span class="line">        from_data = &#123;</span><br><span class="line">            &quot;column&quot;: &quot;szse_latest&quot;,</span><br><span class="line">            &quot;pageNum&quot;: str(page),</span><br><span class="line">            &quot;pageSize&quot;: &quot;30&quot;,</span><br><span class="line">            &quot;sortName&quot;: &quot;&quot;,</span><br><span class="line">            &quot;sortType&quot;: &quot;&quot;,</span><br><span class="line">            &quot;clusterFlag&quot;: &quot;true&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        push_start_url(redis_cli, &#123;&#x27;from_data&#x27;: from_data&#125;)</span><br><span class="line">    redis_cli.close()</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="十、scrapy项目部署"><a href="#十、scrapy项目部署" class="headerlink" title="十、scrapy项目部署"></a>十、scrapy项目部署</h2><h3 id="1-项目部署-scrapyd"><a href="#1-项目部署-scrapyd" class="headerlink" title="1. 项目部署_scrapyd"></a>1. 项目部署_scrapyd</h3><ul><li><p><strong>【服务器端】安装scrapyd：<code>pip install scrapyd</code></strong></p><ul><li><p><strong>在存储所有爬虫项目的文件夹根路径下创建并配置 scrapyd.conf 文件：<code>vim scrapyd.conf</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[scrapyd]</span><br><span class="line"># 监听的IP地址，默认为127.0.0.1（修改成0.0.0.0才能在别的电脑上访问scrapyd运行之后的服务器）</span><br><span class="line">bind_address = 0.0.0.0</span><br><span class="line"># 监听的端口，默认为6800</span><br><span class="line">http_port = 6800</span><br><span class="line"># 是否打开debug模式，默认为off</span><br><span class="line">debug = off</span><br></pre></td></tr></table></figure></li><li><p><strong>在当前路径下开启 scrapy 服务：<code>scrapyd</code>（服务器地址更改为 <a class="link"   href="http://0.0.0.0:6800/" >http://0.0.0.0:6800/<i class="fas fa-external-link-alt"></i></a> 即可）</strong></p></li></ul></li><li><p><strong>【客户端】安装scrapyd-client：<code>pip install scrapyd-client</code></strong></p><ul><li><p><strong>配置爬虫项目的 scrapy.cfg 文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[settings]</span><br><span class="line">default = douban.settings</span><br><span class="line"></span><br><span class="line">[deploy:ubuntu-1]  # 标记要发布道哪个服务器</span><br><span class="line">url = http://192.168.64.12:6800/</span><br><span class="line">project = douban</span><br><span class="line"></span><br><span class="line">;如果有多台服务器可以编写多个deploy</span><br><span class="line">;[deploy:ubuntu-2]</span><br><span class="line">;url = http://192.168.64.13:6800/</span><br><span class="line">;project = douban</span><br></pre></td></tr></table></figure></li><li><p><strong>检查 scrapy.cfg 配置是否生效：<code>scrapyd-deploy -l</code>（小写L）</strong></p></li></ul></li><li><p><strong>将客户端 scrapy 项目发布到服务器端：<code>scrapyd-deploy &lt;target&gt; -p &lt;project&gt; --version &lt;version&gt;</code></strong></p><ul><li>target：配置文件 scrapy.cfg 里 deploy 后面的 target 名字，例如 <code>ubuntu-1</code></li><li>project：可以随意定义，跟爬虫的工程名字无关，一般与scrapy爬虫项目名相同</li><li>version：自定义版本号，不写的话默认为当前时间戳，<strong>一般不写</strong></li><li><strong>注意：发布时爬虫是未运行状态，且爬虫目录下不要放无关的py文件，否则可能会导致发布失败</strong></li></ul></li><li><p><strong>运行爬虫：<code>curl http://服务器ip:6800/schedule.json -d project=项目名 -d spider=脚本名</code></strong></p></li><li><p><strong>停止爬虫：<code>curl http://服务器ip:6800/cancel.json -d project=项目名 -d job=任务的id值</code></strong></p></li></ul><h3 id="2-项目部署-scrapydweb"><a href="#2-项目部署-scrapydweb" class="headerlink" title="2. 项目部署_scrapydweb"></a>2. 项目部署_scrapydweb</h3><blockquote><p><strong>注意：scrapydweb的兼容问题很大，需要创建 requirements.txt 文件统一控制包的版本，通过 <code>pip install -r requirements.txt</code> 安装所有兼容版本的包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pip&gt;=19.1.1</span><br><span class="line">APScheduler==3.5.3</span><br><span class="line">click==7.0</span><br><span class="line">colorama==0.4.0</span><br><span class="line">Flask==1.0.2</span><br><span class="line">Flask-Compress==1.4.0</span><br><span class="line">Flask-SQLAlchemy==2.4.0</span><br><span class="line">idna==2.7</span><br><span class="line">itsdangerous==1.1.0</span><br><span class="line">Jinja2==2.10</span><br><span class="line">logparser==0.8.2</span><br><span class="line">MarkupSafe==1.1.1</span><br><span class="line">pexpect==4.7.0</span><br><span class="line">ptyprocess==0.6.0</span><br><span class="line">pytz==2018.9</span><br><span class="line">requests&gt;=2.21.0</span><br><span class="line">setuptools&gt;=40.6.3</span><br><span class="line">six==1.12.0</span><br><span class="line">SQLAlchemy==1.3.24</span><br><span class="line">tzlocal==1.5.1</span><br><span class="line">w3lib==1.19.0</span><br><span class="line">Werkzeug==0.14.1</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>【服务器端】安装scrapydweb：<code>pip install scrapydweb</code></strong></p></li><li><p><strong>开启 scrapydweb 服务（必须先开启 scrapyd 服务）：<code>scrapydweb</code></strong></p><ul><li>scrapydweb 服务可以在任意路径下开启</li><li>scrapydweb 服务第一次运行不会成功，只会创建一个文件，第二次运行即可成功</li></ul></li><li><p><strong>基本使用：</strong></p><ol><li>通过 5000 端口访问 scrapydweb 服务</li><li>在 Deploy Project –&gt; Upload file 中上传压缩后的项目</li><li>在 Run Spider 中运行爬虫</li><li>在 Jobs 中可以进行爬虫的暂停和启动</li></ol></li></ul><h3 id="3-项目部署-Gerapy"><a href="#3-项目部署-Gerapy" class="headerlink" title="3. 项目部署_Gerapy"></a>3. 项目部署_Gerapy</h3><blockquote><p><strong>注意：Gerapy 是一个基于Web的客户端，安装在客户端，用于管理和监控分布式爬虫，基于 django 开发</strong></p><p><strong>安装：<code>pip install gerapy==0.9.12</code>（0.9.12是稳定版本）</strong></p></blockquote><ul><li><p><strong>Gerapy 基本使用：</strong></p><ol><li><strong><code>gerapy init</code>：</strong>指定一个单独用于部署 Gerapy 的文件夹，通过此命令创建一个 Gerapy 工作目录</li><li><strong><code>gerapy migrate</code>：</strong>执行数据库迁移操作，将数据库模型的变更应用到数据库中</li><li><strong><code>gerapy createsuperuser</code>：</strong>创建一个具有系统中最高级别的权限的超级用户</li><li><strong><code>gerapy runserver</code>：</strong>在开发环境中启动 Gerapy 的 Web 服务器</li></ol></li><li><p><strong>Gerapy 的 Web 服务器基本使用：</strong></p><ol><li><strong>主机管理：</strong>用于连接 scrapyd 服务，所以需要确保 ubuntu 中的 scrapyd 服务是开启的（名称：ubuntu-1，ip：ubuntu的ip地址，端口：6800，认证：scrapyd也有账号密码则需要认证）</li><li><strong>项目管理：</strong>用于上传 scrapy 项目，上传 –&gt; 部署 –&gt; 打包项目 –&gt; 选取节点 –&gt; 点击部署 –&gt; 主机管理</li><li><strong>任务管理：</strong>用于开启不同爬虫任务（Date：指定时间运行爬虫，Interval：间隔指定时间后 - 重复调用爬虫，Crontab：定时爬虫）</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、了解Scrapy框架&quot;&gt;&lt;a href=&quot;#一、了解Scrapy框架&quot; class=&quot;headerlink&quot; title=&quot;一、了解Scrapy框架&quot;&gt;&lt;/a&gt;一、了解Scrapy框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是 Scrap</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>爬虫_1_基础知识</title>
    <link href="http://example.com/2023/09/01/%E7%88%AC%E8%99%AB_1_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2023/09/01/%E7%88%AC%E8%99%AB_1_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-08-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h2><h3 id="1-B-S和C-S架构"><a href="#1-B-S和C-S架构" class="headerlink" title="1. B&#x2F;S和C&#x2F;S架构"></a>1. B&#x2F;S和C&#x2F;S架构</h3><ul><li><strong>B&#x2F;S架构（Browser&#x2F;Server）：浏览器&#x2F;服务器模式，是一种基于浏览器的客户端和服务器端的计算机架构</strong><ul><li>在B&#x2F;S架构中，浏览器作为客户端，负责处理用户交互和呈现数据，而服务器负责数据存储和处理。浏览器通过网络连接到服务器并请求数据，服务器将数据返回给浏览器，浏览器再将数据呈现给用户。</li></ul></li><li><strong>C&#x2F;S架构（Client&#x2F;Server）：客户端&#x2F;服务器模式，是一种常见的计算机系统架构，用于构建应用程序</strong><ul><li>在C&#x2F;S架构中，客户端和服务器端之间的通信是直接的，而不是通过浏览器中转。客户端通常是一款专门的软件应用程序，它向服务器请求数据，并将处理结果返回给用户</li></ul></li><li><strong>注意：B&#x2F;S架构也是C&#x2F;S架构的一种。</strong>当我们使用网络浏览器访问一个网站时，实际上是向该网站对应的服务器发出了请求，服务器响应后把网站的内容发送给浏览器，浏览器再将内容呈现给我们</li></ul><h3 id="2-OSI模型"><a href="#2-OSI模型" class="headerlink" title="2. OSI模型"></a>2. OSI模型</h3><ul><li>简介：<strong>OSI七层模型是计算机网络中的一种通信体系结构，它将计算机网络通信的过程划分为七个抽象层次</strong>。每一层都负责特定的任务，并与其它层进行交互，从而实现完整的数据通信<ol><li><strong>应用层</strong>：提供特定于应用程序的协议和服务，如HTTP、SMTP和FTP等</li><li><strong>表示层</strong>：将应用层的数据格式转换为网络标准格式，并提供加密和解密等数据转换服务</li><li><strong>会话层</strong>：建立、管理和终止会话，为应用程序提供端到端的连接</li><li><strong>传输层</strong>：在端到端的通信中负责数据的可靠传输，提供差错恢复和流量控制</li><li><strong>网络层</strong>：对数据包进行路由选择和转发，实现端到端的传输</li><li><strong>数据链路层</strong>：将比特流组装成数据帧，并提供错误检测和校验</li><li><strong>物理层</strong>：传输比特流，提供介质、机械和电气特性</li></ol></li><li><strong>TCP&#x2F;IP协议栈（Internet协议栈）：将会话层和表示层合并到了应用层，这是因为在实际应用中，会话层和表示层的功能已经被一些应用层协议所替代</strong><ol><li><strong>应用层</strong>：HTTP、FTP、SMTP、POP3、IMAP</li><li><strong>传输层</strong>：TCP、UDP</li><li><strong>网络层</strong>：IP、ICMP、IGMP</li><li><strong>数据链路层</strong>：ARP、RARP</li><li><strong>物理层</strong>：IEEE 802.3、EIA&#x2F;TIA-232、EIA&#x2F;TIA-449、V.35</li></ol></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1676623298-334a74bcfb5e64b.jpg"                         style="width:80%;margin:0 auto;"                 ><h3 id="3-TCP-IP协议"><a href="#3-TCP-IP协议" class="headerlink" title="3. TCP&#x2F;IP协议"></a>3. TCP&#x2F;IP协议</h3><ul><li>简介：<strong>TCP&#x2F;IP是一组通信协议，其由多种协议组成，共同构成因特网的核心协议栈。通过TCP&#x2F;IP协议，不同类型的计算机和设备可以在全球范围内相互通信，并确保可靠和正确的数据传输</strong></li><li><strong>基本组成部分：</strong><ol><li><strong>IP协议</strong>：是TCP&#x2F;IP协议的基础，它用于在互联网上传输数据包。IP协议将每个数据包（也称为数据报）从源计算机传送到目标计算机，它使用IP地址来标识源和目标计算机</li><li><strong>TCP协议</strong>：是一个面向连接的协议，用于在计算机之间可靠地传输数据。TCP协议建立一个连接，使发送方和接收方能够以正确的顺序接收数据。如果某个数据包在传输过程中丢失，TCP会重新发送该数据包，以确保数据的完整性。此外，TCP还可以实现流量控制和拥塞控制，以避免网络拥塞和数据丢失</li><li><strong>UDP协议</strong>：是另一种在计算机之间传输数据的协议。与TCP协议不同，UDP协议不会建立连接或执行流量控制，因此传输速度更快。UDP协议适用于需要快速传输数据，但不要求数据完整性和可靠性的应用程序</li><li><strong>HTTP协议</strong>：是在互联网上传输超文本的协议。HTTP协议使用TCP协议作为其底层传输协议，它定义了客户端和服务器之间的通信格式。在使用HTTP协议时，客户端会向服务器发送请求，服务器会响应这些请求并返回请求的数据。HTTP协议支持多种不同的请求类型，如GET、POST、PUT和DELETE</li><li><strong>DNS协议</strong>：用于将域名转换为IP地址。DNS服务器负责维护域名和IP地址之间的映射，当您访问一个域名时，计算机会向DNS服务器发出请求，以获取与该域名对应的IP地址。然后计算机可以使用IP地址来连接该域名对应的服务器并获取网页或其他数据</li></ol></li></ul><h3 id="4-Socket编程"><a href="#4-Socket编程" class="headerlink" title="4. Socket编程"></a>4. Socket编程</h3><ul><li><p>简介：<strong>Socket是一种在计算机网络中用于通信的抽象概念，它充当了应用层与TCP&#x2F;IP协议族之间的中间层，使应用程序可以使用这些协议进行通信，而无需了解底层的网络细节，这种实现网络通信的方式被称为套接字（Socket）技术</strong></p></li><li><p><strong>套接字技术</strong>：套接字是一种在网络上运行的软件模块，可以使不同计算机之间的程序相互通信。它是一种接口，用于在应用层和传输层之间传递数据，通常被称为<strong>应用程序编程接口（API）</strong></p></li><li><p><strong>套接字应用</strong>：通过套接字技术，程序可以使用标准的TCP&#x2F;IP协议栈与其他程序进行通信。套接字提供了一个通信端点，可以通过一个网络协议和一个网络地址唯一的标识，通信的两端都需要创建一个套接字，并使用同一个网络协议和网络地址</p></li><li><p><strong>Socket编程（指定）</strong>：</p><ol><li><strong>IP地址</strong>：用于唯一标识一个计算机的地址</li><li><strong>端口号</strong>：用于标识一个应用程序的地址，一个端口号唯一对应一个应用程序</li></ol></li><li><p><strong>Socket编程（流程）</strong>：</p><ol><li>服务器端创建一个Socket，并绑定到一个IP地址和端口上</li><li>服务器端开始监听连接请求</li><li>客户端创建一个Socket，并连接到服务器端的IP地址和端口上</li><li>服务器端接受客户端的连接请求，并返回一个新的Socket对象，用于与客户端通信</li><li>服务器端和客户端可以通过新的Socket对象进行双向通信</li></ol></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1698062898-31d16a48b844a8e.jpeg"                         style="width:80%;margin:0 auto;"                 ><ul><li><p><strong>代码实现（服务端）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># socket服务端</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># 端口0-65535，其中0-1024给操作系统用</span><br><span class="line">server.bind((&#x27;127.0.0.1&#x27;, 8000))  # 绑定到127.0.0.1:8000端口上</span><br><span class="line">server.listen()  # 监听，最大挂起的链接数</span><br><span class="line"></span><br><span class="line">def handl_sock(conn, addr):</span><br><span class="line">    # 循环以完成和客户端的交互</span><br><span class="line">    while True:</span><br><span class="line">        tmp_data = conn.recv(1024)  # 单位：bytes，表示单次最大接受1024个bytes</span><br><span class="line">        print(&#x27;client_data：&#123;&#125;&#x27;.format(tmp_data.decode(&#x27;utf-8&#x27;)))</span><br><span class="line">        # 响应模版，即服务端发送给客户端的响应头</span><br><span class="line">        response_template = &#x27;&#x27;&#x27;HTTP/1.0 200 OK  </span><br><span class="line">Content-type: text/html  </span><br><span class="line">Set-Cookie: name=bobby</span><br><span class="line">Set-Cookie: course_id=78</span><br><span class="line">Set-Cookie: sessionid=abc123; Expires=Wed, 09 Jun 2023 10:18:14 GMT</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">        # 服务端即将发送给客服端的消息，输入什么在客户端就显示什么</span><br><span class="line">        input_data = input()</span><br><span class="line">        # 服务端将数据包装在响应模板中，发送给客户端</span><br><span class="line">        conn.send(response_template.format(input_data).encode(&#x27;utf-8&#x27;))</span><br><span class="line">        # 如果是使用浏览器访问端口，则需要关闭链接，并退出循环；如果是自己的socket客户端，为了实现交互，则不需要关闭链接</span><br><span class="line">        conn.close()</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># 获取客户端连接并启动线程去处理</span><br><span class="line">while True:</span><br><span class="line">    # 阻塞等待连接，建立一个独立的通道，得到通道参数和地址</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">    # 启动一个线程去处理新的用户连接</span><br><span class="line">    client_thread = threading.Thread(target=handl_sock, args=(conn, client_addr))</span><br><span class="line">    client_thread.start()</span><br><span class="line"></span><br><span class="line"># conn.close()</span><br><span class="line"># server.close()</span><br></pre></td></tr></table></figure></li><li><p><strong>代码实现（客户端）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># socket客户端</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((&#x27;127.0.0.1&#x27;, 8099))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    input_data = input()</span><br><span class="line">    client.send(input_data.encode(&#x27;utf-8&#x27;))  # 不能直接发字符串，因为物理层是二进制流</span><br><span class="line">    server_data = client.recv(1024)</span><br><span class="line">    print(&#x27;server_data：&#123;&#125;&#x27;.format(server_data.decode(&#x27;utf-8&#x27;)))</span><br><span class="line"></span><br><span class="line"># client.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-HTTP协议"><a href="#5-HTTP协议" class="headerlink" title="5. HTTP协议"></a>5. HTTP协议</h3><ul><li>简介：<strong>HTTP（超文本传输协议）是一种应用层协议，主要用于Web浏览器和Web服务器之间的通信，是Web通信的基础</strong>。HTTP协议基于<strong>请求-响应模型</strong>，客户端发送HTTP请求，服务器端返回HTTP响应</li><li><strong>http和https的区别：</strong><ul><li><strong>端口：</strong>http的默认端口号为80，https的默认端口号为443</li><li><strong>安全：</strong>http不提供数据加密，因此数据以明文形式传输；而https使用TLS&#x2F;SSL加密协议来保护数据传输的安全性，使得数据在传输过程中难以被截取或窃听</li></ul></li><li><strong>HTTP协议特点：</strong><ol><li><strong>无状态协议</strong>：即每次请求和响应之间没有关联，服务器不会记录客户端的状态，每个请求都是独立的，它不知道请求和响应之间是否存在先后关系，也不知道它们是否来自同一个客户端</li><li><strong>请求方法</strong>：即常用的有GET、POST、PUT、DELETE等，它们分别用于获取资源、提交数据、更新资源和删除资源等操作</li><li><strong>缓存机制</strong>：即客户端可以缓存服务器返回的资源，避免重复请求，减轻服务器的负担</li><li><strong>传输方式</strong>：HTTP协议支持多种传输方式，包括TCP和UDP等，但TCP是最常用的传输方式</li></ol></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1676642514-e89120c0c6e0ba6.jpg"                         style="width:80%;margin:0 auto;"                 ><ul><li><p><strong>Keep-Alive字段：HTTP Keep-Alive是一种HTTP协议的扩展，它允许一个单独的TCP连接在处理多个HTTP请求和响应时保持打开状态</strong>。在HTTP&#x2F;1.0中，每个HTTP请求和响应都需要打开一个新的TCP连接，这导致了额外的网络开销，降低了性能。而在HTTP&#x2F;1.1中，Keep-Alive成为了默认行为</p></li><li><p><strong>Keep-Alive作用：</strong>通过Keep-Alive字段，浏览器和Web服务器之间的TCP连接可以重用，以减少创建新连接的开销，提高了性能</p></li><li><p><strong>Keep-Alive原理：</strong></p><ul><li>当客户端请求到达服务器时，服务器告诉客户端是否支持Keep-Alive，如果支持，则在响应中添加一个Keep-Alive头，并在其后面指定超时时间。客户端可以利用此头保持连接打开，并在请求中添加一个Connection头，以告知服务器它的请求结束了</li><li>如果服务器没有在响应头中添加Keep-Alive头，客户端会自动关闭连接。默认情况下，服务器会在发送完响应后立即关闭连接。如果服务器发送Content-Length头，则可以不添加Keep-Alive头</li></ul></li><li><p><strong>模拟简单的HTTP服务器：创建一个Socket服务器，用于接收连接并返回HTTP响应，使得在客户端（浏览器）向Socket服务器发送HTTP请求后，Socket服务器可以返回正确的HTTP响应</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &#x27;127.0.0.1&#x27;  # 监听的 IP 地址</span><br><span class="line">PORT = 8000  # 监听的端口号</span><br><span class="line"></span><br><span class="line"># 处理客户端请求并返回响应</span><br><span class="line">def handle_request(client):</span><br><span class="line">    # 1. 接收客户端请求数据</span><br><span class="line">    request_headers = client.recv(1024).decode()</span><br><span class="line">    print(request_headers)  # 打印请求头</span><br><span class="line">    # 2. 构造 HTTP 响应报文</span><br><span class="line">    response = &#x27;HTTP/1.1 200 OK\nContent-Type: text/html\n\nHello, World!&#x27;</span><br><span class="line">    # 3. 发送 HTTP 响应报文到客户端</span><br><span class="line">    client.sendall(response.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    # 4. 最后关闭客户端连接</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"># 开启http服务器</span><br><span class="line">def start_server():</span><br><span class="line">    # 1. 创建一个套接字对象，使用 IPv4 和 TCP 协议</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    #  2. 允许地址重用</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    # 3. 将套接字对象绑定到指定的地址和端口</span><br><span class="line">    sock.bind((HOST, PORT))</span><br><span class="line">    # 4. 监听来自客户端的连接请求</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    print(&#x27;Listening at&#x27;, sock.getsockname())</span><br><span class="line"></span><br><span class="line">    # 5. 使用死循环模拟http的Keep-Alive功能，使服务器能够保持长连接并接受多个客户端请求</span><br><span class="line">    while True:</span><br><span class="line">        # 接受到客户端连接请求，返回一个客户端套接字对象和对应的客户端地址信息</span><br><span class="line">        client, address = sock.accept()</span><br><span class="line">        print(&#x27;Accepted connection from&#x27;, address)</span><br><span class="line"></span><br><span class="line">        # 处理客户端请求，通过client套接字对象与客户端进行数据交互</span><br><span class="line">        handle_request(client)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    start_server()</span><br></pre></td></tr></table></figure><h2 id="二、了解爬虫"><a href="#二、了解爬虫" class="headerlink" title="二、了解爬虫"></a>二、了解爬虫</h2><blockquote><p><strong>网络爬虫按照系统结构和实现技术，大致可以分为：</strong></p><ul><li><strong>通用网络爬虫（General Purpose Web Crawler）</strong></li><li><strong>聚焦网络爬虫（Focused Web Crawler）</strong></li><li><strong>增量式网络爬虫（Incremental Web Crawler）</strong></li><li><strong>深层网络爬虫（Deep Web Crawler）</strong></li></ul></blockquote><h3 id="1-请求头与响应头"><a href="#1-请求头与响应头" class="headerlink" title="1. 请求头与响应头"></a>1. 请求头与响应头</h3><ul><li><p><strong>请求头（Request Headers）：</strong>包含客户端向服务器发送的信息，以指示它们的需求和特定的请求参数</p><ul><li><p><strong>Host：</strong> 指示请求的主机名（域名），用于服务器根据不同主机名分配请求</p></li><li><p><strong>Accept：</strong> 指示客户端所能接受的响应媒体类型，例如文本&#x2F;html、图像、json等</p></li><li><p><strong>Accept-Encoding：</strong>指示客户端可以接受的内容编码方式，通常用于通知服务器客户端支持的压缩算法</p></li><li><p><strong>Authorization：</strong> 包含身份验证凭证，用于验证客户端的身份</p></li><li><p><strong>Cache-Control：</strong> 控制缓存行为，以便客户端和服务器可以更好地管理缓存</p></li><li><p><strong>Cookie：</strong> 包含客户端存储的会话信息，用于维持状态和跟踪用户</p></li><li><p><strong>Content-Type：</strong> 仅出现在POST请求中，指定请求正文的媒体类型</p></li><li><p><strong>Referer：</strong> 表示当前请求是通过哪个URL引发的，通常用于跟踪来源</p></li><li><p><strong>Upgrade-Insecure-Requests：</strong>用于指示服务器在可能的情况下将HTTP请求升级为HTTPS请求</p></li><li><p><strong>User-Agent：</strong> 表示客户端的类型和版本，服务器可以使用它来适应不同的客户端</p></li><li><p><code>X-Requested-With: XMLHttpRequest</code>：自定义参数，表示请求是通过JS使用XMLHttpRequest对象发起的（Ajax异步请求）</p></li></ul></li><li><p><strong>响应头（Response Headers）：</strong>包含服务器对客户端请求的响应信息，以告知客户端有关响应的元数据</p><ul><li><strong>Content-Type：</strong> 指示响应的媒体类型，如文本&#x2F;HTML、图像、JSON等</li><li><strong>Content-Length：</strong> 指示响应正文的长度，以便客户端可以正确接收和处理数据</li><li><strong>Location：</strong> 通常在重定向响应中使用，指示客户端跳转到另一个URL</li><li><strong>Set-Cookie：</strong> 用于在响应中设置新的Cookie，以便在客户端上维持状态和会话</li><li><strong>Cache-Control：</strong> 控制缓存行为，以便客户端和中间代理可以更好地管理缓存</li><li><strong>Server：</strong> 包含服务器的信息，用于告诉客户端服务器的类型和版本</li><li><strong>HTTP状态码：</strong> 表示响应的状态，如200成功、403无请求权限、404找不到页面等</li><li><strong>Date：</strong> 表示响应生成的日期和时间</li></ul></li></ul><h3 id="2-Robots协议"><a href="#2-Robots协议" class="headerlink" title="2. Robots协议"></a>2. Robots协议</h3><blockquote><p><strong>robots协议</strong>：也叫君子协议，是一种存放于网站根目录下的ASCII编码的文本文件，通常<strong>用来告诉网络搜索引擎的漫游器（网络蜘蛛）此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的</strong></p><ul><li>因为一些系统中的URL是大小写敏感的，所以<strong>robots.txt的文件名应统一为小写</strong></li><li>robots.txt应放置于网站的根目录下</li><li>如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）</li></ul><blockquote><p><strong>明确：robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私</strong></p></blockquote></blockquote><ul><li><strong>常用的robots协议语法：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># 1. 禁止所有搜索引擎抓取整个网站</span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /</span><br><span class="line"></span><br><span class="line"># 2. 禁止所有搜索引擎抓取某一目录及其内容（禁止抓取的目录字符串可以出现在路径中的任何位置，因此Disallow: </span><br><span class="line">/junk/与https://example.com/junk/和https://example.com/for-sale/other/junk/均匹配）</span><br><span class="line"></span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /calendar/</span><br><span class="line">Disallow: /junk/</span><br><span class="line">Disallow: /books/fiction/contemporary/</span><br><span class="line"></span><br><span class="line"># 3. 只有 googlebot-news 可以抓取整个网站</span><br><span class="line">User-agent: Googlebot-news</span><br><span class="line">Allow: /</span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /</span><br><span class="line"></span><br><span class="line"># 4. Unnecessarybot 不能抓取相应网站，所有其他漫游器都可以</span><br><span class="line">User-agent: Unnecessarybot</span><br><span class="line">Disallow: /</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line"></span><br><span class="line"># 5. 禁止所有搜索引擎抓取 useless_file.html 网页</span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /useless_file.html</span><br><span class="line"></span><br><span class="line"># 6. 禁止访问 dogs.jpg 图片</span><br><span class="line">User-agent: Googlebot-Image</span><br><span class="line">Disallow: /images/dogs.jpg</span><br><span class="line"></span><br><span class="line"># 7. 禁止 Google 图片访问您网站上的所有图片(如果无法抓取图片和视频，则 Google 无法将其编入索引)</span><br><span class="line">User-agent: Googlebot-Image</span><br><span class="line">Disallow: /</span><br><span class="line"></span><br><span class="line"># 8. 禁止谷歌抓取所有 .gif 文件</span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow: `/*.gif$`</span><br><span class="line"></span><br><span class="line"># 9. 禁止抓取整个网站，但允许 Mediapartners-Google 访问内容</span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /</span><br><span class="line">User-agent: Mediapartners-Google</span><br><span class="line">Allow: /</span><br><span class="line"></span><br><span class="line"># 10. 禁止谷歌抓取所有 .xls 文件</span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow: `/*.xls$`</span><br></pre></td></tr></table></figure><h3 id="3-unicode和utf8编码"><a href="#3-unicode和utf8编码" class="headerlink" title="3. unicode和utf8编码"></a>3. unicode和utf8编码</h3><ul><li><p><strong>Unicode：Unicode是一个字符集，它定义了每个字符的唯一编号（即码点），并为这些字符提供了一个标准名称</strong></p></li><li><p><strong>UTF-8：UTF-8是一种可变长度字符编码方案，它将Unicode中的每个字符编码成1到4个字节序列，是一种广泛使用的字符编码格式</strong></p></li><li><p><strong>主要区别：</strong></p><ul><li><p><strong>Unicode是一个字符集，UTF-8是一种字符编码方式，它们共同构成了现代计算机系统中广泛使用的文本编码标准</strong></p></li><li><p>UTF-8是一种变长编码，ASCII字符在UTF-8中只占用一个字节，对于英文字母和数字等常见字符，也只占用一个字节，而对于汉字、日文、韩文等字符，则需要2到3个字节</p></li><li><p><strong>UTF-8最大的优点是它向后兼容ASCII码，也就是说，如果一段文本中只包含ASCII字符，那么使用UTF-8编码后，该文本仍然可以使用ASCII码进行解码，无需转换</strong></p></li></ul></li><li><p><strong>encode()方法：用于将字符串从Unicode编码转换为其他编码格式（例如UTF-8、ISO-8859-1等），返回一个字节对象，即bytes</strong></p></li><li><p><strong>decode()方法：用于将字节数据从其他编码格式（例如UTF-8、ISO-8859-1等）转换为Unicode编码的字符串，返回一个字符串</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Python 3中，默认的字符串类型是Unicode字符串</span><br><span class="line"># 从外部源接收的字节数据通常需要使用decode()来转换为字符串以进行处理</span><br><span class="line"></span><br><span class="line">str_code = &#x27;xfblog&#x27;</span><br><span class="line"></span><br><span class="line"># 使用encode()方法编码</span><br><span class="line">byte_code = str_code.encode(&#x27;utf-8&#x27;)</span><br><span class="line">print(byte_code)  # b&#x27;xfblog&#x27;</span><br><span class="line">print(type(byte_code))  # `&lt;class &#x27;bytes&#x27;&gt;`</span><br><span class="line"></span><br><span class="line"># 使用decode()方法解码</span><br><span class="line">str_c = byte_code.decode(&#x27;utf-8&#x27;)</span><br><span class="line">print(str_c)  # xfblog</span><br><span class="line">print(type(str_c))  # `&lt;class &#x27;str&#x27;&gt;`</span><br><span class="line">&quot;&quot;&quot;编码方式必须和解码方式必须一样，否则就会出现乱码问题&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="4-网站分析"><a href="#4-网站分析" class="headerlink" title="4. 网站分析"></a>4. 网站分析</h3><blockquote><p><strong>注意：</strong></p><ul><li><strong>通过浏览器直接访问的方式是无法发送get以外的请求的</strong></li><li><strong>进行post方法请求时，参数data和headers尽量都使用关键字实参</strong></li><li><strong>进行port方法请求时，如果data中携带的某一字段值为空，则需使用空字符串””代替，而不是None！</strong></li><li><strong>请求移动端获取的数据接口时，请求头的user-agent也一定要用移动端的</strong></li></ul></blockquote><ul><li><p><strong>查询字符串参数：</strong></p><ul><li><p><strong>get请求[url链接中]：显现的，需要通过request.get()方法中的params参数传递，可以不完整</strong></p></li><li><p><strong>post请求[表单数据]：隐藏的，需要通过request.post()方法中的data参数传递，必须完整</strong></p></li><li><p><strong>post请求[请求载荷]：隐藏的，需要通过request.post()方法中的json参数传递，必须完整</strong></p></li></ul></li><li><p><strong>判断网站是否是动态网站：</strong></p><ul><li>观察当前网站页面中的翻页按钮，如果翻页后浏览器的url地址没有发生变化，则此网站数据大概率是动态数据，否则，大概率是静态数据</li><li><strong>如果一个页面有下一页，一定要分析一下，有些网站只在第一页使用静态数据，而后面使用动态数据，所以不要认为网页源代码中能搜索到数据，就一定是静态数据（要以api接口为主）</strong></li></ul></li><li><p><strong>数据抓包流程：</strong></p><ul><li>打开浏览器开发者工具，选择网路选项卡，使用放大镜搜索相关数据关键字，会在响应和预览中得到对应的json数据，分析json数据是否存在需要的数据（响应与预览中的数据一致）</li><li>第一次进入网站后先清除日志，再刷新网站以获取当前全部api。当数据过多时，一般不在响应中定位数据，而是直接在预览中配合ctrl+F搜索关键字直接定位到数据</li></ul></li></ul><h3 id="5-miniconda的使用"><a href="#5-miniconda的使用" class="headerlink" title="5. miniconda的使用"></a>5. miniconda的使用</h3><ul><li><p><strong>创建</strong>：conda create -n 虚拟环境名称 python&#x3D;版本号</p></li><li><p><strong>列表</strong>：conda env list</p></li><li><p><strong>激活：</strong>conda activate myenv</p></li><li><p><strong>退出</strong>：conda deactivate</p></li><li><p><strong>删除</strong>：conda remove -n “myenv” –all</p></li><li><p><strong>查看python版本：</strong><code>python -V</code></p></li></ul><h2 id="三、Requests模块"><a href="#三、Requests模块" class="headerlink" title="三、Requests模块"></a>三、Requests模块</h2><blockquote><p><strong><a class="link"   href="https://requests.readthedocs.io/projects/cn/zh_CN/latest/"  target="_blank">Requests官方文档<i class="fas fa-external-link-alt"></i></a><strong>：Requests 唯一的一个</strong>非转基因</strong>的 Python HTTP 库，人类可以安全享用</p><p><strong>警告</strong>：非专业使用其他 HTTP 库会导致危险的副作用，包括：安全缺陷症、冗余代码症、重新发明轮子症、啃文档症、抑郁、头疼、甚至死亡</p><p><strong>看吧，这就是 Requests 的威力：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">服务器：使用&quot;HTTP协议&quot;中通过socket模拟的简单HTTP服务器</span><br><span class="line">客户端：使用requests模拟浏览器向HTTP服务器发起请求</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://127.0.0.1:8000&quot;</span><br><span class="line"># 在服务器接受到的客户端请求头中，会出现很多并没有进行指定的其余字段，</span><br><span class="line"># 这是因为requests认为这些字段在此次http请求中是必不可少的，所以默认添加的</span><br><span class="line">header = &#123;</span><br><span class="line">    &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">    &quot;username&quot;: &#x27;wcf&#x27;,</span><br><span class="line">    &#x27;password&#x27;: &#x27;123456&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 1. 请求方法为get，使用params关键字指定参数</span><br><span class="line"># r = requests.get(url, headers=header, params=params)</span><br><span class="line"></span><br><span class="line"># 2. 请求方法为post，使用data关键字指定参数，发送表单数据或其他编码的数据</span><br><span class="line"># r = requests.post(url, headers=header, data=params)</span><br><span class="line"></span><br><span class="line"># 3. 请求方法为post，使用json关键字指定参数，发送JSON格式的数据</span><br><span class="line">r = requests.post(url, headers=header, json=params)</span><br><span class="line">&quot;&quot;&quot;携带不同类型的参数进行请求，请求头中Content-Type字段值和http内容实体都是不一样的&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-响应属性"><a href="#1-响应属性" class="headerlink" title="1. 响应属性"></a>1. 响应属性</h3><ul><li><p>常用响应属性：</p><ul><li><strong>response.status_code：</strong>响应的http状态码</li><li><strong>response.text：</strong>响应的文本内容（str类型）</li><li><strong>response.content：</strong>响应的二进制内容（bytes类型）</li><li><strong>response.json()：</strong>用于将json响应解析为python对象</li><li><strong>response.history：</strong>包含请求重定向历史，是一个包含Response对象的列表</li></ul></li><li><p>响应头：</p><ul><li><strong>response.headers：</strong>包含响应头信息的字典</li><li><strong>response.cookies：</strong>一个RequestsCookieJar对象，包含响应中的cookies，即Set-Cookie值</li></ul></li><li><p>请求头：</p><ul><li><strong>response.request：</strong>包含生成此响应的请求的相关信息，是一个PreparedRequest对象</li><li><strong>response.request.headers</strong>：包含响应对应请求头信息的字典</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;https://www.baidu.com&quot;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"># 通常：通过response.encoding修改成网页源码的编码格式</span><br><span class="line">response.encoding = &quot;utf-8&quot;</span><br><span class="line"># 技巧：将字节数据转为字符串数据，python中decode默认解码方式为utf-8</span><br><span class="line">print(response.content.decode())  # 百度网页源代码</span><br><span class="line"></span><br><span class="line"># 获取响应中的cookies，即set-cookie信息</span><br><span class="line">print(response.cookies)  # `&lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;`</span><br><span class="line">print(response.cookies.get_dict())  # &#123;&#x27;BDORZ&#x27;: &#x27;27315&#x27;&#125;</span><br><span class="line">print(requests.utils.dict_from_cookiejar(response.cookies))  # &#123;&#x27;BDORZ&#x27;: &#x27;27315&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># 获取响应对应的请求头中的cookies</span><br><span class="line">print(response.request.headers.get(&#x27;cookies&#x27;))  # None</span><br></pre></td></tr></table></figure><h3 id="2-字节流下载"><a href="#2-字节流下载" class="headerlink" title="2. 字节流下载"></a>2. 字节流下载</h3><ul><li>简介：将stream参数设置为True时，Requests库返回的响应对象具有类似生成器的特性，即<strong>可迭代的流式响应</strong>。在这种流式响应对象下，<strong>可以使用iter_content()方法逐块处理响应内容</strong>，而不是一次性加载整个响应内容到内存中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">video_url = &quot;&quot;</span><br><span class="line"></span><br><span class="line"># requests是同步的，设置了stream参数后，requests请求类似于生成器，是懒惰的</span><br><span class="line"># 只有调用iter_content方法时，才会真正发起请求，获取响应内容</span><br><span class="line">response = requests.get(video_url, stream=True)</span><br><span class="line"></span><br><span class="line"># 获取视频数据长度，通过响应头中的Content-Length字段</span><br><span class="line">data_length = int(response.headers.get(&quot;Content-Length&quot;))</span><br><span class="line"></span><br><span class="line"># 检查响应状态</span><br><span class="line">if response.status_code == 200:</span><br><span class="line">    with open(&quot;./video.mp4&quot;, &quot;wb&quot;) as f:</span><br><span class="line">        write_length = 0</span><br><span class="line">        # 逐块处理响应内容，使用iter_content方法，每次处理1024字节的数据</span><br><span class="line">        for chunk in response.iter_content(chunk_size=1024):</span><br><span class="line">            if chunk:</span><br><span class="line">                write_length += f.write(chunk)  # write方法返回写入的字节数</span><br><span class="line">                print(f&quot;下载进度：&#123;(write_length / data_length) * 100: .2f&#125;%&quot;)</span><br></pre></td></tr></table></figure><h3 id="3-请求重定向"><a href="#3-请求重定向" class="headerlink" title="3. 请求重定向"></a>3. 请求重定向</h3><blockquote><p><strong>自动重定向：</strong>默认情况下，requests 会自动处理 HTTP 重定向。即当发起一个请求时，如果服务器返回了一个重定向响应（HTTP 状态码 3xx），requests 会自动跟踪并执行这个重定向，直到达到重定向的最终目标或达到最大允许重定向次数</p></blockquote><ul><li><p><strong>allow_redirects参数：</strong>可以控制是否允许自动重定向</p></li><li><p><strong>response.history属性：</strong>包含请求重定向历史，是一个包含Response对象的列表</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;https://www.360buy.com&quot;  # 自动重定向http://www.jd.com/</span><br><span class="line"></span><br><span class="line"># 设置allow_redirects为False，禁止自动重定向</span><br><span class="line">response = requests.get(url, allow_redirects=False)</span><br><span class="line">print(response.url)  # https://www.360buy.com</span><br><span class="line"></span><br><span class="line"># 获取这次请求中经历的所有重定向请求记录</span><br><span class="line">for resp in response.history:</span><br><span class="line">    print(resp.url)</span><br></pre></td></tr></table></figure><h3 id="4-SSL证书错误"><a href="#4-SSL证书错误" class="headerlink" title="4. SSL证书错误"></a>4. SSL证书错误</h3><ul><li><p><strong>默认验证证书：默认情况下，requests会验证 SSL 证书，确保通信是安全的</strong></p></li><li><p><strong>verify参数：</strong>是requests库中用于控制 SSL 证书验证的重要参数</p></li><li><p><strong>禁用证书验证：</strong>将 verify 参数设置为 False 来禁用证书验证，但由于不安全不建议在生产环境中使用</p></li><li><p><strong>指定自定义 CA 证书文件：</strong>可以使用 verify 参数指定自定义的 CA（Certificate Authority）证书文件，以便 requests 使用该 CA 来验证服务器的证书，可以用于内部服务器或特殊证书的情况</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;requests.exceptions.SSLError异常原因：</span><br><span class="line">1. 网站证书过期</span><br><span class="line">2. 网站链接编写错误</span><br><span class="line">3. urllib3版本过高，查看命令pip show urllib3，最好控制在1.26以下</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">url = &quot;https://chinasoftinc.com/owa&quot;</span><br><span class="line"></span><br><span class="line"># 禁用证书验证后，解决异常抛出</span><br><span class="line">response = requests.get(url, verify=False)</span><br></pre></td></tr></table></figure><h3 id="5-retrying模块"><a href="#5-retrying模块" class="headerlink" title="5. retrying模块"></a>5. retrying模块</h3><ul><li><strong>请求超时：timeout 参数用于设置请求的超时时间，即允许请求花费的最长时间</strong></li><li><strong>@retry装饰器：</strong>用于实现在执行某个函数或方法时进行自动重试的功能（默认决策是在失败后等待1秒并重试，最大尝试次数为3次）<ul><li><strong>wait_fixed</strong>：指定每次重试之间的等待时间（单位为毫秒）</li><li><strong>stop_max_attempt_number</strong>：指定最大尝试次数</li><li><strong>retry_on_exception</strong>：只指定某种异常会触发重试</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from retrying import retry</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">num = 1</span><br><span class="line"></span><br><span class="line">@retry(stop_max_attempt_number=3, wait_fixed=3000,</span><br><span class="line">       retry_on_exception=lambda x: isinstance(x, requests.exceptions.RequestException))</span><br><span class="line">def make_request():</span><br><span class="line">    global num</span><br><span class="line">    print(f&#x27;num：&#123;num&#125;&#x27;)</span><br><span class="line">    num += 1</span><br><span class="line">    # 超时会直接抛出异常并重试：requests.exceptions.ConnectTimeout</span><br><span class="line">    response = requests.get(&quot;https://example.com&quot;, timeout=2)</span><br><span class="line">    </span><br><span class="line">    # &quot;断言&quot;，如果assert后面的条件为True则继续运行，否则会抛出异常并重试</span><br><span class="line">    assert response.status_code == 200  # 状态码不是200，也会报错并重试</span><br><span class="line">    </span><br><span class="line">    # 检查响应的状态码是否表示请求成功，如果不是将引发一个异常</span><br><span class="line">    # response.raise_for_status()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        make_request()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;抛出异常:&quot;, e)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">num：1</span><br><span class="line">num：2</span><br><span class="line">num：3</span><br><span class="line">抛出异常: HTTPSConnectionPool(host=&#x27;example.com&#x27;, port=443): Read timed out. (read timeout=2)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="6-Session会话"><a href="#6-Session会话" class="headerlink" title="6. Session会话"></a>6. Session会话</h3><blockquote><p><strong>问题场景</strong>：在第一次请求后响应头中携带了一个set-cookie回来，需要在第二次发起请求的时候在请求头中设置第一次服务器响应中的set-cookie值</p><p><strong>场景解释</strong>：当在爬取某些页面的时候，服务器往往会需要cookie信息，而想要得到cookie就需要先访问某个url进行登录，服务器接收到请求之后验证用户名以及密码，在登录成功后会返回一个带有set-cookie信息的响应，这个set-cookie信息就是在下一次请求时需要发送给服务器的cookie信息</p><p><strong>问题解决：</strong>虽然可以通过response.cookies.get_dict()提取到此次响应的set-cookie信息，但在下一个请求中再携带这个数据的过程较为麻烦，所以requests库中的Session会话就派上用场了</p></blockquote><ul><li><strong>Session重要作用：</strong><ul><li><strong>状态保持</strong>：会话允许在多个HTTP请求之间保持状态。这对于模拟登录、保持用户会话或执行多步骤的操作非常重要</li><li><strong>Cookie 管理</strong>：会话自动处理cookies的存储和发送，这对于维护用户身份认证和跟踪用户会话非常有用</li><li><strong>全局参数共享</strong>：可以在会话对象中设置全局参数，如请求头、代理设置、认证信息等，以便在多个请求之间共享这些参数，从而减少重复代码</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 创建一个session对象</span><br><span class="line">session = requests.session()</span><br><span class="line"></span><br><span class="line"># 设置全剧参数</span><br><span class="line">session.headers.update(&#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"># session.cookies.update(&#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;)</span><br><span class="line"></span><br><span class="line"># 第一次请求</span><br><span class="line">response = session.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">print(&quot;第一次请求头的User-Agent信息：&quot;, response.request.headers[&#x27;User-Agent&#x27;])</span><br><span class="line"># 第一次请求返回的响应头中的set-cookie信息</span><br><span class="line">print(response.cookies.get_dict())</span><br><span class="line"></span><br><span class="line"># 第二次请求</span><br><span class="line">response = session.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">print(&quot;第二次请求头的User-Agent信息：&quot;, response.request.headers[&#x27;User-Agent&#x27;])</span><br><span class="line"># 第二次请求的请求头所携带的cookie</span><br><span class="line">print(response.request.headers[&#x27;cookie&#x27;])</span><br></pre></td></tr></table></figure><h3 id="7-代理ip"><a href="#7-代理ip" class="headerlink" title="7. 代理ip"></a>7. 代理ip</h3><ul><li><strong>什么是代理（Proxy）：</strong>代理是一个位于客户端和目标服务器之间的中介服务器。客户端的请求首先发送到代理服务器，然后由代理服务器将请求转发给目标服务器，最后将响应传回给客户端</li><li><strong>作用：</strong>代理允许隐藏自己的真实IP地址，绕过网站的访问限制，提高爬取数据的可靠性和隐私保护</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 使用代理进行测试</span><br><span class="line">ip = &quot;127.0.0.1&quot;</span><br><span class="line">port = 7890</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    &quot;http&quot;: f&quot;http://&#123;ip&#125;:&#123;port&#125;&quot;,</span><br><span class="line">    &quot;https&quot;: f&quot;https://&#123;ip&#125;:&#123;port&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(&quot;http://httpbin.org/ip&quot;, proxies=proxies, headers=header)</span><br><span class="line">print(response.json()[&#x27;origin&#x27;])  # 代理ip</span><br></pre></td></tr></table></figure><h2 id="四、数据提取"><a href="#四、数据提取" class="headerlink" title="四、数据提取"></a>四、数据提取</h2><h3 id="1-关于JSON数据"><a href="#1-关于JSON数据" class="headerlink" title="1. 关于JSON数据"></a>1. 关于JSON数据</h3><ul><li><strong>JSON（JavaScript Object Notation）：</strong>是一种轻量级的数据交换格式，用于在不同应用程序之间传输和存储数据</li><li><strong>json数据：主要由对象（Object）和数组（Array）两种结构组成。</strong><ul><li>对象由一组键值对构成，使用大括号”{}”包围</li><li>数组由一个有序的值列表构成，使用方括号”[]”包围</li></ul></li><li><strong>Python处理JSON数据的方法：</strong><ul><li><strong>json.dumps()：用于将Python对象转换为JSON格式的字符串</strong></li><li><strong>json.loads()：用于将JSON字符串解析为Python对象</strong></li><li><strong>json()：用于便捷将响应的JSON数据直接转换为Python对象（通常是字典或列表）</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://www.cninfo.com.cn/new/disclosure&quot;</span><br><span class="line">header = &#123;</span><br><span class="line">    &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    &#x27;column&#x27;: &#x27;szse_latest&#x27;,</span><br><span class="line">    &#x27;pageNum&#x27;: 1,</span><br><span class="line">    &#x27;pageSize&#x27;: 30,</span><br><span class="line">    &#x27;sortName&#x27;: &#x27;&#x27;,</span><br><span class="line">    &#x27;sortType&#x27;: &#x27;&#x27;,</span><br><span class="line">    &#x27;clusterFlag&#x27;: &#x27;true&#x27;</span><br><span class="line">&#125;</span><br><span class="line">str_data = requests.post(url, headers=header, data=data).content.decode()</span><br><span class="line">print(type(str_data))  # `&lt;class &#x27;str&#x27;&gt;`</span><br><span class="line"></span><br><span class="line">json_dict = json.loads(str_data)</span><br><span class="line">print(type(json_dict))  # `&lt;class &#x27;dict&#x27;&gt;`</span><br><span class="line"></span><br><span class="line"># indent指定缩进级别，可以格式美化json字符串；ensure_ascii实现让中文写入的时候保持为中文</span><br><span class="line">json_str = json.dumps(json_dict, indent=2, ensure_ascii=False)</span><br><span class="line">print(type(json_str), json_str)  # &lt;class &#x27;str&#x27;&gt; &#123;......&#125;</span><br><span class="line"></span><br><span class="line"># json()方法：便捷将响应的JSON数据直接转换为Python对象</span><br><span class="line">json_data = requests.post(url, headers=header, data=data).json()</span><br><span class="line">print(type(json_data))  # `&lt;class &#x27;dict&#x27;&gt;`</span><br></pre></td></tr></table></figure><h3 id="2-xpath语法"><a href="#2-xpath语法" class="headerlink" title="2. xpath语法"></a>2. xpath语法</h3><blockquote><p>可以直接通过浏览器开发者工具选取对应元素，<strong>对元素对应的标签右键Copy –&gt; Copy XPath</strong>，即可提取对应的xpath路径表达式</p></blockquote><ul><li><strong>XPath（XML Path Language）：</strong>是一种用于在XML文档中定位和选择元素的查询语言。其语法非常强大，可以实现以非常精确的方式遍历和提取XML文档中的数据，<strong>返回值为列表</strong>（<a class="link"   href="https://www.w3school.com.cn/xpath/xpath_syntax.asp"  target="_blank" rel="noopener">W3chool官方文档<i class="fas fa-external-link-alt"></i></a>）</li><li><strong>选取节点：</strong><ul><li>nodename ：选取此节点的所有子节点</li><li>&#x2F; ：从根节点选取；或表示一个层级关系</li><li>&#x2F;&#x2F; ：从匹配选择的当前节点选择文档中的所有节点，而不考虑它们的位置；或表示多个层级关系</li><li>. ：选取当前节点</li><li>.. ：选取当前节点的父节点</li><li>@ ：选取属性</li><li>text() ：选取文本</li></ul></li><li><strong>谓语：</strong><ul><li>&#x2F;bookstore&#x2F;book[1] ：选取属于 bookstore 子元素的第一个 book 元素（**<span style="color:red;">索引定位，索引是从1开始的</span>**）</li><li>&#x2F;bookstore&#x2F;book[last()] ：选取属于 bookstore 子元素的最后一个 book 元素</li><li>&#x2F;bookstore&#x2F;book[last()-1] ：选取属于 bookstore 子元素的倒数第二个 book 元素</li><li>&#x2F;bookstore&#x2F;book[position()&lt;3] ：选取最前面的两个属于 bookstore 元素的子元素的 book 元素</li><li>&#x2F;&#x2F;title[@lang] ：选取所有拥有名为 lang 的属性的 title 元素</li><li>&#x2F;&#x2F;title[@lang&#x3D;’eng’] ：选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性</li><li>&#x2F;bookstore&#x2F;book[price&gt;35.00] ：选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00</li><li>&#x2F;bookstore&#x2F;book[price&gt;35.00]&#x2F;title ：选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00</li></ul></li><li><strong>选取未知节点：</strong><ul><li>* ：匹配任何元素节点</li><li>@* ：匹配任何属性节点</li><li>node() ：匹配任何类型的节点</li></ul></li><li><strong>选取若干路径：</strong>通过在路径表达式中使用“|”运算符，可以选取若干个路径</li><li><strong>contains包含</strong>：<ul><li><strong>tag[contains(text(),”item”)]：</strong>文本包含item的tag标签</li><li><strong>tag[contains(@class,”item-“)]：</strong>class属性值包含item-的tag标签</li></ul></li><li><strong>lxml解析数据：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">text = &#x27;&#x27;&#x27; &lt;div&gt; &lt;ul&gt; </span><br><span class="line">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">        &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt; </span><br><span class="line">        &lt;/ul&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># 创建element对象来使用xpath语法（不能使用etree关键字定义变量！）</span><br><span class="line">tree = etree.HTML(text)  # `&lt;Element html at 0x10030abc0&gt;`</span><br><span class="line">li_list = tree.xpath(&#x27;//li[@class=&quot;item-1&quot;]&#x27;)  # 返回多个element对象的列表</span><br><span class="line">print(li_list)  # [&lt;Element li at 0x10312f5c0&gt;, &lt;Element li at 0x10312f540&gt;, &lt;Element li at 0x10312f640&gt;]</span><br><span class="line"></span><br><span class="line">info = []</span><br><span class="line">for li in li_list:  # 分组，将li和a标签分为一组，不会出现关系混乱的问题</span><br><span class="line">    # 只有element对象才有xpath方法，xpath方法返回的是列表</span><br><span class="line">    item_info = &#123;&#125;</span><br><span class="line">    item_info[&#x27;href&#x27;] = li.xpath(&#x27;./a/@href&#x27;)[0] if len(li.xpath(&#x27;./a/@href&#x27;)) &gt; 0 else None</span><br><span class="line">    item_info[&#x27;text&#x27;] = li.xpath(&#x27;./a/text()&#x27;)[0] if len(li.xpath(&#x27;./a/text()&#x27;)) &gt; 0 else None</span><br><span class="line">    info.append(item_info)</span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure><h3 id="3-jsonpath语法"><a href="#3-jsonpath语法" class="headerlink" title="3. jsonpath语法"></a>3. jsonpath语法</h3><ul><li><strong>JSONPath：</strong>是一种用于从JSON数据结构中提取信息的查询语言和表达式，类似于XPath用于在XML数据中定位和选择节点，常用于解析多层嵌套的json数据，<strong>返回值为列表</strong>（<a class="link"   href="https://goessner.net/articles/JsonPath/"  target="_blank" rel="noopener">官方文档<i class="fas fa-external-link-alt"></i></a>）</li><li><strong>jsonpath语法元素：</strong><ul><li>$ ：根节点</li><li>@ ：现行节点</li><li>. 或 [] ：子节点</li><li>.. ：递归下降，从匹配选择的现行节点选择文档中的所有节点，而不考虑它们的位置</li><li>* ：通配符，所有节点</li><li>[] ：下标运算符</li><li>[, ] ：并运算符，产生节点集的组合（<strong>兼容切片操作，直接选取范围的节点集</strong>）</li><li>() ：支持表达式计算</li><li>?() ：应用过滤器表达式，包括过滤和判断（**与&amp;&amp;、或||、非!**）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import jsonpath</span><br><span class="line"></span><br><span class="line"># 提取数据前，一定要先在开发者工具的预览中分析返回数据的数据结构</span><br><span class="line">json_data = &#123;</span><br><span class="line">    &quot;store&quot;: &#123;</span><br><span class="line">        &quot;book&quot;: [</span><br><span class="line">            &#123;&quot;category&quot;: &quot;reference&quot;, &quot;author&quot;: &quot;jack&quot;, &quot;title&quot;: &quot;First Book&quot;, &quot;price&quot;: 8.95&#125;,</span><br><span class="line">            &#123;&quot;category&quot;: &quot;fiction&quot;, &quot;author&quot;: &quot;alice&quot;, &quot;title&quot;: &quot;Second Book&quot;, &quot;price&quot;: 12.99&#125;,</span><br><span class="line">            &#123;&quot;category&quot;: &quot;fiction&quot;, &quot;author&quot;: &quot;tony&quot;, &quot;title&quot;: &quot;Thrid Book&quot;, &quot;isbn&quot;: &quot;0-519-15&quot;, &quot;price&quot;: 8.99&#125;,</span><br><span class="line">            &#123;&quot;category&quot;: &quot;fiction&quot;, &quot;author&quot;: &quot;lucy&quot;, &quot;title&quot;: &quot;Fourth Book&quot;, &quot;isbn&quot;: &quot;0-1225-15&quot;, &quot;price&quot;: 22.99&#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;bicycle&quot;: &#123;&quot;color&quot;: &quot;red&quot;, &quot;price&quot;: 19.95&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 1. 提取第一本书的title</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$.store.book[0].title&#x27;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"># 2. 提取第1和第3两本书的title</span><br><span class="line"># res = jsonpath.jsonpath(json_data, &#x27;$.store.book[0,2].title&#x27;)</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$.store.book[::2].title&#x27;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"># 3. 提取最后一本书的title</span><br><span class="line"># res = jsonpath.jsonpath(json_data, &#x27;$.store.book[(@.length-1)].title&#x27;)</span><br><span class="line"># 切片指定从倒数第一个元素开始一直到列表的末尾，因此它将提取最后一个元素</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$.store.book[-1:].title&#x27;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"># 4. 提取价格小于10的所有书本的title</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$.store.book[?(@.price&lt;10)].title&#x27;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"># 5. 提取价格小于等于20的所有商品的价格</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$..*[?(@.price&lt;=20)].price&#x27;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"># 6. 提取所有书本的作者信息</span><br><span class="line"># res = jsonpath.jsonpath(json_data, &#x27;$.store.book[::].author&#x27;)</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$.store.book[*].author&#x27;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"># 7. 提取store中所有商品的价格</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$.store..price&#x27;)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"># 8. 提取是否带有isbn键的书本信息，判断是否带有，所以用?()</span><br><span class="line">rest = jsonpath.jsonpath(json_data, &#x27;$..book[?(@.isbn)].title&#x27;)  # 带有</span><br><span class="line">resf = jsonpath.jsonpath(json_data, &#x27;$..book[?(!@.isbn)].title&#x27;)  # 不带有，非 !</span><br><span class="line">print(rest, resf)</span><br><span class="line"></span><br><span class="line"># 9. 提取价格在5-10之间的书本信息，提取价格不在5-10之间的书本信息</span><br><span class="line">res1 = jsonpath.jsonpath(json_data, &#x27;$..book[?(@.price&gt;=5 &amp;&amp; @.price&lt;=10)].price&#x27;)  # 与 &amp;&amp;</span><br><span class="line">res2 = jsonpath.jsonpath(json_data, &#x27;$..book[?(@.price&lt;5 || @.price&gt;10)].price&#x27;)  # 或 ||</span><br><span class="line">print(res1, res2)</span><br><span class="line"></span><br><span class="line"># 10. 获取所有元素</span><br><span class="line">res = jsonpath.jsonpath(json_data, &#x27;$..&#x27;)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h3 id="4-bs4语法"><a href="#4-bs4语法" class="headerlink" title="4. bs4语法"></a>4. bs4语法</h3><ul><li><strong>Beautiful Soup：</strong>通常缩写为bs4，是Python中一个用于解析HTML和XML文档的第三方库。bs4是基于HTML DOM的，会载入整个文档并解析整个DOM树，因此性能要低于lxml模块（<a class="link"   href="https://beautifulsoup.readthedocs.io/"  target="_blank" rel="noopener">官方文档<i class="fas fa-external-link-alt"></i></a>）</li><li><strong>find(self, name&#x3D;None, attrs&#x3D;{}, recursive&#x3D;True, string&#x3D;None, **kwargs)</strong><ul><li>用于查找第一个匹配的标签或元素，返回匹配的标签或元素，没有匹配项则返回None</li></ul></li><li><strong>find_all(self, name&#x3D;None, attrs&#x3D;{}, recursive&#x3D;True, string&#x3D;None, limit&#x3D;None, **kwargs)</strong><ul><li>用于查找所有匹配的标签或元素，返回一个结果列表，没有匹配项则返回一个空列表</li><li><strong>name参数</strong>：用于指定要查找的标签名称或过滤条件</li><li><strong>attrs参数</strong>：根据标签的属性来过滤元素（或者直接使用class_|id|attr &#x3D; ‘’进行属性定位）</li><li><strong>recursive参数</strong>：用于指定是否递归查找子元素，默认为True</li><li><strong>string参数</strong>：用于搜索包含指定文本的元素</li><li><strong>limit参数</strong>：用于指定返回结果的数量上限</li></ul></li><li><strong>select(self, selector, namespaces&#x3D;None, limit&#x3D;None, **kwargs)</strong><ul><li>方法接受一个CSS选择器字符串作为参数，用于选择文档中的标签或元素。返回一个结果列表</li></ul></li><li><strong>提取标签中的文本和属性：</strong><ul><li>**text &#x2F; get_text()**：获取标签中所有的文本内容</li><li>**get(‘attr’)**：获取标签的指定属性值</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_doc = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;讲故事&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 class=&quot;sister&quot;&gt;&lt;b&gt;熊出没&lt;/b&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class=&quot;story&quot;&gt;两只狗熊和一个人：</span><br><span class="line">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 创建一个BeautifulSoup对象，并指定lxml解析器（该对象包含了解析后的文档树）</span><br><span class="line">soup = BeautifulSoup(html_doc, &#x27;lxml&#x27;)</span><br><span class="line"></span><br><span class="line"># 注意：指定name参数则在指定的标签中做属性定位，不指定则在文档所有标签中做属性定位</span><br><span class="line">&quot;&quot;&quot;find()方法、find_all()方法&quot;&quot;&quot;</span><br><span class="line"># res = soup.find(&#x27;a&#x27;, attrs=&#123;&#x27;class&#x27;: &#x27;sister&#x27;&#125;)  # find()指定class属性定位</span><br><span class="line"># res = soup.find_all(class_=&quot;sister&quot;)  # find_all()不指定name参数，所有元素中匹配</span><br><span class="line"># res = soup.find_all(&#x27;a&#x27;, class_=&quot;sister&quot;)  # 根据class属性定位</span><br><span class="line"># res = soup.find_all(&#x27;a&#x27;, id=&quot;link3&quot;)  # 根据id属性定位</span><br><span class="line">res = soup.find_all(&#x27;a&#x27;, string=&#x27;Tillie&#x27;)  # 根据包含文本定位</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;select()方法&quot;&quot;&quot;</span><br><span class="line"># res = soup.select(&#x27;.sister&#x27;)  # 匹配所有标签中class属性为sister的标签</span><br><span class="line">res = soup.select(&#x27;h1[class=sister]&#x27;)  # 匹配h1标签中class属性为sister的标签</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;提取标签中的文本和属性&quot;&quot;&quot;</span><br><span class="line">print(res[0].text)  # 熊出没</span><br><span class="line">print(res[0].get_text())  # 熊出没</span><br><span class="line">print(res[0].get(&#x27;class&#x27;))  # [&#x27;sister&#x27;]</span><br></pre></td></tr></table></figure><h3 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h3><blockquote><p><strong>关于正则表达式的学习内容：<a class="link"   href="https://xfblog.cn/2023/07/01/Python_4_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"  target="_blank" rel="noopener">04_Python_正则表达式<i class="fas fa-external-link-alt"></i></a></strong></p></blockquote><h2 id="五、数据存储"><a href="#五、数据存储" class="headerlink" title="五、数据存储"></a>五、数据存储</h2><h3 id="1-csv文件存储"><a href="#1-csv文件存储" class="headerlink" title="1. csv文件存储"></a>1. csv文件存储</h3><ul><li><p><strong>CSV（Comma-Separated Values）：</strong>csv文件是一种常见的文本文件格式，用于存储表格数据</p></li><li><p><strong>csv数据：数据通常由逗号分隔，每一行表示表格中的一行数据，每个逗号表示一列数据</strong></p></li><li><p><strong>读写列表数据：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">headers = [&#x27;班级&#x27;, &#x27;姓名&#x27;, &#x27;性别&#x27;, &#x27;手机号&#x27;, &#x27;QQ&#x27;]</span><br><span class="line">rows = [</span><br><span class="line">    [&quot;18级Python&quot;, &#x27;小王&#x27;, &#x27;男&#x27;, &#x27;13146060xx1&#x27;, &#x27;123456xx1&#x27;],</span><br><span class="line">    [&quot;18级Python&quot;, &#x27;小李&#x27;, &#x27;男&#x27;, &#x27;13146060xx2&#x27;, &#x27;123456xx2&#x27;],</span><br><span class="line">    [&quot;19级Python&quot;, &#x27;小赵&#x27;, &#x27;女&#x27;, &#x27;13146060xx3&#x27;, &#x27;123456xx3&#x27;],</span><br><span class="line">    [&quot;19级Python&quot;, &#x27;小红&#x27;, &#x27;女&#x27;, &#x27;13146060xx4&#x27;, &#x27;123456xx4&#x27;],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 1. 写入列表数据到csv文件</span><br><span class="line">if not os.path.isfile(&#x27;example.csv&#x27;):</span><br><span class="line">    with open(&#x27;example.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;) as file:</span><br><span class="line">        # 创建csv写入对象（写入器）</span><br><span class="line">        writer = csv.writer(file)</span><br><span class="line">        # 写入数据，一行用writerow，多行用writerows</span><br><span class="line">        writer.writerow(headers)</span><br><span class="line">        writer.writerows(rows)</span><br><span class="line"></span><br><span class="line"># 2. 读取csv文件数据</span><br><span class="line">with open(&#x27;example.csv&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    # 创建csv读取对象（读取器）</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    # 遍历每一行数据</span><br><span class="line">    for row in reader:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure><ul><li><strong>读写字典数据：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 操作字典数据时，表头数据必须对应字典中的key</span><br><span class="line">headers = [&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;City&#x27;]</span><br><span class="line">rows = [</span><br><span class="line">    &#123;&#x27;Name&#x27;: &#x27;Alice&#x27;, &#x27;Age&#x27;: 25, &#x27;City&#x27;: &#x27;New York&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Age&#x27;: 30, &#x27;City&#x27;: &#x27;San Francisco&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;Name&#x27;: &#x27;Charlie&#x27;, &#x27;Age&#x27;: 22, &#x27;City&#x27;: &#x27;Los Angeles&#x27;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 1. 写入字典数据到csv文件</span><br><span class="line">if not os.path.isfile(&#x27;example.csv&#x27;):</span><br><span class="line">    with open(&#x27;example.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;) as file:</span><br><span class="line">        # 创建csv字典写入对象（字典写入器）</span><br><span class="line">        writer = csv.DictWriter(file, headers)</span><br><span class="line">        # **需要先将传递的表头信息写入**</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        # 写入数据，一行用writerow，多行用writerows</span><br><span class="line">        writer.writerows(rows)</span><br><span class="line"></span><br><span class="line"># 2. 读取csv文件字典数据</span><br><span class="line">with open(&#x27;example.csv&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    # 创建csv字典读取对象（字典读取器）</span><br><span class="line">    reader = csv.DictReader(file)</span><br><span class="line">    # 遍历每一行数据</span><br><span class="line">    for row in reader:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure><h3 id="2-json文件存储"><a href="#2-json文件存储" class="headerlink" title="2. json文件存储"></a>2. json文件存储</h3><blockquote><p><strong>常见的json数据格式：外层列表，内层字典（存储时一般以这种格式存储）</strong></p><ul><li><strong>[{“name”: “jack”, “age”: 20}, {“name”: “alice”, “age”: 18}]</strong></li></ul></blockquote><ul><li><strong>json模块常用方法：</strong><ul><li>**json.dumps()**：将 Python 对象转换为 JSON 格式的字符串</li><li>**json.dump()**：将 Python 对象转换为 JSON 格式的字符串，并将其写入文件对象</li><li>**json.loads()**：将 JSON 格式的字符串转换为 Python 对象</li><li>**json.load()**：从文件对象中读取 JSON 数据，并将其转换为 Python 对象</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"># 数据获取</span><br><span class="line">url = &#x27;https://www.4399.com/flash/&#x27;</span><br><span class="line">data = requests.get(url).content.decode(&#x27;gb2312&#x27;)</span><br><span class="line"></span><br><span class="line"># 数据解析</span><br><span class="line">tree = etree.HTML(data)</span><br><span class="line">li_list = tree.xpath(&#x27;//ul[@class=&quot;b-game cf&quot;]/li&#x27;)</span><br><span class="line">game_info = list()</span><br><span class="line">for li in li_list:</span><br><span class="line">    item = dict()</span><br><span class="line">    item[&#x27;href&#x27;] = url.replace(&#x27;/flash/&#x27;, &#x27;&#x27;) + li.xpath(&#x27;./a/@href&#x27;)[0]</span><br><span class="line">    item[&#x27;title&#x27;] = li.xpath(&#x27;./a/text()&#x27;)[0]</span><br><span class="line">    game_info.append(item)</span><br><span class="line"></span><br><span class="line"># 数据存储，两种方法等价</span><br><span class="line"># 1. 使用json.dumps()方法将python对象转换为字符串，通过fp.write()写入json文件</span><br><span class="line">with open(&quot;game_info.json_1&quot;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as fp:</span><br><span class="line">    fp.write(json.dumps(game_info, indent=4, ensure_ascii=False))</span><br><span class="line"></span><br><span class="line"># 2. 使用json.dump()方法将python对象转换为字符串，并直接写入json文件</span><br><span class="line">with open(&quot;game_info.json_2&quot;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as fp:</span><br><span class="line">    json.dump(game_info, fp, indent=4, ensure_ascii=False)</span><br></pre></td></tr></table></figure><h3 id="3-MySQL数据库存储"><a href="#3-MySQL数据库存储" class="headerlink" title="3. MySQL数据库存储"></a>3. MySQL数据库存储</h3><blockquote><p>创建一个数据库：<code>create database py_spider charset=utf8;</code></p></blockquote><ul><li><strong>代码逻辑：</strong><ol><li><strong>将url和headers定义为类属性</strong></li><li><strong>构建数据库链接对象</strong>，定义为实例属性，保证每一个实例对象都独有一份</li><li><strong>获取数据</strong>，定义为类方法，因为方法中所使用的都是类对象</li><li><strong>创建表</strong>，定义为实例方法，因为使用的mysql链接对象和游标都是实例属性</li><li><strong>数据录入</strong>，因为execute执行插入sql语句时，是需要传入参数的，所以函数通过*args接受参数</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">class TxWork:</span><br><span class="line">    # 将url和headers定义为类属性</span><br><span class="line">    url = &quot;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1699680197162&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=1&amp;keyword=python&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=cn&quot;</span><br><span class="line">    header = &#123;</span><br><span class="line">        &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 构建数据库链接对象，定义为实例属性，保证每一个实例对象都独有一份</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, db=&#x27;py_spider&#x27;)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line"></span><br><span class="line">    # 当这个类的生命周期为del退出时，会触发__del__方法</span><br><span class="line">    def __del__(self):</span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.db.close()</span><br><span class="line"></span><br><span class="line">    # 1. 获取数据，定义为类方法（代码优化），因为方法中所使用的都是类对象</span><br><span class="line">    # 类方法的内存占用空间更小，虽然可以将所有方法定义为实例方法，但不建议</span><br><span class="line">    @classmethod</span><br><span class="line">    def get_data(cls):</span><br><span class="line">        for page in range(1, 11):</span><br><span class="line">            info = requests.get(cls.url.format(page), headers=cls.header).json()</span><br><span class="line">            print(f&quot;正在获取第&#123;page&#125;页数据...&quot;)</span><br><span class="line">            data_list = info[&#x27;Data&#x27;][&#x27;Posts&#x27;]</span><br><span class="line">            # 1) 将所有数据都append到列表中，然后return，但数据量过大时列表占用内存空间太大</span><br><span class="line">            # 2) 定义为生成器，因为生成器是惰性加载的，只有用到的时候才去加载，这能有效地利用内存</span><br><span class="line">            yield data_list</span><br><span class="line"></span><br><span class="line">    # 2. 创建表，定义为实例方法，因为使用的mysql链接对象和游标都是实例属性</span><br><span class="line">    def create_table(self):</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            create table if not exists tx_work(</span><br><span class="line">                id int primary key auto_increment,</span><br><span class="line">                work_name varchar(100),</span><br><span class="line">                country_name varchar(50),</span><br><span class="line">                city_name varchar(50),</span><br><span class="line">                work_desc text</span><br><span class="line">            );</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            self.cursor.execute(&#x27;truncate table tx_work&#x27;)  # 保证可以正常多次调试</span><br><span class="line">            print(&quot;表创建成功&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(f&quot;创建表失败：&#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 3. 数据录入，因为execute执行插入sql语句时，是需要传入参数的，所以函数通过*args接受参数</span><br><span class="line">    def insert_mysql(self, *args):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param ags: 对应插入时需要的数据库中的字段参数</span><br><span class="line">            id  work_name  country_name  city_name  work_desc</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            insert into tx_work values(%s, %s, %s, %s, %s);</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.cursor.execute(sql, args)  # args参数是可迭代对象，所以不能用*拆包</span><br><span class="line">            self.db.commit()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(f&quot;此页中有数据插入失败：&#123;e&#125;&quot;)</span><br><span class="line">            self.db.rollback()</span><br><span class="line">        &quot;&quot;&quot;此处不能关闭游标和链接，因为是循环插入多页数据，第一页关了第二页就不能存了</span><br><span class="line">        finally:</span><br><span class="line">            self.cursor.close()</span><br><span class="line">            self.db.close()</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        self.create_table()</span><br><span class="line">        data_generator = self.get_data()  # 返回一个生成器对象</span><br><span class="line">        work_id = 0  # 使用0或None占位，id为主键，占位可以实现自动自增长</span><br><span class="line">        for data_list in data_generator:</span><br><span class="line">            for data in data_list:</span><br><span class="line">                work_name = data[&#x27;RecruitPostName&#x27;]</span><br><span class="line">                country_name = data[&#x27;CountryName&#x27;]</span><br><span class="line">                city_name = data[&#x27;LocationName&#x27;]</span><br><span class="line">                work_desc = data[&#x27;Responsibility&#x27;]</span><br><span class="line">                self.insert_mysql(work_id, work_name, country_name, city_name, work_desc)</span><br><span class="line">            print(&quot;数据录入成功！&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    tx_work = TxWork()</span><br><span class="line">    tx_work.main()</span><br></pre></td></tr></table></figure><h3 id="4-Peewee的使用"><a href="#4-Peewee的使用" class="headerlink" title="4. Peewee的使用"></a>4. Peewee的使用</h3><ul><li>Peewee简介：Peewee 是一个轻量级的 Python ORM 库，它支持 SQLite、MySQL、PostgreSQL 和 Oracle 数据库等多种数据库，并且提供了简单易用的 API</li><li>ORM简介：<strong>ORM（Object-Relational Mapping）是一种将关系型数据库中的表和数据映射为对象和属性的方法，从而通过操作对象来完成数据库的增删改查等操作。</strong>使用 ORM 可以让我们更加专注于业务逻辑的实现，而不用过多关注 SQL 语句的编写和数据库的细节操作</li><li><strong>数据的增删改查：</strong><ol><li><strong>增：</strong>1、使用**create()<strong>方法创建一个对象，这个对象会自动调用</strong>execute()<strong>方法保存到数据库中。2、使用实例化对象并调用</strong>save()**方法保存到数据库中，那么在调用save()方法之前，对象并没有被保存到数据库中；如果要保存的对象已经存在于数据库中，则save()方法会更新该对象，而不是新增一个对象</li><li><strong>删：使用update()修改数据，返回被删除的行数</strong></li><li><strong>改：使用delete()删除数据，返回被删除的行数</strong></li><li><strong>查：使用selete()查询数据，返回SelectQuery对象，需要通过execute()方法执行查询并获取结果</strong></li><li><strong>execute()：是peewee中的一个方法，用于执行SQL语句并返回受影响的行数</strong></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from peewee import *</span><br><span class="line"></span><br><span class="line"># 连接MySQL数据库</span><br><span class="line">db = MySQLDatabase(&#x27;spider&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, host=&#x27;localhost&#x27;, port=3306)</span><br><span class="line"></span><br><span class="line"># 定义模型类</span><br><span class="line">class User(Model):</span><br><span class="line">    username = CharField()</span><br><span class="line">    password = CharField()</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        database = db  # 指定使用的数据库</span><br><span class="line">        table_name = &#x27;user&#x27;  # 指定对应的表名</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 创建表</span><br><span class="line">    db.create_tables([User])</span><br><span class="line"></span><br><span class="line">    # 插入数据</span><br><span class="line">    user = User.create(username=&#x27;wcf&#x27;, password=&#x27;123456&#x27;)</span><br><span class="line">    print(user)</span><br><span class="line"></span><br><span class="line">    # 查询所有用户</span><br><span class="line">    users = User.select().where(User.username == &#x27;00jack&#x27;)</span><br><span class="line">    print(users)</span><br><span class="line"></span><br><span class="line">    # 查询用户名为&#x27;Alice&#x27;的用户</span><br><span class="line">    users = User.select().where(User.username == &#x27;Alice&#x27;)</span><br><span class="line"></span><br><span class="line">    # 更新用户名为&#x27;Alice&#x27;的用户的密码</span><br><span class="line">    User.update(password=&#x27;654321&#x27;).where(User.username == &#x27;Alice&#x27;).execute()</span><br><span class="line"></span><br><span class="line">    # 删除用户名为&#x27;Alice&#x27;的用户</span><br><span class="line">    User.delete().where(User.username == &#x27;Alice&#x27;).execute()</span><br></pre></td></tr></table></figure><h3 id="5-MongDB数据库存储"><a href="#5-MongDB数据库存储" class="headerlink" title="5. MongDB数据库存储"></a>5. MongDB数据库存储</h3><blockquote><p><strong>在pyhton中，可以使用PyMongo直接将字典数据插入到MongoDB数据库中</strong></p><p><strong>原理：</strong>MongoDB文档是一种使用类似 JSON 的 BSON（Binary JSON）格式表示的数据结构，而字典在Python中与JSON结构非常相似，因此字典数据可以直接映射为MongoDB文档</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">class AiQiYi:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url = &quot;https://pcw-api.iqiyi.com/search/recommend/list&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">        self.mongo_cli = pymongo.MongoClient(host=&#x27;localhost&#x27;, port=27017)</span><br><span class="line"></span><br><span class="line">    # 获取数据</span><br><span class="line">    def get_data(self, params):</span><br><span class="line">        # 这里不使用yield返回数据是因为没有循环，构建params参数的实现放在了main方法中</span><br><span class="line">        data = requests.get(url=self.url, headers=self.headers, params=params).json()</span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line">    # 解析数据</span><br><span class="line">    def parse_data(self, data):</span><br><span class="line">        for item in data[&#x27;data&#x27;][&#x27;list&#x27;]:</span><br><span class="line">            info = dict()</span><br><span class="line">            info[&#x27;title&#x27;] = item[&#x27;title&#x27;]</span><br><span class="line">            info[&#x27;score&#x27;] = item[&#x27;score&#x27;]</span><br><span class="line">            info[&#x27;description&#x27;] = item[&#x27;description&#x27;]</span><br><span class="line"></span><br><span class="line">            # 将这条数据保存到mongdb中</span><br><span class="line">            try:</span><br><span class="line">                self.save_data(info)</span><br><span class="line">                print(&quot;保存成功...&quot;)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(f&quot;保存失败：&#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 保存数据</span><br><span class="line">    def save_data(self, info):</span><br><span class="line">        self.mongo_cli[&#x27;AiQiYi&#x27;][&#x27;movie_info&#x27;].insert_one(info)</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        for page in range(1, 6):</span><br><span class="line">            params = &#123;</span><br><span class="line">                &quot;channel_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;data_type&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;mode&quot;: &quot;11&quot;,</span><br><span class="line">                &quot;page_id&quot;: page,</span><br><span class="line">                &quot;ret_num&quot;: &quot;48&quot;,</span><br><span class="line">                &quot;session&quot;: &quot;2ead98f78a643719307ff1643f591f59&quot;,</span><br><span class="line">                &quot;three_category_id&quot;: &quot;15;must&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            data = self.get_data(params)</span><br><span class="line">            self.parse_data(data)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    aqy = AiQiYi()</span><br><span class="line">    aqy.main()</span><br></pre></td></tr></table></figure><h3 id="6-md5数据去重"><a href="#6-md5数据去重" class="headerlink" title="6. md5数据去重"></a>6. md5数据去重</h3><blockquote><p><strong>MD5哈希函数</strong>：是一种不可逆的哈希函数，用于产生固定长度的散列值，通常是128位的16进制数（对于相同的源数据，无论何时计算，其产生的 MD5 哈希值都是固定的、不变的）</p><p><strong>不可逆特性：</strong>不可逆特性是指通过 MD5 算法产生的摘要（哈希值）不能被逆向还原为原始输入数据</p><p><strong>数据完整性验证：</strong>在某些应用中，需要确保存储的数据在后续读取时没有被篡改。计算数据的MD5哈希并将其存储在数据库中，然后在读取时再次计算哈希并与存储的哈希进行比较，以验证数据的完整性</p></blockquote><ul><li><strong>思路分析：</strong>将获取的数据存储到 mongodb 数据库中，在调用保存方法之前，先调用md5哈希方法将数据转为哈希值并保存到 redis 中，再判断当前获取的数据的哈希值是否已存在于 redis 数据库，不存在则保存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line">import pymongo</span><br><span class="line">import hashlib</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">class MovieInfo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url = &quot;https://pianku.api.mgtv.com/rider/list/pcweb/v3&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">        self.mongo_cli = pymongo.MongoClient()</span><br><span class="line">        self.redis_cli = redis.Redis()</span><br><span class="line"></span><br><span class="line">    # 请求数据</span><br><span class="line">    def get_data(self, params):</span><br><span class="line">        response = requests.get(self.url, headers=self.headers, params=params).json()</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">    # 数据清洗以及数据结构调整</span><br><span class="line">    def parse_data(self, response):</span><br><span class="line">        for data in response[&#x27;data&#x27;][&#x27;hitDocs&#x27;]:</span><br><span class="line">            info = dict()</span><br><span class="line">            info[&#x27;title&#x27;] = data[&quot;title&quot;]</span><br><span class="line">            info[&#x27;subtitle&#x27;] = data[&quot;subtitle&quot;]</span><br><span class="line">            info[&#x27;story&#x27;] = data[&quot;story&quot;]</span><br><span class="line"></span><br><span class="line">            # 在数据清洗之后保存数据</span><br><span class="line">            self.save_data(info)</span><br><span class="line"></span><br><span class="line">    # 数据去重，主要是为了多线程或协程服务的，当线程对象过多时可能会导致保存数据重复</span><br><span class="line">    @staticmethod</span><br><span class="line">    def get_md5(item):</span><br><span class="line">        # md5方法只能接收字节数据，计算哈希值, 哈希值是唯一的</span><br><span class="line">        return hashlib.md5(str(item).encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line"></span><br><span class="line">    # 数据保存，在保存数据前进行数据重复判断，即数据去重</span><br><span class="line">    def save_data(self, data):</span><br><span class="line">        md5_data = self.get_md5(data)</span><br><span class="line">        # 当前集合的key如果有冒号，redis会在内部创建一个文件夹</span><br><span class="line">        result = self.redis_cli.sadd(&#x27;movie:folder&#x27;, md5_data)  # 返回1或0</span><br><span class="line">        if result:</span><br><span class="line">            self.mongo_cli[&#x27;MGTV&#x27;][&#x27;movie&#x27;].insert_one(data)</span><br><span class="line">            print(&quot;数据保存成功&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;数据重复...&quot;)</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        for page in range(1, 5):</span><br><span class="line">            params = &#123;</span><br><span class="line">                &quot;allowedRC&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;platform&quot;: &quot;pcweb&quot;,</span><br><span class="line">                &quot;channelId&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;pn&quot;: page,</span><br><span class="line">                &quot;pc&quot;: &quot;80&quot;,</span><br><span class="line">                &quot;hudong&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_support&quot;: &quot;10000000&quot;,</span><br><span class="line">                &quot;kind&quot;: &quot;19&quot;,</span><br><span class="line">                &quot;area&quot;: &quot;10&quot;,</span><br><span class="line">                &quot;year&quot;: &quot;all&quot;,</span><br><span class="line">                &quot;chargeInfo&quot;: &quot;a1&quot;,</span><br><span class="line">                &quot;sort&quot;: &quot;c2&quot;,</span><br><span class="line">                &quot;feature&quot;: &quot;all&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            data = self.get_data(params)</span><br><span class="line">            self.parse_data(data)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mgtv = MovieInfo()</span><br><span class="line">    mgtv.main()</span><br></pre></td></tr></table></figure><h2 id="六、并发爬虫"><a href="#六、并发爬虫" class="headerlink" title="六、并发爬虫"></a>六、并发爬虫</h2><blockquote><p>当使用异步关键词 async&#x2F;await 进行开发时，需要利用各种异步操作来执行不同类型的任务：</p><ul><li><strong>异步网络请求：</strong>使用 <strong>aiohttp</strong> 库代替同步的 requests 库来执行异步的网络请求操作</li><li><strong>异步MySQL数据库操作：</strong>使用 <strong>aiomysql</strong> 库代替同步的 pymysql 库来操作 mysql 数据库</li><li><strong>异步MongoDB数据库操作：</strong>使用 <strong>motor</strong> 库代替同步的 pymongo 库来操作 mongodb 数据库</li><li><strong>Redis数据库操作：</strong>Redis 本身是异步的</li></ul></blockquote><h3 id="1-协程配合requests"><a href="#1-协程配合requests" class="headerlink" title="1. 协程配合requests"></a>1. 协程配合requests</h3><ul><li>回顾并利用之前学习的协程来完成爬虫并发任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import requests</span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">url = &#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async def get_movie_info(page):</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    # run_in_executor不支持关键字参数传递headers, 可以使用lambda包装，也可以使用偏函数传递</span><br><span class="line">    # lambda函数在这里的作用是将请求操作包装成一个可调用对象，相当于直接return这个requests.get方法</span><br><span class="line">    # response = await loop.run_in_executor(None, lambda: requests.get(url.format(page * 25), headers=headers))</span><br><span class="line">    response = await loop.run_in_executor(None, partial(requests.get, url.format(page * 25), headers=headers))</span><br><span class="line">    print(response.text)</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    tasks = [asyncio.create_task(get_movie_info(page)) for page in range(5)]</span><br><span class="line">    await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 异步随机调度会导致输出的数据不是顺序输出</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="2-aiohttp代替requests"><a href="#2-aiohttp代替requests" class="headerlink" title="2. aiohttp代替requests"></a>2. aiohttp代替requests</h3><blockquote><p><strong>问题：</strong>由于 requests 爬虫库本身不支持异步，在 asyncio 中需要 run_in_executor 开启线程池才能异步</p><p><strong>优化：使用 aiohttp 库的【客户端】代替同步的 requests 库来执行异步的网络请求操作</strong></p></blockquote><ul><li><strong>aiohttp：</strong>是一个基于异步IO的 HTTP 客户端和服务器框架，适用于 Python 的 asyncio 库（<a class="link"   href="https://docs.aiohttp.org/en/stable/"  target="_blank" rel="noopener">官方文档<i class="fas fa-external-link-alt"></i></a>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import aiohttp</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">url = &quot;https://www.baidu.com&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async def get_data():</span><br><span class="line">    # 创建一个异步http客户端会话（session），通过async with异步上下文管理器管理会话资源</span><br><span class="line">    async with aiohttp.ClientSession() as session:</span><br><span class="line">        # 使用session会话发起get请求，同样请求和响应也是需要关闭的</span><br><span class="line">        async with session.get(url, headers=headers, ssl=False) as resp:</span><br><span class="line">            print(resp.status)</span><br><span class="line">            # text()被定义为协程函数：async def text()，所以需要await等待</span><br><span class="line">            print(await resp.text())</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    asyncio.run(get_data())</span><br></pre></td></tr></table></figure><h3 id="3-aiomysql的使用"><a href="#3-aiomysql的使用" class="headerlink" title="3. aiomysql的使用"></a>3. aiomysql的使用</h3><ul><li><strong>aiomysql：</strong>是一个基于 asyncio 的 MySQL 异步驱动，用于在异步应用程序中执行 MySQL 数据库操作</li><li><strong>异步连接池的作用：</strong><ul><li><strong>资源复用：</strong>连接池通过提供一个池化的连接资源集合，减少了每次数据库操作都需要新建连接的开销。每个协程可以从连接池中获取一个可用的连接，使用完毕后将其放回池中，以便其他协程继续使用。这有助于降低连接的创建和销毁成本</li><li><strong>并发性：</strong>异步连接池允许多个协程同时从池中获取连接，执行数据库操作，而无需等待</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import aiomysql</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def conn_mysql():</span><br><span class="line">    # 创建一个异步连接池，可用于管理多个异步连接，从池中获取连接执行查询，最后关闭连接池</span><br><span class="line">    async with aiomysql.create_pool(user=&#x27;root&#x27;, password=&#x27;123456&#x27;, db=&#x27;py_spider&#x27;) as pool:</span><br><span class="line">        # 从连接池中获取连接</span><br><span class="line">        async with pool.acquire() as conn:</span><br><span class="line">            # 使用连接创建异步游标，用于执行sql查询</span><br><span class="line">            async with conn.cursor() as cursor:</span><br><span class="line">                # 执行sql语句</span><br><span class="line">                await cursor.execute(&#x27;select * from tx_work;&#x27;)</span><br><span class="line">                # 获取查询结果的第一行</span><br><span class="line">                result = await cursor.fetchone()  # 返回的是一个Future对象</span><br><span class="line">                print(result)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    asyncio.run(conn_mysql())</span><br></pre></td></tr></table></figure><h3 id="4-汽车之家数据采集"><a href="#4-汽车之家数据采集" class="headerlink" title="4. 汽车之家数据采集"></a>4. 汽车之家数据采集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line">import re</span><br><span class="line">import hashlib</span><br><span class="line">import chardet</span><br><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import aiomysql</span><br><span class="line"></span><br><span class="line">class CarSpider:</span><br><span class="line">    redis_cli = redis.Redis()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url = &quot;https://www.che168.com/china/a0_0msdgscncgpi1ltocsp&#123;&#125;exf4x0/?pvareaid=102179#currengpostion&quot;</span><br><span class="line">        self.api_url = &quot;https://cacheapigo.che168.com/CarProduct/GetParam.ashx?specid=&#123;&#125;&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    # 获取页面中汽车的id</span><br><span class="line">    async def get_car_id(self, page, session, pool):</span><br><span class="line">        async with session.get(self.url.format(page), headers=self.headers, ssl=False) as response:</span><br><span class="line">            # aiohttp中，需要使用read()而不是content，获得响应的二进制内容（bytes类型）</span><br><span class="line">            content = await response.read()</span><br><span class="line">            # 由于汽车之家每一次请求返回的页面编码格式都可能不一样，并且错误的页面还无法获取到需要的数据</span><br><span class="line">            # 所以需要使用第三方库chardet识别页面的编码格式，因为自己去获取出的可能是别人伪装过的编码格式</span><br><span class="line">            encoding = chardet.detect(content)[&quot;encoding&quot;]</span><br><span class="line">            if encoding == &quot;GB2312&quot;:</span><br><span class="line">                data = content.decode(&quot;gbk&quot;)  # 编码格式为 gb2312 或者 iso-8859-1，均可用gbk解码</span><br><span class="line">                print(f&quot;第&#123;page&#125;次数据获取成功...&quot;)</span><br><span class="line">                # 使用正则表达式匹配文档中所有car_id，返回一个列表</span><br><span class="line">                car_id_list = re.findall(r&#x27;&lt;li.*?specid=&quot;(.*?)&quot;.*?&lt;/li&gt;&#x27;, data)</span><br><span class="line">                # 通过每一个汽车id获取其对应的api数据</span><br><span class="line">                tasks = [asyncio.create_task(self.get_car_info(car_id, session, pool)) for car_id in car_id_list]</span><br><span class="line">                await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">    # 通过汽车id获取api接口的数据，并清洗数据</span><br><span class="line">    async def get_car_info(self, spec_id, session, pool):</span><br><span class="line">        async with session.get(self.api_url.format(spec_id), headers=self.headers, ssl=False) as resp:</span><br><span class="line">            result = await resp.json()</span><br><span class="line">            # 返回的json数据中存在paramtypeitems这个key的值不存在的情况</span><br><span class="line">            if result[&#x27;result&#x27;].get(&#x27;paramtypeitems&#x27;):</span><br><span class="line">                info = dict()</span><br><span class="line">                info[&#x27;name&#x27;] = result[&#x27;result&#x27;][&quot;paramtypeitems&quot;][0][&quot;paramitems&quot;][0][&#x27;value&#x27;]</span><br><span class="line">                info[&#x27;price&#x27;] = result[&#x27;result&#x27;][&quot;paramtypeitems&quot;][0][&quot;paramitems&quot;][1][&#x27;value&#x27;]</span><br><span class="line">                info[&#x27;brand&#x27;] = result[&#x27;result&#x27;][&quot;paramtypeitems&quot;][0][&quot;paramitems&quot;][2][&#x27;value&#x27;]</span><br><span class="line"></span><br><span class="line">                # 调度保存任务，由于此处只有一个任务，所以是无法并发执行的，可以直接使用await直接将任务提交到事件循环</span><br><span class="line">                await self.save_car_info(info, pool)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def get_md5(info):</span><br><span class="line">        return hashlib.md5(str(info).encode(&quot;utf-8&quot;)).hexdigest()</span><br><span class="line"></span><br><span class="line">    # 将数据保存到mysql中，保存前使用redis配合md5完成数据去重</span><br><span class="line">    async def save_car_info(self, info, pool):</span><br><span class="line">        # 这里体现传递pool连接池的作用，因为有多个协程都需要保存数据，所以每个协程可以从连接池中获取一个可用的连接，</span><br><span class="line">        # 使用完毕后将其放回池中，以便其他协程继续使用。这减少了每次数据库操作都需要新建连接的开销</span><br><span class="line">        async with pool.acquire() as conn:</span><br><span class="line">            async with conn.cursor() as cursor:</span><br><span class="line">                sql = &quot;&quot;&quot;</span><br><span class="line">                    insert into car_info values(%s, %s, %s, %s);</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">                info_md5 = self.get_md5(info)</span><br><span class="line">                # 判断能否存入redis中，利用集合的不可重复的，成功则返回1，失败返回0</span><br><span class="line">                if self.redis_cli.sadd(&quot;car_info&quot;, info_md5):</span><br><span class="line">                    try:</span><br><span class="line">                        # cursor.execute()传参数时，第二个参数需要为元组或列表，所以使用tuple(info.values())构造元组</span><br><span class="line">                        await cursor.execute(sql, (0, *tuple(info.values())))</span><br><span class="line">                        await conn.commit()</span><br><span class="line">                        print(&quot;数据保存成功...&quot;)</span><br><span class="line">                    except Exception as e:</span><br><span class="line">                        await conn.rollback()</span><br><span class="line">                        print(&quot;数据保存失败：&quot;, e)</span><br><span class="line">                else:</span><br><span class="line">                    print(&quot;数据重复!&quot;)</span><br><span class="line"></span><br><span class="line">    async def main(self):</span><br><span class="line">        async with aiomysql.create_pool(user=&#x27;root&#x27;, password=&#x27;123456&#x27;, db=&#x27;py_spider&#x27;) as pool:</span><br><span class="line">            async with pool.acquire() as conn:</span><br><span class="line">                async with conn.cursor() as cursor:</span><br><span class="line">                    # 创建表</span><br><span class="line">                    sql = &quot;&quot;&quot;</span><br><span class="line">                        create table car_info(</span><br><span class="line">                            id int primary key auto_increment,</span><br><span class="line">                            name varchar(100),</span><br><span class="line">                            price varchar(100),</span><br><span class="line">                            brand varchar(100)</span><br><span class="line">                        );</span><br><span class="line">                    &quot;&quot;&quot;</span><br><span class="line">                    # 检查表是否存在，cursor.execute()方法存在则返回1，不存在则返回0</span><br><span class="line">                    if not await cursor.execute(&#x27;show tables like &quot;car_info&quot;;&#x27;):</span><br><span class="line">                        await cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">            async with aiohttp.ClientSession() as session:</span><br><span class="line">                # 通过分析发现，不管第几页，页面每次刷新所返回的数据都不一样，所以不同的page相当于只是区分又发起了一次请求而已</span><br><span class="line">                # 异步发起15次请求，获取汽车的id数据，其中可能只能成功几次，所以这种网站一般是需要24*7不间断爬取的</span><br><span class="line">                tasks = [asyncio.create_task(self.get_car_id(page, session, pool)) for page in range(1, 16)]</span><br><span class="line">                await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    car = CarSpider()</span><br><span class="line">    asyncio.run(car.main())</span><br></pre></td></tr></table></figure><h3 id="5-JoinableQueue队列"><a href="#5-JoinableQueue队列" class="headerlink" title="5. JoinableQueue队列"></a>5. JoinableQueue队列</h3><ul><li><p><strong>JoinableQueue：</strong>是 multiprocessing 模块中的一种队列类型，<strong>它是 Queue 的子类</strong>，其主要用于在<strong>多进程</strong>编程中进行任务的协同。它允许一个进程放入任务，而另一个进程则从队列中取出任务。</p></li><li><p><strong>put(item[, block[, timeout]])：将项目放入队列</strong></p><ul><li><strong>参数item</strong>：即要放入队列的任务</li><li><strong>参数block</strong>：控制在队列已满时的行为，为布尔值。为True时，在队列有空间之前会阻塞；为False时，会立即引发 Full 异常</li><li><strong>参数timeout</strong>：表示阻塞的最长时间，如果在指定时间内队列仍然是满的，将引发 Full 异常</li></ul></li><li><p><strong>get([block[, timeout]])：从队列中取出一个项目</strong></p><ul><li><strong>参数block</strong>：控制在队列为空时的行为，为布尔值。为True时，在队列不为空之前会阻塞；为False时，会立即引发 Empty 异常</li><li><strong>参数timeout</strong>：表示阻塞的最长时间，如果在指定时间内队列仍然是空的，将引发 Empty 异常</li></ul></li><li><p><strong>task_done()：用于表示之前放入队列的任务已经完成</strong></p><ul><li><strong>解释：</strong>JoinableQueue中存在一个队列计数器，每调用 put() 后，则计数器 +1，每调用 get() 后，表示对应的任务已经被处理完毕，则需要调用 task_done() 表示此任务已经完成，且计数器 -1</li></ul></li><li><p><strong>join()：阻塞，直到队列中的所有任务都被处理并调用了 task_done()</strong></p><ul><li><strong>解释：</strong>阻塞主进程，等待工作进程执行完所有任务再继续执行。即当队列中所有任务都调用了 get() 和 task_done() 后，表示队列中的所有任务都已经完成了，此时队列计数器为零，主进程则不再阻塞</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># https://careers.tencent.com/search.html?keyword=python</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">from multiprocessing import JoinableQueue</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">url = &quot;https://careers.tencent.com/tencentcareer/api/post/Query&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def get_data(page, queue):</span><br><span class="line">    params = &#123;</span><br><span class="line">        &quot;timestamp&quot;: &quot;1700122896844&quot;,</span><br><span class="line">        &quot;countryId&quot;: &quot;&quot;,</span><br><span class="line">        &quot;cityId&quot;: &quot;&quot;,</span><br><span class="line">        &quot;bgIds&quot;: &quot;&quot;,</span><br><span class="line">        &quot;productId&quot;: &quot;&quot;,</span><br><span class="line">        &quot;categoryId&quot;: &quot;&quot;,</span><br><span class="line">        &quot;parentCategoryId&quot;: &quot;&quot;,</span><br><span class="line">        &quot;attrId&quot;: &quot;&quot;,</span><br><span class="line">        &quot;keyword&quot;: &quot;python&quot;,</span><br><span class="line">        &quot;pageIndex&quot;: page,</span><br><span class="line">        &quot;pageSize&quot;: &quot;10&quot;,</span><br><span class="line">        &quot;language&quot;: &quot;zh-cn&quot;,</span><br><span class="line">        &quot;area&quot;: &quot;cn&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url, headers=headers, params=params).json()</span><br><span class="line">    for item in response[&quot;Data&quot;][&quot;Posts&quot;]:</span><br><span class="line">        info = dict()</span><br><span class="line">        info[&quot;CountryName&quot;] = item[&quot;CountryName&quot;]</span><br><span class="line">        info[&quot;RecruitPostName&quot;] = item[&quot;RecruitPostName&quot;]</span><br><span class="line">        info[&quot;Responsibility&quot;] = item[&quot;Responsibility&quot;]</span><br><span class="line">        queue.put(info)</span><br><span class="line"></span><br><span class="line">def save_data(queue):</span><br><span class="line">    mongo_cli = pymongo.MongoClient()</span><br><span class="line">    db = mongo_cli[&quot;tencent&quot;][&quot;tx_work&quot;]</span><br><span class="line">    while True:</span><br><span class="line">        info = queue.get()</span><br><span class="line">        db.insert_one(info)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    queue = JoinableQueue()</span><br><span class="line">    # 创建并添加子进程到列表，所有子进程都已经启动后，主进程再等待它们完成，实现并行</span><br><span class="line">    processes = []</span><br><span class="line">    # 使用两个进程，一个用于获取数据，另一个用于保存数据到MongoDB</span><br><span class="line">    # 这样在获取数据的同时，可以在另一个进程中保存数据，从而实现并行处理</span><br><span class="line">    for page in range(1, 11):</span><br><span class="line">        process = Process(target=get_data, args=(page, queue))</span><br><span class="line">        processes.append(process)</span><br><span class="line"></span><br><span class="line">    processes.append(Process(target=save_data, args=(queue,)))</span><br><span class="line"></span><br><span class="line">    for item in processes:</span><br><span class="line">        item.daemon = True  # 设置守护进程</span><br><span class="line">        item.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(1)  # 让操作系统有足够的时间来启动进程</span><br><span class="line">    # 由于队列计数器默认为0，所以需要给启动进程一点时间，否则计数器还没来得及调用put方法+1，</span><br><span class="line">    # queue.join()中也就没有需要完成的任务，也就不会阻塞主进程，这样整个程序就直接结束了</span><br><span class="line"></span><br><span class="line">    queue.join()  # 阻塞主进程，直到队列中的所有任务完成后解堵塞</span><br><span class="line">    # 解堵塞后，整个程序按理说就应该执行完毕了，但是因为子进程save_data方法中是一个死循环，</span><br><span class="line">    # 它不能自己退出，所以需要设置守护进程，当主进程解堵塞后，子进程就随着主进程的退出而退出</span><br></pre></td></tr></table></figure><h2 id="七、综合并发爬虫案例"><a href="#七、综合并发爬虫案例" class="headerlink" title="七、综合并发爬虫案例"></a>七、综合并发爬虫案例</h2><blockquote><p><strong>队列在多线程编程中传输数据的好处：</strong></p><ol><li><strong>线程安全：</strong> <strong>队列提供了线程安全的数据结构，确保在多线程环境中数据传输的安全性</strong>。队列的实现通常会使用锁机制，以防止多个线程同时修改队列数据导致的竞态条件</li><li><strong>解耦和协作：</strong> <strong>队列允许不同的线程在不直接依赖于对方的内部实现的情况下进行协作</strong>。通过将数据放入队列，一个线程可以向其他线程传递信息，而无需了解接收线程的具体实现细节</li><li><strong>异步处理：</strong> <strong>队列可以用于实现异步处理</strong>。一个线程可以将任务放入队列，而不必等待任务完成，从而允许线程继续执行其他任务。接收任务的线程可以异步处理队列中的任务</li><li><strong>防止资源竞争：</strong> 在多线程环境中，如果多个线程同时访问和修改共享的数据结构，可能会导致竞争条件。<strong>通过使用队列，可以减少对共享资源的直接访问，降低了出现竞争条件的可能性</strong></li><li><strong>平衡生产者和消费者速度：</strong> 如果一个线程生成数据的速度快于另一个线程处理数据的速度，<strong>使用队列可以平衡生产者和消费者之间的速度差异</strong>。队列充当了缓冲区，使得生产者和消费者可以在各自的速度下独立操作</li><li><strong>可扩展性：</strong> 使用队列可以方便地扩展程序，因为你可以很容易地添加或删除处理特定任务的线程，而不必修改其他部分的代码</li></ol></blockquote><h3 id="1-多线程实现并发爬虫"><a href="#1-多线程实现并发爬虫" class="headerlink" title="1. 多线程实现并发爬虫"></a><strong>1. 多线程实现并发爬虫</strong></h3><ul><li>案例目标：使用多线程完成并发爬虫，通过队列进行数据传递，最后将数据存入mongodb数据库</li></ul><ul><li><strong>独立线程：</strong>每个函数 <strong>get_api_url</strong>、<strong>get_api_json</strong>、<strong>parse_movie_info</strong> 和 <strong>save_movie_info</strong> 在独立的线程中运行</li><li><strong>数据传递：</strong>使用队列 <strong>url_queue</strong>、<strong>json_queue</strong> 和 <strong>data_queue</strong> 进行数据传递，明确控制线程之间的通信</li><li><strong>线程控制：</strong>提供更细粒度的线程控制，可以手动管理线程的启动和关闭，适用于需要对每个线程进行精细调整的场景</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"># https://list.iqiyi.com/www/2/15-------------11-1-1-iqiyi--.html?s_source=PCW_SC</span><br><span class="line">import requests</span><br><span class="line">import pymongo</span><br><span class="line">from threading import Thread</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">class AiQiYi:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.api_url = &quot;https://pcw-api.iqiyi.com/search/recommend/list?channel_id=2&amp;data_type=1&amp;mode=11&amp;page_id=&#123;&#125;&amp;ret_num=48&amp;session=fcfd98ff68e5d561762262c1ece3fb7e&amp;three_category_id=15;must&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">            &#x27;Referer&#x27;: &#x27;https://list.iqiyi.com/www/2/15-------------11-1-1-iqiyi--.html?s_source=PCW_SC&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        self.mongo_cli = pymongo.MongoClient()</span><br><span class="line">        self.collection = self.mongo_cli[&quot;AiQiYi&quot;][&quot;movie_info&quot;]</span><br><span class="line"></span><br><span class="line">        # 创建几个用于线程间传递数据的队列</span><br><span class="line">        self.url_queue = Queue()</span><br><span class="line">        self.json_queue = Queue()</span><br><span class="line">        self.data_queue = Queue()</span><br><span class="line"></span><br><span class="line">    def get_api_url(self):</span><br><span class="line">        for i in range(1, 6):</span><br><span class="line">            self.url_queue.put(self.api_url.format(i))</span><br><span class="line"></span><br><span class="line">    def get_api_json(self):</span><br><span class="line">        while True:</span><br><span class="line">            url = self.url_queue.get()</span><br><span class="line">            response = requests.get(url, headers=self.headers)</span><br><span class="line">            self.json_queue.put(response.json())</span><br><span class="line">            self.url_queue.task_done()</span><br><span class="line"></span><br><span class="line">    def parse_movie_info(self):</span><br><span class="line">        while True:</span><br><span class="line">            json = self.json_queue.get()</span><br><span class="line">            for item in json[&quot;data&quot;][&quot;list&quot;]:</span><br><span class="line">                info = dict()  # 字典要定义在循环内，因为每循环一次都要存入一条新数据</span><br><span class="line">                info[&quot;name&quot;] = item[&quot;name&quot;]</span><br><span class="line">                info[&quot;playUrl&quot;] = item[&quot;playUrl&quot;]</span><br><span class="line">                info[&quot;description&quot;] = item[&quot;description&quot;]</span><br><span class="line">                self.data_queue.put(info)</span><br><span class="line">            self.json_queue.task_done()</span><br><span class="line"></span><br><span class="line">    def save_movie_info(self):</span><br><span class="line">        while True:</span><br><span class="line">            data = self.data_queue.get()</span><br><span class="line">            self.collection.insert_one(data)</span><br><span class="line">            self.data_queue.task_done()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        # 初始化线程对象列表</span><br><span class="line">        thread_list = list()</span><br><span class="line"></span><br><span class="line">        # 创建获取url的线程对象并加入到线程对象列表中，1个线程</span><br><span class="line">        thread_list.append(Thread(target=self.get_api_url))</span><br><span class="line"></span><br><span class="line">        # 创建发送请求的线程对象并加入到线程对象列表中，3个线程</span><br><span class="line">        for _ in range(3):</span><br><span class="line">            thread_list.append(Thread(target=self.get_api_json))</span><br><span class="line"></span><br><span class="line">        # 创建数据清洗的线程对象并加入到线程对象列表中，1个线程</span><br><span class="line">        thread_list.append(Thread(target=self.parse_movie_info))</span><br><span class="line"></span><br><span class="line">        # 创建保存数据的线程对象并加入到线程对象列表中，1个线程</span><br><span class="line">        thread_list.append(Thread(target=self.save_movie_info))</span><br><span class="line"></span><br><span class="line">        # 循环线程列表设置线程对象为守护线程并启动</span><br><span class="line">        for t_obj in thread_list:</span><br><span class="line">            t_obj.daemon = True  # 设置守护线程</span><br><span class="line">            t_obj.start()</span><br><span class="line"></span><br><span class="line">        # 阻塞主进程，直到队列中的所有任务完成后解堵塞，即等待所有队列中的计数器减为零</span><br><span class="line">        for q_obj in [self.url_queue, self.json_queue, self.data_queue]:</span><br><span class="line">            q_obj.join()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    aiqiyi = AiQiYi()</span><br><span class="line">    aiqiyi.main()</span><br></pre></td></tr></table></figure><h3 id="2-线程池实现并发爬虫"><a href="#2-线程池实现并发爬虫" class="headerlink" title="2. 线程池实现并发爬虫"></a>2. <strong>线程池实现并发爬虫</strong></h3><ul><li>案例目标：使用线程池完成并发爬虫，通过 Future 对象异步获取任务的结果，最后将数据存入mysql数据库</li></ul><ul><li><strong>线程控制：</strong>提供更高级的线程管理，可以更好地管理线程的生命周期，减少了线程创建和销毁的开销，适用于大量短时任务的场景</li><li><strong>数据传递：</strong>通过 Future 对象异步获取任务的结果，线程间的数据传递更为抽象，不直接使用队列</li><li><strong>API抽象程度：</strong>提供更高级别、更抽象的API，减少了对线程和队列的直接管理，使得程序员更专注于业务逻辑，降低了操作线程和队列的复杂性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"># https://talent.baidu.com/jobs/social-list?search=python</span><br><span class="line">import requests</span><br><span class="line">import pymysql</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line">class BaiduSpider:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.api_url = &quot;https://talent.baidu.com/httservice/getPostListNew&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">            &#x27;cookie&#x27;: &#x27;BIDUPSID=60FBCA8DBF4F3E49D29E6D84287CBA53; PSTM=1688559896; BAIDUID=60FBCA8DBF4F3E499AAD874D85AABF9F:FG=1; H_WISE_SIDS=110085_268592_269832_269904_271169_271269_271812_272280_272461_273118_273300_273460_275940_269610_271120_276250_274502_275171_276419_276441_276572_276600_275589_276831_276985_276987_276964_270102_277313_277356_276264_277633_275188_275733; BDUSS=ItSERNVUVCSkE2ODRYbG5idEJEVm5kUjNFSDJvRy03SWlPYzhLUG16UzZvVTFsSVFBQUFBJCQAAAAAAAAAAAEAAAAfu5VDd2NmMTUzMjUyNzc0MzUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoUJmW6FCZlY3; BDUSS_BFESS=ItSERNVUVCSkE2ODRYbG5idEJEVm5kUjNFSDJvRy03SWlPYzhLUG16UzZvVTFsSVFBQUFBJCQAAAAAAAAAAAEAAAAfu5VDd2NmMTUzMjUyNzc0MzUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoUJmW6FCZlY3; H_WISE_SIDS_BFESS=110085_268592_269832_269904_271169_271269_271812_272280_272461_273118_273300_273460_275940_269610_271120_276250_274502_275171_276419_276441_276572_276600_275589_276831_276985_276987_276964_270102_277313_277356_276264_277633_275188_275733; BAIDUID_BFESS=60FBCA8DBF4F3E499AAD874D85AABF9F:FG=1; BDRCVFR[bLbo9QmdyQn]=mk3SLVN4HKm; delPer=0; PSINO=5; H_PS_PSSID=39634_39648_39671_39664_39682_39676_39678_39712_39733_39740_39758; ZFY=C1sztMdYGAwYdUxZ5HRR6vVXN3v8TQAhQMgFnDurHfA:C; Hm_lvt_50e85ccdd6c1e538eb1290bc92327926=1700214719; Hm_lpvt_50e85ccdd6c1e538eb1290bc92327926=1700215474; RT=&quot;z=1&amp;dm=baidu.com&amp;si=d38ba4f2-7dbd-44e1-b182-33ddf62dd746&amp;ss=lp2fy0ex&amp;sl=1&amp;tt=1a2&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&quot;&#x27;,</span><br><span class="line">            &quot;Referer&quot;: &quot;https://talent.baidu.com/jobs/social-list?search=python&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">        self.db = pymysql.connect(user=&#x27;root&#x27;, password=&quot;123456&quot;, db=&quot;py_spider&quot;)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line"></span><br><span class="line">    def get_data(self, page):</span><br><span class="line">        data = &#123;</span><br><span class="line">            &quot;recruitType&quot;: &quot;SOCIAL&quot;,</span><br><span class="line">            &quot;pageSize&quot;: &quot;10&quot;,</span><br><span class="line">            &quot;keyWord&quot;: &quot;python&quot;,</span><br><span class="line">            &quot;curPage&quot;: page,</span><br><span class="line">            &quot;projectType&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return requests.post(self.api_url, headers=self.headers, data=data).json()</span><br><span class="line"></span><br><span class="line">    def parse_date(self, json):</span><br><span class="line">        for item in json[&#x27;data&#x27;][&#x27;list&#x27;]:</span><br><span class="line">            name = item[&#x27;name&#x27;]</span><br><span class="line">            publish_date = item[&#x27;publishDate&#x27;]</span><br><span class="line">            service_condition = item[&#x27;serviceCondition&#x27;]</span><br><span class="line"></span><br><span class="line">            # 保存数据</span><br><span class="line">            self.save_data(name, publish_date, service_condition)</span><br><span class="line"></span><br><span class="line">    def create_table(self):</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            create table if not exists job_info(</span><br><span class="line">                id int primary key auto_increment,</span><br><span class="line">                name varchar(100),</span><br><span class="line">                publish_date date,</span><br><span class="line">                service_condition text</span><br><span class="line">            );</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            print(&#x27;表创建成功...&#x27;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#x27;表创建失败:&#x27;, e)</span><br><span class="line"></span><br><span class="line">    def save_data(self, *args):</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            insert into job_info values (%s, %s, %s, %s);</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            self.cursor.execute(sql, (0, *args))</span><br><span class="line">            self.db.commit()</span><br><span class="line">            print(&quot;数据保存成功...&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;数据保存失败:&quot;, e)</span><br><span class="line">            self.db.rollback()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        self.create_table()</span><br><span class="line">        with ThreadPoolExecutor(max_workers=5) as pool:</span><br><span class="line">            futures = [pool.submit(self.get_data, page) for page in range(1, 6)]</span><br><span class="line"></span><br><span class="line">            for item in as_completed(futures):</span><br><span class="line">                json = item.result()</span><br><span class="line">                self.parse_date(json)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.db.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    baidu_work = BaiduSpider()</span><br><span class="line">    baidu_work.main()</span><br></pre></td></tr></table></figure><h3 id="3-多进程实现并发爬虫"><a href="#3-多进程实现并发爬虫" class="headerlink" title="3. 多进程实现并发爬虫"></a>3. 多进程实现并发爬虫</h3><ul><li>案例目标：使用多进程完成并发爬虫，通过 JoinableQueue 队列进行数据传递，对数据去重并将数据存入 mongodb 数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"># https://www.mgtv.com/lib/</span><br><span class="line">import redis</span><br><span class="line">import hashlib</span><br><span class="line">import pymongo</span><br><span class="line">import requests</span><br><span class="line">from multiprocessing import JoinableQueue, Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class MgTv:</span><br><span class="line">    # 在多进程中，对于数据库初始化操作必须设置为类属性</span><br><span class="line">    # 目的是确保每个子进程都共享同一个数据库连接，而不是创建各自独立的数据库连接</span><br><span class="line">    redis_cli = redis.Redis()</span><br><span class="line">    mongo_cli = pymongo.MongoClient()</span><br><span class="line">    collection = mongo_cli[&#x27;py_spider&#x27;][&#x27;mg_movie&#x27;]</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.api_url = &quot;https://pianku.api.mgtv.com/rider/list/pcweb/v3&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.params_queue = JoinableQueue()</span><br><span class="line">        self.json_queue = JoinableQueue()</span><br><span class="line">        self.data_queue = JoinableQueue()</span><br><span class="line"></span><br><span class="line">    def get_params(self):</span><br><span class="line">        for page in range(1, 6):</span><br><span class="line">            params = &#123;</span><br><span class="line">                &quot;allowedRC&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;platform&quot;: &quot;pcweb&quot;,</span><br><span class="line">                &quot;channelId&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;pn&quot;: page,</span><br><span class="line">                &quot;pc&quot;: &quot;80&quot;,</span><br><span class="line">                &quot;hudong&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_support&quot;: &quot;10000000&quot;,</span><br><span class="line">                &quot;kind&quot;: &quot;a1&quot;,</span><br><span class="line">                &quot;chargeInfo&quot;: &quot;a1&quot;,</span><br><span class="line">                &quot;sort&quot;: &quot;c2&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            self.params_queue.put(params)</span><br><span class="line"></span><br><span class="line">    def get_api_json(self):</span><br><span class="line">        while True:</span><br><span class="line">            params = self.params_queue.get()</span><br><span class="line">            response = requests.get(self.api_url, headers=self.headers, params=params)</span><br><span class="line">            self.json_queue.put(response.json())</span><br><span class="line">            self.params_queue.task_done()</span><br><span class="line"></span><br><span class="line">    def parse_movie_info(self):</span><br><span class="line">        while True:</span><br><span class="line">            json = self.json_queue.get()</span><br><span class="line">            for item in json[&#x27;data&#x27;][&#x27;hitDocs&#x27;]:</span><br><span class="line">                info = dict()</span><br><span class="line">                info[&#x27;title&#x27;] = item[&#x27;title&#x27;]</span><br><span class="line">                info[&#x27;updateInfo&#x27;] = item[&#x27;updateInfo&#x27;]</span><br><span class="line">                info[&#x27;views&#x27;] = item[&#x27;views&#x27;]</span><br><span class="line">                self.data_queue.put(info)</span><br><span class="line">            self.json_queue.task_done()</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def get_md5(info):</span><br><span class="line">        return hashlib.md5(str(info).encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line"></span><br><span class="line">    def save_movie_info(self):</span><br><span class="line">        while True:</span><br><span class="line">            data = self.data_queue.get()</span><br><span class="line">            data_md5 = self.get_md5(data)</span><br><span class="line">            if self.redis_cli.sadd(&#x27;movie:MgTv&#x27;, data_md5):</span><br><span class="line">                self.collection.insert_one(data)</span><br><span class="line">                print(&quot;数据保存成功&quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;数据重复...&quot;)</span><br><span class="line">            self.data_queue.task_done()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        # 创建进程对象列表</span><br><span class="line">        processes = list()</span><br><span class="line"></span><br><span class="line">        # 创建一个进程对象用于构造请求参数并添加到进程对象列表中</span><br><span class="line">        processes.append(Process(target=self.get_params))</span><br><span class="line"></span><br><span class="line">        # 创建五个进程对象用于发送请求并添加到进程对象列表中</span><br><span class="line">        for _ in range(5):</span><br><span class="line">            processes.append(Process(target=self.get_api_json))</span><br><span class="line"></span><br><span class="line">        # 创建一个进程对象用于数据清洗并添加到进程对象列表中</span><br><span class="line">        processes.append(Process(target=self.parse_movie_info))</span><br><span class="line"></span><br><span class="line">        # 创建一个进程对象用户数据保存并添加到进程对象列表中</span><br><span class="line">        processes.append(Process(target=self.save_movie_info))</span><br><span class="line"></span><br><span class="line">        for item in processes:</span><br><span class="line">            item.daemon = True  # 设置守护进程</span><br><span class="line">            item.start()</span><br><span class="line">            time.sleep(0.2)  # 进程的启动是需要时间的</span><br><span class="line"></span><br><span class="line">        # 阻塞主进程，直到所有队列中的所有任务完成后解堵塞</span><br><span class="line">        for que in [self.params_queue, self.json_queue, self.data_queue]:</span><br><span class="line">            que.join()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mg_tv = MgTv()</span><br><span class="line">    mg_tv.main()</span><br></pre></td></tr></table></figure><h3 id="4-用协程实现并发爬虫"><a href="#4-用协程实现并发爬虫" class="headerlink" title="4. 用协程实现并发爬虫"></a>4. 用协程实现并发爬虫</h3><ul><li><p>案例目标：使用协程完成并发爬虫下载图片，并使用 aiofile 模块异步读写文件，将图片保存到本地文件夹</p></li><li><p><strong>aiofile：是一个用于异步文件操作的 Python 模块，专门设计用于异步 I&#x2F;O 程序。它建立在 asyncio 库的基础上，提供了异步文件读写的功能。</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import aiofile</span><br><span class="line">import aiohttp</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">class WzryHero:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.json_url = &quot;https://pvp.qq.com/web201605/js/herolist.json&quot;</span><br><span class="line">        self.img_url = &quot;https://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/&#123;&#125;/&#123;&#125;-bigskin-&#123;&#125;.jpg&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    async def main(self):</span><br><span class="line">        async with aiohttp.ClientSession() as session:</span><br><span class="line">            async with session.get(self.json_url, headers=self.headers, ssl=False) as resp:</span><br><span class="line">                # 通常情况下，aiohttp 会根据响应的 Content-Type 头部字段自动选择解析方式，</span><br><span class="line">                # 将其设置为None，就是告诉 aiohttp 不要尝试解析响应的 Content-Type</span><br><span class="line">                # 即在解析响应内容时不要依赖于 Content-Type 头部字段的值，而是尝试使用 JSON 解析器解析响应的整个内容</span><br><span class="line">                json = await resp.json(content_type=None)</span><br><span class="line">                tasks = list()</span><br><span class="line">                for item in json:</span><br><span class="line">                    ename = item[&#x27;ename&#x27;]</span><br><span class="line">                    cname = item[&#x27;cname&#x27;]</span><br><span class="line">                    coro_obj = self.get_img_data(session, ename, cname)</span><br><span class="line">                    tasks.append(asyncio.create_task(coro_obj))</span><br><span class="line">                await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">    async def get_img_data(self, session, ename, cname):</span><br><span class="line">        for skin_id in range(1, 20):</span><br><span class="line">            async with session.get(self.img_url.format(ename, ename, skin_id), headers=self.headers, ssl=False) as resp:</span><br><span class="line">                # aiohttp中的响应状态码是使用status，而不是requests模块的status_code</span><br><span class="line">                if resp.status == 200:</span><br><span class="line">                    content = await resp.read()</span><br><span class="line">                    async with aiofile.async_open(&#x27;./images/&#x27; + cname + &#x27;-&#x27; + str(skin_id) + &#x27;.jpg&#x27;, &#x27;wb&#x27;) as afp:</span><br><span class="line">                        await afp.write(content)</span><br><span class="line">                    print(&quot;下载成功&quot;)</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if not os.path.exists(&#x27;./images&#x27;):</span><br><span class="line">        os.mkdir(&#x27;./images&#x27;)</span><br><span class="line">    hero = WzryHero()</span><br><span class="line">    asyncio.run(hero.main())</span><br></pre></td></tr></table></figure><h2 id="八、selenium测试框架"><a href="#八、selenium测试框架" class="headerlink" title="八、selenium测试框架"></a>八、selenium测试框架</h2><blockquote><p><strong>安装selenium限定框架版本为4.9.1：<code>pip install selenium==4.9.1</code></strong></p><ul><li><p>驱动下载地址（关闭代理才能下载）：</p><ul><li><a class="link"   href="https://googlechromelabs.github.io/chrome-for-testing/"  target="_blank" rel="noopener">谷歌驱动下载地址<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/mozilla/geckodriver/releases"  target="_blank" rel="noopener">火狐驱动下载地址<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p>驱动下载完成后将文件移动到系统环境变量中：</p><ul><li>MacOS：将文件移动到 &#x2F;use&#x2F;local&#x2F;bin 目录</li><li>Windows：将文件移动到 miniconda3 安装目录</li></ul></li><li><p>在 macOS 上禁止 Chrome 自动更新（<strong>以下方法全部在第二天失效</strong>）：</p><ul><li>停止了检查更新的频率：<code>defaults write com.google.Keystone.Agent checkInterval 0</code></li><li>删除谷歌更新代理的执行文件：在 &#x2F;Library&#x2F;Google&#x2F; 中直接删除文件夹 GoogleSoftwareUpdate</li><li>在 CleanMyMac 的优化中移除或禁用谷歌更新相关的代理</li><li>在任何情况下，不要点击<code>关于Google Chrome</code>的按钮，否则直接自动更新</li></ul></li></ul></blockquote><h3 id="1-基本网页使用"><a href="#1-基本网页使用" class="headerlink" title="1. 基本网页使用"></a>1. 基本网页使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line"># 创建一个Chrome浏览器实例，并打开一个页面</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line"># 1. 截取当前页面的屏幕并保存为&quot;截屏图片.png&quot;，最好等页面加载完成后截屏</span><br><span class="line">time.sleep(1)</span><br><span class="line">browser.save_screenshot(&quot;截屏图片.png&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 在原有的标签页中重新访问一个新的网址</span><br><span class="line">browser.get(&quot;https://www.jd.com&quot;)</span><br><span class="line"></span><br><span class="line"># 3. 页面前进与页面后退</span><br><span class="line">browser.back()  # 页面后退</span><br><span class="line">browser.forward()  # 页面前进</span><br><span class="line"></span><br><span class="line"># 4. 执行js脚本在新标签页中访问一个新的网址</span><br><span class="line">browser.execute_script(&quot;window.open(&#x27;https://xfblog.cn&#x27;)&quot;)</span><br><span class="line"></span><br><span class="line"># 5. 切换标签页，先切到标签页1，再切回标签页2</span><br><span class="line">browser.switch_to.window(browser.window_handles[0])</span><br><span class="line">browser.switch_to.window(browser.window_handles[1])</span><br><span class="line"># browser.switch_to.frame(iframe)  # 切入到iframe子页面中</span><br><span class="line"></span><br><span class="line"># 6. 页面滚动，大部分网站数据是动态数据，需要触发 ajax 请求后才能在页面中进行数据渲染</span><br><span class="line">for _ in range(1, 11):</span><br><span class="line">    browser.execute_script(&quot;window.scrollBy(0, 200)&quot;)</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"># 7. 关闭当前所在的标签页，当只有一个标签页时就是退出浏览器</span><br><span class="line">browser.close()</span><br><span class="line"></span><br><span class="line"># 8. 退出浏览器</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><h3 id="2-获取请求相关信息"><a href="#2-获取请求相关信息" class="headerlink" title="2. 获取请求相关信息"></a>2. 获取请求相关信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line"># 获取当前页面的源代码（selenium获取到的是动态数据渲染好的页面）</span><br><span class="line">html = browser.page_source</span><br><span class="line">print(type(html))  # `&lt;class &#x27;str&#x27;&gt;`</span><br><span class="line"></span><br><span class="line"># 获取cookies</span><br><span class="line">cookies = browser.get_cookies()</span><br><span class="line">print(cookies)</span><br><span class="line"></span><br><span class="line"># 获取经过处理之后，页面最后显示的url（如果有302的话，那么就是302之后的url）</span><br><span class="line">time.sleep(2)</span><br><span class="line">browser.get(&quot;https://www.360buy.com&quot;)  # 在原有标签页中重新访问新网址</span><br><span class="line">url = browser.current_url</span><br><span class="line">print(url)  # https://www.jd.com/</span><br></pre></td></tr></table></figure><h3 id="3-元素定位方法"><a href="#3-元素定位方法" class="headerlink" title="3. 元素定位方法"></a>3. 元素定位方法</h3><ul><li>**find_element()**：用于定位匹配给定选择器表达式的第一个元素，返回一个WebElements对象</li><li>**find_elements()**：用于定位匹配给定选择器表达式的所有元素，返回一个WebElements对象的列表<ul><li>获取文本：<strong>element.text</strong></li><li>获取属性值：<strong>element.get_attribute(“href”)</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(&quot;https://news.baidu.com/&quot;)</span><br><span class="line"></span><br><span class="line"># 定位单个对象，返回一个WebElement对象</span><br><span class="line">element_obj1 = browser.find_element(By.ID, &quot;ww&quot;)</span><br><span class="line">element_obj2 = browser.find_element(By.CSS_SELECTOR, &quot;.word&quot;)</span><br><span class="line">element_obj3 = browser.find_element(By.XPATH, &quot;//input[@id=&#x27;ww&#x27;]&quot;)</span><br><span class="line">print(element_obj1 == element_obj2 == element_obj3)  # True</span><br><span class="line"># LINK_TEXT要求链接文本完全匹配，而PARTIAL_LINK_TEXT只需要部分匹配（查找对象必须是超链接）</span><br><span class="line">element_obj4 = browser.find_element(By.LINK_TEXT, &quot;热点要闻&quot;)</span><br><span class="line">element_obj5 = browser.find_element(By.PARTIAL_LINK_TEXT, &quot;热点要&quot;)</span><br><span class="line">print(element_obj4 == element_obj5)  # True</span><br><span class="line"></span><br><span class="line"># 定位热点要闻（多个），返回包含多个WebElement对象的列表</span><br><span class="line">element_objs = browser.find_elements(By.XPATH, &quot;//div[@class=&#x27;hotnews&#x27;]//li&quot;)</span><br><span class="line">for item in element_objs:</span><br><span class="line">    print(item.get_attribute(&#x27;class&#x27;))</span><br><span class="line">    print(item.text)</span><br></pre></td></tr></table></figure><h3 id="4-cookie信息处理"><a href="#4-cookie信息处理" class="headerlink" title="4. cookie信息处理"></a>4. cookie信息处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(&quot;https://www.baidu.com/&quot;)</span><br><span class="line"></span><br><span class="line"># 通过selenium控制浏览器请求获得的是服务器响应设置的完整cookies信息（包含多个字段），</span><br><span class="line"># 这与requests模块中 response.cookies.get_dict() 所获取的set-cookie信息不同，</span><br><span class="line"># 并且浏览器在发送新请求时携带的cookie也只需要name和value字段，</span><br><span class="line"># 所以这里需要将cookies整理为requests等请求需要的只包含 name 和 value 字段的字典格式</span><br><span class="line">cookies = browser.get_cookies()</span><br><span class="line"></span><br><span class="line"># 通过字典生成式直接生成</span><br><span class="line">cookie_dict = &#123;item[&#x27;name&#x27;]: item[&#x27;value&#x27;] for item in cookies&#125;</span><br><span class="line">print(cookie_dict)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">cookie设置：browser.add_cookie(&#123;name: &#x27;xfblog&#x27;&#125;)</span><br><span class="line">cookie删除：browser.delete_cookie(&#x27;name&#x27;)，browser.delete_all_cookies()</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="5-WebDriverWait等待"><a href="#5-WebDriverWait等待" class="headerlink" title="5. WebDriverWait等待"></a>5. WebDriverWait等待</h3><ul><li><strong>WebDriverWait：</strong>是Selenium库中的一个类，用于实现<strong>显式等待</strong>。显式等待是指在查找元素或执行某些操作之前，显式地等待某个特定条件的发生。与隐式等待不同，显式等待仅适用于特定的操作，而不是整个页面</li><li><strong>使用：</strong>使用 WebDriverWait 通常需要配合 expected_conditions 模块，它包含了一系列可以用于等待的条件，例如元素可见、元素存在、元素可点击等（<strong>以下方法参数接受一个元组</strong>）<ul><li><strong>等待元素可见：<code>EC.visibility_of_element_located()</code></strong></li><li><strong>等待元素存在：<code>EC.presence_of_element_located()</code></strong></li><li><strong>等待元素可点击：&#96;&#96;EC.element_to_be_clickable()&#96;</strong></li><li><strong>等待文本出现在元素中：<code>EC.text_to_be_present_in_element()</code></strong></li></ul></li><li><strong>隐式等待：</strong>是Selenium提供的一种等待机制，适用于 WebDriver 实例的整个生命周期  **<code>browser.implicitly_wait(10)</code>**。一旦设置了隐式等待，它将在后续的所有查找操作中生效，直到WebDriver实例关闭。这使得代码中不必在每个查找操作前都显式地等待元素出现，但隐式等待并不是对所有操作都有效，它主要影响 find_element 方法。对于一些异步加载的元素或 JavaScript 动态渲染的内容，隐式等待可能不如显式等待精确和灵活</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">class LoginEmail:</span><br><span class="line">    def __init__(self, email, password):</span><br><span class="line">        self.browser = webdriver.Chrome()</span><br><span class="line">        self.wait_ob = WebDriverWait(self.browser, timeout=5)</span><br><span class="line">        self.url = &quot;https://mail.163.com/&quot;</span><br><span class="line">        self.email = email</span><br><span class="line">        self.password = password</span><br><span class="line"></span><br><span class="line">    def open_email(self):</span><br><span class="line">        self.browser.get(self.url)</span><br><span class="line"></span><br><span class="line">    def login_email(self):</span><br><span class="line">        # 使用WebDriverWait等待iframe可用并切换到它，等价于不用等待的以下用法：</span><br><span class="line">        # iframe = self.browser.find_element(By.XPATH, &quot;//div[@id=&#x27;loginDiv&#x27;]/iframe&quot;)</span><br><span class="line">        # self.browser.switch_to.frame(iframe)  # 切入到iframe子页面中</span><br><span class="line">        self.wait_ob.until(</span><br><span class="line">            EC.frame_to_be_available_and_switch_to_it((By.XPATH, &quot;//div[@id=&#x27;loginDiv&#x27;]/iframe&quot;)))</span><br><span class="line"></span><br><span class="line">        input_user = self.wait_ob.until(EC.presence_of_element_located((By.XPATH, &quot;//input[@name=&#x27;email&#x27;]&quot;)))</span><br><span class="line">        input_pass = self.wait_ob.until(EC.presence_of_element_located((By.XPATH, &quot;//input[@name=&#x27;password&#x27;]&quot;)))</span><br><span class="line">        login_button = self.wait_ob.until(EC.presence_of_element_located((By.ID, &quot;dologin&quot;)))</span><br><span class="line"></span><br><span class="line">        input_user.send_keys(self.email)</span><br><span class="line">        input_pass.send_keys(self.password)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        login_button.click()</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        time.sleep(6)  # 成功登录后，等待跳转至邮箱页面</span><br><span class="line">        self.browser.quit()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        self.open_email()</span><br><span class="line">        self.login_email()</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    login = LoginEmail(&quot;&quot;, &quot;&quot;)</span><br><span class="line">    login.main()</span><br></pre></td></tr></table></figure><h3 id="6-绕过检测配置"><a href="#6-绕过检测配置" class="headerlink" title="6. 绕过检测配置"></a>6. 绕过检测配置</h3><blockquote><p><strong>问题：</strong>默认情况下Selenium在加载页面时，根据正常的加载策略，会将页面及其所有静态资源都下载完（如css、图片、js等）</p><p><strong>解决：修改WebDriver的页面加载策略</strong></p><ul><li><strong>normal （默认）：</strong>等待所有内容加载完成，包括静态资源文件、css、js等</li><li><strong>eager：</strong>等待初始HTML文档完全加载和解析，并放弃css、图像和子框架等的加载</li><li><strong>none：</strong>仅等待初始页面下载，即进行操作</li></ul></blockquote><ul><li><strong>绕过检测：</strong>通常是指网站使用一些手段来检测自动化工具（Selenium）并采取一些措施阻止自动化脚本的执行。在使用Selenium时，有一些配置项可以尽量隐藏浏览器驱动的信息，以减少被检测的概率</li><li><strong>无头浏览器运行：<code>options.add_argument(&#39;--headless&#39;)</code></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line"># 1. 禁用Chrome的Blink渲染引擎中相关的自动化特性，目的是减少被自动化工具检测到的概率</span><br><span class="line">options.add_argument(&#x27;--disable-blink-features=AutomationControlled&#x27;)</span><br><span class="line"></span><br><span class="line"># 2. 更改User-Agent</span><br><span class="line">options.add_argument(</span><br><span class="line">    &quot;user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&quot;)</span><br><span class="line"></span><br><span class="line"># 3. 禁用浏览器扩展，减少了浏览器的标识，使其更难以被网站检测到</span><br><span class="line">options.add_argument(&quot;--disable-extensions&quot;)</span><br><span class="line"></span><br><span class="line"># 4. 禁用图片加载，有些检测机制可能通过检查图片加载行为来判断是否使用了自动化工具</span><br><span class="line">options.add_argument(&quot;--blink-settings=imagesEnabled=false&quot;)</span><br><span class="line">&quot;&quot;&quot;以下也可以禁用图片加载：</span><br><span class="line">prefs = &#123;&quot;profile.managed_default_content_settings.images&quot;: 2&#125;</span><br><span class="line">options.add_experimental_option(&#x27;prefs&#x27;, prefs)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 5. 禁用浏览器提示，如是否保存密码、是否允许通知等，这些提示可能包含了一些浏览器的信息</span><br><span class="line">options.add_argument(&quot;--disable-infobars&quot;)</span><br><span class="line"></span><br><span class="line"># 6. 禁用自动化标志和扩展（隐藏开发者警告）</span><br><span class="line">options.add_experimental_option(&quot;excludeSwitches&quot;, [&quot;enable-automation&quot;])</span><br><span class="line">options.add_experimental_option(&#x27;useAutomationExtension&#x27;, False)</span><br><span class="line"></span><br><span class="line"># 7. 使用代理IP，切换IP地址可能有助于绕过一些检测机制</span><br><span class="line">options.add_argument(&#x27;--proxy-server=http://127.0.0.1:7890&#x27;)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(&quot;https://bot.sannysoft.com/&quot;)</span><br><span class="line">time.sleep(10)</span><br></pre></td></tr></table></figure><h3 id="7-ActionChains动作链"><a href="#7-ActionChains动作链" class="headerlink" title="7. ActionChains动作链"></a>7. ActionChains动作链</h3><ul><li><p><strong>ActionChains：</strong>是 Selenium 中的一个类，它提供了一种用于处理一系列连续的、复杂的用户输入操作的方式，例如鼠标移动、点击、拖拽、键盘输入等，可以模拟用户在浏览器中的真实行为，执行多个动作的组合</p></li><li><p><strong>常用动作方法：</strong></p><ol><li>**click_and_hold()**：鼠标单击并按住不放</li><li>**pause()**：暂停一段时间，单位为秒</li><li>**wait()**：等待某个条件成立，比如等待元素出现或消失，或者等待某个属性变化</li><li>**drag_and_drop()**：将源元素拖拽到目标元素的位置</li><li>**drag_and_drop_by_offset()**：将元素拖拽到指定的坐标位置</li><li>**move_by_offset()**：将鼠标移动到指定的坐标位置</li><li>**move_to_element_with_offset()**：将鼠标移动到指定元素的偏移位置</li><li>**release()**：释放鼠标操作</li><li>**perform()**：执行ActionChains中所有动作，通常在最后调用</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver import ActionChains</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(&quot;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;)</span><br><span class="line"></span><br><span class="line">wait_ob = WebDriverWait(browser, timeout=5)</span><br><span class="line">wait_ob.until(EC.frame_to_be_available_and_switch_to_it((By.XPATH, &quot;//iframe[@id=&#x27;iframeResult&#x27;]&quot;)))</span><br><span class="line">div_1 = wait_ob.until(EC.element_to_be_clickable((By.XPATH, &quot;//div[@id=&#x27;draggable&#x27;]&quot;)))</span><br><span class="line">div_2 = wait_ob.until(EC.element_to_be_clickable((By.XPATH, &quot;//div[@id=&#x27;droppable&#x27;]&quot;)))</span><br><span class="line"></span><br><span class="line">action = ActionChains(browser)</span><br><span class="line">action.drag_and_drop(div_1, div_2)</span><br><span class="line">action.perform()  # 执行动作链</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure><h3 id="8-selenium异常处理"><a href="#8-selenium异常处理" class="headerlink" title="8. selenium异常处理"></a>8. selenium异常处理</h3><ul><li><strong>selenium异常处理：</strong>虽然 Selenium 中的异常是继承自 Python 中的 Exception 类的，但是它们不仅仅是 Python 标准异常的简单子类，还包含了一些 Selenium 自定义的特定异常类（例如 <code>NoSuchElementException</code>、<code>TimeoutException</code> 等）。因此，<strong>不能使用 Python 中的通用异常类 Exception 来捕获 Selenium 中的某些特定异常，需要导入 Selenium 中特定的异常类进行捕获</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.common.exceptions import TimeoutException, NoSuchElementException</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"># 设置页面加载超时时间为3秒</span><br><span class="line">browser.set_page_load_timeout(3)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    browser.get(&quot;https://www.google.com&quot;)</span><br><span class="line">except TimeoutException as e:</span><br><span class="line">    print(f&quot;页面加载超时：&#123;e&#125;&quot;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">页面加载超时：Message: timeout: Timed out receiving message from renderer: -0.005</span><br><span class="line">  (Session info: chrome=119.0.6045.159)</span><br><span class="line">Stacktrace:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    browser.find_element(By.ID, &quot;abc&quot;)</span><br><span class="line">except NoSuchElementException as e:</span><br><span class="line">    print(f&quot;元素没找到：&#123;e&#125;&quot;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">元素没找到：Message: no such element: Unable to locate element: &#123;&quot;method&quot;:&quot;css selector&quot;,&quot;selector&quot;:&quot;[id=&quot;abc&quot;]&quot;&#125;</span><br><span class="line">  (Session info: chrome=119.0.6045.159)</span><br><span class="line">Stacktrace:</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="9-唯品会数据采集"><a href="#9-唯品会数据采集" class="headerlink" title="9. 唯品会数据采集"></a>9. 唯品会数据采集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">from pymongo import MongoClient</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line"></span><br><span class="line">class Wpshop:</span><br><span class="line">    # MongoDB 客户端和集合初始化</span><br><span class="line">    mongo_cli = MongoClient()</span><br><span class="line">    collection = mongo_cli[&#x27;py_spider&#x27;][&#x27;wp_shop&#x27;]</span><br><span class="line"></span><br><span class="line">    # 配置 Chrome 浏览器选项</span><br><span class="line">    options = webdriver.ChromeOptions()</span><br><span class="line">    options.add_argument(&quot;--blink-settings=imagesEnabled=false&quot;)  # 禁止图片加载</span><br><span class="line"></span><br><span class="line">    # 初始化 Chrome 浏览器和等待对象</span><br><span class="line">    browser = webdriver.Chrome(options=options)</span><br><span class="line">    wait_ob = WebDriverWait(browser, timeout=5)</span><br><span class="line"></span><br><span class="line">    def index_html(self):</span><br><span class="line">        # 打开首页，搜索输入框输入关键字 &quot;口红&quot;，点击搜索按钮</span><br><span class="line">        self.browser.get(&quot;https://www.vip.com/&quot;)</span><br><span class="line">        search_input = self.wait_ob.until(EC.presence_of_element_located((By.XPATH, &quot;//div[@id=&#x27;J-search&#x27;]/div/input&quot;)))</span><br><span class="line">        search_input.send_keys(&quot;口红&quot;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        search_btn = self.wait_ob.until(EC.element_to_be_clickable((By.XPATH, &quot;//div[@id=&#x27;J-search&#x27;]/div/a&quot;)))</span><br><span class="line">        search_btn.click()</span><br><span class="line"></span><br><span class="line">        # 当前页面成功获取之后建议延迟两秒，让浏览器滚动</span><br><span class="line">        time.sleep(2)</span><br><span class="line"></span><br><span class="line">    # 页面滚动</span><br><span class="line">    def drop_down(self):</span><br><span class="line">        # 控制滚动12次，差一点到底部，直接滑动到底部可能被反爬</span><br><span class="line">        for i in range(1, 12):</span><br><span class="line">            self.browser.execute_script(f&#x27;document.documentElement.scrollTop = &#123;i * 1000&#125;&#x27;)</span><br><span class="line">            time.sleep(1.5 + random.random())  # 每次滑动等待一定时间，因为数据可能通过ajax继续加载更多出来</span><br><span class="line"></span><br><span class="line">    # 商品数据解析</span><br><span class="line">    def parse_data(self):</span><br><span class="line">        self.drop_down()</span><br><span class="line">        # xpath解析出包含data-product-id属性的div标签</span><br><span class="line">        div_list = self.browser.find_elements(By.XPATH, &quot;//section[@id=&#x27;J_searchCatList&#x27;]/div[@data-product-id]&quot;)</span><br><span class="line">        for item in div_list:</span><br><span class="line">            # xpath解析出class属性contains包含部分值的div标签</span><br><span class="line">            title = item.find_element(By.XPATH, &#x27;.//div[contains(@class, &quot;c-goods-item__name  c-goods-item__name&quot;)]&#x27;)</span><br><span class="line">            price = item.find_element(By.XPATH, &#x27;.//div[@class=&quot;c-goods-item__sale-price J-goods-item__sale-price&quot;]&#x27;)</span><br><span class="line">            data_item = &#123;</span><br><span class="line">                &#x27;title&#x27;: title.text,</span><br><span class="line">                &#x27;price&#x27;: price.text</span><br><span class="line">            &#125;</span><br><span class="line">            print(data_item)</span><br><span class="line">            self.save_mongo(data_item)</span><br><span class="line">        self.next_page()</span><br><span class="line"></span><br><span class="line">    # 翻页控制</span><br><span class="line">    def next_page(self):</span><br><span class="line">        try:</span><br><span class="line">            # 等待下一页按钮可点击</span><br><span class="line">            next_button = self.browser.find_element(By.XPATH, &#x27;//a[@id=&quot;J_nextPage_link&quot;]&#x27;)</span><br><span class="line">            next_button.click()</span><br><span class="line">            self.parse_data()</span><br><span class="line">        except NoSuchElementException as e:  # 最后一页没有下一页的按钮</span><br><span class="line">            print(f&quot;最后一页了：&#123;e&#125;&quot;)</span><br><span class="line">            self.browser.quit()</span><br><span class="line"></span><br><span class="line">    # 将商品信息存入 MongoDB 数据库</span><br><span class="line">    def save_mongo(self, data):</span><br><span class="line">        self.collection.insert_one(data)</span><br><span class="line"></span><br><span class="line">    # 主程序入口</span><br><span class="line">    def main(self):</span><br><span class="line">        self.index_html()</span><br><span class="line">        self.parse_data()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    wp_shop = Wpshop()</span><br><span class="line">    wp_shop.main()</span><br></pre></td></tr></table></figure><h3 id="10-pyppeteer框架"><a href="#10-pyppeteer框架" class="headerlink" title="10. pyppeteer框架"></a>10. pyppeteer框架</h3><blockquote><p><strong>注意：无论使用什么测试框架，只要涉及到浏览器，就已经与速度告别了，永远不可能比直接请求协议快</strong></p></blockquote><ul><li><strong>pyppeteer：</strong>是 Python 中的一个库，用于使用 Headless Chrome 浏览器进行无头浏览器测试和网页爬取。它是 Puppeteer 的 Python 版本，Puppeteer 是一个由 Google 提供的 Node.js 库，专门用于控制无头 Chrome 或 Chromium 浏览器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要设置显示内容的宽度、高度</span></span><br><span class="line">width, height = <span class="number">1366</span>, <span class="number">768</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pypeteer不用配置浏览器驱动，它会自动下载Chromium用于测试</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    `headless=False`：开启浏览器界面</span></span><br><span class="line"><span class="string">    `devtools=True`：开启浏览器开发工具</span></span><br><span class="line"><span class="string">    `userDataDir=&quot;./userdata&quot;`：数据持久化</span></span><br><span class="line"><span class="string">    `args=[&#x27;--disable-infobars&#x27;]`：禁用提示条</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(</span><br><span class="line">        headless=<span class="literal">False</span>,</span><br><span class="line">        devtools=<span class="literal">False</span>,</span><br><span class="line">        userDataDir=<span class="string">&quot;./userdata&quot;</span>,</span><br><span class="line">        <span class="comment"># 禁用提示条，同时绕过检测</span></span><br><span class="line">        args=[<span class="string">&#x27;--disable-infobars&#x27;</span>, <span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>],</span><br><span class="line">    )</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="comment"># 设置显示界面与浏览器窗口大小一致</span></span><br><span class="line">    <span class="keyword">await</span> page.setViewport(&#123;<span class="string">&#x27;width&#x27;</span>: width, <span class="string">&#x27;height&#x27;</span>: height&#125;)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://bot.sannysoft.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 屏幕截图</span></span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;example.png&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h2 id="九、IP代理池"><a href="#九、IP代理池" class="headerlink" title="九、IP代理池"></a>九、IP代理池</h2><blockquote><p><strong>开放代理（Public Proxy）：</strong>这类代理服务器是公开的，任何人都可以免费或者付费使用，可以快速获取。通常，开放代理服务器的 IP 地址和端口号是公开的，并且不限制访问。由于是公开的，被滥用的可能性较大。速度和稳定性大不如私密代理或独享代理。</p><p><strong>私密代理（Shared Proxy）：</strong>私密代理是由多个用户共享的，但是相对于开放代理，使用者需要经过认证，并且通常会提供更高的速度和稳定性。拥有相对较好的速度和稳定性，适用于一些对质量要求较高的场景。</p><p><strong>独享代理（Dedicated Proxy）：</strong>独享代理是由单个用户独享的，用户可以完全控制代理的使用。通常，这类代理的 IP 提供更高的隐私和稳定性，适用于需要保密性和高可用性的场景。但通常费用较高，相对于开放代理和私密代理来说，成本更高。</p></blockquote><h3 id="1-免费代理采集脚本"><a href="#1-免费代理采集脚本" class="headerlink" title="1. 免费代理采集脚本"></a>1. 免费代理采集脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import pymongo</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">class FreeProxy:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url = &quot;https://proxy.ip3366.net/free/?action=china&amp;page=&#123;&#125;&quot;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">        self.mongo_cli = pymongo.MongoClient()</span><br><span class="line">        self.collection = self.mongo_cli[&#x27;py_spider&#x27;][&#x27;ip_port&#x27;]</span><br><span class="line"></span><br><span class="line">    def get_proxy(self, page):</span><br><span class="line">        response = requests.get(self.url.format(page), headers=self.headers).text</span><br><span class="line">        proxy_list = re.findall(r&#x27;.*?IP&quot;&gt;(.*?)&lt;/td&gt;.*?PORT&quot;&gt;(.*?)&lt;/td&gt;&#x27;, response, re.S)</span><br><span class="line">        for item in proxy_list:</span><br><span class="line">            proxy_info = dict()</span><br><span class="line">            proxy_info[&#x27;http&#x27;] = f&quot;http://&#123;item[0]&#125;:&#123;item[1]&#125;&quot;</span><br><span class="line">            proxy_info[&#x27;https&#x27;] = f&quot;https://&#123;item[0]&#125;:&#123;item[1]&#125;&quot;</span><br><span class="line"></span><br><span class="line">            self.test_ip(proxy_info)</span><br><span class="line"></span><br><span class="line">    def test_ip(self, proxy_info):</span><br><span class="line">        try:</span><br><span class="line">            response = requests.get(&quot;http://httpbin.org/ip&quot;, proxies=proxy_info, timeout=3)</span><br><span class="line">            if response.status_code == 200:</span><br><span class="line">                self.collection.insert_one(proxy_info)</span><br><span class="line">            print(f&quot;代理 &#123;proxy_info&#125; 可用&quot;)</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        with ThreadPoolExecutor(max_workers=10) as pool:</span><br><span class="line">            futures = [pool.submit(self.get_proxy, page) for page in range(1, 11)]</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    fp = FreeProxy()</span><br><span class="line">    fp.main()</span><br></pre></td></tr></table></figure><h3 id="2-付费代理的使用"><a href="#2-付费代理的使用" class="headerlink" title="2. 付费代理的使用"></a>2. 付费代理的使用</h3><ul><li>快代理：<a class="link"   href="https://www.kuaidaili.com/"  target="_blank" rel="noopener">https://www.kuaidaili.com/<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="3-亚马逊数据采集"><a href="#3-亚马逊数据采集" class="headerlink" title="3. 亚马逊数据采集"></a>3. 亚马逊数据采集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">import pymysql</span><br><span class="line">import requests</span><br><span class="line">import retrying</span><br><span class="line">from queue import Queue</span><br><span class="line">from loguru import logger</span><br><span class="line">from feapder.network.user_agent import get  # User-Agent池</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">class Amazon:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.db = pymysql.connect(user=&quot;root&quot;, password=&#x27;123456&#x27;, db=&#x27;py_spider&#x27;)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line">        self.menu_url = &quot;https://www.amazon.cn/nav/ajax/hamburgerMainContent?ajaxTemplate=hamburgerMainContent&amp;pageType=Gateway&amp;hmDataAjaxHint=1&amp;navDeviceType=desktop&amp;isSmile=0&amp;isPrime=0&amp;isBackup=false&amp;hashCustomerAndSessionId=4c2b8b7d251e031f867340dd748fdc203954406c&amp;languageCode=zh_CN&amp;environmentVFI=AmazonNavigationCards%2Fdevelopment-nov13patch%40B6165608796-AL2_x86_64&amp;secondLayerTreeName=apparel_shoes%2Bcomputer_office%2Bhome_kitchen%2Bbeauty_pca%2Bsports_outdoor%2Bgrocery%2Bbaby_toy%2Bphones_elec%2Bjewelry_watch%2Bhome_improvement%2Bvideo_game%2Bmusical_instrument%2Bcamera&amp;customerCountryCode=null&quot;</span><br><span class="line">        # 加其余验证参数主要是为了请求商品具体信息时使用</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">            &quot;Referer&quot;: &quot;https://www.amazon.cn&quot;,</span><br><span class="line">            &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;,</span><br><span class="line">            &quot;downlink&quot;: &quot;10&quot;,</span><br><span class="line">            &quot;ect&quot;: &quot;4g&quot;,</span><br><span class="line">            &quot;rtt&quot;: &quot;200&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">        # 付费ip代理的api链接</span><br><span class="line">        self.ip_url = &quot;&quot;</span><br><span class="line">        # 付费ip地址队列</span><br><span class="line">        self.ip_queue = Queue()</span><br><span class="line"></span><br><span class="line">        # 商品分类对应所有商品数据的地址队列</span><br><span class="line">        self.classify_url_queue = Queue()</span><br><span class="line">        # 商品详情数据地址队列</span><br><span class="line">        self.detail_url_queue = Queue()</span><br><span class="line">        # 商品数据队列</span><br><span class="line">        self.shop_info_queue = Queue()</span><br><span class="line"></span><br><span class="line">    # 获取代理ip并上传到ip队列</span><br><span class="line">    def get_ip(self):</span><br><span class="line">        while True:</span><br><span class="line">            # 判断当前队列是否为空, 为空则获取ip</span><br><span class="line">            if self.ip_queue.empty():</span><br><span class="line">                ips = requests.get(self.ip_url).json()</span><br><span class="line">                for ip in ips:</span><br><span class="line">                    self.ip_queue.put(ip)</span><br><span class="line">            else:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">    # 全局通用发起请求，使用随机UA和代理ip，抛出异常则重试3次</span><br><span class="line">    @retrying.retry(stop_max_attempt_number=3)</span><br><span class="line">    def request_data(self, url):</span><br><span class="line">        &quot;&quot;&quot;主要访问菜单api并返回api中的分类数据&quot;&quot;&quot;</span><br><span class="line">        ip = self.ip_queue.get()</span><br><span class="line">        proxies = &#123;</span><br><span class="line">            &#x27;http&#x27;: &#x27;http://&#x27; + ip,</span><br><span class="line">            &#x27;https&#x27;: &#x27;https://&#x27; + ip</span><br><span class="line">        &#125;</span><br><span class="line">        self.headers[&#x27;User-Agent&#x27;] = get()</span><br><span class="line">        response = requests.get(url, headers=self.headers, proxies=proxies, verify=False, timeout=2)</span><br><span class="line">        # 代理ip重用</span><br><span class="line">        if response.status_code == 200:</span><br><span class="line">            self.ip_queue.put(ip)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;状态码异常:&#x27;, ip)</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">    # 获取分类数据中的node参数，并构造商品分类对应所有商品数据的地址队列</span><br><span class="line">    def get_classify_url(self):</span><br><span class="line">        try:</span><br><span class="line">            response = self.request_data(self.menu_url).text</span><br><span class="line">        except Exception as e:</span><br><span class="line">            logger.error(f&quot;请求菜单 &#123;self.menu_url&#125; 异常：&#123;e&#125; &quot;)</span><br><span class="line">        else:</span><br><span class="line">            node_list = re.findall(r&#x27;&lt;a.*?node=(?!1478512071|1484186071|865184051)(.*?)&amp;.*?&lt;/a&gt;&#x27;, response, re.S)</span><br><span class="line">            for node in node_list:</span><br><span class="line">                self.classify_url_queue.put(f&quot;https://www.amazon.cn/s?rh=n%3A&#123;node&#125;&amp;fs=true&quot;)</span><br><span class="line"></span><br><span class="line">    # 重试获取最大页数，亚马逊有一定的反爬，导致部分链接的最大页数是获取不到的</span><br><span class="line">    @retrying.retry(stop_max_attempt_number=10)</span><br><span class="line">    def get_max_page(self, classify_url):</span><br><span class="line">        try:</span><br><span class="line">            response = self.request_data(classify_url).text</span><br><span class="line">        except Exception as e:</span><br><span class="line">            logger.error(f&quot;请求分类 &#123;classify_url&#125; 异常：&#123;e&#125; &quot;)</span><br><span class="line">        else:</span><br><span class="line">            max_page = re.findall(r&#x27;true&quot;&gt;(\d&#123;1,3&#125;)&lt;/span&gt;&lt;a.*?aria-label=&quot;转到下一页&#x27;, response, re.S)</span><br><span class="line">            if not max_page:</span><br><span class="line">                print(f&quot;。。。正在重试获取最大页数：&#123;classify_url&#125;&quot;)</span><br><span class="line">                raise Exception(classify_url)</span><br><span class="line">            return max_page[0]  # re.findall返回值为列表，重试过后</span><br><span class="line"></span><br><span class="line">    # 根据classify_url_queue地址，循环翻页，构造每个商品的详情数据地址队列</span><br><span class="line">    def get_detail_url(self):</span><br><span class="line">        while True:</span><br><span class="line">            classify_url = self.classify_url_queue.get()</span><br><span class="line">            try:</span><br><span class="line">                max_page = self.get_max_page(classify_url)</span><br><span class="line">                print(classify_url, max_page)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                # 情况1：重试10次后，获取最大页数依然失败了，重试过后max_page值依然是空列表</span><br><span class="line">                # 情况2：所有商品数据只有一页的情况，也会重试并产生空列表</span><br><span class="line">                max_page = 1  # 如果失败抛出异常则将max_page赋值为1，否则只有成功的时候finally中的max_page才有值</span><br><span class="line">                logger.error(f&quot;获取最大页数失败：&#123;e&#125;&quot;)</span><br><span class="line">            finally:  # 如果使用else，那么获取最大页数成功的时候就不会走下面的逻辑</span><br><span class="line">                for page in range(1, int(max_page) + 1):</span><br><span class="line">                    # 这里不需要进行异常捕获，因为在获取这页数据时，被反爬则会返回一个没用的页面，不会抛出异常</span><br><span class="line">                    resp = self.request_data(classify_url + f&quot;&amp;page=&#123;page&#125;&quot;).text</span><br><span class="line">                    detail_url_list = re.findall(r&#x27;&lt;a.*?a-link-normal s-no-outline&quot;.*?href=&quot;(.*?)&quot;&gt;&lt;div&#x27;, resp, re.S)</span><br><span class="line">                    for detail in detail_url_list:</span><br><span class="line">                        detail_url = &quot;https://www.amazon.cn&quot; + detail</span><br><span class="line">                        self.detail_url_queue.put(detail_url)</span><br><span class="line">                self.classify_url_queue.task_done()</span><br><span class="line"></span><br><span class="line">    # 根据detail_url_queue商品的详情数据地址，拿到商品详情数据并进行数据清洗</span><br><span class="line">    def parse_shop_info(self):</span><br><span class="line">        while True:</span><br><span class="line">            detail_url = self.detail_url_queue.get()</span><br><span class="line">            response = self.request_data(detail_url).text</span><br><span class="line">            try:</span><br><span class="line">                if re.search(r&quot;a-price-range&quot;, response):</span><br><span class="line">                    match = re.findall(r&#x27;a-offscreen&quot;&gt;(¥.*?)&lt;/span&gt;&#x27;, response)</span><br><span class="line">                    price = match[0] + &#x27;-&#x27; + match[1]</span><br><span class="line">                    title = re.findall(r&#x27;&lt;span id=&quot;productTitle&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;, response, re.S)[0]</span><br><span class="line">                else:</span><br><span class="line">                    price = re.search(r&#x27;a-offscreen&quot;&gt;(¥.*?)&lt;/span&gt;&#x27;, response).group(1)</span><br><span class="line">                    title = re.findall(r&#x27;&lt;span id=&quot;productTitle&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;, response, re.S)[0]</span><br><span class="line">            except Exception as e:</span><br><span class="line">                logger.error(f&quot;获取数据 &#123;detail_url&#125; 详情信息被反爬了：&#123;e&#125; &quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(title.strip(), price)</span><br><span class="line">                # 将解析到的商品数据打包成一个元组提交到队列中</span><br><span class="line">                self.shop_info_queue.put((title.strip(), price, detail_url))</span><br><span class="line">            finally:</span><br><span class="line">                self.detail_url_queue.task_done()</span><br><span class="line"></span><br><span class="line">    # 创建mysql数据表用于保存数据</span><br><span class="line">    def create_table(self):</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            create table if not exists amazon_shop(</span><br><span class="line">                id int primary key auto_increment,</span><br><span class="line">                price varchar(255) not null,</span><br><span class="line">                title varchar(255) not null,</span><br><span class="line">                goods_url varchar(255) not null</span><br><span class="line">            );</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            print(&#x27;数据表创建成功...&#x27;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(f&#x27;数据表创建失败:&#x27;, e)</span><br><span class="line">            logger.error(&#x27;数据表创建失败:&#x27;, e)</span><br><span class="line"></span><br><span class="line">    # 将shop_info_queue中的详情数据信息保存到mysql数据库中，一次性保存30条</span><br><span class="line">    def save_shop_info(self):</span><br><span class="line">        while True:</span><br><span class="line">            info_list = list()  # 定义列表用于数据的批量存储</span><br><span class="line"></span><br><span class="line">            # 在队列中连续取到30条数据并添加到info列表中</span><br><span class="line">            for _ in range(30):</span><br><span class="line">                info = self.shop_info_queue.get()</span><br><span class="line">                info_list.append((0,) + info)  # 0占位id字段</span><br><span class="line">                self.shop_info_queue.task_done()</span><br><span class="line"></span><br><span class="line">            sql = &quot;&quot;&quot;</span><br><span class="line">                insert into amazon_shop values (%s, %s, %s, %s);</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">            try:</span><br><span class="line">                # 批量保存, executemany接收的是一个迭代对象</span><br><span class="line">                self.cursor.executemany(sql, info_list)</span><br><span class="line">                self.db.commit()</span><br><span class="line">                print(&#x27;数据插入成功:&#x27;, info_list)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(&#x27;数据插入失败:&#x27;, e)</span><br><span class="line">                logger.error(&#x27;数据库保存失败:&#x27;, e)</span><br><span class="line">                self.db.rollback()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        &quot;&quot;&quot;启动函数，使用多线程的方式并发爬取数据&quot;&quot;&quot;</span><br><span class="line">        self.create_table()</span><br><span class="line"></span><br><span class="line">        thread_list = list()  # 创建线程对象列表</span><br><span class="line"></span><br><span class="line">        # 获取代理ip线程</span><br><span class="line">        for _ in range(5):</span><br><span class="line">            thread_list.append(threading.Thread(target=self.get_ip))</span><br><span class="line">        # 获取分类地址线程</span><br><span class="line">        thread_list.append(threading.Thread(target=self.get_classify_url))</span><br><span class="line">        # 获取商品地址线程</span><br><span class="line">        for _ in range(10):</span><br><span class="line">            thread_list.append(threading.Thread(target=self.get_detail_url))</span><br><span class="line">        # 获取数据详细信息并清洗的线程</span><br><span class="line">        for _ in range(10):</span><br><span class="line">            thread_list.append(threading.Thread(target=self.parse_shop_info))</span><br><span class="line">        # 保存数据的线程，只能有一个，防止资源竞争</span><br><span class="line">        thread_list.append(threading.Thread(target=self.save_shop_info))</span><br><span class="line"></span><br><span class="line">        for thread in thread_list:</span><br><span class="line">            thread.daemon = True</span><br><span class="line">            thread.start()</span><br><span class="line"></span><br><span class="line">        # 延迟等待子线程对象启动</span><br><span class="line">        print(f&quot;正在等待子线程启动...&quot;)</span><br><span class="line">        time.sleep(4)</span><br><span class="line"></span><br><span class="line">        for q in [self.classify_url_queue, self.detail_url_queue, self.shop_info_queue]:</span><br><span class="line">            q.join()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    logger.add(&#x27;runtime_&#123;time&#125;.log&#x27;, rotation=&#x27;500 MB&#x27;)</span><br><span class="line">    amazon = Amazon()</span><br><span class="line">    amazon.main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、计算机网络&quot;&gt;&lt;a href=&quot;#一、计算机网络&quot; class=&quot;headerlink&quot; title=&quot;一、计算机网络&quot;&gt;&lt;/a&gt;一、计算机网络&lt;/h2&gt;&lt;h3 id=&quot;1-B-S和C-S架构&quot;&gt;&lt;a href=&quot;#1-B-S和C-S架构&quot; class=&quot;he</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_5_数据结构</title>
    <link href="http://example.com/2023/08/01/Python_5_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/08/01/Python_5_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-07-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、评判算法的优劣标准"><a href="#一、评判算法的优劣标准" class="headerlink" title="一、评判算法的优劣标准"></a>一、评判算法的优劣标准</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h3><ul><li>简介：时间复杂度是用来<strong>估计</strong>算法运行时间的一个式子（<strong>单位</strong>）</li><li>知识点：<ol><li>一般来说，时间复杂度高的算法比复杂度低的算法慢</li><li>按效率排序：**<code>$$ O(1) &lt; O(\log n) &lt; O(n) &lt; O(n\log n) &lt; O(n^2) &lt; O(n^2\log n) &lt; O(n^3) $$</code>**</li><li>复杂问题的时间复杂度：<code>$$O(n!)$$</code>、<code>$$O(2^n)$$</code>、<code>$$O(n^n)$$</code>……</li></ol></li><li>常用快速判断算法复杂度：<ol><li>确定问题规模<code>$$n$$</code></li><li>循环减半过程—<code>$$logn$$</code></li><li>k层关于n的循环—<code>$$n^k$$</code></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;hello world&#x27;)  # O(1)</span><br><span class="line"></span><br><span class="line">for i range(n):  # O(n)</span><br><span class="line">    print(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line">for i in range(n):  # O(n^2)</span><br><span class="line">    for j in range(n):</span><br><span class="line">        print(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line">for i in range(n):  # O(n^3)</span><br><span class="line">    for j in range(n):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            print(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"># 注意：这里时间复杂度不是O(3)！正解O(1)</span><br><span class="line"># 1. 因为时间复杂度本就是一个估计、大概的概念</span><br><span class="line"># 2. 其次O(1)是一个单位的概念，好比&quot;秒&quot;</span><br><span class="line">print(&#x27;hello world&#x27;)</span><br><span class="line">print(&#x27;hello python&#x27;)</span><br><span class="line">print(&#x27;hello nihao&#x27;)</span><br><span class="line"></span><br><span class="line"># 注意：这里时间复杂度也不是O(n(n+1))即O(n^2+n)！正解：O(n^2)</span><br><span class="line"># 由于时间复杂度本就是一个大概的概念，所以n是可以被忽略（类似求极限抓大头）</span><br><span class="line">for i in range(n):</span><br><span class="line">    print(&#x27;hello world&#x27;)</span><br><span class="line">    for j in range(n):</span><br><span class="line">        print(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"># n=64时输出：64 32 16 8 4 2 有2^6=64 log底2^64=6</span><br><span class="line"># 时间复杂度记为O(log底2^n)或O(logn)</span><br><span class="line"># 当算法过程出现循环折半的时候，复杂度式子中会出现logn</span><br><span class="line">while n &gt; 1:</span><br><span class="line">    print(n)</span><br><span class="line">    n = n // 2</span><br></pre></td></tr></table></figure><h3 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h3><ul><li>简介：用来评估算法内存占用大小的式子</li><li>空间复杂度的表示方式与时间复杂度完全一样：<ol><li>算法使用了几个变量：<code>$$O(1)$$</code></li><li>算法使用了长度为n的一维列表：<code>$$O(n)$$</code></li><li>算法使用了m行n列的二维列表：<code>$$O(mn)$$</code></li></ol></li></ul><h3 id="3-汉诺塔问题"><a href="#3-汉诺塔问题" class="headerlink" title="3. 汉诺塔问题"></a>3. 汉诺塔问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;汉诺塔问题</span><br><span class="line">传说：大梵天创造世界的时候做了三根金刚石柱子，</span><br><span class="line">     在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘，</span><br><span class="line">     大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。</span><br><span class="line">     64跟柱子移动完毕之日，就是世界毁灭之时！</span><br><span class="line">规则：</span><br><span class="line">    小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;分析</span><br><span class="line">n个盘子时：</span><br><span class="line">    1. 把n-1个圆盘从A经过C移动到B</span><br><span class="line">    2. 把第n个圆盘从A移动到C</span><br><span class="line">    3. 把n-1个圆盘从B经过A移动到C</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def hanoi(n, a, b, c):</span><br><span class="line">    if n &gt; 0:</span><br><span class="line">        hanoi(n - 1, a, c, b)</span><br><span class="line">        print(&quot;移动%s最上方的盘子至%s&quot; % (a, c))</span><br><span class="line">        hanoi(n - 1, b, a, c)</span><br><span class="line"></span><br><span class="line">hanoi(3, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br><span class="line">&quot;&quot;&quot;输出：</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动A最上方的盘子至B</span><br><span class="line">移动C最上方的盘子至B</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动B最上方的盘子至A</span><br><span class="line">移动B最上方的盘子至C</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;总结：</span><br><span class="line">汉诺塔移动次数的递推式：h(x)=2h(x-1)+1</span><br><span class="line">h(64)=18446744073709551615</span><br><span class="line">假设婆罗门每秒钟搬一个盘子，则总共需要5800亿年</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="二、八大排序和查找算法"><a href="#二、八大排序和查找算法" class="headerlink" title="二、八大排序和查找算法"></a>二、八大排序和查找算法</h2><h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><ul><li>简介：顺序查找也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止（<strong>对象有序无序都可以，所以内置函数index()使用的是顺序查找</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line"># 顺序查找，时间复杂度：O(n)</span><br><span class="line">def linear_search(li, value):</span><br><span class="line">    for index, v in enumerate(li):</span><br><span class="line">        if v == value:</span><br><span class="line">            return index</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">L = [32, 64, 3, 25, 9, 34, 7, 15, 27, 66]</span><br><span class="line">print(linear_search(L, 7))  # 6</span><br></pre></td></tr></table></figure><h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h3><ul><li>简介：二分查找又叫折半查找，从有序列表的初始候选区li[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半（<strong>对象一定是有序列表！</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 函数装饰器，用于计算不同查找方法的查找时间</span><br><span class="line">def cal_time(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(&quot;%s查找时间为：%s&quot; % (func.__name__, end - start))</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"># 顺序查找，时间复杂度：O(n)</span><br><span class="line">@cal_time</span><br><span class="line">def linear_search(li, value):</span><br><span class="line">    for index, v in enumerate(li):</span><br><span class="line">        if v == value:</span><br><span class="line">            return index</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"># 二分查找，时间复杂度：O(logn)</span><br><span class="line">@cal_time</span><br><span class="line">def binary_search(li, value):</span><br><span class="line">    left = 0</span><br><span class="line">    right = len(li) - 1</span><br><span class="line">    while left &lt;= right:  # 候选区有值</span><br><span class="line">        mid = (left + right) // 2</span><br><span class="line">        if li[mid] == value:</span><br><span class="line">            return mid</span><br><span class="line">        elif li[mid] &gt; value:  # mid在待查找的值的右边，修改right位置</span><br><span class="line">            right = mid - 1</span><br><span class="line">        else:  # mid在待查找的值的左边，修改left位置</span><br><span class="line">            left = mid + 1</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">li = list(range(100000))</span><br><span class="line">linear_search(li, 21715)  # linear_search查找时间为：0.0005478858947753906</span><br><span class="line">binary_search(li, 21715)  # binary_search查找时间为：3.814697265625e-06</span><br></pre></td></tr></table></figure><h3 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3. 冒泡排序"></a>3. 冒泡排序</h3><ul><li>简介：列表每两个相邻的数，如果前面比后面大，则交换这两个数。一趟排序完成后，则无序区减少一个数，有序区增加一个数（**时间复杂度为<code>$$O(n^2)$$</code>**）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def bubble_sort(li):</span><br><span class="line">    # 每走一趟排好一个数，且最后一次不用排，所以总共应该是n-1趟</span><br><span class="line">    for i in range(len(li) - 1):  # i表示第i趟</span><br><span class="line">        flag = False</span><br><span class="line">        # 指针在无序区比较至倒数第二个数时停下，同时与最后一个数比较后，</span><br><span class="line">        # 由于后面是有序区就不会再继续往后走了，所以指针每次应该走n-i-1次</span><br><span class="line">        for j in range(len(li) - i - 1):</span><br><span class="line">            if li[j] &gt; li[j + 1]:</span><br><span class="line">                li[j], li[j + 1] = li[j + 1], li[j]</span><br><span class="line">                flag = True</span><br><span class="line">        # 如果flag在某一趟中没有被改变，说明这一趟走完都没有数进行交换，</span><br><span class="line">        # 则说明此时列表已经完成排序了，所以为了算法优化，没必要继续后面的循环了</span><br><span class="line">        if not flag:</span><br><span class="line">            return li</span><br><span class="line"></span><br><span class="line"># 列表生成式：随机生成10个零到一百的数</span><br><span class="line">li = [random.randint(0, 100) for i in range(10)]</span><br><span class="line">print(li)  # [73, 27, 85, 22, 66, 87, 4, 16, 91, 40]</span><br><span class="line">print(bubble_sort(li))  # [4, 16, 22, 27, 40, 66, 73, 85, 87, 91]</span><br></pre></td></tr></table></figure><h3 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h3><ul><li>简介：一趟排序记录最小的数，放到第一个位置；再一趟排序记录记录列表无序区最小的数，放到第二个位置（**时间复杂度为<code>$$O(n^2)$$</code>**）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def select_sort(li):</span><br><span class="line">    for i in range(len(li) - 1):  # i即第i趟</span><br><span class="line">        min_index = i  # 第一次最小值索引就定为无序区的第一个数的索引</span><br><span class="line">        for j in range(i + 1, len(li)):  # 在无序区中指针的循环次数，i+1是因为不跟自己比</span><br><span class="line">            if li[j] &lt; li[min_index]:</span><br><span class="line">                min_index = j  # 得到每趟无序区中最小值的索引</span><br><span class="line">        if min_index != i:</span><br><span class="line">            li[i], li[min_index] = li[min_index], li[i]</span><br><span class="line">    return li</span><br><span class="line"></span><br><span class="line">li = [random.randint(0, 100) for i in range(10)]</span><br><span class="line">print(li)  # [87, 93, 28, 62, 13, 34, 28, 22, 53, 87]</span><br><span class="line">print(select_sort(li))  # [13, 22, 28, 28, 34, 53, 62, 87, 87, 93]</span><br></pre></td></tr></table></figure><h3 id="5-插入排序"><a href="#5-插入排序" class="headerlink" title="5. 插入排序"></a>5. 插入排序</h3><ul><li>简介：初始化有序区只有一张牌，每次从无序区摸一张牌，插入到手里已有牌的正确位置，类似打牌（**时间复杂度为<code>$$O(n^2)$$</code>**）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def insert_sort(li):</span><br><span class="line">    for i in range(1, len(li)):  # i即这一趟从列表抽出的元素的下标</span><br><span class="line">        tmp = li[i]  # 为了防止被覆盖，需要记录抽出的值</span><br><span class="line">        # j即用来指向被比较的元素的下标，只要j位置的值比i位置的值大，</span><br><span class="line">        # 那么就把j位置的元素往后移一个位置，同时j再往前走一个位置</span><br><span class="line">        j = i - 1</span><br><span class="line">        # j=0时，走完循环j=-1，此时说明j已经处于整个列表的最前面了，</span><br><span class="line">        # 说明这个抽出的元素是整个列表中最小的，则可以将tmp的值插入索引为0的位置即可</span><br><span class="line">        while li[j] &gt; tmp and j &gt; -1:</span><br><span class="line">            li[j + 1] = li[j]</span><br><span class="line">            j -= 1</span><br><span class="line">        # 循环结束后，则找到了插入tmp值的正确位置，即此时j位置的后面</span><br><span class="line">        li[j + 1] = tmp</span><br><span class="line">    return li</span><br><span class="line"></span><br><span class="line">li = [random.randint(0, 100) for i in range(10)]</span><br><span class="line">print(li)  # [80, 76, 58, 19, 28, 25, 60, 76, 16, 37]</span><br><span class="line">print(insert_sort(li))  # [16, 19, 25, 28, 37, 58, 60, 76, 76, 80]</span><br></pre></td></tr></table></figure><blockquote><p>一般来说，一台电脑运算效率大约为<code>$$10^7$$</code>次&#x2F;秒钟</p><p>如果一个函数的时间复杂度为<code>$$O(n^2)$$</code>，对一个有10000个元素的列表进行排序，则<code>$$n^2=10^8$$</code></p><p>那么对10000个元素排序大约需要<code>$$10^8/10^7$$</code>&#x3D;10秒钟，可见效率是非常慢的，那就要看接下来的NB三人组</p></blockquote><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><ul><li>简介：取一个元素p（第一个元素），使元素p归位；列表被p分成两部分，左边都比p小，右边都比p大；最后递归完成排序（**时间复杂度为<code>$$O(n\log n)$$</code>**）</li><li>最坏时间复杂度：当使用快速排序对一个完全倒序排好的序列进行排序时，经过推算此时的算法时间复杂度最高，接近<code>$$O(n^2)$$</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def partition(li, left, right):</span><br><span class="line">    tmp = li[left]  # 用left而不是0，是因为可能切片的第一个元素索引不为0</span><br><span class="line">    while left &lt; right:</span><br><span class="line">    # 内循环使指针的移动</span><br><span class="line">        while left &lt; right and li[right] &gt;= tmp:  # 从右边找比tmp小的数</span><br><span class="line">            right -= 1  # 只要比tmp值大，就往左走一个</span><br><span class="line">        li[left] = li[right]  # 循环结束则找到了比tmp值小的数，把右边的值写到左边的空位处</span><br><span class="line">        while left &lt; right and li[left] &lt;= tmp:  # 从左边找比tmp大的数</span><br><span class="line">            left += 1</span><br><span class="line">        li[right] = li[left]  # 循环结束则找到了比tmp值大的数，把左边的值写到右边的空位处</span><br><span class="line"></span><br><span class="line">    li[left] = tmp</span><br><span class="line">    return left</span><br><span class="line"></span><br><span class="line"># 递归完成快速排序</span><br><span class="line">def quick_sort(li, left, right):</span><br><span class="line">    if left &lt; right:  # 至少有两个元素</span><br><span class="line">        mid = partition(li, left, right)</span><br><span class="line">        quick_sort(li, left, mid - 1)</span><br><span class="line">        quick_sort(li, mid + 1, right)</span><br><span class="line">    return li</span><br><span class="line"></span><br><span class="line">li = [random.randint(0, 10) for i in range(9)]</span><br><span class="line">print(li)</span><br><span class="line">print(quick_sort(li, 0, len(li) - 1))</span><br></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><h2 id="三、七大数据结构"><a href="#三、七大数据结构" class="headerlink" title="三、七大数据结构"></a>三、七大数据结构</h2><h3 id="1-数据结构介绍"><a href="#1-数据结构介绍" class="headerlink" title="1. 数据结构介绍"></a>1. 数据结构介绍</h3><blockquote><p><strong>程序 &#x3D; 数据结构 + 算法</strong></p></blockquote><ul><li><p>简介：数据结构是指<strong>相互之间存在着一种或多种关系的数据元素的集合</strong>和<strong>该集合中数据元素之间的关系组成</strong>。简单来说，<strong>数据结构就是设计数据以何种方式组织并存储在计算机中</strong></p></li><li><p><strong>数据结构按照其逻辑结构可分为线性结构、树结构、图结构</strong></p><ul><li>线性结构：数据结构中的元素存在一对一的相互关系</li><li>树结构：数据结构中的元素存在一对多的相互关系</li><li>图结构：数据结构中的元素存在多对多的相互关系</li></ul></li></ul><h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h3><ul><li>简介：栈（Stack）是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表</li><li>栈的特点：<strong>后进先出</strong> - LIFO（last-in，first-out）</li><li>栈的概念：栈顶、栈底</li><li>栈的基本操作：<ul><li>进栈（压栈）：push</li><li>出栈：pop</li><li>取栈顶：gettop</li></ul></li></ul><h3 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h3><ul><li><p>简介：队列（Queue）是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除。（类似排队）</p></li><li><p>队列的特点：<strong>先进先出</strong> - FIFO（first-in，first-out）</p></li><li><p>队列的基本操作：</p><ul><li>进队（入队）：进入插入的一端称为队尾，插入动作称为进队或入队</li><li>出队：进行删除的一端称为队头，删除动作称为出队</li></ul></li><li><p>环形队列：当队首指针front &#x3D;&#x3D; MaxSize - 1时，再前进一个位置就自动到0</p><ul><li>队首指针前进1：front &#x3D; (front + 1) % MaxSize</li><li>队尾指针前进1：rear &#x3D; (rear + 1) % MaxSize</li><li>队空条件：rear &#x3D;&#x3D; front</li><li>队满条件：(rear + 1) % MaxSize &#x3D;&#x3D; front</li></ul></li><li><p>双向队列：两端都支持进队和出队操作（<strong>使用from collections import deque</strong>）</p><ul><li>创建队列：queue &#x3D; deque()</li><li>进队：append()</li><li>出队：popleft()</li><li>双向队列队首进队：appendleft()</li><li>双向队列队尾出队：pop()</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、评判算法的优劣标准&quot;&gt;&lt;a href=&quot;#一、评判算法的优劣标准&quot; class=&quot;headerlink&quot; title=&quot;一、评判算法的优劣标准&quot;&gt;&lt;/a&gt;一、评判算法的优劣标准&lt;/h2&gt;&lt;h3 id=&quot;1-时间复杂度&quot;&gt;&lt;a href=&quot;#1-时间复杂度&quot; c</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_4_正则表达式</title>
    <link href="http://example.com/2023/07/01/Python_4_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2023/07/01/Python_4_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2023-06-30T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h2><blockquote><p><strong>什么是正则表达式？</strong></p><p><strong>正则表达式，即一个定义了匹配规则的特殊字符串，该字符串中包含了一些特定字符，其中普通字符用于精确匹配，特定字符具有明确的匹配规则</strong>。如果某个字符串符合正则表达式定义的所有匹配规则，那么该字符串就与该正则表达式匹配（<a class="link"   href="https://regexr-cn.com/"  target="_blank" rel="noopener">在线测试工具<i class="fas fa-external-link-alt"></i></a>）</p><ul><li><p>模块：<strong>标准库模块re是专门用于支持正则表达式的</strong></p></li><li><p>作用：正则表达式是字符串处理的利器，它可以用于字符串的匹配、查找、替换和劈分</p></li><li><p>注意：正则表达式在很多编程语言中都是适用的，且绝大部分语法都是通用的</p></li></ul></blockquote><h3 id="1-原始字符串"><a href="#1-原始字符串" class="headerlink" title="1. 原始字符串"></a>1. 原始字符串</h3><ul><li><strong>原始字符串：</strong>是一种字符串字面值的表示方式，通常用于处理正则表达式模式、文件路径或其他需要特殊字符的情况（<strong>其中特殊字符不会被转义，而是将其解释为普通字符</strong>）</li><li>解释：<ul><li>在原始字符串中，包含了哪些字符就表示哪些字符，而无需考虑转义字符</li><li>如果使用普通字符串来表示正则表达式，则需要考虑转义字符</li></ul></li><li><strong>重要概念</strong>：<ul><li><strong>转义字符</strong>：简单来说就是在一些字符前加上反斜杠 \ 使它具有其他意义，例<code>\n、\\、\r、\t、\&quot;</code>等</li><li><strong>字符的字面值</strong>：简单的说，就是要确切的显示出一个字符，即一个没有任何意义的字符</li><li><strong>正则表达式中具有特殊含义的字符</strong>：例<code>\ . ^ $ ? + * &#123;&#125; [] () |</code>，想要使用这些字符的字面值，就必须使用反斜杠进行转义</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 在原始字符串r&#x27;\d&#x27;中，包含了一个反斜杠和一个d</span><br><span class="line"># 在正则表达式中，用\d匹配任意一个数字</span><br><span class="line">print(re.match(r&#x27;\d&#x27;, &#x27;8&#x27;))  # &lt;re.Match object; span=(0, 1), match=&#x27;8&#x27;&gt;</span><br><span class="line"></span><br><span class="line"># 在普通字符串&#x27;\\d&#x27;中，第一个反斜杠用于对第二个反斜杠的转义，所以也是包含了一个反斜杠和一个d</span><br><span class="line"># 在正则表达式中，用\d匹配任意一个数字</span><br><span class="line">print(re.match(&#x27;\\d&#x27;, &#x27;8&#x27;))  # &lt;re.Match object; span=(0, 1), match=&#x27;8&#x27;&gt;</span><br><span class="line"></span><br><span class="line"># 由于在正则表达式中，反斜杠是具有特殊含义的，所以要表示反斜杠的字面值，必须使用反斜杠进行转义，</span><br><span class="line"># 所以r&#x27;a\\b&#x27;表示的是：a、一个反斜杠、b。</span><br><span class="line"># 而&#x27;a\\b&#x27;为普通字符串，所以表示的也是：a、一个反斜杠、b。</span><br><span class="line">print(re.match(r&#x27;a\\b&#x27;, &#x27;a\\b&#x27;))  # &lt;re.Match object; span=(0, 3), match=&#x27;a\\b&#x27;&gt;</span><br><span class="line"></span><br><span class="line"># 由于&#x27;a\\\\b&#x27;为普通字符串，所以因为转义，每两个反斜杠会代表一个反斜杠，</span><br><span class="line"># 又因为在正则表达式中，反斜杠是具有特殊含义的，所以第一个反斜杠又会对第二个反斜杠再次转义，</span><br><span class="line"># 这样最后的反斜杠才能表示其字面值，即表示的是：a、一个反斜杠、b。</span><br><span class="line"># 而&#x27;a\\b&#x27;为普通字符串，所以表示的也是：a、一个反斜杠、b。</span><br><span class="line">print(re.match(&#x27;a\\\\b&#x27;, &#x27;a\\b&#x27;))  # &lt;re.Match object; span=(0, 3), match=&#x27;a\\b&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-match方法匹配（图）"><a href="#2-match方法匹配（图）" class="headerlink" title="2. match方法匹配（图）"></a>2. match方法匹配（图）</h3><ul><li><p><strong>match(pattern, string[, flags])：</strong></p><ul><li>作用：该方法会根据参数string指定的字符串与参数pattern指定的正则表达式进行匹配</li></ul><ul><li><p><strong>参数pattern</strong>：是一个正则表达式，或对正则表达式预编译之后得到的对象</p></li><li><p><strong>参数string</strong>：需要匹配的普通字符串</p></li><li><p><strong>参数flags</strong>：是一个标志位，用于控制正则表达式的匹配方式。如果需要同时使用多个，可以使用 | 对标志位进行分隔</p><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1667544375-0b0386fbdfe2ae0.jpg"                         style="width:70%;margin:0 auto;"                 ></li></ul></li><li><p><strong>匹配方式：</strong>该方法会从参数string指定的字符串的<strong>开头开始</strong>，一直向后尝试匹配参数pattern指定的正则表达式，在到达pattern的末尾前，如果遇到无法匹配的字符或到达了string的末尾，都表示<strong>匹配失败</strong>。反之，如果到达pattern的末尾时，所有的字符都是匹配成功的，则表示<strong>匹配成功，且终止匹配，不再对string向后匹配</strong></p></li><li><p><strong>返回值：若匹配成功，则返回一个Match对象；若匹配失败，则返回None</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.match(r&#x27;...&#x27;, &#x27;ab&#x27;))  # None</span><br><span class="line">print(re.match(r&#x27;...&#x27;, &#x27;a\nc&#x27;))  # None</span><br><span class="line"></span><br><span class="line">print(re.match(r&#x27;...&#x27;, &#x27;abc&#x27;))  # &lt;re.Match object; span=(0, 3), match=&#x27;abc&#x27;&gt;</span><br><span class="line">print(re.match(r&#x27;...&#x27;, &#x27;abcdef&#x27;))  # &lt;re.Match object; span=(0, 3), match=&#x27;abc&#x27;&gt;</span><br><span class="line"></span><br><span class="line">print(re.match(r&#x27;[a-z]&#123;7&#125;&#x27;, &#x27;aBCdefG&#x27;, re.I))  # &lt;re.Match object; span=(0, 7), match=&#x27;aBCdefG&#x27;&gt;</span><br><span class="line">print(re.match(r&#x27;...[a-z]&#123;7&#125;&#x27;, &#x27;a\ncaBCdefG&#x27;, re.I | re.S))  # &lt;re.Match object; span=(0, 10), match=&#x27;a\ncaBCdefG&#x27;&gt;</span><br><span class="line"></span><br><span class="line"># 根据方法match()的返回值可知，还可以将其用作if语句的判断条件</span><br><span class="line">if re.match(r&#x27;...&#x27;, &#x27;a\nc&#x27;):</span><br><span class="line">    print(&quot;匹配成功&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;匹配失败&quot;)</span><br></pre></td></tr></table></figure><h3 id="3-正则表达式的预编译"><a href="#3-正则表达式的预编译" class="headerlink" title="3. 正则表达式的预编译"></a>3. 正则表达式的预编译</h3><ul><li><p><strong>compile(pattern[, flags])：</strong></p><ul><li><p>作用：该方法用于预编译正则表达式，使得在重复使用一个正则表达式时不用多次编译，以提高效率</p></li><li><p><strong>参数pattern</strong>：是一个正则表达式</p></li><li><p><strong>参数flags</strong>：是一个标志位，与方法match()中参数flags的含义完全相同</p></li></ul></li><li><p><strong>返回值：该方法会返回对正则表达式预编译之后得到的对象</strong></p></li><li><p><strong>知识点</strong>：</p><ul><li><p><strong>预编译之后得到的对象提供了方法 match(string[, pos[, endpos]]) ，即对应模块re中的match方法</strong></p></li><li><p><strong>参数pos</strong>：用于指定被匹配的字符串的起始位置，默认值为0</p></li><li><p><strong>参数endpos</strong>：用于指定被匹配的字符串的结束位置，默认值是字符串的长度（<strong>左闭右开</strong>）</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 预编译正则表达式</span><br><span class="line">obj = re.compile(r&#x27;[a-z]*&#x27;, re.I)</span><br><span class="line"></span><br><span class="line"># 等价于print(re.match(r&#x27;[a-z]*&#x27;, &#x27;aBcDeF&#x27;, re.I))</span><br><span class="line">print(obj.match(&#x27;aBcDeF&#x27;))  # &lt;re.Match object; span=(0, 6), match=&#x27;aBcDeF&#x27;&gt;</span><br><span class="line">print(obj.match(&#x27;aBcDeF&#x27;, 1, 3))  # &lt;re.Match object; span=(1, 3), match=&#x27;Bc&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="4-单个字符的匹配（图）"><a href="#4-单个字符的匹配（图）" class="headerlink" title="4. 单个字符的匹配（图）"></a>4. 单个字符的匹配（图）</h3><blockquote><p><strong>注意：正则表达式里的中括号[ ]具有去除字符的特殊含义的作用，从而只剩下字符的字面值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;[(](.*?)[)]&#x27;, &#x27;H(1a2(name)xf888)M&#x27;))  # [&#x27;1a2(name&#x27;]</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>中括号 [] 的使用：</strong><ul><li>当 ^ 是中括号内的第一个字符时，表示否定</li><li>当 - 不是中括号内的第一个字符时，表示范围</li><li>在中括号中可以使用运算符&amp;，表示并且</li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1667551175-0a588ab1a6ff988.jpg"                         style="width:80%;margin:0 auto;"                 ><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.match(r&#x27;\d*\D&#x27;, &#x27;1-2&#x27;))  # &lt;re.Match object; span=(0, 2), match=&#x27;1-&#x27;&gt;</span><br><span class="line">print(re.match(r&#x27;\w*\W&#x27;, &#x27;7_a#8&#x27;))  # &lt;re.Match object; span=(0, 4), match=&#x27;7_a#&#x27;&gt;</span><br><span class="line"></span><br><span class="line">print(re.match(r&#x27;\s\s\s\s\s\s&#x27;, &#x27; \t\r\n\f\vac&#x27;))  # &lt;re.Match object; span=(0, 6), match=&#x27; \t\r\n\x0c\x0b&#x27;&gt;</span><br><span class="line">print(re.match(r&#x27;\S\S\S&#x27;, &#x27;c-3 \t&#x27;))  # &lt;re.Match object; span=(0, 3), match=&#x27;c-3&#x27;&gt;</span><br><span class="line"></span><br><span class="line"># 匹配a、b和c中的任意一个字符</span><br><span class="line">print(re.match(r&#x27;[abc]&#x27;, &#x27;b&#x27;))  # &lt;re.Match object; span=(0, 1), match=&#x27;b&#x27;&gt;</span><br><span class="line"># 匹配除a、b和c之外的任意一个字符</span><br><span class="line">print(re.match(r&#x27;[^abc]&#x27;, &#x27;f&#x27;))  # &lt;re.Match object; span=(0, 1), match=&#x27;f&#x27;&gt;</span><br><span class="line"># 匹配任意一个英文字母。</span><br><span class="line">print(re.match(r&#x27;[a-zA-Z]&#x27;, &#x27;M&#x27;))  # &lt;re.Match object; span=(0, 1), match=&#x27;M&#x27;&gt;</span><br><span class="line"># 匹配a到n，并且h-t，相当于：[h-n]</span><br><span class="line">print(re.match(r&#x27;[a-n&amp;h-t]&#x27;, &#x27;k&#x27;))  # &lt;re.Match object; span=(0, 1), match=&#x27;k&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="5-贪婪与勉强模式（图）"><a href="#5-贪婪与勉强模式（图）" class="headerlink" title="5. 贪婪与勉强模式（图）"></a>5. 贪婪与勉强模式（图）</h3><blockquote><p><strong>. ：点号是通配符，表示匹配任何单个字符，除了换行符 \n 之外的任何字符</strong></p><p><strong>* ：星号是量词，表示匹配前面的元素零次或多次</strong></p><p><strong>? ：问号也是量词，表示匹配前面的元素零次或一次</strong></p></blockquote><ul><li><strong>贪婪模式：</strong><ul><li>在贪婪模式下，正则表达式引擎会尽可能多地匹配符合模式的文本（它会匹配尽量长的字符串）</li><li>贪婪模式使用 * 和 + 量词（**.* 表示匹配任意多个字符，直到不能再匹配为止**）</li></ul></li><li><strong>勉强模式（非贪婪模式）：</strong><ul><li>在勉强模式下，正则表达式引擎会尽可能少地匹配符合模式的文本（它会匹配尽量短的字符串）</li><li>勉强模式使用 *? 和 +? 量词（**.*? 表示匹配任意多个字符，但尽可能少**）</li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1667649195-bef57dd3a8393af.jpg"                         style="width:80%;margin:0 auto;"                 ><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &#x27;abbbbbc&gt;abc&gt;ac&#x27;</span><br><span class="line"></span><br><span class="line"># 以下分别是各个情况下的贪婪模式和勉强模式的演示</span><br><span class="line">print(re.findall(r&#x27;ab*&#x27;, text))  # [&#x27;abbbbb&#x27;, &#x27;ab&#x27;, &#x27;a&#x27;]</span><br><span class="line">print(re.findall(r&#x27;ab*?&#x27;, text))  # [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;ab+&#x27;, text))  # [&#x27;abbbbb&#x27;, &#x27;ab&#x27;]</span><br><span class="line">print(re.findall(r&#x27;ab+?&#x27;, text))  # [&#x27;ab&#x27;, &#x27;ab&#x27;]</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;ab?&#x27;, text))  # [&#x27;ab&#x27;, &#x27;ab&#x27;, &#x27;a&#x27;]</span><br><span class="line">print(re.findall(r&#x27;ab??&#x27;, text))  # [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;ab&#123;3&#125;&#x27;, text))  # [&#x27;abbb&#x27;]</span><br><span class="line">print(re.findall(r&#x27;ab&#123;3&#125;?&#x27;, text))  # [&#x27;abbb&#x27;]</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;ab&#123;3,&#125;&#x27;, text))  # [&#x27;abbbbb&#x27;]</span><br><span class="line">print(re.findall(r&#x27;ab&#123;3,&#125;?&#x27;, text))  # [&#x27;abbb&#x27;]</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;ab&#123;3,5&#125;&#x27;, text))  # [&#x27;abbbbb&#x27;]</span><br><span class="line">print(re.findall(r&#x27;ab&#123;3,5&#125;?&#x27;, text))  # [&#x27;abbb&#x27;]</span><br></pre></td></tr></table></figure><h3 id="6-边界匹配（图）"><a href="#6-边界匹配（图）" class="headerlink" title="6. 边界匹配（图）"></a>6. 边界匹配（图）</h3><ul><li><strong>边界匹配：</strong>是用于确定匹配的文本边界的一种技术，主要用于<strong>匹配字符串的边界</strong>或<strong>单词的边界</strong></li><li><strong>注意</strong>：\b和\B是单词边界，<strong>只用于识别边界，而不匹配任何实际字符</strong>，所以是看不到的<ul><li>\b：<strong>表示字母数字与非字母数字的边界， 非字母数字与字母数字的边界</strong></li><li>\B：<strong>表示字母数字与非非字母数字的边界，非字母数字与非字母数字的边界</strong></li></ul></li></ul><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1667711175-04a9aa01bf69433.jpg"                         style="width:80%;margin:0 auto;"                 ><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &quot;&quot;&quot;001-苹果价格-60</span><br><span class="line">002-橙子价格-70</span><br><span class="line">003-香蕉价格-80&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;^\d+&#x27;, text))  # [&#x27;001&#x27;]</span><br><span class="line">print(re.findall(r&#x27;^\d+&#x27;, text, re.M))  # [&#x27;001&#x27;, &#x27;002&#x27;, &#x27;003&#x27;]</span><br><span class="line">print(re.findall(r&#x27;\A\d+&#x27;, text, re.M))  # [&#x27;001&#x27;]</span><br><span class="line">print(re.findall(r&#x27;\d+$&#x27;, text, re.M))  # [&#x27;60&#x27;, &#x27;70&#x27;, &#x27;80&#x27;]</span><br><span class="line">print(re.findall(r&#x27;\d+\Z&#x27;, text, re.M))  # [&#x27;80&#x27;]，字符串终止位置</span><br><span class="line"></span><br><span class="line"># 制定\b的边界匹配，分隔符为123对字符串进行劈分</span><br><span class="line">print(re.split(r&#x27;123\b&#x27;, &#x27;==123!! abc123. 123abc. 123\tabc 123&#x27;))</span><br><span class="line"># [&#x27;==&#x27;, &#x27;!! abc&#x27;, &#x27;. 123abc. &#x27;, &#x27;\tabc &#x27;, &#x27;&#x27;]</span><br><span class="line"># 结论：分隔边界都是字母数字与非字母数字的边界，符合\b的规则</span><br><span class="line"># 其中&#x27;123abc&#x27;没有被分隔，而&#x27;123\tabc&#x27;被分隔了，因为&#x27;\t&#x27;是非字母数字，所以不分隔</span><br><span class="line"></span><br><span class="line"># 制定\B的边界匹配，分隔符为pyc对字符串进行劈分</span><br><span class="line">print(re.split(r&#x27;pyc\B&#x27;, &#x27;1pycthon 2pyc56 3pyc# 4pyc&#x27;))</span><br><span class="line"># [&#x27;1&#x27;, &#x27;thon 2&#x27;, &#x27;56 3pyc# 4pyc&#x27;]</span><br><span class="line"># 结论：分隔边界都是字母数字与字母数字的边界，符合\B的规则</span><br><span class="line"># 其中&#x27;56 3pyc# 4pyc&#x27;没有被分隔，这是因为#是非字母数字，空字符串也是非字母数字，所以不分隔</span><br><span class="line"></span><br><span class="line"># 同时制定\b和\B的边界匹配，分隔符为123=对字符串进行劈分</span><br><span class="line">print(re.split(r&#x27;\b123=\B&#x27;, &#x27;abc,123==abc&#x27;))</span><br><span class="line"># [&#x27;abc,&#x27;, &#x27;=abc&#x27;]</span><br><span class="line"># 总结：&#x27;123=&#x27;的前面是逗号，符合\b的规则；后面是等号，也符合\B的规则</span><br></pre></td></tr></table></figure><h3 id="7-分组匹配与逻辑匹配"><a href="#7-分组匹配与逻辑匹配" class="headerlink" title="7. 分组匹配与逻辑匹配"></a>7. 分组匹配与逻辑匹配</h3><blockquote><p><strong>逻辑匹配</strong>：即使用竖线 | 来表示逻辑或操作</p><ul><li><p>如果 | 被使用在分组中，则作用范围是那个组()内</p></li><li><p>如果 | 没有被使用在()中，则作用范围是整个正则表达式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.match(r&#x27;123|abc&#x27;, &#x27;abc&#x27;))  # &lt;re.Match object; span=(0, 3), match=&#x27;abc&#x27;&gt;</span><br><span class="line"></span><br><span class="line">print(re.match(r&#x27;P(ython|erl)&#x27;, &#x27;Python&#x27;))  # &lt;re.Match object; span=(0, 6), match=&#x27;Python&#x27;&gt;</span><br><span class="line">print(re.match(r&#x27;P(ython|erl)&#x27;, &#x27;Python&#x27;).group())  # Python</span><br><span class="line">print(re.match(r&#x27;P(ython|erl)&#x27;, &#x27;Python&#x27;).groups())  # (&#x27;ython&#x27;,)</span><br><span class="line"></span><br><span class="line">print(re.findall(r&#x27;P(ython|erl)&#x27;, &#x27;Python&#x27;))  # [&#x27;ython&#x27;]</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>分组（group）：是一种将模式中的子表达式包装在括号内的机制。</strong>分组允许对匹配的文本进行更详细的控制，例如捕获特定部分的文本，对不同部分应用不同的量词，或者引用分组中的文本</li><li><strong>捕获分组：</strong>使用小括号 <code>( )</code> 来创建捕获分组，以捕获匹配的文本，捕获分组可以在匹配后被引用<ul><li>捕获分组通常通过数字编号来引用，语法格式为：<strong>\编号</strong></li></ul></li><li><strong>非捕获分组：</strong>使用 <code>(?: )</code> 创建非捕获分组，不会捕获匹配的文本，只用于分组操作，不会在匹配后被引用<ul><li><code>(?:abc)+</code> 表示匹配一个或多个 “abc”，但不会捕获这些文本</li></ul></li><li><strong>命名分组：</strong>使用 <code>(?P&lt;name&gt; )</code> 创建命名分组，以便在匹配后使用名称引用分组中的文本<ul><li>命名分组通常通过别名来引用，语法格式为：**?P&#x3D;别名**</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &#x27;012-3456-012&#x27;</span><br><span class="line"></span><br><span class="line"># 捕获分组</span><br><span class="line">mt = re.match(r&#x27;(\d+)-(\d+)-(\1)&#x27;, text)</span><br><span class="line">print(mt)  # &lt;re.Match object; span=(0, 12), match=&#x27;012-3456-012&#x27;&gt;</span><br><span class="line">print(mt.group())  # group()等价于group(0)，表示模式匹配到的字符串012-3456-012</span><br><span class="line">print(mt.group(1))  # 012，表示第1个捕获分组</span><br><span class="line">print(mt.group(2))  # 3456，表示第2个捕获分组</span><br><span class="line">print(mt.group(3))  # 012，表示第3个捕获分组</span><br><span class="line">print(mt.groups())  # (&#x27;012&#x27;, &#x27;3456&#x27;, &#x27;012&#x27;)，得到每一个分组</span><br><span class="line"></span><br><span class="line"># 非捕获分组</span><br><span class="line">date = &quot;2017-3-11, 2023-7-15&quot;</span><br><span class="line">pattern = r&quot;(\d&#123;4&#125;)-(\d&#123;1&#125;)-(?:\d&#123;2&#125;)&quot;</span><br><span class="line"># (?:\d&#123;2&#125;)表示只匹配day，但不捕获day</span><br><span class="line">matches = re.finditer(pattern, date)</span><br><span class="line">for match in matches:</span><br><span class="line">    year = match.group(1)</span><br><span class="line">    month = match.group(2)</span><br><span class="line">    print(f&quot;&#123;year&#125;年&#123;month&#125;月&quot;)  # 2017年3月 2023年7月</span><br><span class="line"></span><br><span class="line"># 命名分组</span><br><span class="line">mt = re.match(r&#x27;(?P&lt;sec&gt;\d+)-(?P&lt;fir&gt;\d+)-(?P=sec)&#x27;, text)</span><br><span class="line">print(mt.group())  # 012-3456-012</span><br><span class="line">print(mt.group(&#x27;sec&#x27;))  # 012</span><br><span class="line">print(mt.group(&#x27;fir&#x27;))  # 3456</span><br><span class="line">print(mt.groups())  # (&#x27;012&#x27;, &#x27;3456&#x27;)</span><br></pre></td></tr></table></figure><h2 id="二、理解与记录"><a href="#二、理解与记录" class="headerlink" title="二、理解与记录"></a>二、理解与记录</h2><h3 id="1-贪婪与勉强模式"><a href="#1-贪婪与勉强模式" class="headerlink" title="1. 贪婪与勉强模式"></a>1. 贪婪与勉强模式</h3><ul><li>第一个理解案例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">line = &quot;boooobbbby123&quot;</span><br><span class="line"></span><br><span class="line"># 从左边第一个.*开始贪婪匹配，会匹配掉boooobb，所以最后剩下bb</span><br><span class="line">print(re.match(r&quot;.*(b.*b).*&quot;, line).group(1))  # bb</span><br><span class="line"></span><br><span class="line"># 从左边的.*?开始勉强匹配b，则遇到第一个b就开始匹配组，但组里面是贪婪匹配，所以一直匹配到了最后一个b</span><br><span class="line">print(re.match(r&quot;.*?(b.*b).*&quot;, line).group(1))  # boooobbbb</span><br><span class="line"></span><br><span class="line"># 从左边第一个.*?开始勉强匹配，遇到第一个b就开始匹配组，组里也是勉强匹配，所以匹配到第二个b就结束了组的匹配</span><br><span class="line">print(re.match(r&quot;.*?(b.*?b).*&quot;, line).group(1))  # boooob</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;总结：从左至右，无论是贪婪匹配还是勉强匹配都是针对其后面一个字符而言&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>第二个理解案例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">line = &quot;&quot;&quot;张三，手机号码15945678901</span><br><span class="line">李四，手机号码13945677701</span><br><span class="line">王二，手机号码13845666901&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 主要通过第2组和第3组正则表达式的变化，理解贪婪与非贪婪模式</span><br><span class="line">print(re.findall(r&quot;(.+?)，(.*?)(\d+)&quot;, line))</span><br><span class="line"># [(&#x27;张三&#x27;, &#x27;手机号码&#x27;, &#x27;15945678901&#x27;), ...</span><br><span class="line">print(re.findall(r&quot;(.+?)，(.*)(\d+)&quot;, line))</span><br><span class="line"># [(&#x27;张三&#x27;, &#x27;手机号码1594567890&#x27;, &#x27;1&#x27;), ...</span><br><span class="line">print(re.findall(r&quot;(.+?)，(.*)(\d*)&quot;, line))</span><br><span class="line"># [(&#x27;张三&#x27;, &#x27;手机号码15945678901&#x27;, &#x27;&#x27;), ...</span><br><span class="line">print(re.findall(r&quot;(.+?)，(.*?)(\d*)&quot;, line))</span><br><span class="line"># [(&#x27;张三&#x27;, &#x27;&#x27;, &#x27;&#x27;), ...</span><br></pre></td></tr></table></figure><h3 id="2-组的关键解析"><a href="#2-组的关键解析" class="headerlink" title="2. 组的关键解析"></a>2. 组的关键解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &quot;zvzc zcpython python1234 abcPython&quot;</span><br><span class="line"></span><br><span class="line"># 1. 无分组</span><br><span class="line">pattern = re.compile(&#x27;[Pp]ython&#x27;)  # 预编译正则表达式</span><br><span class="line">print(pattern.search(text).group())  # 在整个字符串中搜索到的第一个子串 python</span><br><span class="line">print(pattern.findall(text))  # [&#x27;python&#x27;, &#x27;python&#x27;, &#x27;Python&#x27;]</span><br><span class="line"></span><br><span class="line"># 2. 有一层分组</span><br><span class="line">pattern = re.compile(&#x27;(P|p)ython&#x27;)</span><br><span class="line">print(pattern.search(text).group())  # python</span><br><span class="line">print(pattern.search(text).groups())  # (&#x27;p&#x27;,)</span><br><span class="line"># 先匹配整个模式得到子串&#x27;python&#x27;，再拿子串&#x27;python&#x27;去匹配小括号里的模式，得到&#x27;p&#x27;子串</span><br><span class="line">print(pattern.findall(text))  # [&#x27;p&#x27;, &#x27;p&#x27;, &#x27;P&#x27;]</span><br><span class="line"># 先匹配整个模式得到子串&#x27;python&#x27;、&#x27;python&#x27;和&#x27;Python&#x27;，</span><br><span class="line"># 再拿子串&#x27;python&#x27;或&#x27;Python&#x27;去匹配小括号里的模式，得到&#x27;p&#x27;或&#x27;P&#x27;</span><br><span class="line"></span><br><span class="line"># 3. 有多层分组</span><br><span class="line">pattern = re.compile(&#x27;((P|p)ython)&#x27;)</span><br><span class="line">print(pattern.search(text).group())  # python</span><br><span class="line">print(pattern.search(text).groups())  # (&#x27;python&#x27;, &#x27;p&#x27;)</span><br><span class="line"># 先得到外层小括号匹配的子串&#x27;python&#x27;，再拿子串&#x27;python&#x27;去匹配内层小括号里的模式，得到&#x27;p&#x27;子串</span><br><span class="line">print(pattern.findall(text))  # [(&#x27;python&#x27;, &#x27;p&#x27;), (&#x27;python&#x27;, &#x27;p&#x27;), (&#x27;Python&#x27;, &#x27;P&#x27;)]</span><br><span class="line"># 先得到外层小括号匹配的子串&#x27;python&#x27;、&#x27;python&#x27;和&#x27;Python&#x27;，</span><br><span class="line"># 再拿得到的子串&#x27;python&#x27;或&#x27;Python&#x27;去匹配小括号里的模式，得到&#x27;p&#x27;或&#x27;P&#x27;子串，最后把两个子串放到元组里</span><br></pre></td></tr></table></figure><h3 id="3-常用正则提取技巧"><a href="#3-常用正则提取技巧" class="headerlink" title="3. 常用正则提取技巧"></a>3. 常用正则提取技巧</h3><ul><li><strong>匹配汉字：<code>[\u4E00-\u9FA5]</code></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 常用手机号处理</span><br><span class="line">phone = &quot;18712345678&quot;</span><br><span class="line">regex1 = re.sub(r&quot;([\d]&#123;3&#125;).*([\d]&#123;4&#125;)&quot;, r&quot;\1****\2&quot;, phone)</span><br><span class="line">print(regex1)  # 187****5678</span><br><span class="line"></span><br><span class="line"># 汉字处理</span><br><span class="line">chinese = &quot;12a我是谁bbc哈哈&quot;</span><br><span class="line">regex2 = re.match(r&quot;.*?([\u4E00-\u9FA5].*?)b.*?([\u4E00-\u9FA5]+)&quot;, chinese)</span><br><span class="line">print(regex2.groups())  # (&#x27;我是谁&#x27;, &#x27;哈哈&#x27;)</span><br><span class="line"></span><br><span class="line"># 提取出生年份</span><br><span class="line">bir1 = &quot;xxx出生于2001年6月1日&quot;</span><br><span class="line">bir2 = &quot;xxx出生于2002/5/2&quot;</span><br><span class="line">bir3 = &quot;xxx出生于2003-4-3&quot;</span><br><span class="line">bir4 = &quot;xxx出生于2004-05-04&quot;</span><br><span class="line">bir5 = &quot;xxx出生于2005-07&quot;</span><br><span class="line">bir6 = &quot;xxx出生于2006-8月&quot;</span><br><span class="line">listbd = [bir1, bir2, bir3, bir4, bir5, bir6]</span><br><span class="line">comp = re.compile(r&quot;.*?(\d&#123;4&#125;)[-年/](\d&#123;1,2&#125;)[-月/]*(\d&#123;0,2&#125;).*&quot;)</span><br><span class="line">for bir in listbd:</span><br><span class="line">    if comp.match(bir).group(3):</span><br><span class="line">        birthday = comp.sub(r&quot;\1-\2-\3&quot;, bir)</span><br><span class="line">        print(birthday)</span><br><span class="line">    else:</span><br><span class="line">        birthday = comp.sub(r&quot;\1-\2&quot;, bir)</span><br><span class="line">        print(birthday)</span><br><span class="line"># 2001-6-1  2002-5-2  2003-4-3  2004-05-04  2005-07  2006-8</span><br></pre></td></tr></table></figure><h2 id="三、正则常用方法"><a href="#三、正则常用方法" class="headerlink" title="三、正则常用方法"></a>三、正则常用方法</h2><h3 id="1-search方法搜索"><a href="#1-search方法搜索" class="headerlink" title="1. search方法搜索"></a>1. search方法搜索</h3><ul><li><p>方法：<strong>search(pattern, string[, flags])，该方法会在参数string指定的字符串中查找参数pattern指定的第一个字符串</strong></p><ul><li>参数pattern：是一个正则表达式，或对正则表达式预编译之后得到的对象</li><li>参数string：需要查找的普通字符串</li></ul></li><li><p>返回值：<strong>如果有匹配的子串，则返回第一个匹配对应的Match对象；如果没有匹配的子串，则返回None</strong></p></li><li><p>注意：除了直接调用模块re的方法search()之外，也可以调用模块re的方法compile()的返回值的方法<strong>search(string[, pos[, endpos]])</strong></p><ul><li>参数pos用于指定被查找的字符串的起始位置，默认值为0</li><li>参数endpos用于指定被查找的字符串的结束位置，默认值是字符串的长度。被查找的子串不包括结束位置，<strong>类似左闭右开</strong></li><li><strong>模块re的方法search()中的参数pattern和flags被转移到了方法compile()中</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">compile = re.compile(r&#x27;\d+&#x27;)</span><br><span class="line">print(re.search(r&#x27;\d+&#x27;, &#x27;-123-56-89-&#x27;))  # &lt;re.Match object; span=(1, 4), match=&#x27;123&#x27;&gt;</span><br><span class="line">print(re.search(r&#x27;\d+&#x27;, &#x27;-abc-d-efg-&#x27;))  # None</span><br><span class="line">print(re.search(compile, &#x27;-123-56-89-&#x27;))  # &lt;re.Match object; span=(1, 4), match=&#x27;123&#x27;&gt;</span><br><span class="line"></span><br><span class="line">print(compile.search(&#x27;-123-56-89-&#x27;))  # &lt;re.Match object; span=(1, 4), match=&#x27;123&#x27;&gt;</span><br><span class="line">print(compile.search(&#x27;-123-56-89-&#x27;, 4))  # &lt;re.Match object; span=(5, 7), match=&#x27;56&#x27;&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>python正则表达式函数match()和search()的区别：</strong></p><ul><li><strong>match()函数是从字符串的开头进行匹配，只有在字符串开头匹配到模式时才会返回匹配结果。如果模式在字符串开头没有匹配到，则match()函数返回None</strong></li><li><strong>search()函数则是在整个字符串中搜索模式，只要找到第一个匹配的结果，就会返回匹配结果。如果模式在整个字符串中没有匹配到，则search()函数返回None</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line"># 使用match()函数匹配正则表达式</span><br><span class="line">result1 = re.match(r&quot;Hello&quot;, text)</span><br><span class="line">print(result1)  # `&lt;re.Match object; span=(0, 5), match=&#x27;Hello&#x27;&gt;`</span><br><span class="line">result2 = re.match(r&quot;World&quot;, text)</span><br><span class="line">print(result2)  # None</span><br><span class="line"></span><br><span class="line"># 使用search()函数匹配正则表达式</span><br><span class="line">result3 = re.search(r&quot;Hello&quot;, text)</span><br><span class="line">print(result3)  # `&lt;re.Match object; span=(0, 5), match=&#x27;Hello&#x27;&gt;`</span><br><span class="line">result4 = re.search(r&quot;World&quot;, text)</span><br><span class="line">print(result4)  # `&lt;re.Match object; span=(6, 11), match=&#x27;World&#x27;&gt;`</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-findall方法查找"><a href="#2-findall方法查找" class="headerlink" title="2. findall方法查找"></a>2. findall方法查找</h3><ul><li><p>方法：<strong>findall(pattern, string[, flags])，该方法会在参数string指定的字符串中查找参数pattern指定的所有子串</strong></p><ul><li>参数pattern：是一个正则表达式，或对正则表达式预编译之后得到的对象</li><li>参数string：需要查找的普通字符串</li></ul></li><li><p>返回值：<strong>如果有匹配的子串，则返回所有匹配的子串组成的列表；如果没有匹配的子串，则返回空列表</strong></p></li><li><p>注意：除了直接调用模块re的方法findall()之外，也可以调用模块re的方法compile()的返回值的方法<strong>findall(string[, pos[, endpos]])</strong></p><ul><li>参数pos用于指定被查找的字符串的起始位置，默认值为0</li><li>参数endpos用于指定被查找的字符串的结束位置，默认值是字符串的长度。被查找的子串不包括结束位置，<strong>类似左闭右开</strong></li><li>模块re的方法findall()中的参数pattern和flags被转移到了方法compile()中</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">compile = re.compile(r&#x27;\d+&#x27;)</span><br><span class="line">print(re.findall(r&#x27;\d+&#x27;, &#x27;-123-56-89-&#x27;))  # [&#x27;123&#x27;, &#x27;56&#x27;, &#x27;89&#x27;]</span><br><span class="line">print(re.findall(r&#x27;\d+&#x27;, &#x27;-abc-d-efg-&#x27;))  # []</span><br><span class="line"></span><br><span class="line">print(compile.findall(&#x27;-123-56-89-&#x27;))  # [&#x27;123&#x27;, &#x27;56&#x27;, &#x27;89&#x27;]</span><br><span class="line">print(compile.findall(&#x27;-123-56-89-&#x27;, 4))  # [&#x27;56&#x27;, &#x27;89&#x27;]</span><br></pre></td></tr></table></figure><h3 id="3-finditer方法查找"><a href="#3-finditer方法查找" class="headerlink" title="3. finditer方法查找"></a>3. finditer方法查找</h3><ul><li><p>方法：<strong>finditer(pattern, string[, flags])，该方法会在参数string指定的字符串中查找参数pattern指定的所有子串</strong></p><ul><li>参数pattern：是一个正则表达式，或对正则表达式预编译之后得到的对象</li><li>参数string：需要查找的普通字符串</li></ul></li><li><p>返回值：<strong>如果有匹配的子串，则返回所有匹配的子串组成的迭代器；如果没有匹配的子串，则返回不包含任何元素的迭代器</strong></p></li><li><p>注意：除了直接调用模块re的方法finditer()之外，也可以调用模块re的方法compile()的返回值的方法<strong>finditer(string[, pos[, endpos]])</strong></p><ul><li>参数pos用于指定被查找的字符串的起始位置，默认值为0</li><li>参数endpos用于指定被查找的字符串的结束位置，默认值是字符串的长度。被查找的子串不包括结束位置，<strong>类似左闭右开</strong></li><li>模块re的方法finditer()中的参数pattern和flags被转移到了方法compile()中</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">compile = re.compile(r&#x27;\d+&#x27;)</span><br><span class="line"></span><br><span class="line">iterator = re.finditer(r&#x27;\d+&#x27;, &#x27;-123-56-89-&#x27;)</span><br><span class="line">for match in iterator:</span><br><span class="line">    print(match)</span><br><span class="line">    # &lt;re.Match object; span=(1, 4), match=&#x27;123&#x27;&gt;</span><br><span class="line">    # &lt;re.Match object; span=(5, 7), match=&#x27;56&#x27;&gt;</span><br><span class="line">    # &lt;re.Match object; span=(8, 10), match=&#x27;89&#x27;&gt;</span><br><span class="line">iterator = re.finditer(r&#x27;\d+&#x27;, &#x27;-abc-d-efg-&#x27;)</span><br><span class="line">for match in iterator:</span><br><span class="line">    print(match)  # </span><br><span class="line"></span><br><span class="line">iterator = compile.finditer(&#x27;-123-56-89-&#x27;)</span><br><span class="line">for match in iterator:</span><br><span class="line">    print(match)</span><br><span class="line">    # &lt;re.Match object; span=(1, 4), match=&#x27;123&#x27;&gt;</span><br><span class="line">    # &lt;re.Match object; span=(5, 7), match=&#x27;56&#x27;&gt;</span><br><span class="line">    # &lt;re.Match object; span=(8, 10), match=&#x27;89&#x27;&gt;</span><br><span class="line">iterator = compile.finditer(&#x27;-123-56-89-&#x27;, 4)</span><br><span class="line">for match in iterator:</span><br><span class="line">    print(match)</span><br><span class="line">    # &lt;re.Match object; span=(5, 7), match=&#x27;56&#x27;&gt;</span><br><span class="line">    # &lt;re.Match object; span=(8, 10), match=&#x27;89&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="4-sub方法替换"><a href="#4-sub方法替换" class="headerlink" title="4. sub方法替换"></a>4. sub方法替换</h3><ul><li><p>方法：<strong>sub(pattern, repl, string[, count][, flags])，该方法会将参数string指定的字符串中所匹配参数pattern的子串替换为参数repl指定的字符串</strong></p><ul><li>参数pattern：是一个正则表达式，或对正则表达式预编译之后得到的对象</li><li>参数string：需要查找的普通字符串</li><li>参数repl：<strong>既可以指定为替换的字符串，还可以指定为一个函数。通过该函数，可以把每次匹配对应的Match对象作为函数的输入参数，在函数体中对匹配的子串进行处理，函数的输出返回值作为替换的字符串</strong></li><li>参数count：用于指定最大替换次数，默认值为0，表示替换所有的匹配</li></ul></li><li><p>返回值：<strong>替换成功后得到的字符串</strong></p></li><li><p>应用：sub()方法也可以实现字符串中子串的删除，将repl参数（替换字符串）设置为空字符串即可</p></li><li><p>方法：<strong>subn()(pattern, repl, string[, count][, flags])，其用法与sub()方法完全一致，不同的是返回值为包含两个元素的元组，即对应的方法sub()的返回值、替换次数</strong></p></li><li><p>注意：除了直接调用模块re的方法sub()和subn()之外，也可以调用模块re的方法compile()的返回值的方法**sub(repl, string[, count])、subn(repl, string[, count])**。模块re的方法sub()和subn()中的参数pattern和flags被转移到了方法compile()中</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.sub(r&#x27;\d+&#x27;, &#x27;888&#x27;, &#x27;-123-56-89-&#x27;))  # -888-888-888-</span><br><span class="line">print(re.sub(r&#x27;\d+&#x27;, &#x27;888&#x27;, &#x27;-123-56-89-&#x27;, 2))  # -888-888-89-</span><br><span class="line"></span><br><span class="line">def add1(match):</span><br><span class="line">    # print(match)        # &lt;re.Match object; span=(1, 4), match=&#x27;123&#x27;&gt;</span><br><span class="line">    val = match.group()  # &lt;re.Match object; span=(5, 7), match=&#x27;56&#x27;&gt;</span><br><span class="line">    num = int(val) + 1  # &lt;re.Match object; span=(8, 11), match=&#x27;789&#x27;&gt;</span><br><span class="line">    return str(num)</span><br><span class="line"></span><br><span class="line">print(re.sub(r&#x27;\d+&#x27;, add1, &#x27;-123-56-89-&#x27;))  # -124-57-90-</span><br><span class="line">print(re.subn(r&#x27;\d+&#x27;, add1, &#x27;-123-56-89-&#x27;))  # (&#x27;-124-57-90-&#x27;, 3)</span><br><span class="line"></span><br><span class="line"># 当替换字符串为空字符串时，可以实现字符串中子串的删除</span><br><span class="line">print(re.sub(r&#x27;[aeiou]&#x27;, &#x27;&#x27;, &#x27;HELLO world&#x27;, flags=re.I))  # HLL wrld</span><br><span class="line"></span><br><span class="line">compile = re.compile(r&#x27;\d+&#x27;)</span><br><span class="line">print(compile.sub(&#x27;888&#x27;, &#x27;-123-56-789-&#x27;))  # -888-888-888-</span><br><span class="line">print(compile.sub(add1, &#x27;-123-56-789-&#x27;))  # -124-57-790-</span><br><span class="line">print(compile.subn(add1, &#x27;-123-56-789-&#x27;))  # (&#x27;-124-57-790-&#x27;, 3)</span><br></pre></td></tr></table></figure><h3 id="5-split方法劈分"><a href="#5-split方法劈分" class="headerlink" title="5. split方法劈分"></a>5. split方法劈分</h3><ul><li>方法：<strong>split(pattern, string[, maxsplit][, flags])，该方法会根据参数pattern指定的劈分符对参数string指定的字符串进行劈分</strong><ul><li>参数pattern：是一个正则表达式，或对正则表达式预编译之后得到的对象</li><li>参数string：需要劈分的普通字符串</li><li>参数maxsplit：用于指定最大劈分次数，默认值为0，表示不限制劈分次数</li></ul></li><li>返回值：<strong>劈分后所有子串组成的列表</strong></li><li>注意：除了直接调用模块re的方法split()之外，也可以调用模块re的方法compile()的返回值的方法**split(string[, maxsplit])**。模块re的方法split()中的参数pattern和flags被转移到了方法compile()中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.split(r&#x27;\s+&#x27;, &#x27;a  b    c   d&#x27;))  # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">print(re.split(r&#x27;\s+&#x27;, &#x27;a  b    c   d&#x27;, 2))  # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c   d&#x27;]</span><br><span class="line">print(re.split(&#x27;[\s,;]+&#x27;, &#x27;a,  b;; c , ;d,e&#x27;))  # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line"></span><br><span class="line">pattern = re.compile(r&#x27;\s+&#x27;)</span><br><span class="line">print(pattern.split(&#x27;a  b    c   d&#x27;))  # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">print(pattern.split(&#x27;a  b    c   d&#x27;, 2))  # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c   d&#x27;]</span><br></pre></td></tr></table></figure><h3 id="6-Match对象属性和方法（图）"><a href="#6-Match对象属性和方法（图）" class="headerlink" title="6. Match对象属性和方法（图）"></a>6. Match对象属性和方法（图）</h3><ul><li><p>简介：模块re的方法match()和search()在匹配成功时都会返回一个Match对象，该对象包含了很多关于此次匹配的信息，可以通过访问Match对象提供的属性和方法来获取这些匹配信息</p><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1667733266-50ed1fdb00264c5.jpg"                         style="width:80%;margin:0 auto;"                 ><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1667733264-c7554c63e22a758.jpg"                         style="width:80%;margin:0 auto;"                 ></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">match_obj = re.compile(r&#x27;(\d+)-(?P&lt;sec&gt;\d+)&#x27;).match(&#x27;025-3456abc&#x27;, 1, 7)</span><br><span class="line">print(match_obj)  # &lt;re.Match object; span=(1, 7), match=&#x27;25-345&#x27;&gt;</span><br><span class="line"></span><br><span class="line">print(match_obj.string)  # 025-3456abc</span><br><span class="line">print(match_obj.re)  # re.compile(&#x27;(\\d+)-(?P&lt;sec&gt;\\d+)&#x27;)</span><br><span class="line">print(match_obj.pos)  # 1</span><br><span class="line">print(match_obj.endpos)  # 7</span><br><span class="line">print(match_obj.lastindex)  # 2</span><br><span class="line">print(match_obj.lastgroup)  # sec</span><br><span class="line"></span><br><span class="line">print(match_obj.group(2))  # 345</span><br><span class="line">print(match_obj.group(&#x27;sec&#x27;))  # 345</span><br><span class="line">print(match_obj.group())  # 25-345</span><br><span class="line">print(match_obj.group(0))  # 25-345</span><br><span class="line">print(match_obj.group(1, &#x27;sec&#x27;))  # (&#x27;25&#x27;, &#x27;345&#x27;)</span><br><span class="line">print(match_obj.groups())  # (&#x27;25&#x27;, &#x27;345&#x27;)</span><br><span class="line">print(match_obj.groupdict())  # &#123;&#x27;sec&#x27;: &#x27;345&#x27;&#125;</span><br><span class="line"></span><br><span class="line">print(match_obj.start(&#x27;sec&#x27;))  # 4</span><br><span class="line">print(match_obj.start())  # 1</span><br><span class="line">print(match_obj.end(&#x27;sec&#x27;))  # 7</span><br><span class="line">print(match_obj.end())  # 7</span><br><span class="line">print(match_obj.span(&#x27;sec&#x27;))  # (4, 7)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、正则表达式&quot;&gt;&lt;a href=&quot;#一、正则表达式&quot; class=&quot;headerlink&quot; title=&quot;一、正则表达式&quot;&gt;&lt;/a&gt;一、正则表达式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是正则表达式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_3_线程、进程与协程</title>
    <link href="http://example.com/2023/06/01/Python_3_%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
    <id>http://example.com/2023/06/01/Python_3_%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</id>
    <published>2023-05-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h2><blockquote><p><strong>重要概念：</strong></p><ul><li><strong>进程</strong>：是系统进行资源分配和调度的一个独立单位。即运行中的应用程序，应用程序是静态的，而进程是动态的</li><li><strong>线程</strong>：是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务</li><li><strong>并发</strong>：多个任务交替执行的方式称为并发</li><li><strong>并行</strong>：多个任务同时执行的方式称为并行（<strong>不管是单核 cpu 还是多核 cpu 都支持多任务</strong>）</li></ul><p><strong>进程与线程的关联：</strong></p><ol><li>每个进程至少对应一个线程。每个进程用来完成一件任务，每个线程用来完成进程内的一件子任务</li><li><strong>每个进程都有独立的内存空间，而进程内的所有线程共享内存空间</strong></li></ol></blockquote><h3 id="1-自动创建与启动的线程"><a href="#1-自动创建与启动的线程" class="headerlink" title="1. 自动创建与启动的线程"></a>1. 自动创建与启动的线程</h3><ul><li>简介：<strong>任何进程都会自动创建并启动一个线程，该线程被称为父&#x2F;主线程，其默认名称为 MainThread</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 自动创建并启动了主线程：MainThread</span><br><span class="line">print(f&#x27;自动创建并启动了主线程：&#123;threading.current_thread().name&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure><h3 id="2-子线程的创建1"><a href="#2-子线程的创建1" class="headerlink" title="2. 子线程的创建1"></a>2. 子线程的创建1</h3><ul><li><p><strong>使用类对象 Thread 创建并启动子线程：</strong>标准库模块 threading 中提供了一个类对象 Thread，用于表示线程</p></li><li><p><strong>应用：</strong>根据类对象 Thread 创建线程实例对象，调用线程实例对象的方法 start() 即可启动线程（<strong>调用方法 start() 后，先会自动调用 Thread 类中的 run() 方法，方法run()又会自动调用参数 target 指定的函数</strong>）</p></li><li><p><strong>创建线程实例对象时必须指定关键字实参：</strong></p><ul><li>其构造方法定义为：<strong>__init__(self, group&#x3D;None, target&#x3D;None, name&#x3D;None, args&#x3D;(), kwargs&#x3D;None, *, daemon&#x3D;None)</strong></li></ul><ol><li><strong>参数 group：</strong>用于指定线程实例对象所属的线程组，默认不属于任何线程组</li><li><strong>参数 name：</strong>用于指定创建的线程实例对象的名称，第n个子线程的默认名称为’Thread-n’</li><li><strong>参数 target：</strong>用于指定被方法run()调用的函数，默认没有函数被调用</li><li><strong>参数 args：</strong>用于指定target接收的位置参数，用元组表示，默认不接收位置参数</li><li><strong>参数 kwargs：</strong>用于指定target接收的关键字参数，用字典表示，默认不接收关键字参数</li><li><strong>参数 daemon：</strong>用于指定线程实例对象是否是守护线程，默认不是守护线程</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(&#x27;父线程%s启动&#x27; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">def do_sth(arg1, arg2):</span><br><span class="line">    print(&#x27;子线程%s启动&#x27; % threading.current_thread().name)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#x27;arg1 = %d, arg2 = %d&#x27; % (arg1, arg2))</span><br><span class="line">    print(&#x27;子线程%s结束&#x27; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"># 创建线程对象，但线程是没有被操作系统创建的</span><br><span class="line">t1 = threading.Thread(target=do_sth, args=(5, 8), name=&#x27;mythread&#x27;)</span><br><span class="line"># 启动线程对象时，操作系统才创建线程</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br><span class="line">print(&#x27;父线程%s结束&#x27; % threading.current_thread().name)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父线程MainThread启动</span><br><span class="line">子线程mythread启动</span><br><span class="line">arg1 = 5, arg2 = 8</span><br><span class="line">子线程mythread结束</span><br><span class="line">父线程MainThread结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-子线程的创建2"><a href="#3-子线程的创建2" class="headerlink" title="3. 子线程的创建2"></a>3. 子线程的创建2</h3><ul><li><strong>自定义继承自 Thread 的类对象：</strong>重写 __init__() 和 run() 方法，使用自定义类对象创建并启动子线程</li><li><strong>应用：</strong>根据自定义的类对象创建线程实例对象，然后调用线程实例对象的方法 start() 启动线程（<strong>调用方法 start() 后，会自动调用重写后的 run() 方法</strong>）</li><li><strong>与子线程的创建 1 的区别：</strong><ul><li><strong>在创建线程实例对象时无需再指定参数 target</strong>，参数 target 指定的函数的函数体转移到了方法 run() 中</li><li>第 1 种方式创建线程实例对象时指定的其它参数，在第 2种方式中可以传递给重写后的特殊方法__init__()</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread, current_thread</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(&#x27;父线程%s启动&#x27; % current_thread().name)</span><br><span class="line"></span><br><span class="line">class MyThread(Thread):</span><br><span class="line">    def __init__(self, name, args):</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;子线程%s启动&#x27; % current_thread().name)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&#x27;arg1 = %d, arg2 = %d&#x27; % self.args)</span><br><span class="line">        print(&#x27;子线程%s结束&#x27; % current_thread().name)</span><br><span class="line"></span><br><span class="line">mt = MyThread(name=&#x27;mythread&#x27;, args=(5, 8))</span><br><span class="line">mt.start()</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br><span class="line">print(&#x27;父线程%s结束&#x27; % current_thread().name)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父线程MainThread启动</span><br><span class="line">子线程mythread启动</span><br><span class="line">arg1 = 5, arg2 = 8</span><br><span class="line">子线程mythread结束</span><br><span class="line">父线程MainThread结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="二、进程"><a href="#二、进程" class="headerlink" title="二、进程"></a>二、进程</h2><h3 id="1-自动创建与启动的进程"><a href="#1-自动创建与启动的进程" class="headerlink" title="1. 自动创建与启动的进程"></a>1. 自动创建与启动的进程</h3><ul><li>简介：当PyCharm中运行一个py文件时，PyCharm对应的进程会自动创建并启动一个新进程，该进程被称为父进程，其默认名称为Python。<strong>当文件运行结束时，进程也会随之结束</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import multiprocessing</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(os.getpid())  # 获取当前的进程id</span><br><span class="line">print(os.getppid())  # 获取当前进程的父进程id</span><br><span class="line"></span><br><span class="line"># 方法current_process可以直接创建当前进程的实例对象，其属性pid即为当前进程id</span><br><span class="line">print(multiprocessing.current_process().pid)</span><br><span class="line"></span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure><h3 id="2-子进程的创建1"><a href="#2-子进程的创建1" class="headerlink" title="2. 子进程的创建1"></a>2. 子进程的创建1</h3><blockquote><p><strong>为什么要在 if __name__ &#x3D;&#x3D; ‘__main__‘: 条件下执行代码？</strong></p><p>解释：<strong>当在 Python 中使用多进程编程时，由于操作系统在创建子进程时会复制主进程的内存空间，包括所有已导入的模块和全局变量，当子进程被创建时，它会重新执行整个脚本，导致导入的模块被重复导入，全局变量被重新初始化，这可能会导致不正确的执行结果</strong>。在 __name__ &#x3D;&#x3D; ‘__main__‘ 的条件下执行代码的作用是仅当你的脚本直接运行时（即作为主程序执行时），才会执行条件块中的代码，如果你的脚本被作为模块导入到其他脚本中，那么条件块中的代码就不会执行。</p></blockquote><ul><li><p><strong>使用类对象 Process 创建并启动子进程：</strong>标准库模块 multiprocessing 中提供了一个类对象 Process，用于表示进程</p></li><li><p><strong>应用：</strong>根据类对象 Process 创建进程实例对象，调用进程实例对象的方法 start() 即可启动进程（<strong>调用方法 start() 后，先会自动调用 Process 类中的 run() 方法，方法 run() 又会自动调用参数 target 指定的函数</strong>）</p></li><li><p><strong>创建进程实例对象时必须指定关键字实参：</strong></p><ul><li>其构造方法定义为：<strong>__init__(self, group&#x3D;None, target&#x3D;None, name&#x3D;None, args&#x3D;(), kwargs&#x3D;{}, *, daemon&#x3D;None)</strong></li></ul><ol><li><strong>参数 group：</strong>用于指定进程实例对象所属的进程组，默认不属于任何进程组</li><li><strong>参数 target：</strong>用于指定被方法run()调用的函数，默认没有函数被调用</li><li><strong>参数 name：</strong>用于指定创建的进程实例对象的名称，第n个子进程的默认名称为’Process-n’</li><li><strong>参数 args：</strong>用于指定target接收的位置参数，用元组表示，默认不接收位置参数</li><li><strong>参数 kwargs：</strong>用于指定target接收的关键字参数，用字典表示，默认不接收关键字参数</li><li><strong>参数 daemon：</strong>用于指定进程实例对象是否是守护进程，默认不是守护进程</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, current_process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">current_pid = current_process().pid</span><br><span class="line">current_name = current_process().name</span><br><span class="line"></span><br><span class="line">def do_sth(arg1, arg2):</span><br><span class="line">    print(&#x27;子进程启动(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#x27;arg1 = %d, arg2 = %d&#x27; % (arg1, arg2))</span><br><span class="line">    print(&#x27;子进程结束(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line"></span><br><span class="line"># 确保在多进程环境中，主进程和子进程之间不会相互干扰，保持代码的预期行为</span><br><span class="line"># python默认使用fork的方式成创建进程，macOS和windows必须要写函数入口，而linux不用</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;父进程启动(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line">    process = Process(target=do_sth, args=(5, 8), name=&quot;childProcess&quot;)</span><br><span class="line">    process.start()</span><br><span class="line">    # is_alive()方法用于检查一个进程是否处于活动状态</span><br><span class="line">    print(process.is_alive())</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(process.is_alive())</span><br><span class="line">    print(&#x27;父进程结束(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父进程启动(15936--MainProcess)</span><br><span class="line">True</span><br><span class="line">子进程启动(15938--childProcess)</span><br><span class="line">arg1 = 5, arg2 = 8</span><br><span class="line">子进程结束(15938--childProcess)</span><br><span class="line">False</span><br><span class="line">父进程结束(15936--MainProcess)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-子进程的创建2"><a href="#3-子进程的创建2" class="headerlink" title="3. 子进程的创建2"></a>3. 子进程的创建2</h3><ul><li><p><strong>自定义继承自 Process 的类对象：</strong>重写 __init__() 和 run() 方法，使用自定义类对象创建并启动子进程</p></li><li><p><strong>应用：</strong>根据自定义的类对象创建进程实例对象，调用进程实例对象的方法 start() 启动进程（<strong>调用方法 start() 后，会自动调用重写后的 run() 方法</strong>）</p></li><li><p><strong>与子进程的创建 1 的区别：</strong></p><ul><li><p><strong>在创建进程实例对象时无需再指定参数 target</strong>，参数 target 指定的函数的函数体转移到了方法 run() 中</p></li><li><p>第 1 种方式创建进程实例对象时指定的其它参数，在第 2 种方式中可以传递给重写后的特殊方法__init__()</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, current_process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">current_pid = current_process().pid</span><br><span class="line">current_name = current_process().name</span><br><span class="line"></span><br><span class="line">class MyProcess(Process):</span><br><span class="line">    def __init__(self, name, args):</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;子进程启动(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&#x27;arg1 = %d, arg2 = %d&#x27; % self.args)</span><br><span class="line">        print(&#x27;子进程结束(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;父进程启动(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line"></span><br><span class="line">    mp = MyProcess(name=&#x27;myprocess&#x27;, args=(5, 8))</span><br><span class="line">    mp.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&#x27;父进程结束(%d--%s)&#x27; % (current_pid, current_name))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父进程启动(16074--MainProcess)</span><br><span class="line">子进程启动(16076--myprocess)</span><br><span class="line">arg1 = 5, arg2 = 8</span><br><span class="line">子进程结束(16076--myprocess)</span><br><span class="line">父进程结束(16074--MainProcess)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="4-子进程的创建3"><a href="#4-子进程的创建3" class="headerlink" title="4. 子进程的创建3"></a>4. 子进程的创建3</h3><ul><li><strong>标准库模块 os 中提供了一个函数 fork()：</strong>用于将当前进程复制一份为子进程，而后父进程和子进程从调用 fork() 处开始分叉，fork的含义即兵分两路，继续并行运行后面的程序</li><li><strong>与普通函数不同的是，函数 fork() 会返回两次，分别在父进程和子进程内返回。返回值有三种情况：</strong><ol><li>返回值小于0，表示复制子进程失败</li><li>返回值等于0，表示处在子进程中</li><li>返回值大于0，表示处在父进程中，返回值就是子进程的 id</li></ol></li><li><strong>注意：函数 fork() 不是跨平台的，所以在 windows 操作系统上无法调用函数 fork()，而模块 multiprocessing 是跨平台的</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    flag = os.fork()</span><br><span class="line">except OSError:</span><br><span class="line">    print(&#x27;你的操作系统不支持调用函数fork()&#x27;)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">if flag &lt; 0:</span><br><span class="line">    print(&#x27;复制子进程失败&#x27;)</span><br><span class="line">elif flag == 0:</span><br><span class="line">    print(f&#x27;我处在子进程 &#123;os.getpid()&#125; 中，父进程id为 &#123;os.getppid()&#125;&#x27;)</span><br><span class="line">    # 我处在子进程 2646 中，父进程id为 2645</span><br><span class="line">else:</span><br><span class="line">    print(f&#x27;我处在父进程中，子进程id为 &#123;flag&#125;&#x27;)</span><br><span class="line">    # 我处在父进程中，子进程id为 2646</span><br></pre></td></tr></table></figure><h2 id="三、进程池与线程池"><a href="#三、进程池与线程池" class="headerlink" title="三、进程池与线程池"></a>三、进程池与线程池</h2><h3 id="1-进程池Pool"><a href="#1-进程池Pool" class="headerlink" title="1. 进程池Pool"></a>1. 进程池Pool</h3><ul><li><strong>标准库模块 multiprocessing 中提供了一个类对象Pool：</strong>用于表示进程池，进程池中所能容纳的进程数目可以在创建 Pool 实例对象时进行指定，如果不指定，默认大小是 CPU 的核数</li><li><strong>作用：</strong>如果并发的任务数过多，一次性创建并启动大量的进程会给计算机带来很大的压力，那么就可以使用进程池对创建与启动的进程进行限制和管理（<strong>进程池中所能容纳的进程数目是固定的</strong>）</li><li><strong>Pool 进程池的常用方法：</strong><ul><li><strong>apply_async()：</strong>表示异步，子进程接收到请求之后就各自去执行了。作用与方法 start() 类似，但创建并启动的是由进程池管理的子进程</li><li>apply()：表示同步，子进程们将一个一个的执行，后一个子进程的执行永远以前一个子进程的结束为信号，开始执行</li><li><strong>close()：</strong>关闭进程池，至此进程池中不再有进程可以接受任务（调用方法 join 之前必须先调用方法 close）</li><li>terminate()：结束当前进程池中的所有进程，不再处理未完成的任务，不管执没执行</li><li><strong>join()：</strong>阻塞主进程，等待子进程执行完毕，再继续执行主进程</li></ul></li><li><strong>各方法执行顺序：close() &gt; terminate() &gt; join()。其中，terminate和join方法可以都不执行，那么子进程和主进程就各自执行各自的，无论执行到哪里，子进程会随着主进程的结束而结束</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import time, random</span><br><span class="line"></span><br><span class="line">def do_sth(i):</span><br><span class="line">    print(&#x27;子进程%d启动&#x27; % i)</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * 10)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;子进程%d结束，耗时%.2f秒&#x27; % (i, end - start))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;父进程启动&#x27;)</span><br><span class="line">    # 将进程池所能容纳的最大进程数指定为3</span><br><span class="line">    pp = Pool(3)</span><br><span class="line">    # 异步执行子进程</span><br><span class="line">    for i in range(1, 11):</span><br><span class="line">        pp.apply_async(do_sth, args=(i,))</span><br><span class="line"></span><br><span class="line">    pp.close()  # 在join之前必须关闭进程池</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    pp.terminate()  # 5秒后，终止父进程和进程池中的所有进程，且不受join限制，是无敌的</span><br><span class="line">    pp.join()  # 如果开启 time.sleep(5) + pp.terminate()，那么join在此处已经无效了</span><br><span class="line">    print(&quot;父进程结束&quot;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父进程启动</span><br><span class="line">子进程1启动</span><br><span class="line">子进程2启动</span><br><span class="line">子进程3启动</span><br><span class="line">子进程3结束，耗时3.23秒</span><br><span class="line">子进程4启动</span><br><span class="line">子进程1结束，耗时3.37秒</span><br><span class="line">子进程5启动</span><br><span class="line">子进程4结束，耗时0.54秒</span><br><span class="line">子进程6启动</span><br><span class="line">父进程结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="2-ProcessPoolExecutor"><a href="#2-ProcessPoolExecutor" class="headerlink" title="2. ProcessPoolExecutor"></a>2. ProcessPoolExecutor</h3><ul><li><strong>标准库模块 concurrent.futures 中提供了一个类对象 ProcessPoolExecutor：</strong>也用于表示进程池，与 Pool 相比，ProcessPoolExecutor 的功能和性能更加强大</li><li><strong>应用：</strong>类对象 ProcessPoolExecutor <strong>遵守了上下文管理协议</strong>，使用 with 语句在离开运行时上下文会自动调用 ppe.shutdown(wait&#x3D;True) 方法关闭进程池</li><li><strong>ProcessPoolExecutor 进程池的常用方法：</strong><ul><li><strong>submit(func, *args, **kwargs)：</strong>用于将单个任务提交到进程池，并返回一个 Future 对象，该对象代表了将来会完成的任务，此后会创建并启动由进程池管理的子进程</li><li><strong>map(func, iterable, timeout&#x3D;None)：</strong>用法与内置函数 map 类似，是阻塞的，用于批量提交多个任务到进程池，并返回一个迭代器，通过迭代器可以获取每个任务的结果。其第二个参数为可迭代对象，此后会创建并启动由进程池管理的子进程</li><li><strong>shutdown()：</strong>阻塞主进程，待进程池管理的所有子进程执行完毕后，父进程再从被阻塞的地方继续执行，并且把进程池关闭（<strong>相当于 close + join 方法的组合</strong>）</li></ul></li><li><strong>Future对象</strong>：在 ProcessPoolExecutor 进程池中，方法 submit() 的返回值是一个 Future 实例对象，表示子进程所调用的函数的执行，<strong>可以调用 Future 的方法 result() 得到这个函数的返回值</strong><ul><li><strong>result()：方法 result() 是一个同步方法，也就是每直到这个函数执行完毕之后，result() 才会返回</strong></li><li><strong>cancel()：任务取消</strong></li><li><strong>done()：获取当前 future 对象是否完成任务的状态</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def do_sth(i):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    return i * i</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # with ProcessPoolExecutor(max_workers=3) as ppe:</span><br><span class="line">    #     for i in range(1, 5):</span><br><span class="line">    #         future = ppe.submit(do_sth, i)</span><br><span class="line">    #         print(future.result())  # 同步，需要等待每一个子进程的do_sth执行完毕</span><br><span class="line"></span><br><span class="line">    future_objs = []</span><br><span class="line">    start = time.time()</span><br><span class="line">    with ProcessPoolExecutor(max_workers=3) as ppe:</span><br><span class="line">        for i in range(1, 5):</span><br><span class="line">            future = ppe.submit(do_sth, i)</span><br><span class="line">            future_objs.append(future)  # 异步，先不调用方法result()，只是存进列表</span><br><span class="line"></span><br><span class="line">    for obj in future_objs:</span><br><span class="line">        print(obj.result())</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&quot;异步执行总耗时：%.2f秒&quot; % (end - start))  # 异步执行总耗时：4.08秒</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">异步执行总耗时：4.07秒</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-线程池ThreadPool"><a href="#3-线程池ThreadPool" class="headerlink" title="3. 线程池ThreadPool"></a>3. 线程池ThreadPool</h3><ul><li><strong>第三方库 threadpool 中提供了一个类对象 ThreadPool：</strong>用于表示线程池，线程池中所能容纳的线程数目可以在创建 ThreadPool 实例对象时进行指定，如果不指定，默认大小是 CPU 的核数</li><li><strong>作用：</strong>如果并发的任务数过多，一次性创建并启动大量的线程会给计算机带来很大的压力，那么就可以使用线程池对创建与启动的线程进行限制和管理（<strong>线程池中所能容纳的线程数目是固定的</strong>）</li><li><strong>ThreadPool 线程池的常用方法：</strong><ul><li><strong>makeRequests()：</strong>创建需要线程池处理的任务，返回一个列表</li><li><strong>putRequest()：</strong>将需要线程池处理的任务全部交给线程池，此后会创建并启动由线程池管理的子线程</li><li><strong>wait()：</strong>阻塞主线程，待线程池管理的所有子线程执行完后，父线程再从被阻塞的地方继续执行</li></ul></li><li><strong>注意：wait() 方法等价 join() 方法。虽然线程中也可以使用 join() 方法，但那是 threading 模块中的 Thread 类对象中才有的方法，而此处 threadpool 模块中的 ThreadPool 类对象中只有 wait() 方法用于阻塞主线程</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">from threadpool import ThreadPool, makeRequests</span><br><span class="line">import time, random</span><br><span class="line"></span><br><span class="line"># 传递给函数的实参列表</span><br><span class="line">args_list = [i for i in range(1, 11)]</span><br><span class="line"></span><br><span class="line">def do_sth(i):</span><br><span class="line">    print(&#x27;子线程%d启动&#x27; % i)</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * 10)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;子线程%d结束，耗时%.2f秒&#x27; % (i, end - start))</span><br><span class="line"></span><br><span class="line">print(&#x27;父线程启动&#x27;)</span><br><span class="line">tp = ThreadPool(3)  # 创建能容纳的最大线程数为3的线程池</span><br><span class="line">requests = makeRequests(do_sth, args_list)  # 创建需要线程池处理的任务列表</span><br><span class="line">for req in requests:  # 将需要线程池处理的任务全部交给线程池</span><br><span class="line">    tp.putRequest(req)</span><br><span class="line">tp.wait()  # 阻塞主线程</span><br><span class="line">print(&#x27;父线程结束&#x27;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父线程启动</span><br><span class="line">子线程1启动</span><br><span class="line">子线程2启动</span><br><span class="line">子线程3启动</span><br><span class="line">子线程1结束，耗时1.48秒</span><br><span class="line">子线程4启动</span><br><span class="line">子线程4结束，耗时0.03秒</span><br><span class="line">子线程5启动</span><br><span class="line">子线程5结束，耗时2.12秒</span><br><span class="line">子线程6启动</span><br><span class="line">子线程2结束，耗时3.81秒</span><br><span class="line">子线程7启动</span><br><span class="line">子线程6结束，耗时4.11秒</span><br><span class="line">子线程8启动</span><br><span class="line">子线程8结束，耗时1.11秒</span><br><span class="line">子线程9启动</span><br><span class="line">子线程3结束，耗时9.79秒</span><br><span class="line">子线程10启动</span><br><span class="line">子线程9结束，耗时1.71秒</span><br><span class="line">子线程7结束，耗时7.13秒</span><br><span class="line">子线程10结束，耗时3.09秒</span><br><span class="line">父线程结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="4-ThreadPoolExecutor"><a href="#4-ThreadPoolExecutor" class="headerlink" title="4. ThreadPoolExecutor"></a>4. ThreadPoolExecutor</h3><ul><li><p><strong>标准库模块 concurrent.futures 中还提供了一个类对象 ThreadPoolExecutor：</strong>用于实现线程池，管理并发执行的任务</p></li><li><p><strong>应用：</strong>类对象 ThreadPoolExecutor <strong>遵守了上下文管理协议</strong>，使用 with 语句在离开运行时上下文会自动调用 tpe.shutdown() 方法关闭线程池</p></li><li><p><strong>其余用法：线程池 ThreadPoolExecutor 与进程池 ProcessPoolExecutor 的所有用法几乎一致</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def square(x):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line">with ThreadPoolExecutor(max_workers=2) as tpe:</span><br><span class="line">    # 主线程提交了 3 个任务并等待其完成，在等待的过程中，前面两个任务可能已经完成，它们的结果会立即被打印出来</span><br><span class="line">    # 1. 使用submit方法提交任务到线程池</span><br><span class="line">    future_objs = []</span><br><span class="line">    for i in range(2, 5):</span><br><span class="line">        future = tpe.submit(square, i)</span><br><span class="line">        future_objs.append(future)</span><br><span class="line"></span><br><span class="line">    for obj in future_objs:</span><br><span class="line">        print(obj.result())  # 4 9 16</span><br><span class="line"></span><br><span class="line">    # 2. 使用map方法批量提交任务到线程池</span><br><span class="line">    # results = tpe.map(square, range(2, 5))</span><br><span class="line">    # for result in results:</span><br><span class="line">    #     print(result)  # 4 9 16</span><br></pre></td></tr></table></figure><h3 id="5-方法wait与as-completed"><a href="#5-方法wait与as-completed" class="headerlink" title="5. 方法wait与as_completed"></a>5. 方法wait与as_completed</h3><ul><li>**wait(fs, timeout&#x3D;None, return_when&#x3D;ALL_COMPLETED)**：<ul><li><strong>作用：用于等待一组任务完成，是阻塞的，可接受一个或多个 Future 对象作为参数，一直等待直到所有指定的 Future 对象都满足指定的条件</strong></li><li><strong>参数 fs</strong>：是一个 Future 对象的列表，表示要等待的任务集合</li><li><strong>参数 timeout</strong>：指定最长等待时间，在超时时间内等待，超时则不再等待（如果指定为 None 或不指定，则一直等待）</li><li><strong>参数 return_when</strong>：指定何时返回，取值为<strong>FIRST_COMPLETED</strong>（当第一个Future实例对象已经完成或已被取消时）、<strong>FIRST_EXCEPTION</strong>（当第一个Future实例对象抛出异常时）和<strong>ALL_COMPLETED</strong>（当所有Future实例对象已经完成或已被取消时）</li><li><strong>返回值：返回两个集合组成的一个元组，第一个集合包含已经完成或已被取消的所有 Future 实例对象，第二个集合包含没有完成并且没有被取消的 Future 实例对象</strong></li></ul></li><li>**as_completed(fs, timeout&#x3D;None)**：<ul><li><strong>作用：用于获取一组任务中已完成的任务的结果，是非阻塞的，类似于生成器，它接受一个 Future 对象的序列作为参数，并返回一个迭代器，通过遍历迭代器可以立即获取已完成的任务的结果</strong></li><li><strong>参数fs</strong>：是一个 Future 对象的序列，表示要获取结果的任务集合</li><li><strong>参数timeout</strong>：指定最长等待时间，在超时时间内获取已完成的任务，超时则不再等待（如果指定为 None 或不指定，则不会超时）</li><li><strong>返回值：返回一个 Future 实例对象的迭代器，可以通过 for 循环遍历获取已完成的任务的结果</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import time</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor, \</span><br><span class="line">    wait, FIRST_COMPLETED, as_completed</span><br><span class="line"></span><br><span class="line">def square(x):</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    with ProcessPoolExecutor(max_workers=1) as ppe:</span><br><span class="line">        futures = [ppe.submit(square, i) for i in range(1, 6)]</span><br><span class="line">        # 1. wait方法默认等待所有任务完成</span><br><span class="line">        # done, not_done = wait(futures)</span><br><span class="line">        # 阻塞主线程，只等待第一个任务完成</span><br><span class="line">        # done, not_done = wait(futures, return_when=FIRST_COMPLETED)</span><br><span class="line">        # 等待所有任务完成后，再获取已完成的所有任务的结果</span><br><span class="line">        # for future in done:</span><br><span class="line">        #     print(future.result())  # 4 9 25 1 16</span><br><span class="line"></span><br><span class="line">        # 2. as_completed方法异步获取任务结果</span><br><span class="line">        for future in as_completed(futures):</span><br><span class="line">            print(future.result())  # 1 4 9 16 25</span><br></pre></td></tr></table></figure><h2 id="四、多进程与多线程"><a href="#四、多进程与多线程" class="headerlink" title="四、多进程与多线程"></a>四、多进程与多线程</h2><h3 id="1-执行的不确定性"><a href="#1-执行的不确定性" class="headerlink" title="1. 执行的不确定性"></a>1. 执行的不确定性</h3><ul><li>简介：<strong>无论是多进程还是多线程，在默认情况下，多个进程或者多个线程的执行顺序和时间都是不确定的，完全取决于操作系统的调度</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, current_process</span><br><span class="line">from threading import Thread, current_thread</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def process_task():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&#x27;%s: %d&#x27; % (current_process().name, i))</span><br><span class="line">        time.sleep(2)</span><br><span class="line"></span><br><span class="line">def thread_task():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&#x27;%s: %d&#x27; % (current_thread().name, i))</span><br><span class="line">        time.sleep(2)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for i in range(3):</span><br><span class="line">        Process(target=process_task).start()  # 循环创建3个子进程</span><br><span class="line">        # Thread(target=thread_task).start()  # 循环创建3个子线程</span><br><span class="line"></span><br><span class="line">    process_task()  # 主进程</span><br><span class="line">    # thread_task()  # 主线程</span><br><span class="line">&quot;&quot;&quot;从输出结果来看，多进程的执行顺序和时间都是不确定的</span><br><span class="line">MainProcess: 0</span><br><span class="line">Process-2: 0</span><br><span class="line">Process-1: 0</span><br><span class="line">Process-3: 0</span><br><span class="line">......</span><br><span class="line">MainProcess: 4</span><br><span class="line">Process-1: 4</span><br><span class="line">Process-3: 4</span><br><span class="line">Process-2: 4</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="2-守护属性daemon"><a href="#2-守护属性daemon" class="headerlink" title="2. 守护属性daemon"></a>2. 守护属性daemon</h3><blockquote><p><strong>作用：</strong>防止子进程&#x2F;子线程因为任务无法退出造成整个程序卡死（<strong>作用于创建子进程或子线程的对象上</strong>）</p><p><strong>解释：</strong>只要主程序的代码走到了最后一行，不管里面的子线程或子进程的任务有没有完成，都会随着主程序的退出而退出</p></blockquote><ul><li>简介：<strong>daemon 属性用于标识线程或进程是否是守护线程或进程，其作用是控制线程或进程的生命周期（守护线程或进程是指在主程序结束时会被强制退出的子线程或子进程）</strong></li><li>作用：<ul><li><strong>守护线程或进程的退出时机：</strong>当主程序（主线程或主进程）结束时，会等待所有非守护线程或进程完成任务后再退出。但是对于守护线程或进程，不管任务是否完成，都会被强制退出，不会阻塞主程序的退出</li><li><strong>资源清理：</strong>守护线程或进程在被强制退出时，不会执行清理操作，比如释放资源或关闭文件。因此，它们通常用于执行一些不需要在程序退出时做清理的任务</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import current_process, Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class MyProcess(Process):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;子进程%d启动&#x27; % current_process().pid)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&#x27;子进程%d结束&#x27; % current_process().pid)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;父进程%d启动&#x27; % current_process().pid)</span><br><span class="line">    mp = MyProcess()</span><br><span class="line">    mp.daemon = True</span><br><span class="line">    mp.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&#x27;父进程%d结束&#x27; % current_process().pid)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父进程17514启动</span><br><span class="line">子进程17516启动</span><br><span class="line">父进程17514结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-阻塞方法join"><a href="#3-阻塞方法join" class="headerlink" title="3. 阻塞方法join()"></a>3. 阻塞方法join()</h3><ul><li>简介：<strong>join() 方法用于等待一个多进程或多线程的任务完成，常用于让主线程或主进程等待指定的子线程或子进程执行完毕，然后再继续执行主线程或主进程的后续代码</strong></li><li>作用：<strong>等待任务完成和防止并发问题。在调用方法 join() 时，可以指定参数 timeout，从而指定子进程阻塞父进程的时间</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def worker():</span><br><span class="line">    print(&quot;子线程启动&quot;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;子线程结束&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(&quot;父线程启动&quot;)</span><br><span class="line">    thread = threading.Thread(target=worker)</span><br><span class="line">    thread.start()</span><br><span class="line">    thread.join(1)  # 等待子线程完成</span><br><span class="line">    print(&quot;父线程结束&quot;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">父线程启动</span><br><span class="line">子线程启动</span><br><span class="line">父线程结束</span><br><span class="line">子线程结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="4-全局变量访问与共享"><a href="#4-全局变量访问与共享" class="headerlink" title="4. 全局变量访问与共享"></a>4. 全局变量访问与共享</h3><ul><li><strong>全局变量在多个进程中不能共享</strong>：每个进程都有独立的内存空间，从而子进程的操作不会影响到父进程中的全局变量，它们不是共享同一块内存</li><li><strong>线程之间共享全局变量</strong>：子线程可以访问和修改父线程定义的全局变量，因为它们在同一进程内，共享同一块内存空间。默认情况下，所有线程都共享相同的全局变量</li><li>注意：<strong>在子进程中修改全局变量，对父进程中的全局变量没有影响</strong>，因为子进程中只是对父进程中的全局变量做了一份拷贝，包括global都被拷贝了的，子进程与父进程中的全局变量是完全不同的两个变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">nums = [11, 22]</span><br><span class="line"></span><br><span class="line">def work_1():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        nums.append(i)</span><br><span class="line">    print(nums)</span><br><span class="line"></span><br><span class="line">def work_2():</span><br><span class="line">    print(nums)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    p1 = Process(target=work_1)</span><br><span class="line">    p2 = Process(target=work_2)</span><br><span class="line"></span><br><span class="line">    p1.start()  # [11, 22, 0, 1, 2]</span><br><span class="line">    p1.join()  # 等子进程p1先将元素全部添加到nums中</span><br><span class="line">    print(f&quot;子进程p1中修改nums值后，主进程中nums的值为：&#123;nums&#125;&quot;)  # [11, 22]</span><br><span class="line"></span><br><span class="line">    p2.start()  # [11, 22]，证明子进程p1和p2中的全局变量nums相互独立</span><br><span class="line">    p2.join()</span><br><span class="line">    &quot;&quot;&quot;证明每个进程都有自己独立的内存空间，主进程、子进程p1和p2是3个相互独立的进程&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 子线程中全局变量即为主线程的全局变量</span><br><span class="line">    t1 = Thread(target=work_1)</span><br><span class="line">    t1.start()  # [11, 22, 0, 1, 2]</span><br><span class="line">    t1.join()</span><br><span class="line">    print(f&quot;子线程t1中修改nums值后，主线程中nums的值为：&#123;nums&#125;&quot;)  # [11, 22, 0, 1, 2]</span><br></pre></td></tr></table></figure><h3 id="5-操作数据的不安全性"><a href="#5-操作数据的不安全性" class="headerlink" title="5. 操作数据的不安全性"></a>5. 操作数据的不安全性</h3><ul><li>简介：<strong>多进程与多线程操作共享数据是不安全的</strong>，由于多进程或多线程的执行是不确定的，导致多进程或多线程操作共享数据的结果是不可预期的，常被称为不安全的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">num = 0</span><br><span class="line"></span><br><span class="line">def add():</span><br><span class="line">    global num</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        # num = num + 1</span><br><span class="line">        # 首先计算num + 1，存入临时变量中，然后将临时变量的值赋值给num</span><br><span class="line">        num += 1</span><br><span class="line"></span><br><span class="line">t1 = Thread(target=add)</span><br><span class="line">t2 = Thread(target=add)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(num)  # 1691225</span><br><span class="line"># 当线程1中计算好num+1后，还没有将其赋值给num，cpu就调度到了线程2，此时num值依然为0</span><br><span class="line"># 所以在线程2中计算好num+1的值并存为临时变量也为1，最后cpu再调度回线程1进行赋值num=1，</span><br><span class="line"># 然后调度到线程2也进行赋值num=1，这样最终两个线程虽然进行了两次加法运算，但得到的结果却是num=1</span><br></pre></td></tr></table></figure><h3 id="6-进程间通信之共享内存"><a href="#6-进程间通信之共享内存" class="headerlink" title="6. 进程间通信之共享内存"></a>6. 进程间通信之共享内存</h3><ul><li>简介：想要实现进程之间的通信，共享内存是常见的实现方式之一，它允许多个进程直接访问同一块内存（<strong>共享内存中对象的类型必须是ctypes的，ctypes是C语言兼容的数据类型</strong>）</li><li>实现函数：<ul><li>**Value(self, typecode_or_type, *args, lock&#x3D;True)**，返回值表示一个数值</li><li>**Array(self, typecode_or_type, size_or_initializer, *, lock&#x3D;True)**，返回值表示一个数组</li><li>参数：typecode_or_type用于指定数值&#x2F;数组中元素的类型码或ctypes类型，size_or_initializer用于指定数组的长度或Python中的序列</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Value, Array</span><br><span class="line">import ctypes</span><br><span class="line"></span><br><span class="line"># 在共享内存中创建了一个表示数值的ctypes对象</span><br><span class="line"># num = Value(ctypes.c_float, 2.3)</span><br><span class="line">num = Value(&#x27;d&#x27;, 2.3)</span><br><span class="line"></span><br><span class="line"># 在共享内存中创建了一个表示数组的ctypes对象</span><br><span class="line"># arr = Array(ctypes.c_int, range(1, 5))</span><br><span class="line">arr = Array(&#x27;i&#x27;, range(1, 5))</span><br><span class="line"></span><br><span class="line">def do_sth(num, arr):</span><br><span class="line">    num.value = 1.8</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        arr[i] = -arr[i]</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    p = Process(target=do_sth, args=(num, arr))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(num.value, arr[:])  # 1.8 [-1, -2, -3, -4]</span><br></pre></td></tr></table></figure><h3 id="7-进程间通信之队列"><a href="#7-进程间通信之队列" class="headerlink" title="7. 进程间通信之队列"></a>7. 进程间通信之队列</h3><ul><li>简介：队列是一种线程安全的数据结构，可用于在不同的进程之间成传递数据和消息</li><li><strong>注意：进程池中数据传递是通过 Future 对象异步获取任务的结果，进程间的数据传递更为抽象，不直接使用队列</strong></li><li>方法：<ul><li>put()：将数据放入队列中，是阻塞的。如果队列已满，put()操作会等待直到队列有足够的空间来放入数据</li><li>get()：从队列中获取数据，是阻塞的。如果队列为空，get()操作会等待直到队列中有数据可供获取</li><li>get_nowait()：从队列中获取数据。如果队列为空，则不会等待而是直接抛出异常</li><li>empty()：判断队列是否为空，返回布尔值</li><li>full()：判断队列是否已满，返回布尔值</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import time</span><br><span class="line">from multiprocessing import Queue, Process</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def write_data(queue):</span><br><span class="line">    for item in &#x27;ABC&#x27;:</span><br><span class="line">        queue.put(item)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line">def read_data(queue):</span><br><span class="line">    while True:</span><br><span class="line">        if not queue.empty():</span><br><span class="line">            item = queue.get()</span><br><span class="line">            time.sleep(random.random() * 2)</span><br><span class="line">            print(item)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    queue = Queue()</span><br><span class="line"></span><br><span class="line">    p_write = Process(target=write_data, args=(queue,))</span><br><span class="line">    p_read = Process(target=read_data, args=(queue,))</span><br><span class="line"></span><br><span class="line">    p_write.start()</span><br><span class="line">    p_write.join()</span><br><span class="line"></span><br><span class="line">    p_read.start()  # A B C</span><br><span class="line">    p_read.join()</span><br></pre></td></tr></table></figure><h2 id="五、并发同步"><a href="#五、并发同步" class="headerlink" title="五、并发同步"></a>五、并发同步</h2><h3 id="1-Lock锁"><a href="#1-Lock锁" class="headerlink" title="1. Lock锁"></a>1. Lock锁</h3><ul><li>简介：<strong>锁是一种同步机制，用于控制多个线程或进程对共享资源的访问。</strong>当多个线程或进程同时访问共享资源时，可能会导致数据不一致或错误的结果，为了确保在任何时候只有一个线程或进程可以访问共享资源，可以使用锁（Lock）来同步线程或进程的访问</li><li><strong>锁的两种状态：锁定（被某个线程或进程占用）和未锁定（可供其他线程或进程使用）</strong></li><li><strong>注意：过度使用锁可能会导致性能下降，因为包含锁的相关代码只能以单线程模式执行，因此效率会大大降低</strong></li><li>应用：标准库模块multiprocessing和threading中均提供了一个类对象Lock，用于表示锁，以实现多进程或多线程之间的同步。<strong>由于类对象Lock遵守了上下文管理协议，所以可以使用with语句进行简化，在进入运行时上下文时会自动调用方法acquire()，在离开运行时上下文时会自动调用方法release()</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread, Lock</span><br><span class="line">from multiprocessing import Process, Lock, Value</span><br><span class="line"></span><br><span class="line">num = 0  # 线程中全局变量</span><br><span class="line"># num = Value(&#x27;i&#x27;, 0)  # 进程中全局变量</span><br><span class="line"></span><br><span class="line">lock = Lock()  # 创建lock实例对象</span><br><span class="line"></span><br><span class="line">def add():</span><br><span class="line">    global num</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        &quot;&quot;&quot;1. 获得锁与释放锁</span><br><span class="line">        lock.acquire()</span><br><span class="line">        num += 1</span><br><span class="line">        lock.release()</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        &quot;&quot;&quot;2. 为了确保获得锁的线程用完后一定要释放锁，可以使用try...finally语句</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            num += 1</span><br><span class="line">        finally:</span><br><span class="line">            lock.release()</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 3. 类对象Lock遵守了上下文管理协议，所以可以使用with语句进行简化</span><br><span class="line">        with lock:</span><br><span class="line">            num += 1</span><br><span class="line"></span><br><span class="line">t1 = Thread(target=add)</span><br><span class="line">t2 = Thread(target=add)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(num)  # 2000000</span><br></pre></td></tr></table></figure><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2. 死锁"></a>2. 死锁</h3><ul><li>简介：如果有多个共享数据，在多个线程或进程操作这多个共享数据时，如果两个线程或进程分别通过加锁占有一部分共享数据，并且同时等待对方释放锁，这样就会导致两个线程或进程永远相互等待而产生死锁，即<strong>当多个线程或进程同时持有一些资源并且试图获取其他资源时，可能会发生死锁</strong></li><li><strong>死锁产生的必要条件：</strong><ol><li><strong>互斥条件</strong>：至少有一个资源同时只能被一个线程或进程占用</li><li><strong>请求与保持条件</strong>：线程或进程已经持有了一个资源，同时又请求其他资源</li><li><strong>不可剥夺条件</strong>：资源只能在持有者释放时才能被其他线程或进程获取，不能被强制性地剥夺</li><li><strong>环路等待条件</strong>：存在一组线程或进程，每个线程都在等待下一个线程所持有的资源</li></ol></li><li><strong>避免死锁：</strong><ol><li><strong>加锁顺序</strong>：强制线程按照特定的顺序获取锁，从而消除环路等待条件</li><li><strong>超时</strong>：为获取锁设置超时时间，一段时间后如果未获取到锁就放弃或进行其他处理</li><li><strong>资源分级</strong>：将资源分为不同的级别，要求线程只能按照级别顺序获取资源，避免相互等待</li><li><strong>剥夺资源</strong>：在适当的时机，强制剥夺一些线程的资源，使得其他线程可以继续执行</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">lock_a = threading.Lock()</span><br><span class="line">lock_b = threading.Lock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line">    with lock_a:</span><br><span class="line">        print(&quot;Thread 1 acquired lock a&quot;)  # 此处模拟一些工作</span><br><span class="line">        with lock_b:  # 死锁可能发生在这，线程1在等待线程2释放锁b</span><br><span class="line">            print(&quot;Thread 1 acquired lock b&quot;)</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    with lock_b:</span><br><span class="line">        print(&quot;Thread 2 acquired lock b&quot;)  # 此处模拟一些工作</span><br><span class="line">        with lock_a:  # 死锁可能发生在这，线程2在等待线程1释放锁a</span><br><span class="line">            print(&quot;Thread 2 acquired lock a&quot;)</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=thread_1)</span><br><span class="line">thread2 = threading.Thread(target=thread_2)</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">&quot;&quot;&quot;在满足死锁的必要条件时，死锁并不是一定发生的，这时死锁的发生取决于操作系统的调度</span><br><span class="line">运行程序输出：</span><br><span class="line">Thread 1 acquired lock a</span><br><span class="line">Thread 1 acquired lock b</span><br><span class="line">Thread 2 acquired lock b</span><br><span class="line">Thread 2 acquired lock a</span><br><span class="line">多次运行程序出现死锁：</span><br><span class="line">Thread 1 acquired lock a</span><br><span class="line">Thread 2 acquired lock b</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-RLock锁"><a href="#3-RLock锁" class="headerlink" title="3. RLock锁"></a>3. RLock锁</h3><ul><li>引出：在同一线程中，当调用了普通锁Lock的方法acquire()之后，如果在调用方法release()之前再次调用了方法acquire()，则会导致死锁</li><li>简介：<strong>可重入锁 RLock 是一种同步机制，它允许同一个线程在持有锁的情况下多次获取同一个锁，以避免死锁，而其他线程必须等待该线程释放所有对锁的持有，主要用于解决递归函数调用中的同步问题。</strong>RLock继承自普通锁Lock，并在其基础上增加了重入的特性</li><li>应用：标准库模块threading和multiprocessing中提供了一个用于表示锁的类对象RLock（Reentrant Lock，可重入锁）。<strong>同时类对象RLock也遵循了上下文管理协议</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建一个可重入锁，如果创建的是普通锁Lock，则测试代码时会造成死锁</span><br><span class="line">rlock = threading.RLock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line">    with rlock:</span><br><span class="line">        print(&quot;Inside thread_1&quot;)</span><br><span class="line">        thread_2()</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    with rlock:  # 可重入锁可以被同一个线程多次获取</span><br><span class="line">        print(&quot;Inside thread_2&quot;)</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=thread_1)</span><br><span class="line">thread2 = threading.Thread(target=thread_2)</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">&quot;&quot;&quot;如果将Rlock改成普通锁lock，则死锁一定会发生，</span><br><span class="line">因为在thread_1中调用了thread_2，一把锁被重复获得第二次，而第一次还没有释放，则会产生死锁</span><br><span class="line">print打印：Inside thread_1</span><br><span class="line"></span><br><span class="line">而如果使用Rlock可重入锁，则不会发生死锁，print打印：</span><br><span class="line">Inside thread_1</span><br><span class="line">Inside thread_2</span><br><span class="line">Inside thread_2</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="六、协程"><a href="#六、协程" class="headerlink" title="六、协程"></a>六、协程</h2><blockquote><p><strong>协程：协程是一种特殊的函数，在同一线程内，它可以暂停执行以允许其他代码运行，然后再从暂停的地方继续执行（协程运行状态于多线程类似）</strong></p><p><strong>协程思维：一处异步，处处异步，语法版本需统一，3.6语法与3.7语法不可以混用</strong></p><p><strong>协程优点：</strong></p><ul><li>无需线程上下文切换，协程避免了无意义的调度，可以提高性能</li><li>无需原子操作锁定及同步开销</li><li>方便切换控制流，简化编程模型</li><li>高并发 + 高扩展性 + 低成本，一个CPU甚至可以支持上万的协程，适合用于高并发处理</li></ul><p><strong>协程缺点：</strong></p><ul><li>进行阻塞操作（如IO时）会阻塞掉整个程序</li><li>无法利用多核资源，协程的本质时单线程，不能同时将单个CPU的多个核用上，协程需要进程配合才能运行在多CPU上</li></ul><p><strong>最原始的协程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 最原始的、用生成器实现的协程</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def func_1():</span><br><span class="line">    while True:</span><br><span class="line">        print(&#x27;生成器任务...&#x27;)</span><br><span class="line">        yield  # yield语句允许函数在生成一个值后暂停执行并保存当前状态</span><br><span class="line">        time.sleep(1)  # 然后在需要时继续往下执行</span><br><span class="line"></span><br><span class="line">def func_2(obj):</span><br><span class="line">    while True:</span><br><span class="line">        print(&#x27;普通函数任务...&#x27;)</span><br><span class="line">        next(obj)</span><br><span class="line"></span><br><span class="line">generator = func_1()</span><br><span class="line">func_2(generator)</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-asyncio模块"><a href="#1-asyncio模块" class="headerlink" title="1. asyncio模块"></a>1. asyncio模块</h3><ul><li>简介：asyncio是Python标准库中的一个模块，用于编写异步、非阻塞的并发代码。<strong>asyncio的编程模型是一个消息循环，我们从asyncio模块中直接获取一个事件循环EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，以实现异步IO</strong></li><li><strong>事件循环EventLoop：</strong>事件循环是asyncio的核心，负责处理和调度异步任务和事件。程序会开启一个死循环，将一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数。事件循环的切换底层依靠<strong>io耗时判断</strong>，当判断出某个任务是比较耗时的，则暂停当前任务切换到另一个任务</li><li><strong>协程Coroutines：</strong>协程是一种特殊的函数，协程可以在执行过程中暂停，并在需要时恢复执行。协程函数的调用不会立即执行函数，而是返回一个协程对象，协程对象需要注册到事件循环，由事件循环调用</li><li><strong>Task任务对象：</strong>任务是协程的包装器，用于在事件循环中并发运行协程。任务对象允许跟踪协程的状态，等待它完成或取消它</li><li><strong>Future对象</strong>：用于表示尚未完成的异步操作的结果，允许等待和处理异步操作的完成状态，以及控制异步操作的结果或异常，通常与await一起使用。<strong>Task任务对象是Future的子类，任务对象Task具有更多的功能，可以代表协程的执行状态和结果，因此它们是一种特殊的Future</strong></li><li><strong>async&#x2F;await关键字：</strong>async关键字用于定义协程，声明这是一个协程函数。await关键字用于挂起协程的执行，等待异步操作完成，通常用于调用其他异步函数或操作</li></ul><blockquote><p><strong>协程函数：</strong>协程函数是使用<strong>async def关键字</strong>定义的特殊函数，它可以在执行过程中暂停和恢复执行，通常用于定义异步任务的逻辑</p><p><strong>协程对象：</strong>协程对象是通过<strong>调用协程函数来创建的</strong>，它实际上是协程函数的实例，表示一个可执行的异步任务，可以添加到事件循环中并执行</p></blockquote><h3 id="2-asyncio-run"><a href="#2-asyncio-run" class="headerlink" title="2. asyncio.run()"></a>2. asyncio.run()</h3><ul><li><strong>作用</strong>：用于运行一个协程，是Python 3.7引入的新方法</li><li><strong>用法</strong>：接受一个<strong>协程对象（不能是任务对象）</strong>作为参数，<strong>此函数总是创建一个新的事件循环并运行协程</strong>，然后关闭事件循环</li><li><strong>返回值</strong>：即为协程函数的返回值，如果协程函数没有返回值，则返回None</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"># 定义协程函数</span><br><span class="line">async def my_coroutine():</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    return &quot;协程已完成&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;asyncio.run()内部底层实现</span><br><span class="line">if self._loop_factory is None:</span><br><span class="line">    self._loop = events.new_event_loop()</span><br><span class="line"></span><br><span class="line">可以看出函数总是创建一个新的事件循环用于运行协程</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">result = asyncio.run(my_coroutine())</span><br><span class="line">print(result)  # 协程已完成</span><br></pre></td></tr></table></figure><h3 id="3-asyncio-sleep"><a href="#3-asyncio-sleep" class="headerlink" title="3. asyncio.sleep()"></a>3. asyncio.sleep()</h3><ul><li><strong>作用</strong>：挂起当前协程的执行，模拟等待一段时间</li><li><strong>用法</strong>：接受一个浮点数或整数作为参数，表示等待的秒数</li><li><strong>返回值</strong>：返回一个Future对象，表示异步操作的结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def my_coroutine():</span><br><span class="line">    print(&quot;开始执行&quot;)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    print(&quot;等待完成&quot;)</span><br><span class="line"></span><br><span class="line">asyncio.run(my_coroutine())</span><br></pre></td></tr></table></figure><h3 id="4-await关键字"><a href="#4-await关键字" class="headerlink" title="4. await关键字"></a>4. await关键字</h3><ul><li><strong>await关键字</strong>：await 是用于等待异步操作完成的关键字，其作用是在遇到耗时任务时让出控制权，让事件循环去执行其他任务，从而保持整个程序的异步执行</li><li><strong>特点：</strong><ol><li><strong>只能在异步函数内使用：</strong>await 只能在异步函数内使用，这些函数使用 async def 声明，函数内部的<strong>耗时任务</strong>必须通过 await 修饰（await 可以在一个异步函数内出现多次）</li><li><strong>等待异步操作完成：</strong> await 后面通常跟着一个<strong>可等待对象</strong>，如协程对象、Task 对象或 Future 对象</li></ol></li><li><strong>await可以将任务进行提交到事件循环中，只能提交可等待对象 [coroutine, task, future]：</strong><ul><li><strong>将多个任务分次提交到事件循环中：</strong>此时事件循环始中终保持着只有一个任务的状态，每一个任务的执行都要等待上一个 await 等待完毕并得到返回值，才能将下一个任务添加到事件循环，所以是<strong>同步执行</strong></li><li><strong>将多个任务一次性全部提交到事件循环中：</strong>通常使用 asyncio.wait() 或 asyncio.gather() 等待一组任务完成，使用 await 将任务一次性全部提交到事件循环中，以<strong>并发执行</strong></li></ul></li><li><strong>注意：</strong>Task 对象和 Future 对象本身就是可以被等待的可等待对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def my_coroutine():</span><br><span class="line">    print(&quot;my_coroutine任务启动...&quot;)</span><br><span class="line">    await asyncio.sleep(2)</span><br><span class="line">    print(&quot;my_coroutine任务结束...&quot;)</span><br><span class="line">    return &#x27;模拟一个返回值&#x27;</span><br><span class="line"></span><br><span class="line">async def main1():</span><br><span class="line">    print(&quot;执行main1函数任务...&quot;)</span><br><span class="line">    # 使用await将单个任务提交到事件循环，相当于一次只提交了一个任务到事件循环中</span><br><span class="line">    result1 = await asyncio.create_task(my_coroutine())</span><br><span class="line">    # 由于await的作用就是等待异步操作的完成，但此时事件循环中就一个任务</span><br><span class="line">    # 所以它就要等这一个任务的完成，并得到函数返回值后，才会继续向下执行</span><br><span class="line">    # 那这样就是变向堵塞了，如果一直拿不到第一个任务的返回值，程序就会被一直堵塞</span><br><span class="line">    # 所以说这种实现方式并没有实现并发执行，而是同步执行了</span><br><span class="line">    result2 = await asyncio.create_task(my_coroutine())</span><br><span class="line">    print(result1, result2)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">结论：此时执行为同步执行，因为任务是一个一个被提交到事件循环中的，</span><br><span class="line">     所以事件循环中一直都只有一个任务，并不能进行任务切换，也就无法并发执行</span><br><span class="line">解决：将任务一次性全部添加到事件循环中，便可以在事件循环中进行任务切换，以实现并发</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">async def main2():</span><br><span class="line">    print(&quot;执行main2函数任务...&quot;)</span><br><span class="line">    # 使用asyncio.wait等待一组任务完成，并使用await将任务一次性全部提交到事件循环中</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(my_coroutine()),</span><br><span class="line">        asyncio.create_task(my_coroutine())</span><br><span class="line">    ]</span><br><span class="line">    done, pedding = await asyncio.wait(tasks)</span><br><span class="line">    for item in done:</span><br><span class="line">        print(item.result())</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    asyncio.run(main1())</span><br><span class="line">    asyncio.run(main2())</span><br><span class="line"># 此py文件为了演示await的不同提交方式之间的区别，创建了两个事件循环，这会降低代码执行效率，建议只开启一个！</span><br></pre></td></tr></table></figure><h3 id="5-task对象"><a href="#5-task对象" class="headerlink" title="5. task对象"></a>5. task对象</h3><ul><li><p><strong>不同版本的方法</strong>：</p><ul><li><strong>asyncio.create_task()：</strong>会自动获取当前存在的事件循环（<strong>python 3.7之后的版本使用</strong>）</li><li><strong>loop.create_task()：</strong>需要使用当前的loop事件循环对象驱动（<strong>python 3.6之前的版本使用</strong>）</li></ul></li><li><p><strong>作用</strong>：用于创建一个任务，将协程包装为一个任务对象，以便在事件循环中<strong>并发运行</strong>（<strong>支持并发执行！</strong>）</p></li><li><p><strong>用法</strong>：接受一个<strong>协程对象</strong>作为参数，将协程包装，返回一个<strong>任务对象</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def my_coroutine(name, address):</span><br><span class="line">    print(&quot;任务开始...&quot;)</span><br><span class="line">    await asyncio.sleep(2)</span><br><span class="line">    print(&quot;任务结束...&quot;)</span><br><span class="line">    return f&#x27;&#123;name&#125;,&#123;address&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># python 3.6之前版本的打包方式 -- 完成并发执行</span><br><span class="line">async def main(loop=None):</span><br><span class="line">    task_1 = loop.create_task(my_coroutine(&#x27;me&#x27;, &#x27;南京&#x27;))</span><br><span class="line">    task_2 = loop.create_task(my_coroutine(&#x27;you&#x27;, &#x27;重庆&#x27;))</span><br><span class="line"></span><br><span class="line">    result_1 = await task_1</span><br><span class="line">    result_2 = await task_2</span><br><span class="line">    print(result_1, result_2)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main(loop))</span><br><span class="line"></span><br><span class="line"># python 3.7之后版本的打包方式 -- 完成并发执行</span><br><span class="line">async def main():</span><br><span class="line">    # create_task()会进行代码预处理，一旦遇到await就会停止</span><br><span class="line">    task_1 = asyncio.create_task(my_coroutine(&#x27;me&#x27;, &#x27;南京&#x27;))</span><br><span class="line">    task_2 = asyncio.create_task(my_coroutine(&#x27;you&#x27;, &#x27;重庆&#x27;))</span><br><span class="line">    &quot;&quot;&quot;asyncio.create_task()内部实现：loop = events.get_running_loop()</span><br><span class="line">       可以看出asyncio.create_task()会自动获取正在运行的事件循环</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    result_1 = await task_1</span><br><span class="line">    result_2 = await task_2</span><br><span class="line">    print(result_1, result_2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"># 此py文件为了演示不同版本之间的知识点，创建了两个事件循环，这会降低代码执行效率，建议只开启一个！</span><br></pre></td></tr></table></figure><h3 id="6-asyncio-wait"><a href="#6-asyncio-wait" class="headerlink" title="6. asyncio.wait()"></a>6. asyncio.wait()</h3><ul><li><strong>作用</strong>：等待一组Future对象完成，并且可以获取被提交的任务的运行状态和返回值（<strong>异步执行任务，同步获取结果</strong>）</li><li><strong>用法</strong>：<strong>参数接受一个可迭代的Future对象集合（不能接受协程对象或者协程对象集合）</strong></li><li><strong>返回值</strong>：返回一个包含两个元素的元组<ul><li><strong>done</strong>：包含已经完成的任务对象的集合</li><li><strong>pending</strong>：包含未完成和正在执行的任务对象的集合</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def work1():</span><br><span class="line">    print(&quot;任务1启动...&quot;)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    print(&quot;任务1结束...&quot;)</span><br><span class="line">    return &quot;任务1&quot;</span><br><span class="line"></span><br><span class="line">async def work2():</span><br><span class="line">    print(&quot;任务2启动...&quot;)</span><br><span class="line">    await asyncio.sleep(2)</span><br><span class="line">    print(&quot;任务2结束...&quot;)</span><br><span class="line">    return &quot;任务2&quot;</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(work1()),</span><br><span class="line">        asyncio.create_task(work2())</span><br><span class="line">    ]</span><br><span class="line">    done, pending = await asyncio.wait(tasks, timeout=3)  # 可以设置超时时间timeout</span><br><span class="line">    print(&quot;done:&quot;, done)  # 在done变量中的对象都是已经完成任务的对象</span><br><span class="line">    print(&quot;pending:&quot;, pending)  # pending接受的是未完成和正在执行的任务</span><br><span class="line">    for task in done:</span><br><span class="line">        print(&quot;已完成的任务返回值：&quot;, task.result())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">任务1启动...</span><br><span class="line">任务2启动...</span><br><span class="line">任务1结束...</span><br><span class="line">任务2结束...</span><br><span class="line">done: &#123;&lt;Task finished name=&#x27;Task-2&#x27; coro=&lt;work1() done, defined at /Users/xfblog/PycharmProjects/pythonProject/ceshi.py:3&gt; result=&#x27;任务1&#x27;&gt;, </span><br><span class="line">&lt;Task finished name=&#x27;Task-3&#x27; coro=&lt;work2() done, defined at /Users/xfblog/PycharmProjects/pythonProject/ceshi.py:9&gt; result=&#x27;任务2&#x27;&gt;&#125;</span><br><span class="line">pending: set()</span><br><span class="line">已完成的任务返回值： 任务1</span><br><span class="line">已完成的任务返回值： 任务2</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="7-asyncio-gather"><a href="#7-asyncio-gather" class="headerlink" title="7. asyncio.gather()"></a>7. asyncio.gather()</h3><ul><li><strong>作用</strong>：同时提交多个任务（tasks或coroutines）到事件循环，并等待它们全部完成后获取结果，这种等待是同步的（<strong>异步执行任务，同步获取结果</strong>）</li><li><strong>用法</strong>：接受单个或多个<strong>协程对象或future对象</strong>作为参数，多个对象可以直接传入，但<strong>不能作为迭代对象传入</strong></li><li><strong>返回值</strong>：返回一个包含了所有协程结果的<strong>列表</strong>，结果的顺序与传入的协程顺序一致</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def work1():</span><br><span class="line">    print(&quot;任务1启动...&quot;)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    print(&quot;任务1结束...&quot;)</span><br><span class="line">    return &quot;任务1&quot;</span><br><span class="line"></span><br><span class="line">async def work2():</span><br><span class="line">    print(&quot;任务2启动...&quot;)</span><br><span class="line">    await asyncio.sleep(2)</span><br><span class="line">    print(&quot;任务2结束...&quot;)</span><br><span class="line">    return &quot;任务2&quot;</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    # # 1. 传入单个或多个协程对象，或对协程对象列表解包</span><br><span class="line">    # # results = await asyncio.gather(work1(), work2())</span><br><span class="line">    # coroutines = [work1(), work2()]</span><br><span class="line">    # results = await asyncio.gather(*coroutines)</span><br><span class="line"></span><br><span class="line">    # 2. 传入单个或多个task任务对象，即future对象，或对future对象列表解包</span><br><span class="line">    # results = await asyncio.gather(asyncio.create_task(work1()), asyncio.gather(work2()))</span><br><span class="line">    tasks = [asyncio.create_task(work1()), asyncio.create_task(work2())]</span><br><span class="line">    results = await asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">任务1启动...</span><br><span class="line">任务2启动...</span><br><span class="line">任务1结束...</span><br><span class="line">任务2结束...</span><br><span class="line">[&#x27;任务1&#x27;, &#x27;任务2&#x27;]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="8-asyncio-as-completed"><a href="#8-asyncio-as-completed" class="headerlink" title="8. asyncio.as_completed()"></a>8. asyncio.as_completed()</h3><ul><li><strong>作用</strong>：返回一个<strong>异步生成器（async generator）</strong>，按照完成的顺序产生Future对象，一旦某个任务完成，就会立即返回它，而不需要等待其他任务完成</li><li><strong>用法</strong>：使用<strong>async for异步循环</strong>来迭代这个生成器，获取已完成的Future对象</li><li><strong>返回值</strong>：<strong>返回一个按完成顺序产生Future的生成器</strong>，通过迭代生成器，一旦某个任务完成，就会立即<strong>返回一个可await的任务对象</strong>，然后可以使用await获取任务的结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def work1():</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    return &quot;任务1返回值&quot;</span><br><span class="line"></span><br><span class="line">async def work2():</span><br><span class="line">    await asyncio.sleep(2)</span><br><span class="line">    return &quot;任务2返回值&quot;</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    tasks = [asyncio.create_task(work1()), asyncio.create_task(work2())]</span><br><span class="line"></span><br><span class="line">    # as_completed()获取返回值是异步的</span><br><span class="line">    for item in asyncio.as_completed(tasks):</span><br><span class="line">        res = await item</span><br><span class="line">        print(res)</span><br><span class="line"></span><br><span class="line">    return &quot;main函数的返回值&quot;</span><br><span class="line"></span><br><span class="line">main_res = asyncio.run(main())</span><br><span class="line">print(main_res)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">任务1返回值</span><br><span class="line">任务2返回值</span><br><span class="line">main函数的返回值</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="七、协程进阶"><a href="#七、协程进阶" class="headerlink" title="七、协程进阶"></a>七、协程进阶</h2><h3 id="1-asyncio的future对象"><a href="#1-asyncio的future对象" class="headerlink" title="1. asyncio的future对象"></a>1. asyncio的future对象</h3><ul><li>简介：future类是task类的基类，task对象只有运算得到返回值后，await的对象才能传回值并且向下运行，这个功能是future对象来实现并提供的。<strong>future源码底层中存在一个_state状态，一旦_state状态值变成finished，await就不再继续等待（解堵塞）</strong></li><li>用法：由于future对象偏向于底层（常用于python 3.5版本），新版本中一般不直接使用，而是使用task对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"># 让future对象获取不到返回值使await堵塞</span><br><span class="line">async def main():</span><br><span class="line">    loop = asyncio.get_running_loop()  # 获取一个正在运行的事件循环</span><br><span class="line">    fut = loop.create_future()  # 只是创建了一个future对象，并没有绑定任务</span><br><span class="line">    fut.set_result(&quot;模拟返回值...&quot;)  # 设置返回值后，则await解堵塞</span><br><span class="line">    await fut</span><br><span class="line"></span><br><span class="line"># python3.7以下版本创建并运行事件循环</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure><h3 id="2-asyncio-ensure-future"><a href="#2-asyncio-ensure-future" class="headerlink" title="2. asyncio.ensure_future()"></a>2. asyncio.ensure_future()</h3><ul><li><strong>作用</strong>：类似<strong>asyncio.create_task()<strong>也是将一个协程包装为一个任务对象（</strong>python 3.6之前的版本使用，兼容高版本</strong>）</li><li><strong>用法</strong>：接受一个<strong>协程对象</strong>作为参数，返回一个<strong>任务对象</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def work():</span><br><span class="line">    print(&quot;协程启动...&quot;)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    return &quot;模拟一个返回值&quot;</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    # futures = [asyncio.create_task(work()) for _ in range(2)]  # python 3.7+</span><br><span class="line">    futures = [asyncio.ensure_future(work()) for _ in range(2)`]  # python 3.7-</span><br><span class="line">    result = await asyncio.gather(*futures)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line"># asyncio.run(main())  # python 3.7以上版本运行事件循环</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())  # python 3.7以下版本运行事件循环</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">协程启动...</span><br><span class="line">协程启动...</span><br><span class="line">[&#x27;模拟一个返回值&#x27;, &#x27;模拟一个返回值&#x27;]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-线程池中的future对象"><a href="#3-线程池中的future对象" class="headerlink" title="3. 线程池中的future对象"></a>3. 线程池中的future对象</h3><ul><li>回顾线程池与进程池中的future对象，具体参考本篇中的<a class="link"   href="https://xfblog.cn/2023/06/01/Python_3_%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/#%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"  target="_blank" rel="noopener">三、进程池与线程池<i class="fas fa-external-link-alt"></i></a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from concurrent.futures import Future</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor, as_completed</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def work(name):</span><br><span class="line">    print(&quot;任务启动...&quot;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(name)</span><br><span class="line">    return &quot;模拟一个返回值&quot;</span><br><span class="line"></span><br><span class="line"># 创建线程池</span><br><span class="line">with ThreadPoolExecutor(max_workers=2) as tpe:</span><br><span class="line">    # eg1:</span><br><span class="line">    for _ in range(4):</span><br><span class="line">        # submit的返回值也是future对象，有state状态，但与协程中不可混为一谈</span><br><span class="line">        future = tpe.submit(work, _)</span><br><span class="line">        &quot;&quot;&quot;print(future)</span><br><span class="line">        &lt;Future at 0x100a92750 state=running&gt;</span><br><span class="line">        &lt;Future at 0x100ae99d0 state=running&gt;</span><br><span class="line">        &lt;Future at 0x100ae9d50 state=pending&gt;</span><br><span class="line">        &lt;Future at 0x100ae9fd0 state=pending&gt;&quot;&quot;&quot;</span><br><span class="line">        print(future.result())</span><br><span class="line">        # 但由于方法result()是一个同步方法，需要等待上一个线程的返回值返回后，</span><br><span class="line">        # 才会继续开启下一个线程，这将导致线程池内的线程也成为同步程序了</span><br><span class="line"></span><br><span class="line">    # eg2:</span><br><span class="line">    # 使用as_completed异步获取线程的返回值，会返回一个Future实例对象的迭代器，是非阻塞的</span><br><span class="line">    # futures = [tpe.submit(work, _) for _ in range(4)]</span><br><span class="line">    # for future in as_completed(futures):</span><br><span class="line">    #     print(future.result())</span><br></pre></td></tr></table></figure><h3 id="4-线程与协程交叉编程"><a href="#4-线程与协程交叉编程" class="headerlink" title="4. 线程与协程交叉编程"></a>4. 线程与协程交叉编程</h3><ul><li>引入：在编程时，遇到某个第三方模块不支持asyncio协程异步的时候，则需要线程、进程和协程的两种Future交叉使用。而一般情况下，不会交叉使用，要么使用asyncio协程式实现异步，要么统一用进程或线程池来实现异步</li><li>案例：crm项目中80%是基于协程异步编程 + MySQL，这种情况下只有MySQL内部也支持async异步，两者才能实现无缝衔接。假如MySQL不支持协程，则需要考虑对此用线程、进程来实现了</li><li><strong>loop.run_in_executor()实现原理：</strong><ol><li>在线程池中，先调用线程池的submit()方法去线程中申请一个func函数，并返回一个Future对象（<strong>这里的Future对象与asyncio协程没有任何关系，是concurrent.futures.Future</strong>）</li><li>调用futures.wrap_future()方法将线程中的Future对象（<strong>concurrent.futures.Future</strong>）包装成协程中的Future对象（<strong>asyncio.Future</strong>）</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">image_url_list = [</span><br><span class="line">    &#x27;http://pic.bizhi360.com/bbpic/98/10798.jpg&#x27;,</span><br><span class="line">    &#x27;http://pic.bizhi360.com/bbpic/92/10792.jpg&#x27;,</span><br><span class="line">    &#x27;http://pic.bizhi360.com/bbpic/86/10386.jpg&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">async def get_image(image_url):</span><br><span class="line">    print(&quot;开始下载：&quot;, image_url)</span><br><span class="line">    # 获取一个运行的事件循环</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    # run_in_executor方法默认会创建一个线程池，用于执行不支持async异步的任务，</span><br><span class="line">    # run_in_executor创建的线程池所返回的是future对象，`&lt;class &#x27;_asyncio.Future&#x27;&gt;`</span><br><span class="line">    # 这个future对象是asyncio中的，而不是线程池中的，是支持await的</span><br><span class="line">    future = loop.run_in_executor(None, requests.get, image_url)</span><br><span class="line">    &quot;&quot;&quot;run_in_executor内部底层实现：</span><br><span class="line">        def run_in_executor(self, executor, func, *args):</span><br><span class="line">            if executor is None:</span><br><span class="line">                executor = concurrent.futures.ThreadPoolExecutor(</span><br><span class="line">                    thread_name_prefix=&#x27;asyncio&#x27;</span><br><span class="line">                )</span><br><span class="line">    executor用于确定创建进程或者线程池，没有默认值，如果传入None则默认创建线程池</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    response = await future</span><br><span class="line"></span><br><span class="line">    filename = image_url.rsplit(&#x27;/&#x27;)[-1]</span><br><span class="line">    with open(filename, &#x27;wb&#x27;) as fp:</span><br><span class="line">        fp.write(response.content)</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    tasks = [asyncio.create_task(get_image(url)) for url in image_url_list]</span><br><span class="line">    await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="5-自定义异步迭代器类"><a href="#5-自定义异步迭代器类" class="headerlink" title="5. 自定义异步迭代器类"></a>5. 自定义异步迭代器类</h3><ul><li>基本结构：<ul><li>**__aiter__()**： 必须返回一个异步迭代器对象自身。它不需要使用 async 关键字，因为它通常不执行异步操作，只是返回对象本身</li><li>**__anext__()**：负责异步获取下一个元素，并在迭代结束时引发 StopAsyncIteration 异常。它通常包含异步操作</li></ul></li><li>用法：使用自定义的异步迭代器，可以在异步函数中创建异步迭代器对象，并使用异步for循环来遍历元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"># 异步迭代器</span><br><span class="line">class MyAsyncIter:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.count = 0</span><br><span class="line"></span><br><span class="line">    async def iter_num(self):</span><br><span class="line">        await asyncio.sleep(1)</span><br><span class="line">        self.count += 1</span><br><span class="line">        if self.count == 100:</span><br><span class="line">            return None</span><br><span class="line">        return self.count</span><br><span class="line"></span><br><span class="line">    # 异步迭代协议</span><br><span class="line">    # 无async修饰，因为__aiter__只返回一个对象，并且返回的对象并不耗时</span><br><span class="line">    def __aiter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    async def __anext__(self):</span><br><span class="line">        value = await self.iter_num()</span><br><span class="line">        if value is None:</span><br><span class="line">            raise StopAsyncIteration</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;async def main():</span><br><span class="line">    # 异步循环迭代必须要在协程函数内执行</span><br><span class="line">    async for item in MyAsyncIter():</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">    # 想要使两个异步循环在同一个事件循环中并发交替执行，这样是错误的调用方式，是同步的！</span><br><span class="line">    # async for item in MyAsyncIter():</span><br><span class="line">    #     print(item)</span><br><span class="line"></span><br><span class="line"># 此时事件循环中只有一个任务运行，上面两个循环均存在于一个任务中，所以无法进行任务切换，也无法并发执行</span><br><span class="line">asyncio.run(main())&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">async def work():</span><br><span class="line">    # 异步循环迭代必须要在协程函数内执行</span><br><span class="line">    async for item in MyAsyncIter():</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    # 创建两个task任务对象，并提交到事件循环</span><br><span class="line">    tasks = [asyncio.create_task(work()) for _ in range(2)]</span><br><span class="line">    await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="6-add-done-callback"><a href="#6-add-done-callback" class="headerlink" title="6. add_done_callback"></a>6. add_done_callback</h3><ul><li>简介：<strong>add_done_callback是Python中 asyncio.Future 对象的一个方法，主要作用是在异步操作完成后执行一个回调函数</strong></li><li>作用：用于添加一个回调函数（callback），当该Future对象完成时，会自动调用这个回调函数</li><li>特点：<ol><li>允许在异步操作完成后执行自定义逻辑，这对于处理异步操作的结果或执行清理操作非常有用</li><li><strong>其添加的回调函数是非阻塞的</strong>，因此不会影响主事件循环的执行</li></ol></li><li><strong>注意：定义回调函数时需定义为普通函数，而不是协程函数，不能用async修饰该函数</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def work():</span><br><span class="line">    print(&quot;任务开始...&quot;)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    return &quot;模拟一个返回值&quot;</span><br><span class="line"></span><br><span class="line">def get_return(task):</span><br><span class="line">    # 可以直接调用task对象的result()方法来获取返回结果</span><br><span class="line">    print(task.result())</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    tasks = [asyncio.create_task(work()) for _ in range(2)]</span><br><span class="line">    # 将获取返回值的回调函数绑定到task对象中，任务完成时会自动调用这个回调函数</span><br><span class="line">    for task in tasks:</span><br><span class="line">        task.add_done_callback(get_return)</span><br><span class="line">    await asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">任务开始...</span><br><span class="line">任务开始...</span><br><span class="line">模拟一个返回值</span><br><span class="line">模拟一个返回值</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="7-异步上下文管理器"><a href="#7-异步上下文管理器" class="headerlink" title="7. 异步上下文管理器"></a>7. 异步上下文管理器</h3><ul><li>基本结构：<ul><li>**__aenter__**：在进入异步上下文时执行，通常用于获取异步资源，例如打开文件或建立网络连接。它可以包含异步操作，因此需要async修饰函数为协程函数，并且函数内需要使用到 await 关键字</li><li>**__aexit__**：在退出异步上下文时执行，通常用于释放异步资源，例如关闭文件或断开网络连接。它也可以包含异步操作，因此需要async修饰函数为协程函数，并且函数内需要使用到 await 关键字</li></ul></li><li>用法：使用 async with 语句创建异步上下文和使用异步上下文管理器，在其中执行需要异步资源的操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">class AsyncContextManager:</span><br><span class="line">    def __init__(self, conn=None):</span><br><span class="line">        self.conn = conn</span><br><span class="line"></span><br><span class="line">    async def get_data(self):</span><br><span class="line">        await asyncio.sleep(1)</span><br><span class="line">        return &quot;模拟数据库返回了数据&quot;</span><br><span class="line"></span><br><span class="line">    async def __aenter__(self):</span><br><span class="line">        # 在这里执行获取异步资源的操作</span><br><span class="line">        # 模拟数据库连接的耗时操作，因为连接操作是属于网络IO的</span><br><span class="line">        self.conn = await asyncio.sleep(1, result=&quot;连接数据库成功...&quot;)</span><br><span class="line">        print(self.conn)</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    async def __aexit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        # 在这里执行释放异步资源的操作</span><br><span class="line">        res = await asyncio.sleep(1, result=&quot;关闭数据库连接成功...&quot;)</span><br><span class="line">        print(res)</span><br><span class="line"></span><br><span class="line"># 使用异步上下文管理器</span><br><span class="line">async def main():</span><br><span class="line">    # 使用 async with 语句创建一个上下文，是用于与异步上下文管理器协同工作的语法</span><br><span class="line">    async with AsyncContextManager() as fp:</span><br><span class="line">        # 在此处执行与资源相关的异步操作</span><br><span class="line">        result = await fp.get_data()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">连接数据库成功...</span><br><span class="line">模拟数据库返回了数据</span><br><span class="line">关闭数据库连接成功...</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="8-uvloop"><a href="#8-uvloop" class="headerlink" title="8. uvloop"></a>8. uvloop</h3><ul><li><p>简介：<strong>在 Python 中进行异步编程时，事件循环的性能和效率对于整体应用程序的性能至关重要。uvloop是一个第三方库，它提供了一个高性能的事件循环实现，专门为 Python 异步编程而设计</strong></p></li><li><p>特点：</p><ul><li><strong>高性能事件循环</strong>：uvloop基于libuv，这是一个高性能的事件驱动库，它可以提供非常快速的异步I&#x2F;O操作。相对于标准的asyncio事件循环，uvloop提供了更好的性能，特别是在高负载和高并发情况下</li><li><strong>100%兼容asyncio</strong>：uvloop是asyncio的替代事件循环实现，它与标准库中的asyncio完全兼容。这意味着你可以将现有的asyncio代码迁移到uvloop，并且不需要修改你的代码，只需将事件循环的实现切换为uvloop即可</li><li><strong>协程和异步代码性能提升</strong>：由于uvloop提供了更快的事件循环，因此它可以改善协程和异步代码的性能，特别是在处理大量并发操作时</li></ul></li><li><p>用法：<strong>使用 asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) 可以将uvloop设置为默认的事件循环策略，是全局的，所以不能放在main函数中</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import uvloop</span><br><span class="line"></span><br><span class="line">async def work():</span><br><span class="line">    print(&quot;任务开始...&quot;)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    print(&quot;任务结束...&quot;)</span><br><span class="line">    return &quot;模拟一个返回值&quot;</span><br><span class="line"></span><br><span class="line"># 设置 uvloop 作为事件循环策略，一旦设置了事件循环策略，</span><br><span class="line"># 它将影响整个应用程序中的所有异步操作</span><br><span class="line"># 因此，最佳做法是在应用程序的启动阶段设置事件循环策略，通常在全局范围内进行</span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    tasks = [asyncio.create_task(work()) for _ in range(2)]</span><br><span class="line">    await asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="9-aiomysql异步预告"><a href="#9-aiomysql异步预告" class="headerlink" title="9. aiomysql异步预告"></a>9. aiomysql异步预告</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiomysql</span><br><span class="line"></span><br><span class="line">async def execute(host, password):</span><br><span class="line">    # 网络IO操作，连接mysql</span><br><span class="line">    conn = await aiomysql.connect(host=host, port=3306, user=&#x27;root&#x27;, password=password, db=&#x27;asyncio&#x27;)</span><br><span class="line">    # 网络IO操作，创建cursor()</span><br><span class="line">    cur = await conn.cursor()</span><br><span class="line">    # 网络IO操作，执行sql语句</span><br><span class="line">    await cur.execute(&#x27;SELECT * FROM user&#x27;)</span><br><span class="line">    # 网络IO操作，获取sql结果，返回一个Future对象，</span><br><span class="line">    # 可以通过result()方法，获取sql语句的查询结果，result()方法返回一个元组</span><br><span class="line">    res = cur.fetchall()</span><br><span class="line">    &quot;&quot;&quot;print(res.result())</span><br><span class="line">((1, &#x27;wcf&#x27;, &#x27;22&#x27;, &#x27;程序员&#x27;), (2, &#x27;zxc&#x27;, &#x27;22&#x27;, &#x27;财务&#x27;), (3, &#x27;xfblog.cn&#x27;, &#x27;3&#x27;, &#x27;小傅博客&#x27;))</span><br><span class="line">((1, &#x27;wcf&#x27;, &#x27;22&#x27;, &#x27;程序员&#x27;), (2, &#x27;zxc&#x27;, &#x27;22&#x27;, &#x27;财务&#x27;), (3, &#x27;xfblog.cn&#x27;, &#x27;3&#x27;, &#x27;小傅博客&#x27;))&quot;&quot;&quot;</span><br><span class="line">    # 网络IO操作，关闭链接</span><br><span class="line">    await cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    task_list = [</span><br><span class="line">        asyncio.create_task(execute(&#x27;127.0.0.1&#x27;, &#x27;123456&#x27;)),</span><br><span class="line">        asyncio.create_task(execute(&#x27;127.0.0.1&#x27;, &#x27;123456&#x27;))</span><br><span class="line">    ]</span><br><span class="line">    await asyncio.wait(task_list)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、线程&quot;&gt;&lt;a href=&quot;#一、线程&quot; class=&quot;headerlink&quot; title=&quot;一、线程&quot;&gt;&lt;/a&gt;一、线程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;重要概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/s</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_2_高级语法</title>
    <link href="http://example.com/2023/05/01/Python_2_%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/05/01/Python_2_%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/</id>
    <published>2023-04-30T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h2><h3 id="1-函数的定义与调用"><a href="#1-函数的定义与调用" class="headerlink" title="1. 函数的定义与调用"></a>1. 函数的定义与调用</h3><ul><li>简介：def是Python定义的关键字，用于定义函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;语法格式：</span><br><span class="line"></span><br><span class="line">def 函数名([形参1, 形参2, ... , 形参n]):</span><br><span class="line">    函数体</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def decide_args(arg1, arg2):</span><br><span class="line">    if arg1 and arg2:</span><br><span class="line">        return arg1, arg2</span><br><span class="line">    elif (not arg1) and (not arg2):</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        result = arg1 or arg2</span><br><span class="line"></span><br><span class="line">print(decide_args)  # `&lt;function decide_args at 0x100613eb0&gt;`</span><br><span class="line">print(type(decide_args))  # `&lt;class &#x27;function&#x27;&gt;`</span><br><span class="line"></span><br><span class="line">print(decide_args(18, &#x27;Hello&#x27;))  # (18, &#x27;Hello&#x27;)</span><br><span class="line">print(decide_args([], &#123;&#125;))  # None return返回值什么都没有时，返回值为None</span><br><span class="line">print(decide_args(18, []))  # None 函数正常结束无return时，返回值也为None</span><br></pre></td></tr></table></figure><h3 id="2-函数的多个返回值"><a href="#2-函数的多个返回值" class="headerlink" title="2. 函数的多个返回值"></a>2. 函数的多个返回值</h3><ul><li>简介：在调用函数后需要有多个返回值，可以在定义函数时在函数体内使用return语句返回由多个返回值组成的元组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 把列表中所有数分成奇数和偶数两类</span><br><span class="line">def classify_numbers(numbers):</span><br><span class="line">    odds = []</span><br><span class="line">    evens = []</span><br><span class="line">    for number in numbers:</span><br><span class="line">        if number % 2:</span><br><span class="line">            odds.append(number)</span><br><span class="line">        else:</span><br><span class="line">            evens.append(number)</span><br><span class="line">    return odds, evens</span><br><span class="line"></span><br><span class="line">print(classify_numbers([15, 86, 39, 26, 53, 68]))  # ([15, 39, 53], [86, 26, 68])</span><br></pre></td></tr></table></figure><h3 id="3-函数的两种实参与传递"><a href="#3-函数的两种实参与传递" class="headerlink" title="3. 函数的两种实参与传递"></a>3. 函数的两种实参与传递</h3><ul><li><strong>位置实参</strong>：调用函数时，根据每个形参在所有形参中的位置传递对应位置的实参，从而用每个实参初始化对应位置的形参</li><li><strong>关键字实参</strong>：调用函数时，传递的实参的形式可以为：<strong>形参名 &#x3D; 实参值</strong>，从而用指定的实参值初始化指定名称的形参</li><li>注意：<strong>每个关键字实参在所有关键字实参中的位置是任意的；但当位置实参和关键字实参组合使用时，位置实参必须位于关键字实参之前</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def f(a, b, c):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c)</span><br><span class="line"></span><br><span class="line"># 函数的调用之位置实参</span><br><span class="line">f(2, 5, 8)  # a = 2 b = 5 c = 8</span><br><span class="line"># 函数的调用之关键字实参</span><br><span class="line">f(a=2, b=5, c=8)  # a = 2 b = 5 c = 8</span><br><span class="line"># 位置实参必须位关键字实参之前，否则报错</span><br><span class="line"># f(2, c=8, 5)  # SyntaxError: positional argument follows keyword argument</span><br><span class="line">f(2, 5, c=8)  # a = 2 b = 5 c = 8</span><br></pre></td></tr></table></figure><ul><li>实参的传递：<strong>如果实参对象是可变类型，在函数体内对形参对象的任何修改就是对实参对象本身的修改</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def f(arg1, arg2):</span><br><span class="line">    print(&#x27;初始化形参后：arg1 =&#x27;, arg1, &#x27;arg2 =&#x27;, arg2)</span><br><span class="line">    arg1 *= 2</span><br><span class="line">    arg2.append(4)</span><br><span class="line">    print(&#x27;修改形参后：arg1 =&#x27;, arg1, &#x27;arg2 =&#x27;, arg2)</span><br><span class="line"></span><br><span class="line">i = 10  # 整数类型是不可变对象</span><br><span class="line">L = [1, 2, 3]  # 列表是可变对象</span><br><span class="line"></span><br><span class="line">print(&#x27;调用函数前实参：i =&#x27;, i, &#x27;L =&#x27;, L)  # 调用函数前实参：i = 10 L = [1, 2, 3]</span><br><span class="line">f(i, L)</span><br><span class="line">print(&#x27;调用函数后实参：i =&#x27;, i, &#x27;L =&#x27;, L)  # 调用函数后实参：i = 10 L = [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h3 id="4-函数的默认值形参"><a href="#4-函数的默认值形参" class="headerlink" title="4. 函数的默认值形参"></a>4. 函数的默认值形参</h3><ul><li>简介：定义函数时可以给形参设置默认值，在调用函数时如果不传递对应的实参，就会使用默认值初始化形参</li><li>注意：<strong>定义函数时，普通形参必须位于设置了默认值的形参之前，否则无法根据位置来匹配位置实参和对应的形参</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fun(a, b=5):</span><br><span class="line">    # 技巧：当函数有多个形参时，把变化大的形参放前面，变化小的形参放后面，则变化小的形参就可以设置默认值</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b)</span><br><span class="line"></span><br><span class="line"># 定义默认值形参后，可以有多种调用形式</span><br><span class="line">fun(3)  # a = 3 b = 5</span><br><span class="line">fun(a=3)  # a = 3 b = 5</span><br><span class="line">fun(3, 6)  # a = 3 b = 6</span><br><span class="line">fun(a=3, b=6)  # a = 3 b = 6</span><br><span class="line">fun(b=6, a=3)  # a = 3 b = 6</span><br><span class="line">fun(3, b=6)  # a = 3 b = 6</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题抛出：在定义函数时，给形参设置的默认值就已经被计算出来了</strong></p><p>问题解释：如果给形参设置的默认值是可变类型的对象，且前一次调用函数时在函数体内修改了形参的默认值，则修改后的值将作为下一次调用函数时形参的默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fun1(L=[]):  # 定义的默认值为列表（可变对象），且在函数中改变了列表</span><br><span class="line"> L.append(18)</span><br><span class="line"> print(L)</span><br><span class="line"></span><br><span class="line">fun1()  # [18]</span><br><span class="line">fun1()  # [18, 18]</span><br><span class="line">fun1()  # [18, 18, 18]</span><br></pre></td></tr></table></figure><p>解决问题：<strong>不要把形参的默认值设置为可变类型的对象，可以设置为不可变对象None</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fun2(L=None):</span><br><span class="line"> if L is None:</span><br><span class="line">     L = []</span><br><span class="line"> L.append(18)</span><br><span class="line"> print(L)</span><br><span class="line"></span><br><span class="line">fun2()  # [18]</span><br><span class="line">fun2()  # [18]</span><br><span class="line">fun2()  # [18]</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-函数中-对参数的用法"><a href="#5-函数中-对参数的用法" class="headerlink" title="5. 函数中*对参数的用法"></a>5. 函数中*对参数的用法</h3><ol><li><strong>使用*定义关键字形参</strong><ul><li>简介：定义函数时，可以在所有形参的某个位置添加一个*，则*后面的所有参数都会被定义为关键字形参</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def f(a, b, *, c, d):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d)</span><br><span class="line"></span><br><span class="line">f(1, 2, c=3, d=4)  # a = 1 b = 2 c = 3 d = 4</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用*定义个数可变的位置形参</strong><ul><li><p>简介：定义函数时，在形参前添加一个<em>，可将形参定义为个数可变的位置形参，可以接受0个或任意多个位置实参，这些位置实参会将个数可变的位置形参初始化为一个*<em>元组</em></em></p></li><li><p>注意：<strong>一个函数最多只能定义一个个数可变的位置形参</strong></p></li><li><p>知识点1：<strong>当个数可变的位置形参不是最后一个形参时，则其后的所有形参也都会被定义为关键字形参，此时相当于覆盖了第一点“使用*定义关键字形参”的用法</strong></p></li><li><p>知识点2：如果传递的实参全为位置实参，则所有传递过去的<strong>位置实参</strong>都会被位于前面的<strong>个数可变的位置形参</strong>所接收，这会导致其后的<strong>关键字形参</strong>接收实参缺失，<strong>抛出异常</strong></p></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def fun1(a, b, *c):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c)</span><br><span class="line"></span><br><span class="line">fun1(1, 2, 3, 4, 5)  # a = 1 b = 2 c = (3, 4, 5)</span><br><span class="line"></span><br><span class="line">def fun2(a, *b, c, d):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d)</span><br><span class="line"></span><br><span class="line">fun2(1, 2, 3, 4, c=5, d=6)  # a = 1 b = (2, 3, 4) c = 5 d = 6</span><br><span class="line">&quot;&quot;&quot;fun2(1, 2, 3, 4, 5, 6)</span><br><span class="line">解释：此时实参1传递给了形参a，而剩余所有位置实参都被*b所接收，从而导致关键字实参缺失</span><br><span class="line">抛出异常：TypeError: fun2() missing 2 required keyword-only arguments: &#x27;c&#x27; and &#x27;d&#x27;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用*将序列中的每个元素都转换为位置实参（解包）</strong><ul><li>简介：调用函数时，可以在序列前加一个*，从而将序列中的每个元素都转换为一个单独的位置实参</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">def fun(a, b, c):</span><br><span class="line">    print(a, b, c)</span><br><span class="line"></span><br><span class="line">fun(L[0], L[1], L[2])  # 1 2 3</span><br><span class="line">fun(*L)  # 1 2 3 等价上式</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>使用**定义个数可变的关键字形参</strong><ul><li>简介：定义函数时，在形参前添加上**，可将形参定义为个数可变的关键字形参，可以接受0个或任意多个关键字实参，这些关键字实参会将个数可变的关键字形参初始化为一个<strong>字典</strong></li><li>注意：<strong>一个函数最多只能定义一个个数可变的关键字形参；且个数可变的位置形参必须位于个数可变的关键字形参之前</strong></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def f(**kwargs):</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">f()  # &#123;&#125;</span><br><span class="line">f(a=1)  # &#123;&#x27;a&#x27;: 1&#125;</span><br><span class="line">f(a=1, b=2, c=3)  # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line"></span><br><span class="line">def fun(*args, **kwargs):</span><br><span class="line">    print(kwargs, args)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;可变位置形参必须位于可变关键字形参之前，否则报错</span><br><span class="line">def fun(**kwargs, *args):</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">抛出异常：SyntaxError: arguments cannot follow var-keyword argument</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>使用**将字典中的每个健值对都转换为关键字实参（解包）</strong><ul><li>简介：调用函数时，可以在字典前加上**，从而将字典中的每个健值对都转换为一个单独的关键字实参</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line"></span><br><span class="line">def fun(**kwargs):</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">fun(a=d[&#x27;a&#x27;], b=d[&#x27;b&#x27;], c=d[&#x27;c&#x27;])  # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line">fun(**d)  # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>综合案例</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 案例1</span><br><span class="line">def f1(a, b=5, *args, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;args =&#x27;, args, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f1(2)  # a = 2 b = 5 args = () kwargs = &#123;&#125;</span><br><span class="line">f1(2, 6, 7, 8, c=9)  # a = 2 b = 6 args = (7, 8) kwargs = &#123;&#x27;c&#x27;: 9&#125;</span><br><span class="line"></span><br><span class="line"># 案例2</span><br><span class="line">def f2(a, b=5, *, c, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f2(3, c=8, d=10)  # a = 3 b = 5 c = 8 kwargs = &#123;&#x27;d&#x27;: 10&#125;</span><br><span class="line">my_list = (3, 6)</span><br><span class="line">my_dict = &#123;&#x27;c&#x27;: 8, &#x27;d&#x27;: 10&#125;</span><br><span class="line">f2(*my_list, **my_dict)  # a = 3 b = 6 c = 8 kwargs = &#123;&#x27;d&#x27;: 10&#125;</span><br></pre></td></tr></table></figure><h3 id="6-递归函数"><a href="#6-递归函数" class="headerlink" title="6. 递归函数"></a>6. 递归函数</h3><ul><li>简介：如果在一个函数体内调用了该函数本身，则该函数就是递归函数</li><li>注意：<strong>当递归超过最大深度时，系统会抛出异常。可调用标准库模块sys中的函数setrecursionlimit(n)设置递归最大深度</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(10000)  # 设置递归深度为10000</span><br><span class="line"></span><br><span class="line">def fac(n):</span><br><span class="line">    &quot;&quot;&quot;使用递归计算阶乘&quot;&quot;&quot;</span><br><span class="line">    if n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fac(n - 1)</span><br><span class="line"></span><br><span class="line">print(&#x27;fac(6) =&#x27;, fac(6))  # fac(6) = 720</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    &quot;&quot;&quot;使用递归计算斐波那切数列</span><br><span class="line">    F0=0, F1=1, Fn=F(n-1)+F(n-2)(n&gt;=2)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 0</span><br><span class="line">    if n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    return fib(n - 1) + fib(n - 2)</span><br><span class="line"></span><br><span class="line">print(&#x27;fib(6) =&#x27;, fib(6))  # fib(6) = 8</span><br></pre></td></tr></table></figure><h3 id="7-pass语句、文档字符串、函数注解"><a href="#7-pass语句、文档字符串、函数注解" class="headerlink" title="7. pass语句、文档字符串、函数注解"></a>7. pass语句、文档字符串、函数注解</h3><ul><li>pass语句：只是一个占位符，什么都不做，用在语法上需要占位的地方：if、for-in、函数体等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = 21</span><br><span class="line">if age &gt; 18:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def do_something():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><ul><li><p>文档字符串</p><ul><li><p>简介：对于函数、模块、类或方法，位于其第一行的字符串被称为文档字符串，通常用三个引号表示</p></li><li><p>知识点：通过**属性__doc__<strong>可以访问文档字符串；通过</strong>内置函数help()**得到的帮助信息中也包含文档字符串</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;函数的文档字符串的常见内容和格式约定</span><br><span class="line">1. 第一行时简明扼要的总结</span><br><span class="line">2. 第一行的首字母大写，第一行以句号结尾</span><br><span class="line">3. 如果文档字符串包含多行，第二行是空行，从第三行开始是详细的描述</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def form_complex(real=0.0, imag=0.0):</span><br><span class="line">    &quot;&quot;&quot;Form a complex number.</span><br><span class="line"></span><br><span class="line">    Keyword arguments:</span><br><span class="line">    real -- the real part（default 0.0）</span><br><span class="line">    imag -- the imaginary part（default 0.0）</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(form_complex.__doc__)  # ......</span><br><span class="line">print(help(form_complex))  # ......</span><br></pre></td></tr></table></figure><ul><li><p>函数注解</p><ul><li><p>简介：定义函数时，为了让形参或返回值的类型或作用更加清晰，可以给形参或返回值添加函数注解，以帮助函数文档化</p></li><li><p>注意：<strong>解释器会忽略函数注解，因此解释器并不会使用函数注解来检查实参的类型和返回值的类型</strong></p></li><li><p>知识点：通过**属性__annotations__<strong>可以访问函数注解；通过</strong>内置函数help()**得到的帮助信息中也包含函数注解</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;添加函数注解的方式</span><br><span class="line">给形参添加函数注解：在形参后面添加:和任意的表达式</span><br><span class="line">给返回值添加函数注解：在)的后面添加-&gt;和任意的表达式</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def f(a: &#x27;string type&#x27;, b: int) -&gt; &#x27;join a with b&#x27;:</span><br><span class="line">    return a + str(b)</span><br><span class="line"></span><br><span class="line">print(f(&#x27;hello&#x27;, 12.3))  # hello12.3</span><br><span class="line">print(f.__annotations__)  # &#123;&#x27;a&#x27;: &#x27;string type&#x27;, &#x27;b&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;return&#x27;: &#x27;join a with b&#x27;&#125;</span><br><span class="line">print(help(f))  # ......</span><br></pre></td></tr></table></figure><h2 id="二、浅拷贝和深拷贝"><a href="#二、浅拷贝和深拷贝" class="headerlink" title="二、浅拷贝和深拷贝"></a>二、浅拷贝和深拷贝</h2><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1. 浅拷贝"></a>1. 浅拷贝</h3><ul><li><p>简介：对于某个对象，创建与该对象具有相同值的一个新引用，但是<strong>这两个对象内部嵌套的对应子对象全都是同一个引用</strong></p></li><li><p>应用：</p><ol><li>切片操作[ : ]</li><li>调用列表、字典、集合的方法copy()</li><li>调用内置函数list()、dict()、set()</li><li>调用标准库模块copy中的函数copy()</li></ol></li><li><p><strong>重点：对于没有嵌套子对象的不可变对象，例如：整数、字符串和元组对象等，不会进行拷贝，即不会创建新引用</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">L = [[3, 6], 8]</span><br><span class="line"></span><br><span class="line">L1 = L[:]</span><br><span class="line">L2 = L.copy()</span><br><span class="line">L3 = list(L)</span><br><span class="line">L4 = copy.copy(L)</span><br><span class="line"></span><br><span class="line">print(id(L), id(L[0]), id(L[1]))  # 4335878976 4335878848 4334207440</span><br><span class="line">print(id(L1), id(L1[0]), id(L1[1]))  # 4335878912 4335878848 4334207440</span><br><span class="line">print(id(L2), id(L2[0]), id(L2[1]))  # 4335881600 4335878848 4334207440</span><br><span class="line">print(id(L3), id(L3[0]), id(L3[1]))  # 4335879168 4335878848 4334207440</span><br><span class="line">print(id(L4), id(L4[0]), id(L4[1]))  # 4335881984 4335878848 4334207440</span><br><span class="line"># 结论：4种方法都是浅拷贝，仅拷贝了最外部的L对象，没有拷贝内部对象，此时内部对象依然指向同一对象（地址相同）</span><br><span class="line"></span><br><span class="line">L[0][1] = 7</span><br><span class="line">L[1] = 9</span><br><span class="line">print(L, L1)  # [[3, 7], 9] [[3, 7], 8]</span><br><span class="line"># 解释：虽然子对象列表和整数都没有被拷贝，但是由于列表是可变对象，</span><br><span class="line"># 而整数是不可变对象，所以L1中的列表被同步修改了，而整数并没有被改变</span><br><span class="line"></span><br><span class="line"># 重点：对于没有嵌套子对象的不可变对象，是不会进行拷贝的</span><br><span class="line">i = 8</span><br><span class="line">ip = int(i)</span><br><span class="line">ip1 = copy.copy(i)</span><br><span class="line">print(id(i), id(ip), id(ip1))  # 4380836304 4380836304 4380836304</span><br><span class="line"></span><br><span class="line">t = (1, 2, 3)</span><br><span class="line">tp = tuple(t)</span><br><span class="line">tp1 = copy.copy(t)</span><br><span class="line">print(id(t), id(tp), id(tp1))  # 4382390208 4382390208 4382390208</span><br></pre></td></tr></table></figure><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2. 深拷贝"></a>2. 深拷贝</h3><ul><li><p>简介：对于某个对象，创建与该对象具有相同值的一个新引用，同时<strong>这两个对象内部嵌套的对应可变子对象全都不是同一个引用，而对应不可变子对象依然是同一个引用</strong></p></li><li><p>应用：可以调用标准库模块copy中的函数deepcopy()实现深拷贝</p></li><li><p><strong>重点1：对于没有嵌套子对象的不可变对象，例如：整数、字符串和元组对象等，不会进行拷贝，即不会创建新引用</strong></p></li><li><p><strong>重点2：对于嵌套了可变子对象的不可变对象，深拷贝时会进行拷贝，即会创建一个与该不可变对象具有相同值的新引用</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">L1 = [[3, 6], 8]</span><br><span class="line">L2 = copy.deepcopy(L1)</span><br><span class="line">print(L1, L2)  # [[3, 6], 8] [[3, 6], 8]</span><br><span class="line"></span><br><span class="line">print(id(L1), id(L1[0]), id(L1[1]))  # 4365312512 4365312256 4363764176</span><br><span class="line">print(id(L2), id(L2[0]), id(L2[1]))  # 4365312192 4365421056 4363764176</span><br><span class="line"># 结论：这里深拷贝中内部元素，仅对列表进行了拷贝，这是因为对于没有嵌套子对象的不可变对象是不会进行拷贝的</span><br><span class="line"></span><br><span class="line">L1[0][1] = 7</span><br><span class="line">L1[1] = 9</span><br><span class="line">print(L1, L2)  # [[3, 7], 9] [[3, 6], 8]</span><br><span class="line"># 解释：L2的列表没有改变是因为子对象进行了拷贝，而整数由于是不可变对象，所以即使没有拷贝，也不会被改变</span><br><span class="line"></span><br><span class="line"># 重点1：对于没有嵌套子对象的不可变对象，是不会进行拷贝的</span><br><span class="line">i = 18</span><br><span class="line">ic = copy.deepcopy(i)</span><br><span class="line">print(ic)  # 18</span><br><span class="line">print(id(i), id(ic))  # 4299146000 4299146000</span><br><span class="line"></span><br><span class="line">t = (1, 2, 3)</span><br><span class="line">tc = copy.deepcopy(t)</span><br><span class="line">print(tc)  # (1, 2, 3)</span><br><span class="line">print(id(t), id(tc))  # 4302305216 4302305216</span><br><span class="line"></span><br><span class="line"># 重点2：不可变对象内部又嵌套了可变子对象的情况</span><br><span class="line">t1 = ([3, 6], 8)</span><br><span class="line">t2 = copy.deepcopy(t1)</span><br><span class="line"></span><br><span class="line">print(id(t1), id(t1[0]), id(t1[1]))  # 4365418624 4365585088 4363764176</span><br><span class="line">print(id(t2), id(t2[0]), id(t2[1]))  # 4365421184 4365585344 4363764176</span><br></pre></td></tr></table></figure><h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><blockquote><p><strong>面向对象程序设计</strong>（Object Oriented Programming，<strong>简称OOP</strong>）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP&#x3D;对象+类+继承+多态+消息，其中核心概念是<strong>类和对象</strong>。</p></blockquote><h3 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h3><table style="text-align: center;">    <tr style="font-weight: bold;">        <td></td>        <td style="width: 50px;">操作</td>        <td colspan="3">在类对象的内部（方法中）</td>        <td colspan="3">在类对象的外部</td>    </tr>    <tr>        <td rowspan="2" style="font-weight: bold;">实例属性</td>        <td>绑定</td>        <td colspan="3">self.属性名=属性值</td>        <td colspan="3">实例对象.属性名=属性值（已存在则是修改值）        </td>    </tr>    <tr>        <td>访问</td>        <td colspan="3">self.属性名</td>        <td colspan="3">实例对象.属性名</td>    </tr>    <tr>        <td rowspan="2" style="font-weight: bold;">类属性</td>        <td>绑定</td>        <td colspan="3">属性名=属性值</td>        <td colspan="3">类对象.属性名=属性值（已存在则是修改值）</td>    </tr>    <tr>        <td>访问</td>        <td colspan="3">类对象.属性名</td>        <td colspan="3">类对象.属性名 或 实例对象.属性名</td>    </tr>    <tr>        <td rowspan="2" style="font-weight: bold;">实例方法</td>        <td>解释</td>        <td colspan="6" style="text-align: left;">实例方法指的是只有实例对象才可以调用的方法，定有参数为self</td>    </tr>    <tr>        <td>调用</td>        <td colspan="3">self.方法名([实参])</td>        <td colspan="3">实例对象.方法名([实参])</td>    </tr>    <tr>        <td rowspan="2" style="font-weight: bold;">类方法</td>        <td>解释</td>        <td colspan="6" style="text-align: left;">类方法指的是类对象中使用装饰器@classmethod进行装饰的方法，定有参数为cls</td>    </tr>    <tr>        <td>调用</td>        <td colspan="3">cls.方法名([实参]) 或 self.方法名([实参])</td>        <td colspan="3">类对象.方法名([实参]) 或 实例对象.方法名([实参])</td>    </tr>    <tr>        <td rowspan="2" style="font-weight: bold;">静态方法</td>        <td>解释</td>        <td colspan="6" style="text-align: left;">静态方式指的是类对象中使用装饰器@staticmethod进行装饰的方法，只是一个普通函数，无定有参数</td>    </tr>    <tr>        <td>调用</td>        <td colspan="3">cls.方法名([实参]) 或 self.方法名([实参])</td>        <td colspan="3">类对象.方法名([实参]) 或 实例对象.方法名([实参])</td>    </tr></table><ul><li>注意：<strong>访问实例属性和类属性都可以通过“实例对象.属性名”的方式访问</strong>。但其优先级是<strong>实例属性&gt;类属性</strong>（实例属性存在则会屏蔽类属性的值，实例属性不存在则输出类属性的值）</li><li><strong>重点：</strong><ol><li><strong>由于类对象的所有实例对象都有一个指向类对象的指针，所以类对象的所有实例对象都可以调用类对象中定义的实例方法和类方法（若两者方法名相同，则下面的覆盖上面的）！</strong></li><li><strong>python不能重载构造方法！但可以利用设置默认值形参和多选来达到java中重载的目的，而不用再次重载定义构造方法</strong></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Student:</span><br><span class="line"></span><br><span class="line">    # 定义初始化方法（构造方法），用于初始化对象属性（不支持重载），创建实例对象时会自动调用</span><br><span class="line">    def __init__(self, playgame=None):</span><br><span class="line">        self.sex = &#x27;男&#x27;</span><br><span class="line">        self.playgame = playgame</span><br><span class="line"></span><br><span class="line">    # 类属性</span><br><span class="line">    hobby = &#x27;睡觉&#x27;</span><br><span class="line"></span><br><span class="line">    # 实例方法</span><br><span class="line">    def fun(self, name=&#x27;匿名者&#x27;):  # name如果给默认值就不是必选参数了，没有默认值则是必选参数</span><br><span class="line">        print(&#x27;我叫&#x27; + name + &#x27;，性别&#x27; + self.sex + &#x27;，爱好&#x27; + self.hobby)</span><br><span class="line">        # print(self.fun1())  # 在实例方法可以中调用类方法</span><br><span class="line">        # print(self.fun2(&#x27;我喜欢&#x27;))  # 在实例方法中可以调用静态方法</span><br><span class="line"></span><br><span class="line">    # 类方法</span><br><span class="line">    @classmethod</span><br><span class="line">    def fun1(cls):</span><br><span class="line">        print(cls.hobby)  # 只能访问类属性</span><br><span class="line">        # print(cls.fun2(&#x27;我爱&#x27;))  # 在类方法中可以调用静态方法</span><br><span class="line"></span><br><span class="line">    # 静态方法</span><br><span class="line">    @staticmethod</span><br><span class="line">    def fun2(aaa):  # 静态方法中无`定有参数`，aaa只是普通参数</span><br><span class="line">        print(aaa, Student.hobby)  # 只能通过类名访问类属性</span><br><span class="line"></span><br><span class="line"># 创建实例对象</span><br><span class="line">tom = Student(&quot;lol&quot;)</span><br><span class="line">alice = Student()</span><br><span class="line">print(tom.playgame, alice.playgame)  # lol None</span><br><span class="line"></span><br><span class="line"># 访问-类属性（优先级问题）</span><br><span class="line">print(Student.hobby)  # 通过类访对象问类属性，睡觉</span><br><span class="line">tom.hobby = &#x27;干饭&#x27;  # 为tom添加了一个实例属性，并不会改变类属性中hobby的值</span><br><span class="line">print(tom.hobby)  # 由于tom已经有实例属性，优先级高于类属性，所以这里是访问的实例属性，干饭</span><br><span class="line">print(alice.hobby)  # alice访问时，由于没有实例属性hobby，所以访问的是类属性，睡觉</span><br><span class="line"></span><br><span class="line"># 访问-实例方法</span><br><span class="line">tom.fun()  # 我叫匿名者，性别男，爱好睡觉</span><br><span class="line">tom.fun(&#x27;汤姆&#x27;)  # 我叫汤姆，性别男，爱好睡觉</span><br><span class="line"></span><br><span class="line"># 访问-类方法</span><br><span class="line">Student.fun1()  # 通过类对象访问类方法，睡觉</span><br><span class="line">tom.fun1()  # 通过实例对象访问类方法，睡觉</span><br><span class="line"></span><br><span class="line"># 访问-静态方法</span><br><span class="line">Student.fun2(&#x27;嘿嘿嘿&#x27;)  # 通过类对象访问静态方法，嘿嘿嘿 睡觉</span><br><span class="line">tom.fun2(&#x27;哈哈哈&#x27;)  # 通过实例对象访问静态方法，哈哈哈 睡觉</span><br></pre></td></tr></table></figure><h3 id="2-Python的动态性"><a href="#2-Python的动态性" class="headerlink" title="2. Python的动态性"></a>2. Python的动态性</h3><ul><li><strong>动态地创建类：</strong><ul><li><strong>type是Python的内建元类</strong>，是用来创建所有类的元类，所以可以通过type函数创建类</li><li><strong>任何对象最终的所属类都是type</strong>，可通过type函数验证，也可以通过多级__class__属性验证</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">MyDog = type(&quot;Dog&quot;, (object,), &#123;&quot;role&quot;: &quot;dog&quot;, &quot;__init__&quot;: __init__&#125;)</span><br><span class="line">d = MyDog(&quot;pig&quot;)</span><br><span class="line">print(MyDog)  # `&lt;class &#x27;__main__.Dog&#x27;&gt;`</span><br><span class="line">print(d.__class__)  # `&lt;class &#x27;__main__.Dog&#x27;&gt;`</span><br><span class="line">print(d.__class__.__class__)  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line">print(d.role, d.name)  # dog pig</span><br></pre></td></tr></table></figure><ul><li><strong>动态地绑定实例方法：</strong><ul><li>在实例对象或类对象创建之后，也可以通过<strong>标准库types中的类MethodType</strong>对其动态地绑定实例方法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from types import MethodType</span><br><span class="line"></span><br><span class="line">def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">MyDog = type(&quot;Dog&quot;, (object,), &#123;&quot;role&quot;: &quot;dog&quot;, &quot;__init__&quot;: __init__&#125;)</span><br><span class="line">m1 = MyDog(&quot;jack&quot;)</span><br><span class="line">m2 = MyDog(&quot;alice&quot;)</span><br><span class="line"></span><br><span class="line">def my_pow(self, x, y):</span><br><span class="line">    result = x</span><br><span class="line">    for i in range(y - 1):</span><br><span class="line">        result *= x</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># 给实例对象m1动态地绑定实例方法</span><br><span class="line">m1.my_pow = MethodType(my_pow, m1)</span><br><span class="line">print(m1.my_pow(2, 3))  # 8</span><br><span class="line"></span><br><span class="line"># 删除m1的my_pow方法</span><br><span class="line">del m1.my_pow</span><br><span class="line"># 访问特殊属性__dict__可以获得实例对象所绑定的所有属性和属性对应值的一个字典</span><br><span class="line">print(m1.__dict__)  # &#123;&#x27;name&#x27;: &#x27;jack&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># 给类对象动态地绑定实例方法，这样所有实例都能访问my_pow()方法</span><br><span class="line">MyDog.my_pow = my_pow</span><br><span class="line">print(m1.my_pow(3, 2))  # 9</span><br><span class="line">print(m2.my_pow(2, 4))  # 16</span><br></pre></td></tr></table></figure><h3 id="3-访问控制"><a href="#3-访问控制" class="headerlink" title="3. 访问控制"></a>3. 访问控制</h3><ul><li>简介：目的是为了控制类对象的属性和方法在类对象的外部是否可以直接访问</li><li>应用：在类对象的某个属性或方法前<strong>添加两个下划线“_”</strong>，那么在类对象的外部就<strong>不能直接访问</strong>该属性或方法了；在类对象的某个属性或方法前<strong>添加单个下划线”_“<strong>，表示</strong>依然可以在类对象的外部直接访问</strong>该属性或方法，但<strong>最好不要直接访问</strong></li><li>原理：因为Python解释器对外把__xxx的属性或方法改成了另一个名字：_类名__xxx，虽然也可以通过此访问，但强烈不建议这样访问，因为不同版本的Python解释器可能更换的名字不同</li><li><strong>注意：在类对象的外部动态绑定名为__xxx的属性或方法，这与类对象内部名为__xxx的属性或方法的含义是不同的</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__pia = 18</span><br><span class="line">        self._pib = &#x27;abc&#x27;</span><br><span class="line"></span><br><span class="line">    def __pim(self):</span><br><span class="line">        print(&quot;__pim()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">    def _pin(self):</span><br><span class="line">        print(&quot;_pin()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">    # 通过实例方法访问不能直接访问的属性和方法</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(self.__pia)</span><br><span class="line">        self.__pim()</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line"># print(mc.__pia)  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;__pia&#x27;</span><br><span class="line"># mc.__pim()  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;__pim&#x27;</span><br><span class="line">print(mc._pib)  # abc</span><br><span class="line">mc._pin()  # _pin()被调用了</span><br><span class="line">mc.do_sth()  # 18 __pim()被调用了</span><br><span class="line"></span><br><span class="line"># Python为我们更改的名字，但最好不这样方法</span><br><span class="line"># print(mc._MyClass__pia)  # 18</span><br><span class="line"># mc._MyClass__pim()  # __pim()被调用了</span><br><span class="line">print(dir(mc))  # [&#x27;_MyClass__pia&#x27;, &#x27;_MyClass__pim&#x27;, ......]</span><br><span class="line">print(mc.__dict__)  # &#123;&#x27;_MyClass__pia&#x27;: 18, &#x27;_pib&#x27;: &#x27;abc&#x27;&#125;</span><br><span class="line">&quot;&quot;&quot;dir()和__dict__的区别：</span><br><span class="line">1. 调用内置函数dir()获得指定对象所有可以访问的属性和方法的一个列表</span><br><span class="line">   用于列出对象的所有属性和方法，主要是一个用于查阅对象的工具</span><br><span class="line">2. 访问特殊属性__dict__可以获得实例对象所绑定的所有属性和属性对应值的一个字典，是一个属性字典</span><br><span class="line">   用于保存对象的所有成员变量和对应的值，可以用于直接访问和操作对象的属性</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 在外部直接绑定__xxx属性，和内部意义是不一样的</span><br><span class="line">mc.__pia = &quot;Hi&quot;</span><br><span class="line">print(mc.__pia)  # Hi</span><br><span class="line">print(dir(mc))  # [&#x27;_MyClass__pia&#x27;, &#x27;_MyClass__pim&#x27;, &#x27;__pia&#x27;, ......]</span><br></pre></td></tr></table></figure><h3 id="4-封装、继承、重写、多态"><a href="#4-封装、继承、重写、多态" class="headerlink" title="4. 封装、继承、重写、多态"></a>4. 封装、继承、重写、多态</h3><ul><li><strong>封装</strong>：将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象外部调用方法，这样，就无需关心方法内部的具体实现细节，从而隔离了复杂度</li></ul><ul><li>应用：<strong>对隐藏的信息进行保护</strong>。在类对象的内部通过访问控制把某些属性和方法隐藏起来，不允许在类对象的外部直接访问，而是在类对象的内部对外提供公开的接口方法（例如getter和setter）以访问隐藏的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__score = 90</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&quot;成绩必须在0~100之间&quot;)</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line"></span><br><span class="line">s.set_score(88)</span><br><span class="line"># s.set_score(123)  # ValueError: 成绩必须在0~100之间</span><br><span class="line">print(s.get_score())  # 88</span><br></pre></td></tr></table></figure><ul><li><strong>继承：继承是实现代码复用的重要手段</strong>。把几个类对象中共同的属性和方法抽象并提取到一个基类中，每个类对象特有的属性和方法还是在本类对象中定义，这样，只需要让每个类对象都继承这个基类，就可以访问基类中的属性和方法了。其中，继承基类的每个类对象被称为<strong>派生类</strong>，基类也被称为<strong>父类</strong>或<strong>超类</strong>，派生类也被称为<strong>子类</strong></li></ul><ul><li><p>注意：<strong>Python中的所有类对象都继承自一个统一的基类：object</strong></p></li><li><p>知识点：子类可以有一个直接父类或多个直接父类，分别称为单继承和多继承。<strong>子类会继承父类（所有直接父类和所有间接父类）的所有属性和方法</strong>；子类可以添加父类中没有的属性和方法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ParentClassA(object):</span><br><span class="line">    ca = 18</span><br><span class="line"></span><br><span class="line">    def im(self):</span><br><span class="line">        print(&quot;im()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ParentClassB(object):</span><br><span class="line">    __pca = 23</span><br><span class="line"></span><br><span class="line">    def __pim(self):</span><br><span class="line">        print(&quot;__pim()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ParentClassC(ParentClassA, ParentClassB):</span><br><span class="line">    @classmethod</span><br><span class="line">    def cm(cls):</span><br><span class="line">        print(&quot;cm()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ParentClassD(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def sm():</span><br><span class="line">        print(&quot;sm()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass(ParentClassC, ParentClassD):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 子类会继承父类（所有直接父类和所有间接父类）的所有属性和方法</span><br><span class="line">print(dir(ChildClass))  # [&#x27;_ParentClassB__pca&#x27;, &#x27;_ParentClassB__pim&#x27;, ......, &#x27;ca&#x27;, &#x27;cm&#x27;, &#x27;im&#x27;, &#x27;sm&#x27;]</span><br></pre></td></tr></table></figure><ul><li><strong>重写</strong>：如果子类对继承自父类的某个属性或方法不满意，可以在子类中对其进行重写从而提供自定义的实现</li></ul><ul><li>应用：在子类中定义与父类中同名的属性或方法（包括装饰器）</li><li>注意：在子类中重写父类中的属性或方法后，通过子类或实例对象直接访问只能访问到重写后的属性或方法，想要再访问父类中的属性或方法，<strong>可以在子类重写后的方法中可以通过super( ).xxx( )进行调用</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ParentClass(object):</span><br><span class="line">    ca = &quot;ca（父类）&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;__init__()被调用了（父类）&quot;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def cm(cls):</span><br><span class="line">        print(&quot;cm()被调用了（父类）&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass(ParentClass):</span><br><span class="line">    ca = &quot;ca（子类）&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(&quot;__init__()被调用了（子类）&quot;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def cm(cls):</span><br><span class="line">        print(&quot;cm()被调用了（子类）&quot;)</span><br><span class="line"></span><br><span class="line">cc = ChildClass()  # __init__()被调用了（父类） __init__()被调用了（子类）</span><br><span class="line"></span><br><span class="line">print(ChildClass.ca)  # ca（子类）</span><br><span class="line">print(cc.ca)  # ca（子类）</span><br><span class="line">ChildClass.cm()  # cm()被调用了（子类）</span><br><span class="line">cc.cm()  # cm()被调用了（子类）</span><br></pre></td></tr></table></figure><ul><li><strong>多态：多态就是“具有多种形态”</strong>，即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法，<strong>在运行过程中根据变量所引用对象的类型，动态地决定调用哪个对象中的方法</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ParentClass:</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in ParentClass&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass1(ParentClass):</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in ChildClass1&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass2(ParentClass):</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in ChildClass2&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass3(ParentClass):</span><br><span class="line">    pass  # 子类中不存在指定方法时，会到父类中查找并调用</span><br><span class="line"></span><br><span class="line">class SomeClass(object):</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in SomeClass&quot;)</span><br><span class="line"></span><br><span class="line">def f(parent):</span><br><span class="line">    parent.do_sth()</span><br><span class="line"></span><br><span class="line">f(ParentClass())  # do_sth() in ParentClass</span><br><span class="line">f(ChildClass1())  # do_sth() in ChildClass1</span><br><span class="line">f(ChildClass2())  # do_sth() in ChildClass2</span><br><span class="line">f(ChildClass3())  # do_sth() in ParentClass</span><br><span class="line">f(SomeClass())  # do_sth() in SomeClass</span><br></pre></td></tr></table></figure><blockquote><p><strong>（重点）动态语言与静态语言多态的区别：</strong></p><ul><li><strong>Python是动态语言</strong>，在调用函数时不会检查参数的类型，从而导致与<strong>静态语言（例如Java）</strong>的多态<br>是有区别的。对于静态语言，实现多态有三个必要条件：<ol><li>继承</li><li>重写</li><li><strong>父类类型的变量引用父类或子类类型的实例对象</strong></li></ol></li></ul><p><strong>因此，对于静态语言，在上面的程序中，要限定形参parent的类型是ParentClass，传入的实参只能是</strong><br><strong>ParentClass、ChildClass1、ChildClass2或ChildClass3的实例对象</strong></p><ul><li>动态语言的多态崇尚”<strong>鸭子类型</strong>“：当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子,<br>那么这只鸟就可以被称为鸭子。<strong>在鸭子类型中，我们并不关心对象是什么类型，到底是不是鸭子，只关心对象的行为</strong></li></ul><p><strong>因此，对于动态语言，在上面的程序中，我们并不关心变量parent所引用的对象是什么类型，到底是不是ParentClass或其子类类型，只关心变量parent所引用的对象是否有do_sth( )这个方法</strong></p><img                           lazyload                       alt="image"                       data-src="https://xfblog.cn/1671017104-13bfb99460c4f1d.jpeg"                                         ></blockquote><h3 id="5-MRO"><a href="#5-MRO" class="headerlink" title="5. MRO"></a>5. MRO</h3><ul><li><p>简介：MRO的全称是<strong>Method Resolution Order（方法解析顺序）</strong>，指的是对于一颗类继承树，当调用最底层类对象所对应实例对象的方法时，Python解释器在类继承树上搜索方法的顺序</p></li><li><p>应用：对于一颗类继承树，可以调用最底层类对象的方法<strong>mro( )<strong>或访问最底层类对象的特殊属性</strong>__mro__<strong>，</strong>获得这棵类继承树的MRO</strong></p></li><li><p>知识点：<strong>在子类重写后的方法中通过super( )调用父类中被重写的方法时，在所有父类中搜索方法的顺序基于以该子类为最底层类对象的类继承树的MRO</strong></p></li><li><p>知识点应用：在调用父类中被重写的方法时，给super( )传入两个实参，即super(type, obj)，其中第一个实参type是类对象，第二个实参obj是实例对象。这样，<strong>指定的对象即是obj所对应类对象的MRO中，type后面的那个类对象</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    def f(self):</span><br><span class="line">        print(&quot;A.f&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def f(self):</span><br><span class="line">        print(&quot;B.f&quot;)</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def f(self):</span><br><span class="line">        print(&quot;C.f&quot;)</span><br><span class="line"></span><br><span class="line">class D(B, C):</span><br><span class="line">    def f(self):</span><br><span class="line">        super().f()  # B.f</span><br><span class="line">        # super(D, self).f()  # B.f</span><br><span class="line">        # super(B, self).f()  # C.f</span><br><span class="line">        # super(C, self).f()  # A.f</span><br><span class="line">        # super(B, B()).f()  # A.f</span><br><span class="line"></span><br><span class="line">print(D.mro())</span><br><span class="line"># [`&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;`]</span><br><span class="line">d = D()</span><br><span class="line">d.f()  # B.f</span><br></pre></td></tr></table></figure><h3 id="6-获取对象的信息之内置函数"><a href="#6-获取对象的信息之内置函数" class="headerlink" title="6. 获取对象的信息之内置函数"></a>6. 获取对象的信息之内置函数</h3><ul><li><p><strong>内置函数issubclass(subclass, superclass)<strong>：用于</strong>检查类与类之间的继承关系</strong>，接受两个实参，第一个是类对象，第二个是类对象或由类对象组成的元组</p></li><li><p><strong>内置函数isinstance(object, classinfo)<strong>：用于</strong>检查对象与类之间的实例关系</strong>，接受两个实参，第一个是实例对象，第二个是类对象或由类对象组成的元组</p></li><li><p><strong>内置函数type(object)<strong>：用于</strong>获取对象的类型</strong>，返回表示对象类型的对象（<strong>使用运算符&#x3D;&#x3D;可以直接判断某个对象的类型是否是指定的类型</strong>，对于基本数据类型，可以直接使用其对应的类名；对于非基本数据类型，需要调用标准库中的模块types中定义的变量）</p></li><li><p><strong>内置函数dir([object])<strong>：用于</strong>获取对象有效属性和方法（包括从父类继承的属性和方法）的字符串列表</strong>，其中参数object是可选的，如果没有提供，则返回当前作用域内的名称列表。并且类对象与实例对象的结果是有区别的，类对象的结果中不包括实例属性</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Parent:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class AnotherClass:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 1、内置函数issubclass(subclass, superclass)</span><br><span class="line">print(issubclass(Child, Parent))  # True</span><br><span class="line">print(issubclass(bool, int))  # True</span><br><span class="line">print(issubclass(bool, str))  # False</span><br><span class="line">print(issubclass(bool, (str, int, dict)))  # True</span><br><span class="line"></span><br><span class="line"># 2、内置函数isinstance(object, classinfo)</span><br><span class="line">obj = Child()</span><br><span class="line">print(isinstance(obj, Child))  # True</span><br><span class="line">print(isinstance(obj, AnotherClass))  # False</span><br><span class="line">print(isinstance(obj, (Parent, AnotherClass)))  # True</span><br><span class="line"></span><br><span class="line"># 3、内置函数type(object)</span><br><span class="line"># 实例对象的类型是其对应的类对象</span><br><span class="line">mc = Parent()</span><br><span class="line">print(type(mc))  # `&lt;class &#x27;__main__.Parent&#x27;&gt;`</span><br><span class="line">print(type(18))  # `&lt;class &#x27;int&#x27;&gt;`</span><br><span class="line">print(type(&#x27;abc&#x27;))  # `&lt;class &#x27;str&#x27;&gt;`</span><br><span class="line"># 类对象的类型是type，也就是说，类对象都是type的一个实例</span><br><span class="line">print(type(Parent))  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line">print(type(int))  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line">print(type(str))  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line"></span><br><span class="line"># 自定义函数对象的类型是function</span><br><span class="line">def do_sth():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(type(do_sth))  # `&lt;class &#x27;function&#x27;&gt;`</span><br><span class="line"># 内置函数对象的类型是builtin_function_or_method</span><br><span class="line">print(type(print))  # `&lt;class &#x27;builtin_function_or_method&#x27;&gt;`</span><br><span class="line"></span><br><span class="line"># 使用运算符==判断某个对象的类型是否是指定的类型</span><br><span class="line">print(type(18) == int)  # True</span><br><span class="line">print(type(&#x27;abc&#x27;) == str)  # True</span><br><span class="line">import types</span><br><span class="line"></span><br><span class="line">print(type(do_sth) == types.FunctionType)  # True</span><br><span class="line">print(type(print) == types.BuiltinFunctionType)  # True</span><br><span class="line"></span><br><span class="line"># 4、内置函数dir([object])</span><br><span class="line">def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">AnotherClass.do_sth = do_sth</span><br><span class="line">AnotherClass.__init__ = __init__</span><br><span class="line"># 类对象的结果中不包括实例属性</span><br><span class="line">print(dir(AnotherClass))  # [......, &#x27;__init__&#x27;, ......, &#x27;do_sth&#x27;]</span><br><span class="line">print(dir(AnotherClass(&#x27;xfblog&#x27;)))  # [......, &#x27;__init__&#x27;, ......, &#x27;do_sth&#x27;, &#x27;name&#x27;]</span><br></pre></td></tr></table></figure><h3 id="7-获取对象的信息之反射"><a href="#7-获取对象的信息之反射" class="headerlink" title="7. 获取对象的信息之反射"></a>7. 获取对象的信息之反射</h3><ul><li><p>简介：所谓“反射”，指的是以字符串的形式来操作（增删改查）对象的属性和方法</p></li><li><p>用于“反射”的内置函数有以下四个（参数name为字符串）：</p><ol><li>hasattr(object, name)：用于判断指定的对象object是否有参数name指定的属性或方法</li><li>getattr(object, name[, default])：用于获取指定的对象object中名为name的属性或方法</li><li>setattr(object, name, value)：用于在指定的对象object中添加或修改参数名为name的属性或方法</li><li>delattr(object, name)：用于删除指定的对象object中名为参数name的属性或方法</li></ol></li><li><p>注意：<strong>只有在不知道对象信息的情况下，才会去获取对象的信息</strong>。因此，能写object.name，就不要写getattr(object, ‘name’)</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 1</span><br><span class="line"></span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth被调用&quot;)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line">print(hasattr(mc, &#x27;x&#x27;))  # True</span><br><span class="line">print(hasattr(MyClass, &#x27;x&#x27;))  # False</span><br><span class="line">print(hasattr(mc, &#x27;do_sth&#x27;))  # True</span><br><span class="line"></span><br><span class="line">print(getattr(mc, &#x27;x&#x27;))  # 1</span><br><span class="line">f = getattr(mc, &#x27;do_sth&#x27;)</span><br><span class="line">f()  # do_sth被调用</span><br><span class="line"># print(getattr(mc, &#x27;y&#x27;))  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;y&#x27;</span><br><span class="line">print(getattr(mc, &#x27;y&#x27;, 2))  # 2 获取时给不存在的属性或方法指定默认值，可以避免抛出异常</span><br><span class="line"></span><br><span class="line">setattr(mc, &#x27;z&#x27;, 3)</span><br><span class="line">print(getattr(mc, &#x27;z&#x27;))  # 3</span><br><span class="line">print(dir(mc))  # [......, &#x27;do_sth&#x27;, &#x27;x&#x27;, &#x27;z&#x27;]</span><br><span class="line">setattr(mc, &#x27;z&#x27;, 4)</span><br><span class="line">print(getattr(mc, &#x27;z&#x27;))  # 4</span><br><span class="line"></span><br><span class="line">delattr(mc, &#x27;z&#x27;)</span><br><span class="line">print(hasattr(mc, &#x27;z&#x27;))  # False</span><br></pre></td></tr></table></figure><ul><li>知识点：如何反射一个模块下指定的字符串对应的属性，即<strong>通过模块名反射属性</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 1、如何使用反射机制来检查和获取&quot;当前模块&quot;对象中的属性</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"># for k,v in sys.modules.items():</span><br><span class="line">#     print(k,v)</span><br><span class="line">mod = sys.modules[__name__]  # 获取当前模块的对象</span><br><span class="line"></span><br><span class="line">if hasattr(mod, &quot;p&quot;):  # 检查在当前模块对象中是否存在属性名为&quot;p&quot;的属性</span><br><span class="line">    o = getattr(mod, &quot;p&quot;)</span><br><span class="line">    print(o)  # `&lt;__main__.Person object at 0x100209a10&gt;`</span><br><span class="line"></span><br><span class="line"># 2、如何使用反射机制来检查和获取&quot;其他模块&quot;对象中的属性</span><br><span class="line"># my_module.py</span><br><span class="line">my_variable = 42</span><br><span class="line"></span><br><span class="line"># main.py</span><br><span class="line">module_name = &quot;my_module&quot;</span><br><span class="line">attribute_name = &quot;my_variable&quot;</span><br><span class="line"></span><br><span class="line"># 动态加载模块</span><br><span class="line">module = __import__(module_name)  # 获取其模块对象</span><br><span class="line"></span><br><span class="line"># 获取属性</span><br><span class="line">if hasattr(module, attribute_name):</span><br><span class="line">    attribute = getattr(module, attribute_name)</span><br><span class="line">    print(attribute)  # 42</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;&#123;module_name&#125; 模块中没有名为 &#123;attribute_name&#125; 的属性&quot;)</span><br><span class="line"></span><br><span class="line"># 3、第2种情况的直接静态导入模块，更加直观简洁</span><br><span class="line">import my_module</span><br><span class="line"></span><br><span class="line">if hasattr(my_module, &quot;my_variable&quot;):</span><br><span class="line">    attribute = getattr(my_module, &quot;my_variable&quot;)</span><br><span class="line">    print(attribute)  # 输出 42</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;&#123;my_module.__name__&#125; 模块中没有名为 my_variable 的属性&quot;)</span><br></pre></td></tr></table></figure><ul><li>反射的应用场景：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class User:</span><br><span class="line">    def login(self):</span><br><span class="line">        print(&quot;登录操作&quot;)</span><br><span class="line"></span><br><span class="line">    def register(self):</span><br><span class="line">        print(&quot;注册操作&quot;)</span><br><span class="line"></span><br><span class="line">    def save(self):</span><br><span class="line">        print(&quot;存储操作&quot;)</span><br><span class="line"></span><br><span class="line">obju = User()</span><br><span class="line"></span><br><span class="line"># 没学反射之前，解决根据用户输入进行对应操作</span><br><span class="line"># while True:</span><br><span class="line">#     choose = input(&quot;&gt;&gt;:&quot;).strip()</span><br><span class="line">#     if choose == &#x27;login&#x27;:</span><br><span class="line">#         u.login()</span><br><span class="line">#     elif choose == &#x27;register&#x27;:</span><br><span class="line">#         u.register()</span><br><span class="line">#     else:</span><br><span class="line">#         u.save()</span><br><span class="line"></span><br><span class="line"># 使用反射解决问题</span><br><span class="line">while True:</span><br><span class="line">    choose = input(&quot;&gt;&gt;:&quot;).strip()</span><br><span class="line">    if hasattr(obju, choose):</span><br><span class="line">        fun = getattr(obju, choose)</span><br><span class="line">        fun()</span><br></pre></td></tr></table></figure><h3 id="8-特殊属性和魔术方法"><a href="#8-特殊属性和魔术方法" class="headerlink" title="8. 特殊属性和魔术方法"></a>8. 特殊属性和魔术方法</h3><blockquote><p>简介：调用内置函数dir()后的返回值中，很多属性和方法都是以双下划线__开头和结尾的，其中绝大多数都继承自类object：</p><ul><li>特殊属性：即以双下划线__开头和结尾的属性</li><li>特殊方法：即以双下划线__开头和结尾的方法</li></ul><p>注意：<strong>特殊属性和特殊方法都是系统预定义的</strong>，自定义时尽量不要以双下划线开头和结尾。我们常会重写一个或多个特殊方法，<strong>特殊方法一般会在特定的情形下被自动调用</strong>，很少需要手动调用</p></blockquote><ul><li><strong>特殊属性__dict__<strong>：用于获取指定的类对象或实例对象所</strong>绑定</strong>的所有属性方法与其对应值，并打包为一个字典</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    def my_method(self):</span><br><span class="line">        print(&quot;Hello from my_method&quot;)</span><br><span class="line"></span><br><span class="line"># 创建类的实例</span><br><span class="line">obj = MyClass(42)</span><br><span class="line"></span><br><span class="line"># 获取类的属性字典</span><br><span class="line">print(MyClass.__dict__)</span><br><span class="line"># &#123;......, &#x27;__init__&#x27;: function..., &#x27;my_method&#x27;: function...&#125;</span><br><span class="line"></span><br><span class="line"># 获取实例的属性字典</span><br><span class="line">print(obj.__dict__)  # &#123;&#x27;x&#x27;: 42&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特殊方法__len__()<strong>：当在一个对象上调用len()函数时，会自动调用对象定义的__len__()方法，用于返回对象的长度。</strong>内置函数len()的实参在默认情况下不能是自定义类对象的实例对象，因此需在自定义类对象中实现特殊方法__len__()</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 之所以len()的实参可以是某些内置类对象的实例对象，是因为这些内置类对象中都实现了特殊方法__len__()</span><br><span class="line">print(len([1, 2, 3, 4, 5]))  # 5</span><br><span class="line">print(len(&#x27;abcde&#x27;))  # 5</span><br><span class="line">print(len(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;))  # 3</span><br><span class="line"></span><br><span class="line"># class MyClass(object):</span><br><span class="line">#     pass</span><br><span class="line"># print(len(MyClass()))  # TypeError: object of type &#x27;MyClass&#x27; has no len()</span><br><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    def __len__(self):</span><br><span class="line">        return 18</span><br><span class="line"></span><br><span class="line">print(len(MyClass()))  # 18</span><br></pre></td></tr></table></figure><ul><li><strong>特殊方法__iter__()和__next__()<strong>：只实现__iter__()的类对象被称为</strong>可迭代类对象</strong>，同时实现__iter__()和__next__()的类对象被称为<strong>迭代器类对象</strong><ul><li>应用：<strong>for-in循环语句在默认情况下不能用于自定义类对象的实例对象，因此需在自定义类对象中同时实现特殊方法__iter__()和__next__()</strong></li><li>原理：for-in语句首先会调用特殊方法__iter__()返回一个可迭代对象，然后不断调用可迭代对象的特殊方法__next__()返回下一次迭代的值，直到遇到StopIteration时退出循环</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 之所以for-in语句可以直接用于某些内置类对象的实例对象，</span><br><span class="line"># 是因为这些内置类对象中都同时实现了特殊方法__iter__()和__next__()</span><br><span class="line">L = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">for item in L:</span><br><span class="line">    print(item)  # 1 2 3 4 5</span><br><span class="line"></span><br><span class="line"># class MyClass(object):</span><br><span class="line">#     pass</span><br><span class="line"># for item in MyClass():  # TypeError: &#x27;MyClass&#x27; object is not iterable</span><br><span class="line">#     print(item)</span><br><span class="line"></span><br><span class="line">class MyClass:</span><br><span class="line">    def __init__(self, length):</span><br><span class="line">        self.length = length</span><br><span class="line">        self.index = 0</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &gt;= self.length:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        result = self.index</span><br><span class="line">        self.index += 1</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">for item in MyClass(5):</span><br><span class="line">    print(item)  # 0 1 2 3 4</span><br></pre></td></tr></table></figure><ul><li>**特殊方法__add__()和__radd__()**：<ul><li>应用：<strong>标准算术运算符在默认情况下不能用于自定义类对象的实例对象，因此需在自定义类对象中实现标准算术运算符对应的特殊方法</strong></li><li>原理：假设两个运算符obj1和obj2，以+为例，则需要在obj1对应的自定义类对象中实现特殊方法__add__()；<strong>或</strong>在obj2对应的自定义类对象中实现特殊方法__radd__()（r是right的缩写），因为obj2位于运算符+的右边</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">+对应的特殊方法是__add__()和__radd__();</span><br><span class="line">-对应的特殊方法是__sub__()和__rsub__();</span><br><span class="line">*对应的特殊方法是__mul__()和__rmul__();</span><br><span class="line">/对应的特殊方法是__truediv__()和__rtruediv__();</span><br><span class="line">//对应的特殊方法是__floordiv__()和__rfloordiv__();</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># class MyClass1(object):</span><br><span class="line">#     pass</span><br><span class="line"># class MyClass2(object):</span><br><span class="line">#     pass</span><br><span class="line"># print(MyClass1() + MyClass2())</span><br><span class="line"># 抛出异常 TypeError: unsupported operand type(s) for +: &#x27;MyClass1&#x27; and &#x27;MyClass2&#x27;</span><br><span class="line"></span><br><span class="line">class C1(object):</span><br><span class="line">    def __add__(self, other):</span><br><span class="line">        print(&quot;特殊方法__add__被调用&quot;)</span><br><span class="line">        # return &quot;xxx&quot;</span><br><span class="line">        return NotImplemented</span><br><span class="line"></span><br><span class="line">class C2(object):</span><br><span class="line">    def __radd__(self, other):</span><br><span class="line">        print(&quot;特殊方法__radd__被调用&quot;)</span><br><span class="line">        return &quot;yyy&quot;</span><br><span class="line">        # return NotImplemented</span><br><span class="line"></span><br><span class="line">obj1 = C1()</span><br><span class="line">obj2 = C2()</span><br><span class="line"># 通常只会调用C1类中的add方法，而因为C1中返回了NotImplemented，所以又调用了C2中的radd方法</span><br><span class="line">print(obj1 + obj2)  # 特殊方法__add__被调用 特殊方法__radd__被调用 yyy</span><br><span class="line">&quot;&quot;&quot;print(obj2 + obj1)</span><br><span class="line">抛出异常：TypeError: unsupported operand type(s) for +: &#x27;C2&#x27; and &#x27;C1&#x27;</span><br><span class="line">原因：第一个对象内部必须定义的是__add__()，而obj2对象的类中定义的是__radd__()</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>**特殊方法__str__()和__repr__()**：用于自定义并返回实例对象的字符串表示形式</li></ul><ol><li><p>在交互式命令行中直接打印一个实例对象：__repr__() &gt; 类对象内存地址</p></li><li><p>调用内置函数print打印一个实例对象：__str__() &gt; __repr__() &gt; 类对象内存地址</p></li><li><p>调用内置函数str创建字符串并且实参是一个实例对象：__str__() &gt; __repr__() &gt; 类对象内存地址</p></li><li><p>调用内置函数repr创建字符串并且实参是一个实例对象：__repr__() &gt; 类对象内存地址</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 两者区别：str()的返回值是给用户看的，更加用户友好；repr()的返回值是给开发者看的，是为调试服务的</span><br><span class="line">class MyClass(object):</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line"># 通常情况下，特殊方法__str__()和__repr__()的实现代码是一样的，因此可以直接把方法名赋值给另一个的方法名</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"># str()和repr()的区别</span><br><span class="line">print(str(&quot;Hello,\nworld!&quot;))  # Hello,（换行）world!</span><br><span class="line">print(repr(&quot;Hello,\nworld!&quot;))  # &#x27;Hello,\nworld!&#x27;</span><br></pre></td></tr></table></figure><ul><li>**特殊方法__new__()<strong>：用于创建实例对象，特殊方法__new__()会将创建好的实例对象返回给__init__()方法，并调用__init__()方法。当使用</strong>类名([实参])**创建实例对象时，首先会调用特殊方法__new__()创建实例（没有则在父类依次向上查找），__new__()返回的实例对象会作为实参被自动传递给__init__()的第一个形参self，从而进行初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;父类的__new__()被调用，其形参cls对应实参的id:%s&quot; % id(cls))</span><br><span class="line">        obj = super().__new__(cls)</span><br><span class="line">        print(&quot;创建的实例对象的id:%s&quot; % id(obj))</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        print(&quot;子类的__init__()被调用，其形参self对应实参的id：%s&quot; % id(self))</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">print(&quot;父类Parent的id：%s&quot; % id(Parent))</span><br><span class="line">print(&quot;子类Child的id：%s&quot; % id(Child))</span><br><span class="line"></span><br><span class="line">child = Child(&quot;Mike&quot;)</span><br><span class="line">print(&quot;创建的实例对象的id：%s&quot; % id(child))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;运行结果：</span><br><span class="line">父类Parent的id：4889618576</span><br><span class="line">子类Child的id：4889619520</span><br><span class="line">父类的__new__()被调用，其形参cls对应实参的id:4889619520</span><br><span class="line">创建的实例对象的id:4309941696</span><br><span class="line">子类的__init__()被调用，其形参self对应实参的id：4309941696</span><br><span class="line">创建的实例对象的id：4309941696</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p><strong>重点：__new__()方法实现单例模式（单例模式是一种设计模式，用于确保一个类只有一个实例，并提供全局访问点以获取该实例）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Printer:</span><br><span class="line"> tasks = []</span><br><span class="line"> instance = None  # 用于存放第一个实例对象</span><br><span class="line"></span><br><span class="line"> def __init__(self, name):</span><br><span class="line">     self.name = name</span><br><span class="line"></span><br><span class="line"> def add_task(self, job):</span><br><span class="line">     self.tasks.append(job)</span><br><span class="line">     print(&quot;[%s]添加任务[%s]到打印机，总任务数[%s]&quot; % (self.name, job, len(self.tasks)))</span><br><span class="line"></span><br><span class="line"> def __new__(cls, *args, **kwargs):</span><br><span class="line">     # 只有第一次创建实例对象时，正常创建，后面每次实例化并不真正创建一个新实例</span><br><span class="line">     if not cls.instance:</span><br><span class="line">         # 第一次创建实例对象时，将实例对象存入cls.instance</span><br><span class="line">         obj = super().__new__(cls)  # 实例化过程</span><br><span class="line">         print(&quot;obj:&quot;, obj)  # obj: `&lt;__main__.Printer object at 0x10033ad10&gt;`</span><br><span class="line">         cls.instance = obj  # 把成功创建的实例对象存下来</span><br><span class="line">     return cls.instance  # 以后的每次实例化，直接返回第一次存的实例对象</span><br><span class="line">     # 在上一次实例对象的基础上，再执行__init__方法，相当于每次都会覆盖掉上一次的name</span><br><span class="line"></span><br><span class="line">p1 = Printer(&quot;tom&quot;)</span><br><span class="line">p2 = Printer(&quot;jack&quot;)</span><br><span class="line">p3 = Printer(&quot;alice&quot;)</span><br><span class="line"></span><br><span class="line">p1.add_task(&quot;word-app&quot;)  # [alice]添加任务[word-app]到打印机，总任务数[1]</span><br><span class="line">p2.add_task(&quot;pdf-app&quot;)  # [alice]添加任务[pdf-app]到打印机，总任务数[2]</span><br><span class="line">p3.add_task(&quot;excel-app&quot;)  # [alice]添加任务[excel-app]到打印机，总任务数[3]</span><br><span class="line">print(p1, p2, p3)  # `&lt;...at 0x10033ad10&gt;` `&lt;...at 0x10033ad10&gt;` `&lt;...at 0x10033ad10&gt;`</span><br><span class="line">print(p1.name, p2.name, p3.name)  # alice alice alice</span><br></pre></td></tr></table></figure></blockquote><h3 id="9-对象的引用计数"><a href="#9-对象的引用计数" class="headerlink" title="9. 对象的引用计数"></a>9. 对象的引用计数</h3><ul><li><p>简介：当创建一个对象时，系统会自动分配一块内存以存储该对象的信息，当该对象不再被使用时，系统会进行垃圾回收以自动释放掉其占用的内存；为了确保使用中的对象不会被销毁，<strong>Python使用引用计数来跟踪和计算内存中每个对象被引用的次数</strong>，当对象的引用计数为0时，才可以被销毁</p></li><li><p>对象的引用计数加1的情形：</p><ol><li><p>对象赋值给变量</p></li><li><p>引用对象的变量赋值给另一个变量</p></li><li><p>对象作为容器（例如：列表、元组、集合等）中的元素</p></li><li><p>对象作为函数调用时的实参</p></li></ol></li><li><p>对象的引用计数减1的情形：</p><ol><li><p>对象离开它的作用域，例如：对象所在的函数执行完毕</p></li><li><p>对象的引用被显式销毁</p></li><li><p>引用对象的变量被赋予新的对象</p></li><li><p>从容器中删除对象，或对象所在的容器被销毁</p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def do_sth(param):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">a = MyClass()  # 对象赋值给变量，引用计数加1，变为1</span><br><span class="line">b = a  # 引用对象的变量赋值给另一个变量，引用计数加1，变为2</span><br><span class="line">L = [1, 2, a]  # 对象作为容器中的元素，引用计数加1，变为3</span><br><span class="line">do_sth(a)  # 对象作为函数调用时的实参，引用计数加1，变为4</span><br><span class="line"># 当函数执行后，对实参的引用会自动销毁，引用计数减1，变为3</span><br><span class="line"></span><br><span class="line">del L  # 从容器中删除对象，或对象所在的容器被销毁，引用计数减1，变为2</span><br><span class="line">del a  # 对象的引用被显式销毁，引用计数减1，变为1</span><br><span class="line">c = b  # 引用计数加1，变为2</span><br><span class="line">b = 18  # 引用对象的变量被赋予新的对象，引用计数减1，变为1</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(c))  # 输出2，这里同样，在函数的执行过程中引用计数加1，变为2</span><br><span class="line"># 当函数执行后，对实参的引用会自动销毁，因此，引用计数减1，变为1</span><br><span class="line">print(sys.getrefcount(c))  # 输出2，所以即使再调用一次引用计数也是2</span><br></pre></td></tr></table></figure><h3 id="10-特殊属性和魔术方法（续）"><a href="#10-特殊属性和魔术方法（续）" class="headerlink" title="10. 特殊属性和魔术方法（续）"></a>10. 特殊属性和魔术方法（续）</h3><ul><li><strong>特殊方法__del__()<strong>：当内存中的对象被销毁（垃圾回收）之前，会自动调用其对应的特殊方法__del__()。当对象的引用计数为0时，对象并不会立刻被销毁，</strong>何时进行垃圾回收是不确定的</strong>，因此，特殊方法__del__()何时会被调用也是不确定的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;特殊方法__del__被调用&quot;)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">del mc  # 特殊方法__del__被调用</span><br></pre></td></tr></table></figure><ul><li><strong>特殊方法__getattr__()<strong>：当访问实例对象的属性或方法时，如果指定的属性或方法不存在，就会抛出AttributeError，为了避免抛出异常，可以在实例对象对应的类对象中实现特殊方法__getattr__()，</strong>当指定的属性或方法不存在时，会自动调用特殊方法__getattr__()</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line"># print(mc.data)  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;data&#x27;</span><br><span class="line"># mc.do_sth()  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;do_sth&#x27;</span><br><span class="line"></span><br><span class="line">class SomeClass(object):</span><br><span class="line">    def __getattr__(self, name):</span><br><span class="line">        if name == &quot;data&quot;:</span><br><span class="line">            return 18</span><br><span class="line">        elif name == &quot;do_sth&quot;:</span><br><span class="line">            return print</span><br><span class="line">        raise AttributeError(&quot;&#x27;SomeClass&#x27; object has no attribute &#x27;%s&#x27;&quot; % name)</span><br><span class="line"></span><br><span class="line">sc = SomeClass()</span><br><span class="line">print(sc.data)  # 18</span><br><span class="line">sc.do_sth(1, 2, 3)  # 1 2 3</span><br><span class="line"># print(sc.score)  # AttributeError: &#x27;SomeClass&#x27; object has no attribute &#x27;score&#x27;</span><br></pre></td></tr></table></figure><ul><li><p>**特殊方法__getitem__()**：对于自定义类对象的实例对象，默认是不能像列表和字典那样使用中括号语法来操作数据的</p><ol><li><p>__getitem__(self, key)：当执行操作obj[key]时，会自动调用该特殊方法</p></li><li><p>__setitem__(self, key, value)：当执行操作obj[key] &#x3D; value时，会自动调用该特殊方法</p></li><li><p>__delitem__(self, key)：当执行操作del obj[key]时，会自动调用该特殊方法</p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyDict(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        return self.data[key]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        self.data[key] = value</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        del self.data[key]</span><br><span class="line"></span><br><span class="line">md = MyDict()</span><br><span class="line"></span><br><span class="line">md[&quot;one&quot;] = 18</span><br><span class="line">md[&quot;two&quot;] = 32</span><br><span class="line">print(md[&quot;two&quot;])  # 32</span><br><span class="line">print(md.data)  # &#123;&#x27;one&#x27;: 18, &#x27;two&#x27;: 32&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特殊方法__call__()<strong>：像调用函数一样直接调用这个类对象的实例对象，从而会自动调用类对象中的特殊方法__call__()。</strong>内置函数callable用于判断指定对象是否是可调用的</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(args, kwargs)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">mc()  # () &#123;&#125;</span><br><span class="line">mc(1, 2, x=3, y=4)  # (1, 2) &#123;&#x27;x&#x27;: 3, &#x27;y&#x27;: 4&#125;</span><br><span class="line"></span><br><span class="line">def do_sth():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(callable(MyClass()))  # True</span><br><span class="line">print(callable(do_sth))  # True</span><br><span class="line">print(callable(print))  # True</span><br></pre></td></tr></table></figure><ul><li>**特殊属性__doc__**：调用内置函数dir()得到的所有属性中包含一个特殊属性__doc__，用于表示类对象的文档字符串，与函数的文档字符串类似，位于类的第一行的字符串被称为类的文档字符串，通常用三对引号表示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    &quot;&quot;&quot;这是类对象的文档字符串&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">me = MyClass()</span><br><span class="line">print(list.__doc__)  # Built-in mutable sequence. ......</span><br><span class="line">print(MyClass.__doc__)  # 这是类对象的文档字符串</span><br><span class="line">print(me.__doc__)  # 这是类对象的文档字符串</span><br><span class="line"></span><br><span class="line"># 通过内置函数help()得到的帮助信息中也会包含类对象的文档字符串</span><br><span class="line">print(help(list))</span><br><span class="line">print(help(MyClass))</span><br></pre></td></tr></table></figure><ul><li>**特殊属性__slots__**：</li></ul><ul><li>简介：在类对象中定义特殊属性__slots__用于限制类的实例可以拥有的属性，给__slots__赋值一个所有元素都为字符串的列表或元组，这样，对实例对象动态绑定的属性和方法的名称就只能来自于__slots__中的元素<ul><li>优点：<strong>在类对象中定义特殊属性__slots__既可以防止随意添加新属性，又可以提高属性的访问速度和减少内存</strong></li></ul></li><li><strong>注意：特殊属性__slots__只对其所在类对象的实例对象起作用，对其所在类对象的子类的实例对象是不起作用的。如果子类也定义了特殊属性__slots__，那么子类的实例对象可以动态绑定的属性和方法名的限制为子类的__slots__加上父类的__slots__</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from types import MethodType</span><br><span class="line"></span><br><span class="line">class MyClass:</span><br><span class="line">    __slots__ = (&quot;name&quot;, &quot;do_sth&quot;)</span><br><span class="line"></span><br><span class="line">class MyChildClass(MyClass):</span><br><span class="line">    __slots__ = (&quot;age&quot;,)</span><br><span class="line"></span><br><span class="line">def do_sth(self):</span><br><span class="line">    print(&quot;do_sth被调用了&quot;)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">mcc = MyChildClass()</span><br><span class="line"></span><br><span class="line">mc.name = &#x27;xfblog&#x27;</span><br><span class="line">mc.do_sth = MethodType(do_sth, mc)</span><br><span class="line">mc.do_sth()  # do_sth被调用了</span><br><span class="line"># mc.age = 18  # 抛出异常：AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;age&#x27;</span><br><span class="line"></span><br><span class="line">mcc.age = 18</span><br><span class="line">mcc.name = &#x27;xf&#x27;  # 子类对象绑定属性被限制为子类的__slots__加上父类的__slots__</span><br><span class="line">mcc.do_sth = MethodType(do_sth, mcc)</span><br><span class="line">mcc.do_sth()  # do_sth被调用了</span><br></pre></td></tr></table></figure><h2 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h2><blockquote><p><strong>什么是模块：</strong>模块就是Python中的一个.py文件，定义在模块中的变量、函数和类统称为模块的属性</p><p><strong>模块的作用</strong>：解决代码重用、避免属性名冲突</p><p><strong>模块的组织和管理</strong>：</p><ol><li>为了更好的组织和管理模块，Python引入了包，在某个目录下添加模块__init__.py后，该目录就变成了包</li><li>模块__init__.py的作用是初始化其所在的包，如果不需要初始化，其内容可以为空</li><li>由于目录支持嵌套，所以包也支持嵌套，即包中还可以有子包</li></ol></blockquote><h3 id="1-使用标准库中的模块"><a href="#1-使用标准库中的模块" class="headerlink" title="1. 使用标准库中的模块"></a>1. 使用标准库中的模块</h3><ul><li><p>简介：Python官方提供了一个标准库，其中有非常多的模块，用以完成各种不同的任务</p></li><li><p>标准库路径：</p><ol><li>Mac -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.x&#x2F;lib&#x2F;python3.x</li><li>Win -&gt; &lt;Python的安装路径&gt;\Lib</li></ol></li><li><p>导入模块的语法格式：</p><ol><li><p>导入整个模块：<strong>import [包名.]模块名 [as 模块的别名]</strong></p></li><li><p>导入模块中的属性：<strong>from [包名.]模块名 import 属性名 [as 属性的别名]（可以同时导入多个属性，用逗号隔开）</strong></p></li><li><p>将模块中的属性一次性全部导入（<strong>强烈不推荐</strong>）：from [包名.]模块名 import *</p></li><li><p>导入整个模块时，如果模块在包结构中，也可以使用第二种语法格式导入：from 包名 import 模块名</p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 常用标准库模块</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line">from datetime import datetime, timedelta as td</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(sys.version)  # Python版本</span><br><span class="line">print(sys.path)  # 模块搜索路径，包含了Python解析器查找模块的搜索路径</span><br><span class="line">print(sys.modules)  # 显示当前程序中引入的所有模块</span><br><span class="line">print(sys.getdefaultencoding())  # 默认字符集</span><br><span class="line"># sys.exit(&#x27;程序退出&#x27;) # 退出解析器</span><br><span class="line"></span><br><span class="line">print(os.name)  # 操作系统的类型</span><br><span class="line">print(os.environ)  # 系统的环境变量</span><br><span class="line">print(os.listdir(&#x27;/Users/xfblog/Downloads&#x27;))  # 列出指定目录中的内容</span><br><span class="line"># os.system(&#x27;ping www.baidu.com&#x27;)  # 执行系统命令</span><br><span class="line">print(os.path.exists(&#x27;/Users/xfblog/Downloads&#x27;))  # 判断路径是否存在</span><br><span class="line"></span><br><span class="line">print(math.pi)  # 3.141592653589793</span><br><span class="line">print(math.ceil(3.4))  # 向上取整</span><br><span class="line">print(math.floor(3.4))  # 向下取整</span><br><span class="line">print(math.pow(2, 3))  # 幂运算</span><br><span class="line">print(math.trunc(2.6))  # 截尾取整</span><br><span class="line">print(round(2.6))  # 四舍五入</span><br><span class="line">print(round(math.pi, 3))  # 四舍五入，保留三位小数</span><br><span class="line"></span><br><span class="line">print(random.random())  # 返回[0,1)之间的随机浮点数</span><br><span class="line">print(random.randint(1, 101))  # 返回[1,100]之间的随机整数</span><br><span class="line">print(random.sample([1, 21, 54, 23, 6, 2], 2))  # 从列表中返回随机两个元素</span><br><span class="line"></span><br><span class="line">print(datetime.now())  # 返回当前时间</span><br><span class="line">print(datetime.strftime(datetime.now(), &#x27;%Y&#123;0&#125;%m&#123;1&#125;%d&#123;2&#125; %H:%M:%S&#x27;).format(&#x27;年&#x27;, &#x27;月&#x27;, &#x27;日&#x27;))  # # 将datetime转换为指定格式的str</span><br><span class="line">print(datetime.strptime(&#x27;2016-3-11&#x27;, &#x27;%Y-%m-%d&#x27;))  # 将str转换为datetime</span><br><span class="line">print(&#x27;明天：&#x27;, datetime.now() + td(days=1))  # timedelta表示两个时间之间的时间差，可以用来进行日间的加减操作</span><br><span class="line">print(&#x27;前一秒：&#x27;, datetime.now() - td(seconds=1))</span><br><span class="line"></span><br><span class="line">print(time.time())  # 返回当前时间的时间戳</span><br><span class="line">print(int(time.time()))  # 秒级时间戳</span><br><span class="line">print(int(time.time() * 1000))  # 毫秒时间戳</span><br><span class="line">time.sleep(2)  # 休眠2秒</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 重要的文件操作模块</span><br><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line"># 操作文件和目录</span><br><span class="line">print(os.path.exists(&#x27;itany.txt&#x27;))  # 判断文件是否存在</span><br><span class="line">print(os.path.abspath(&#x27;itany.txt&#x27;))  # 输出文件的绝对路径</span><br><span class="line">print(os.path.isfile(&#x27;itany.txt&#x27;))  # 判断是否为文件</span><br><span class="line">print(os.path.isdir(&#x27;itany.txt&#x27;))  # 判断是否为目录</span><br><span class="line">print(os.listdir(&#x27;.&#x27;))  # 列出指定目录下所有内容</span><br><span class="line">print([f for f in os.listdir(&#x27;.&#x27;) if os.path.isdir(f)])  # 找出当前目录下所有的文件夹</span><br><span class="line"></span><br><span class="line">os.mkdir(&#x27;world&#x27;)  # 创建目录</span><br><span class="line">if os.path.exists(&#x27;world&#x27;):</span><br><span class="line">    os.rmdir(&#x27;world&#x27;)  # 删除目录</span><br><span class="line"></span><br><span class="line">os.rename(&#x27;itany.txt&#x27;, &#x27;aaa.txt&#x27;)  # 重命名文件或目录</span><br><span class="line">os.remove(&#x27;aaa.txt&#x27;)  # 删除文件</span><br><span class="line">shutil.copy(&#x27;baidu.png&#x27;, &#x27;bbb.png&#x27;)  # 拷贝文件</span><br></pre></td></tr></table></figure><h3 id="2-使用第三方库中的模块"><a href="#2-使用第三方库中的模块" class="headerlink" title="2. 使用第三方库中的模块"></a>2. 使用第三方库中的模块</h3><ul><li><p>PyPI简介：<a class="link"   href="https://pypi.org"  target="_blank" rel="noopener">PyPI<i class="fas fa-external-link-alt"></i></a>全称Python Package Index，是Python官方基于web的、集中管理的第三方软件仓库，所有人都可以从PyPI上下载安装第三方库，或将自己开发的库上传发布到PyPI</p></li><li><p>pip3简介：pip3全称Package Installer for Python，通常使用工具pip3从PyPI下载安装第三方库</p><ul><li>验证是否安装：pip3 或 python3 -m pip</li><li>查看安装目录：mac -&gt; which pip3，win -&gt; where pip3</li></ul></li><li><p>使用pip3下载安装第三方库：pip3 install xxx 或 python3 -m pip install xxx</p><ul><li><p>安装路径：Mac -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">a. 查看pip3的帮助信息：pip3</span><br><span class="line">b. 列出已安装的所有第三方库：pip3 list</span><br><span class="line">c. 模糊搜索某个第三方库（及其版本号）：pip3 install xxx[==y.y]</span><br><span class="line">d. 升级指定的第三方库：pip3 install --upgrade xxx</span><br><span class="line">e. 卸载指定的第三方库（及其版本号）：pip3 uninstall xxx[==y.y]</span><br><span class="line">f. 查看pip3之后某个命令的帮助信息：pip3 &lt;命令&gt; --help</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将自己开发的库发布到PyPI或共享给别人</p><ol><li><p><strong>创建配置文件setup.py</strong>：在配置文件setup.py中调用setuptools中的函数setup，通过配置各种关键字参数，该位置文件会告诉系统如何打包自己开发的库</p></li><li><p><strong>创建其他文件</strong>：参考文档<a class="link"   href="https://setuptools.readthedocs.io/en/latest/index.html"  target="_blank" rel="noopener">setuptools的官方文档<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://packaging.python.org/tutorials/packaging-projects/"  target="_blank" rel="noopener">Python的官方文档<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/pypa/sampleproject"  target="_blank" rel="noopener">Github上的sample-project<i class="fas fa-external-link-alt"></i></a></p></li><li><p><strong>打包自己开发的库</strong>：将setup.py、其他文件和自己开发的库放到同一个目录中，在命令行中切换到该目录，执行命令python3 setup.py sdist。此时，在dist目录中会生成一个source distribution（sdist）压缩文件，该压缩文件包含了模块的源代码；还会生成一个名为&lt;package name&gt;.egg-info的文件夹</p></li><li><p><strong>将打包的库发布到PyPI或共享给别人</strong>：参考文档<a class="link"   href="https://packaging.python.org/tutorials/packaging-projects/"  target="_blank" rel="noopener">Python的官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><strong>安装别人共享的库</strong>：切换到dist目录，执行命令pip3 install &lt;dist目录中生成的压缩文件&gt;</p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    # 发布到PyPI后的package name</span><br><span class="line">    name=&#x27;my_python_lib&#x27;,</span><br><span class="line">    # 版本号</span><br><span class="line">    version=&#x27;0.1&#x27;,</span><br><span class="line">    # 描述</span><br><span class="line">    description=&#x27;My Python Lib&#x27;,</span><br><span class="line">    # 如果要发布的项目包含包，既可以手动指定要包含的包，也可以调用函数find_packages，例如：</span><br><span class="line">    # packages=find_packages()</span><br><span class="line">    # 如果要发布的项目只包含模块，那就指定py_modules这个关键字参数</span><br><span class="line">    py_modules=[&#x27;my_module&#x27;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>pyecharts是一个用于Echarts图表的类库，便于在Python中根据数据生成可视化的图表；Echarts是百度开源的一个数据可视化JS库，主要用来进行数据可视化；参考: <a class="link"   href="http://pyecharts.org/" >pyecharts官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="3-安装和配置Anaconda"><a href="#3-安装和配置Anaconda" class="headerlink" title="3. 安装和配置Anaconda"></a>3. 安装和配置Anaconda</h3><ul><li><p>简介：<a class="link"   href="https://www.anaconda.com/download"  target="_blank" rel="noopener">Anaconda<i class="fas fa-external-link-alt"></i></a>是一个基于Python的数据处理和科学计算的平台，<strong>Anaconda是跨平台的</strong>，其内置了大量的常用第三方库，安装后即可直接导入需要使用的第三方库的模块</p></li><li><p>注意：安装程序会把Anaconda安装目录下的bin目录添加到系统环境变量PATH中，因此，安装后会使用其自带的Python。从而：</p><ol><li>在命令行中输入的python3来自于：&lt;Anaconda的安装目录&gt;&#x2F;bin</li><li>使用工具pip3安装的第三方库会被安装到：&lt;Anaconda的安装目录&gt;&#x2F;lib&#x2F;python3.x&#x2F;site-packages</li></ol></li><li><p>Anaconda的第三方管理工具为conda，类似于工具pip3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">a. 查看conda的帮助信息：conda</span><br><span class="line">b. 列出已安装的所有第三方库：conda list</span><br><span class="line">c. 模糊搜索某个第三方库：conda search xxx</span><br><span class="line">d. 安装指定的第三方库（及其版本号）：conda install xxx[=y.y]</span><br><span class="line">e. 升级指定的第三方库：conda update xxx</span><br><span class="line">f. 卸载指定的第三方库（及其版本号）：conda remove xxx[=y.y]</span><br><span class="line">g. 查看conda之后某个命令的帮助信息：conda &lt;命令&gt; --help</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-模块的使用规范"><a href="#4-模块的使用规范" class="headerlink" title="4. 模块的使用规范"></a>4. 模块的使用规范</h3><ul><li>使用当前项目中的模块<ol><li>直接导入：直接导入当前目录的模块名</li><li>绝对导入：导入模块名的绝对路径</li><li>相对导入：导入模块名的相对路径。其中一个.表示当前目录，两个.表示当前目录的父目录</li><li><strong>重点：当直接运行某个模块时，该模块就变成了主模块，主模块位于最顶层，与同目录下的其他模块无法构成相对关系。因此，当直接运行某个模块时，该模块不能使用相对导入</strong></li></ol></li><li>导入的不同模块中存在相同的属性<ul><li>当导入的模块中存在相同的属性时，如果直接导入属性，则后面的属性会把前面导入的属性覆盖掉</li><li>正确的导入方式：1. 给导入的属性起一个别名。2. 导入整个模块，使用时带前缀可以区分</li></ul></li></ul><h3 id="5-import语句的执行流程"><a href="#5-import语句的执行流程" class="headerlink" title="5. import语句的执行流程"></a>5. import语句的执行流程</h3><blockquote><p>当使用import语句导入模块时，解释器会根据sys模块的modules属性值来查找模块是否已经被导入了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pprint, sys</span><br><span class="line">pprint.pprint(sys.modules)</span><br></pre></td></tr></table></figure><p>如果模块没有被导入，则执行流程：</p><ol><li>解释器按照模块sys的变量path中的路径搜索模块</li><li>将搜索到的模块编译为pyc字节码文件（可选）</li><li>执行编译生成的字节码文件从而运行模块</li></ol></blockquote><ol><li><strong>解释器搜索模块的路径存放在模块sys的变量path中</strong></li></ol><ul><li><p>搜索路径主要由<strong>当前目录</strong>、<strong>标准库的目录</strong>、<strong>第三方库的安装目录</strong>三部分组成</p></li><li><p>修改解释器搜索模块路径的方式：1. 直接修改sys.path列表（<strong>代码运行后失效</strong>）2. 设置环境变量PYTHONPATH，环境变量对应的路径会被自动添加到sys.path中（<strong>代码运行后仍然有效</strong>）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import sys, pprint</span><br><span class="line"></span><br><span class="line">pprint.pprint(sys.path)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[&#x27;/Users/xfblog/Documents/pythonProject（当前目录）&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python310.zip&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages&#x27;]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 直接修改sys.path列表</span><br><span class="line">sys.path.insert(0, &#x27;/Users/xfblog/Downloads&#x27;)</span><br><span class="line"># mymodule.py文件存在于&#x27;/Users/xfblog/Downloads&#x27;下，</span><br><span class="line"># 如果不修改sys.path搜索路径，那么运行时就会因为搜索不到此模块而抛出异常，</span><br><span class="line"># 加上其搜索路径后，pycharm检查代码也会有红线，但能搜索到模块并正常运行</span><br><span class="line">import mymodule</span><br><span class="line"></span><br><span class="line">mymodule.do_sth()  # do_sth被调用了</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>搜索到的模块被编译为pyc字节码文件</strong></p><ul><li>解释：当搜索到的模块被第一次导入时，会被编译为pyc字节码文件，即表示被缓存起来了；当再次加载该模块时，如果该模块没有发生变化，就不会再次编译，而是直接读取缓存中的pyc字节码文件，从而提高加载速度</li></ul></li><li><p><strong>执行编译生成的字节码文件从而运行模块</strong></p><ul><li><strong>导入包中的模块时，会先导入包中的__init__.py</strong>。因此，在运行被导入的模块之前，会从最顶层的父包开始，依次运行所有父包中的__init__.py</li><li>使用import语句导入某个模块后，如果对模块做了修改，然后再次使用import语句导入该模块，那么对模块的修改将不会起任何作用。<strong>可以调用标准库importlib中标准函数reload重新加载已经被导入的模块</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">importlib.reload(mod)</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-dir查看模块的所有属性"><a href="#6-dir查看模块的所有属性" class="headerlink" title="6. dir查看模块的所有属性"></a>6. dir查看模块的所有属性</h3><ol><li><p><strong>调用内置函数dir将模块作为实参</strong>：模块作为参数会返回指定模块的所有属性，其中带双下划线__的为模块的特殊属性</p></li><li><p><strong>调用内置函数dir时不带任何参数</strong>：不带任何参数时，会返回当前模块的<strong>局部作用域</strong>中的所有属性</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">print(dir(requests))</span><br><span class="line"># [&#x27;ConnectTimeout&#x27;, &#x27;ConnectionError&#x27;, ......, &#x27;warnings&#x27;]</span><br><span class="line"></span><br><span class="line">print(dir())</span><br><span class="line"># [&#x27;__annotations__&#x27;, ......, &#x27;__spec__&#x27;]</span><br><span class="line">age = 18</span><br><span class="line"></span><br><span class="line">def fun():</span><br><span class="line">    print(&#x27;fun被调用&#x27;)</span><br><span class="line"></span><br><span class="line">class SomeClass(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(dir())</span><br><span class="line"># [&#x27;SomeClass&#x27;, &#x27;__annotations__&#x27;, ......, &#x27;__spec__&#x27;, &#x27;fun&#x27;, &#x27;age&#x27;]</span><br><span class="line">del age</span><br><span class="line">print(dir())</span><br><span class="line"># [&#x27;SomeClass&#x27;, &#x27;__annotations__&#x27;, ....., &#x27;__spec__&#x27;, &#x27;fun&#x27;]</span><br></pre></td></tr></table></figure><h3 id="7-模块的特殊属性"><a href="#7-模块的特殊属性" class="headerlink" title="7. 模块的特殊属性"></a>7. 模块的特殊属性</h3><ul><li><strong>特殊属性__doc__<strong>：模块的特殊属性__doc__，用于表示模块的文档字符串，与函数的文档字符串类似，位于模块的第一行的字符串被称为</strong>模块的文档字符串</strong>，通常用三对引号表示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;本模块的文档字符串，功能对模块功能的简要描述&quot;&quot;&quot;</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">print(__doc__)  # 本模块的文档字符串，功能对模块功能的简要描述</span><br><span class="line">print(base64.__doc__)  # Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings</span><br><span class="line"># 通过内置函数help()得到的帮助信息中也包含模块的文档字符串</span><br><span class="line">print(help(base64))</span><br></pre></td></tr></table></figure><ul><li><strong>特殊属性__name__<strong>：模块的特殊属性__name__，</strong>常用其值判断是否执行模块中的测试代码</strong></li></ul><ol><li><p><strong>对于被导入的模块，其特殊属性__name__的值为模块名</strong></p></li><li><p><strong>对于直接运行的模块，其特殊属性__name__的值为__main__</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;本模块的特殊属性__name__的值为：&#x27;, __name__)  # 本模块的特殊属性__name__的值为：__main__</span><br><span class="line"></span><br><span class="line">def add_num(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line"># 根据__name__的值判断是否执行模块中的测试代码</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;1 + 2 =&#x27;, add_num(1, 2))  # 1 + 2 = 3</span><br><span class="line">    print(&#x27;3 + 5 =&#x27;, add_num(3, 5))  # 3 + 5 = 8</span><br></pre></td></tr></table></figure><h3 id="8-模块的数据访问控制"><a href="#8-模块的数据访问控制" class="headerlink" title="8. 模块的数据访问控制"></a>8. 模块的数据访问控制</h3><ul><li><strong>在模块内的某些属性前添加单下划线_</strong><ul><li>简介：属性前添加单下划线后，就无法使用语句**”from 模块名 import *“<strong>导入相应的属性了，但是使用</strong>“import 模块名”或”form 模块名 import xxx”**仍然可以</li></ul></li><li><strong>模块内的数据访问控制之特殊属性__all__</strong><ul><li>简介：使用属性__all__限制访问，使用语句**”from 模块名 import *“<strong>就只能导入特殊属性__all__中定义的属性，但是使用</strong>“import 模块名”或”form 模块名 import xxx”**仍然可以</li><li>注意：<strong>若对某个属性既使用了单下划线_，又定义在了特殊属性__all__中，那么__all__比单下划线_优先级更高</strong></li></ul></li></ul><h3 id="9-动态加载模块"><a href="#9-动态加载模块" class="headerlink" title="9. 动态加载模块"></a>9. 动态加载模块</h3><ul><li>简介：通过字符串形式指定模块名，从而实现动态加载模块，又称为<strong>热加载</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line"># __import__(&quot;property&quot;)  # 解释器用的</span><br><span class="line"></span><br><span class="line">importlib.import_module(&quot;property&quot;)  # import_module函数允许通过字符串形式指定模块名</span><br><span class="line">importlib.import_module(&quot;dao.fib&quot;)  # 加载位于包dao下的fib模块</span><br></pre></td></tr></table></figure><h2 id="五、生成器与迭代器"><a href="#五、生成器与迭代器" class="headerlink" title="五、生成器与迭代器"></a>五、生成器与迭代器</h2><blockquote><p>关于<strong>元组生成式</strong>：</p><p>在前面《Python_1_基础语法》的 <a class="link"   href="https://xfblog.cn/2023/04/01/Python_1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#%E5%8D%81%E4%BA%8C%E3%80%81%E7%94%9F%E6%88%90%E5%BC%8F"  target="_blank" rel="noopener">十二、生成式<i class="fas fa-external-link-alt"></i></a> 中为元组生成式留下不足，是为了在此更好的引出<strong>生成器</strong></p><ol><li>根本就<strong>不存在元组生成式</strong>，元组是不可变类型的对象，所以无法在代码中<strong>动态地创建元组对象</strong></li><li>将列表生成式的中括号“[]”改成小括号“()”，程序并不会报错，因为得到的是<strong>生成器对象！！！</strong></li></ol></blockquote><h3 id="1-生成器"><a href="#1-生成器" class="headerlink" title="1. 生成器"></a>1. 生成器</h3><ul><li><strong>生成器（generator）对象：生成器中保存的并不是其对应的所有元素，而是如何推算出所有元素的算法</strong></li><li><strong>原理：惰性推算</strong>，它可以在需要时逐个生成值，而不必一次性加载整个数据集到内存中，这对于处理大型数据集或无限序列等情况非常有用，因为它能够有效地利用内存，并且可以提供高效的迭代操作</li><li><strong>获取生成器内的元素</strong>：<ol><li>**调用内置函数next()**：每次调用都返回生成器的下一个元素，直到抛出异常StopIteration时表示没有更多元素了</li><li><strong>使用for-in语句对生成器进行迭代</strong>：不需要关心StopIteration异常，因为<strong>for-in语句会自动处理StopIteration异常</strong></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ge = (i for i in range(1, 7))</span><br><span class="line">print(ge)  # `&lt;generator object &lt;genexpr&gt; at 0x10127c120&gt;`</span><br><span class="line"></span><br><span class="line">print(next(ge))  # 1</span><br><span class="line">print(next(ge))  # 2</span><br><span class="line">print(next(ge))  # 3</span><br><span class="line">print(next(ge))  # 4</span><br><span class="line">print(next(ge))  # 5</span><br><span class="line">print(next(ge))  # 6</span><br><span class="line"># print(next(ge))  # StopIteration</span><br><span class="line"></span><br><span class="line">ge = (i * i for i in range(1, 7))</span><br><span class="line">for item in ge:</span><br><span class="line">    print(item)  # 1 4 9 16 25 36</span><br></pre></td></tr></table></figure><ul><li><strong>生成器函数</strong>：<strong>当推算的算法比较复杂时，可以使用生成器函数得到生成器</strong>。生成器函数中通过<strong>关键字yield</strong>返回推算出的元素，当进行迭代时，<strong>每执行完yield语句后会将函数挂起</strong>，下次会从挂起的地方继续执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 斐波那契数列</span><br><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    for _ in range(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        yield a</span><br><span class="line"></span><br><span class="line">gf = fib(6)</span><br><span class="line">print(gf)  # `&lt;generator object fib at 0x100d3dd90&gt;`</span><br><span class="line"></span><br><span class="line">for item in gf:</span><br><span class="line">    print(item)  # 1 1 2 3 5 8</span><br></pre></td></tr></table></figure><h3 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2. 迭代器"></a>2. 迭代器</h3><ul><li><strong>可迭代对象</strong>：可以用于for-in语句的对象被称为<strong>可迭代对象</strong>，例如：range、list、str、dict、set、<strong>生成器</strong>都是可迭代对象</li><li><strong>迭代器对象</strong>：如果一个<strong>可迭代对象</strong>可以作为内置函数next()的实参从而<strong>支持惰性运算</strong>，那么该对象被称为<strong>迭代器对象</strong></li></ul><blockquote><p><strong>调用内置函数isinstance()可以判断一个对象是否是可迭代对象或者迭代器对象，</strong></p><p>其中标准库模块collections中的<strong>类Iterable用于表示可迭代对象，类Iterator用于表示迭代器对象</strong></p></blockquote><ul><li><strong>生成器的特殊性</strong>：<strong>生成器是一种特殊的迭代器对象</strong>，因为生成器本身就支持<strong>惰性运算</strong>，而对于range、list、str、dict、set等可迭代对象都不支持，<strong>对于可迭代对象，可以调用内置函数iter()把不支持惰性运算的可迭代对象转换为迭代器对象</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable, Iterator</span><br><span class="line"></span><br><span class="line"># 判断可迭代对象</span><br><span class="line">print(isinstance([1, 2, 3], Iterable))  # True</span><br><span class="line">print(isinstance(&#x27;abc&#x27;, Iterable))  # True</span><br><span class="line">print(isinstance((i * i for i in range(1, 7)), Iterable))  # True</span><br><span class="line"># 判断迭代器对象</span><br><span class="line">print(isinstance([1, 2, 3], Iterator))  # False</span><br><span class="line">print(isinstance(&#x27;abc&#x27;, Iterator))  # False</span><br><span class="line">print(isinstance((i * i for i in range(1, 7)), Iterator))  # True</span><br><span class="line"># 调用内置函数iter()把不支持惰性推算的可迭代对象转换为迭代器对象</span><br><span class="line">iter_L = iter([1, 2, 3])</span><br><span class="line">iter_s = iter(&#x27;abc&#x27;)</span><br><span class="line">print(isinstance(iter_L, Iterator))  # True</span><br><span class="line">print(isinstance(iter_s, Iterator))  # True</span><br><span class="line">print(next(iter_L))  # 1</span><br><span class="line">print(next(iter_s))  # a</span><br></pre></td></tr></table></figure><ul><li><strong>自定义迭代器对象</strong>：如果一个类对象同时实现了特殊方法<strong>__iter__()<strong>和</strong>__next__()<strong>，那么该对象就被称为</strong>迭代器对象</strong><ul><li><strong>执行过程</strong>：如果将该对象用于for- in语句，for-in语句首先会调用特殊方法__iter__()返回一个可迭代对象，然后不断调用该可迭代对象的特殊方法__next__()返回下一次迭代的值，直到遇到StopIteration时退出循环</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 斐波那契数列</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        if self.a &gt; 50:</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a</span><br><span class="line"></span><br><span class="line">for item in Fib():</span><br><span class="line">    print(item)  # 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure><h2 id="六、异常处理"><a href="#六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h2><blockquote><p><strong>什么是异常？</strong></p><p>异常指的是程序在没有语法错误的前提下，在运行期间产生的特定错误，每个特定错误都对应一个异常类对象。当产生某个特定错误时，其对应的异常类对象的实例对象就会被抛出。</p><ul><li>对于在程序中抛出的异常实例对象，如果不进行捕获和处理，程序就会停止运行，所以要进行捕获和处理</li><li>对于异常中的Traceback，指的是异常调用堆栈的跟踪信息，其中列出了程序中的相关行数</li><li>对于每个异常类对象所表示的特定错误，参考<a class="link"   href="https://docs.python.org/3/library/exceptions.html"  target="_blank" rel="noopener">Python官方文档<i class="fas fa-external-link-alt"></i></a></li><li><strong>重点：所有异常类对象（内置异常类对象和自定义异常类对象）的基类都是Exception！</strong></li></ul></blockquote><h3 id="1-捕获和处理异常"><a href="#1-捕获和处理异常" class="headerlink" title="1. 捕获和处理异常"></a>1. 捕获和处理异常</h3><ul><li><strong>注意4点</strong>：<ol><li>如果抛出的异常实例对象所对应的类对象是except字句中异常类对象的<strong>子类</strong>，那么该except子句也会被匹配</li><li>当try语句块中产生异常时，会<strong>从上到下依次查找</strong>是否有匹配的except子句，只要有一个匹配上，则不会再往下匹配</li><li>当多个异常类对象对应的异常处理代码完全相同时，可以把这些异常类对象以<strong>元组</strong>的形式放在一个except子句中</li><li>如果想在匹配到的except子句中访问异常实例对象，可以在except子句结束位置<strong>添加关键字as和一个变量</strong></li></ol></li><li><strong>重点：为了在except语句块中能将所有的异常类对象尽可能地覆盖到，可以将最后一个except子句中的异常类对象指定为Exception（或不指定异常类对象也默认为Exception）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">try:</span><br><span class="line">    可能会产生异常的代码</span><br><span class="line">except 异常类对象1:</span><br><span class="line">    当前except字句处理异常的代码</span><br><span class="line">except 异常类对象2:</span><br><span class="line">    当前except字句处理异常的代码</span><br><span class="line">    ......</span><br><span class="line">except 异常类对象n:</span><br><span class="line">    当前except字句处理异常的代码</span><br><span class="line">else:</span><br><span class="line">    try语句块中没有产生异常时执行的代码（有时需要对try语句中部分代码需要进行单独异常捕获，其余代码则需写else）</span><br><span class="line">    # 类似while语句或for-in语句后面添加的else从句，没有执行循环体中的break语句，则会执行else从句</span><br><span class="line">finally:</span><br><span class="line">    总会执行的代码</span><br><span class="line">    # 通常在finally从句中释放资源，例如：关闭文件、关闭网络连接等</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">try:</span><br><span class="line">    result = 1 / 0  # 对应前两个except子句</span><br><span class="line">    # result = int(&#x27;abc&#x27;)  # 对应第三个except子句</span><br><span class="line">    # result = 1 / 2  # 无异常，执行else从句</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    print(&quot;0不能作为除数&quot;)</span><br><span class="line">except ArithmeticError:</span><br><span class="line">    print(&quot;数学错误&quot;)</span><br><span class="line">except (TypeError, ValueError) as err:</span><br><span class="line">    print(type(err))  # `&lt;class &#x27;ValueError&#x27;&gt;`</span><br><span class="line">    # 类对象ValueError实现了特殊方法__str__()</span><br><span class="line">    print(err)  # invalid literal for int() with base 10: &#x27;abc&#x27;</span><br><span class="line">except Exception:</span><br><span class="line">    print(&quot;其他错误&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无异常打印结果：&quot;, result)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;释放资源&quot;)</span><br><span class="line"></span><br><span class="line"># 实现输入一个正确的整数，不正确则重新输入</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        x = int(input(&#x27;请输入一个整数：&#x27;))</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&#x27;无效的输入，请再次输入&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;输入的整数为：&#x27;, x)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><h3 id="2-使用raise语句手动抛出异常"><a href="#2-使用raise语句手动抛出异常" class="headerlink" title="2. 使用raise语句手动抛出异常"></a>2. 使用raise语句手动抛出异常</h3><ul><li>语法：**raise 异常类对象([参数])**，不传入参数时小括号可以省略</li><li>注意：如果在except语句块中不想对异常实例对象进行处理，可以使用关键字raise将其原样抛出，也可以使用raise语句手动抛出另外一个异常类对象的实例对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise ZeroDivisionError(&#x27;0不能作为除数哦&#x27;)  # 模拟异常语句直接抛出异常</span><br><span class="line">except ZeroDivisionError as err:</span><br><span class="line">    print(err)  # 0不能作为除数哦</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    try:</span><br><span class="line">        raise  # 使用关键字raise将异常实例对象原样抛出</span><br><span class="line">    except ZeroDivisionError as ee:</span><br><span class="line">        # raise ValueError(&#x27;输入错误&#x27;)  # 使用raise语句手动抛出另外一个异常类对象的实例对象</span><br><span class="line">        print(ee)  # division by zero</span><br></pre></td></tr></table></figure><h3 id="3-自定义异常"><a href="#3-自定义异常" class="headerlink" title="3. 自定义异常"></a>3. 自定义异常</h3><ul><li>简介：自定义异常类对象只需要如同所有内置异常类对象一样，继承Exception或其子类即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyException(BaseException):  # BaseException是所有异常的基类</span><br><span class="line">    def __init__(self, msg):</span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    # def __str__(self):  # __str__方法定义不定义都可以</span><br><span class="line">    #     return self.msg</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    raise MyException(&#x27;我的错误&#x27;)</span><br><span class="line"># except Exception as err:  # 继承自BaseException类的自定义异常类，Exception捕捉不到</span><br><span class="line">#     print(err)</span><br><span class="line">except MyException as e:</span><br><span class="line">    print(e)  # 我的错误</span><br></pre></td></tr></table></figure><h3 id="4-异常实例err"><a href="#4-异常实例err" class="headerlink" title="4. 异常实例err"></a>4. 异常实例err</h3><ul><li>简介：err对象是except语句中捕捉异常的实例，类型是<strong>元组</strong></li><li><strong>应用：args是Python内置异常类的一个属性，用于保存异常对象的参数，是一个元组</strong><ol><li>当一个异常被抛出时，可以向异常对象传递一些参数，这些参数将作为异常对象的属性来使用</li><li>可以通过使用except语句捕获异常，并使用异常对象的args属性来提取异常参数</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyException(Exception):</span><br><span class="line">    def __init__(self, a, b):</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">    # def __str__(self):</span><br><span class="line">    #     return &quot;都是%s和%s的错&quot; % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    raise MyException(&#x27;jack&#x27;, &#x27;alice&#x27;)</span><br><span class="line">except MyException as err:</span><br><span class="line">    print(err)  # (&#x27;jack&#x27;, &#x27;alice&#x27;)</span><br><span class="line">    print(err.args)  # (&#x27;jack&#x27;, &#x27;alice&#x27;)</span><br><span class="line">    # 1、Python会尝试将整个err元组作为一个参数进行格式化，而不是按照元组的元素进行格式化，从而抛出异常</span><br><span class="line">    # print(&quot;都是%s和%s的错&quot; % err)  # 抛出异常</span><br><span class="line">    # 2、类 &#x27;MyException&#x27; 未定义 &#x27;__getitem__&#x27;，所以不能对其实例使用 &#x27;[]&#x27; 运算符</span><br><span class="line">    # print(&quot;都是%s和%s的错&quot; % (err[0], err[1]))  # 抛出异常</span><br><span class="line">    print(&quot;都是%s和%s的错&quot; % (err.args[0], err.args[1]))  # 都是jack和alice的错</span><br></pre></td></tr></table></figure><h3 id="5-异常和函数"><a href="#5-异常和函数" class="headerlink" title="5. 异常和函数"></a>5. 异常和函数</h3><ul><li>简介：当函数内发生异常时，异常实例对象会被抛给该函数的调用者，如果该函数的调用者没有进行捕获和处理，则继续抛给上一层的调用者，这样一直向上抛，最后会被Python解释器捕获。<strong>在异常实例对象被向上抛的过程中，不需要在每一层都进行捕获和处理，选择合适的层对进行捕获和处理即可</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def f1():</span><br><span class="line">    print(1 / 0)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line">def f3():</span><br><span class="line">    try:</span><br><span class="line">        f2()</span><br><span class="line">    except ZeroDivisionError as err:</span><br><span class="line">        print(err)</span><br><span class="line"></span><br><span class="line">f3()  # division by zero</span><br><span class="line">&quot;&quot;&quot;抛出异常情况</span><br><span class="line">def f1():             # Traceback (most recent call last):</span><br><span class="line">    print(1 / 0)      #    File &quot;/Users/xfblog/Desktop&quot;, line 11, in &lt;module&gt;</span><br><span class="line">                      #        f3()</span><br><span class="line">def f2():             #    File &quot;/Users/xfblog/Desktop&quot;, line 9, in f3</span><br><span class="line">    f1()              #        f2()</span><br><span class="line">                      #    File &quot;/Users/xfblog/Desktop&quot;, line 6, in f2</span><br><span class="line">def f3():             #        f1()</span><br><span class="line">    f2()              #    File &quot;/Users/xfblog/Desktop&quot;, line 3, in f1</span><br><span class="line">                      #        print(1 / 0)</span><br><span class="line">f3()                  # ZeroDivisionError: division by zero</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="6-获取异常信息"><a href="#6-获取异常信息" class="headerlink" title="6. 获取异常信息"></a>6. 获取异常信息</h3><ul><li><p>简介：在捕获异常实例对象后，可以<strong>调用标准库模块sys中的函数exc_info以获取异常的相关信息</strong>，其返回值为一个<strong>元组</strong>，其中包含三个元素分别为<strong>异常的类型、异常的错误信息、Traceback对象（包含异常调用堆栈的跟踪信息）</strong></p></li><li><p>扩展：<strong>进一步从Traceback对象中提取出堆栈帧信息， 可以调用标准库模块traceback中的函数extract_tb()</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">def f1():</span><br><span class="line">    print(1 / 0)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    try:</span><br><span class="line">        f1()</span><br><span class="line">    except ZeroDivisionError:</span><br><span class="line">        ex_type, ex_value, ex_traceback = sys.exc_info()</span><br><span class="line"></span><br><span class="line">        print(ex_type)  # 异常的类型：`&lt;class &#x27;ZeroDivisionError&#x27;&gt;`</span><br><span class="line">        print(ex_value)  # 异常的错误信息：division by zero</span><br><span class="line">        print(ex_traceback)  # 异常调用堆栈的跟踪信息：`&lt;traceback object at 0x1026dca00&gt;`</span><br><span class="line"></span><br><span class="line">        tb = traceback.extract_tb(ex_traceback)  # 进一步从Traceback对象中提取出堆栈帧信息</span><br><span class="line">        print(tb)  # 堆栈帧信息表示代码的执行路径，即函数调用的层次关系和对应的代码位置</span><br><span class="line"></span><br><span class="line">        # tb是一个列表，其中每个元素是一个FrameSummary对象，代表一个堆栈帧的信息，并包含以下4种信息</span><br><span class="line">        for file, line, funcname, source in tb:</span><br><span class="line">            print(&#x27;异常代码的文件路径：%s&#x27; % file)</span><br><span class="line">            print(&#x27;调用堆栈的行号：%s&#x27; % line)</span><br><span class="line">            print(&#x27;函数或方法的名称：%s&#x27; % funcname)</span><br><span class="line">            print(&#x27;源码：%s&#x27; % source)</span><br><span class="line">        &quot;&quot;&quot;循环打印出两个FrameSummary对象中包含的信息</span><br><span class="line">        实际上，输出中的堆栈帧信息是从异常发生的地方开始，逐级追溯调用链，直到最顶层</span><br><span class="line">        所以，第一个堆栈帧对应的是f2函数，第二个堆栈帧对应的是f1函数</span><br><span class="line">        由于堆栈帧信息是从下往上追溯的，所以第一个堆栈帧的行号9表示的是f2函数内部调用f1函数的位置</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure><h3 id="7-assert断言"><a href="#7-assert断言" class="headerlink" title="7. assert断言"></a>7. assert断言</h3><ul><li>简介：<strong>assert断言用于判断代码是否符合执行预期</strong>。在一个还没完善的程序中，不知道哪里会出错的情况下，与其让程序在运行时崩溃，不如在出现错误条件时就立即崩溃，此时则需要使用到assert断言</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 若代码符合执行预期则无返回值，否则直接抛出异常AssertionError</span><br><span class="line">assert type(1) is int</span><br><span class="line">assert len([&#x27;my boy&#x27;, 12]) &lt; 3</span><br><span class="line">assert list(range(4)) == [0, 1, 2, 3]</span><br><span class="line"># assert 1 + 1 == 3  # 抛出异常AssertionError</span><br><span class="line"></span><br><span class="line"># 应用场景举例，别人调用你的接口，接口要求调用时必须传递指定的关键参数，</span><br><span class="line"># 当接受时，就可以使用assert语句判断传入的参数是否符合你的预期</span><br><span class="line">def my_interfance(name, age, score):</span><br><span class="line">    assert type(name) is str</span><br><span class="line">    assert type(age) is int</span><br><span class="line">    assert type(score) is float</span><br><span class="line"></span><br><span class="line">my_interfance(&quot;jack&quot;, 22, 99.5)</span><br><span class="line">my_interfance(&quot;jack&quot;, 22, 99)  # AssertionError</span><br></pre></td></tr></table></figure><ul><li>知识点：<strong>可以为assert断言语句添加异常参数，</strong>即在断言表达式后添加字符串信息，用来解释断言异常的原因</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 简单案例：</span><br><span class="line">s = input(&#x27;请输入 --&gt; &#x27;)</span><br><span class="line">assert len(s) &gt;= 3, &quot;输入的长度不能小于3&quot;  # AssertionError: 输入的长度不能小于3</span><br><span class="line"></span><br><span class="line"># 复杂案例：</span><br><span class="line">class ShortInputException(Exception):</span><br><span class="line">    def __init__(self, length, atleast):</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        s = input(&#x27;请输入 --&gt; &#x27;)</span><br><span class="line">        assert len(s) &gt;= 3, ShortInputException(len(s), 3)</span><br><span class="line">    except AssertionError as err:</span><br><span class="line">        # 这里不是直接捕捉ShortInputException，而是将其作为assert的异常参数，</span><br><span class="line">        # 所以捕捉到的异常对象的属性应该是一个整体，作为err.args这个元组的一个参数</span><br><span class="line">        detail = err.args[0]</span><br><span class="line">        print(&#x27;ShortInputException: 输入的长度是 %d,长度至少应是 %d&#x27; % (detail.length, detail.atleast))</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;没有异常发生.&#x27;)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="8-with语句"><a href="#8-with语句" class="headerlink" title="8. with语句"></a>8. with语句</h3><ul><li><p><strong>上下文管理器</strong>：如果一个类实现了特殊方法<strong>__enter__()和__exit__()<strong>，就称这个类对象遵守了</strong>上下文管理协议</strong>，并称这个类对象的实例对象为<strong>上下文管理器</strong></p></li><li><p>with语句简介：</p><ol><li>with语句会让上下文管理器创建一个<strong>运行时上下文</strong></li><li>当进入<strong>运行时上下文</strong>时自动调用特殊方法__enter__()</li><li>当离开<strong>运行时上下文</strong>时自动调用特殊方法__exit__()</li></ol></li><li><p>with语句知识点：</p><ol><li><strong>特殊方法__exit__()总会被调用</strong>，与finally相似，所以通常在特殊方法__exit__()中释放资源</li><li>当with语句体中产生了异常，那么<strong>sys.exc_info()的返回值中三个元素会被自动传递给特殊方法__exit__()的形参exc_type、exc_val和exc_tb</strong></li></ol></li><li><p>with语句<strong>执行流程</strong>（中括号[]内容表示可选）：</p><ol><li><p>计算上下文表达式，返回一个上下文管理器，并创建一个运行时上下文</p></li><li><p>进入运行时上下文，自动调用上下文管理器的特殊方法__enter__()</p></li><li><p>[将特殊方法__enter__()的返回值赋值给变量，如果提供的话]</p></li><li><p>执行with语句体[，对变量进行操作]</p></li><li><p>判断with语句体是否产生异常，抛出异常则终止执行with语句体，未抛出异常则继续执行</p></li><li><p>无论是否抛出异常，都离开运行时上下文，自动调用上下文管理器的特殊方法__exit__()</p></li><li><p><strong>在__exit__()方法中，再次判断是否抛出异常，如果异常对象为None，则认为没有异常，返回值为True；如果有异常，则可以处理异常并返回一个布尔值，表示是否需要继续传播异常</strong></p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class FileManager:</span><br><span class="line">    def __init__(self, filename, mode):</span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.file = None</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&#x27;特殊方法__enter__()被调用&#x27;)</span><br><span class="line">        self.file = open(self.filename, self.mode)</span><br><span class="line">        return self.file</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_value, traceback):</span><br><span class="line">        print(&#x27;特殊方法__exit__()被调用&#x27;)</span><br><span class="line">        if exc_type is not None:  # 判断异常对象是否为None</span><br><span class="line">            # 发生异常时的处理</span><br><span class="line">            print(f&quot;异常的错误信息: &#123;exc_value&#125;&quot;)</span><br><span class="line">            print(f&quot;异常调用堆栈的跟踪信息: &#123;traceback&#125;&quot;)</span><br><span class="line">        self.file.close()</span><br><span class="line">        return True</span><br><span class="line">        # __exit__()方法的返回值为True时，将抑制异常的传播，而返回False或None时，将继续传播异常</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def do_sth():</span><br><span class="line">        print(&#x27;方法do_sth()被调用&#x27;)</span><br><span class="line">        print(1 / 0)</span><br><span class="line"></span><br><span class="line"># 此时with语句体中产生异常，若__exit__()方法返回True则正常执行，否则直接抛出异常</span><br><span class="line">with FileManager(&#x27;myfile.txt&#x27;, &#x27;w+&#x27;) as fm:</span><br><span class="line">    &quot;&quot;&quot;fm.do_sth()</span><br><span class="line">    注意：此处fm并不是类FileManager的实例，而是一个文件对象，</span><br><span class="line">    由于文件对象并没有do_sth这个方法，因此调用do_sth方法会导致错误</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    FileManager.do_sth()</span><br><span class="line">&quot;&quot;&quot;输出顺序与执行流程一致：</span><br><span class="line">特殊方法__enter__()被调用</span><br><span class="line">方法do_sth()被调用</span><br><span class="line">特殊方法__exit__()被调用</span><br><span class="line">异常的错误信息: division by zero</span><br><span class="line">异常调用堆栈的跟踪信息: &lt;traceback object at 0x102dd8580&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 当with语句体中产生异常，并且特殊方法__exit__()没有返回True时，</span><br><span class="line"># 为了让程序能够继续执行，可以使用try-except语句对抛出的异常实例对象进行捕获和处理</span><br><span class="line"># try:</span><br><span class="line">#     with FileManager(&#x27;myfile.txt&#x27;, &#x27;w+&#x27;) as fm:</span><br><span class="line">#         FileManager.do_sth()</span><br><span class="line"># except ZeroDivisionError as err:</span><br><span class="line">#     print(err)</span><br><span class="line"># 此时输出内容比上面多一行print(err)的内容：division by zero</span><br></pre></td></tr></table></figure><h2 id="七、文件读写"><a href="#七、文件读写" class="headerlink" title="七、文件读写"></a>七、文件读写</h2><blockquote><p><strong>文件读写：文件读写是一种常见的IO操作，把数据存储到文件中是数据存储的方式之一。</strong>由于操作I&#x2F;O的能力是由操作系统提供的，且现代操作系统不允许普通程序直接操作磁盘，所以读写文件时需要请求操作系统打开一个对象（通常被称为文件描述符， 简称fd），即为<strong>文件对象</strong></p><p><strong>文件对象</strong>：文件对象是迭代器对象，可以调用next()方法逐行读取文件内容。当达到文件的末尾时，将引发StopIteration异常，所以通常会使用for循环来迭代文件对象，它会自动处理StopIteration异常</p><p><strong>文件打开模式：</strong></p><ul><li>‘r’：以只读方式打开，只能读文件。不存在则抛出异常（<strong>默认打开模式</strong>）</li><li>‘w’：以只写方式打开，只能写文件。存在则清空文件，不存在则创建文件</li><li>‘a’：以追加方式打开，只能写文件。存在则从文件末尾开始写，不存在则创建文件</li><li>‘x’：以只写方式打开，只能写文件。存在则抛出异常，不存在则创建文件（独占创建）</li><li>‘+’：以读写方式打开，可以读写文件。不能单独使用，只能添加到其他方式的后面：’r+’、’w+’、’a+’、’x+’</li><li>‘t’：以文本方式打开（<strong>默认文本格式</strong>）通常省略，’rt’等价于’r’。不能单独使用，只能添加到其他方式的后面</li><li>‘b’：以二进制方式打开。例如：打开图片、视频等，不能单独使用，只能添加到其他方式的后面</li></ul></blockquote><h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1. 打开文件"></a>1. 打开文件</h3><ul><li>简介：<strong>内置函数open()用于打开文件，其返回值是一个文件对象，通过该对象即可操作文件</strong><ul><li><strong>参数1是文件的路径</strong>，必须指定，既可以指定绝对路径，也可以指定相对路径</li><li><strong>参数2是文件的打开方式</strong>，默认值是’r’，表示以只读方式打开</li><li>其余参数都是带默认值的，可参考官方文档，或直接转到open()函数声明处查看</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;myfile.text文件在与执行文件同级的目录中，其内容为：</span><br><span class="line">1234567890</span><br><span class="line">abcdefghijklmn</span><br><span class="line">opqrstuvwxyz</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 打开方式为&#x27;r&#x27;时，可以省略，即：file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file)  # `&lt;_io.TextIOWrapper name=&#x27;myfile.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;UTF-8&#x27;&gt;`</span><br></pre></td></tr></table></figure><h3 id="2-读文件"><a href="#2-读文件" class="headerlink" title="2. 读文件"></a>2. 读文件</h3><ul><li>简介：<strong>读写文件之前，必须先打开文件</strong>。可以调用内置函数open()并以只读或读写方式打开文件，返回的文件对象有三个用于读文件的方法，分别为read()、readline()、readlines()</li><li><strong>read()：不传入参数时读到文件尾，传入参数时size用于指定字节数</strong><ul><li>用法：当指定的字节数小于读到文件尾的字节数时，读到指定的字节数；当指定的字节数大于读到文件尾的字节数时，或当指定的字节数小于0时，读到文件尾</li><li><strong>注意：指定的size不要超过默认缓冲区的大小。</strong>如果文件很大，调用read()一次性读取整个文件会导致内存占用较大，因此最好可以多次调用，否则可能并取不到指定的字节数，<strong>通过标准库中模块io的属性DEFAULT_BUFFER_SIZE可以查看默认缓冲区的大小</strong></li></ul></li><li><strong>readline()：不传入参数时读到行尾，传入参数时size用于指定字节数</strong><ul><li>用法：当指定的字节数小于读到行尾的字节数时，读到指定的字节数；当指定的字节数大于读到行尾的字节数时，或当指定的字节数小于0时，读到行尾</li></ul></li><li><strong>readlines()：不传入参数时读到文件尾，并返回每一行组成的列表；传入参数时size用于指定字节数</strong><ul><li>用法：当指定的字节数小于读到文件尾的字节数时，一直读取到最后一个字符所在行的行尾；当指定的字节数大于读到文件尾的字节数时，或当指定的字节数小于0时，读到文件尾</li><li><strong>注意：同样指定的size不要超过默认缓冲区的大小</strong>。一次性读取整个文件会导致内存占用较大，而取不到指定的字节数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;myfile.text文件在与执行文件同级的目录中，其内容为：</span><br><span class="line">1234567890</span><br><span class="line">abcdefghijklmn</span><br><span class="line">opqrstuvwxyz</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">print(io.DEFAULT_BUFFER_SIZE)  # 8192</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file.read())  # 1234567890 abcdefghijklmn opqrstuvwxyz</span><br><span class="line">file.close()  # 文件在使用完毕后必须要关闭</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">print(file.read(12))  # 1234567890 a</span><br><span class="line">print(file.read(3))  # 没有关闭文件，所以可以继续提取 bcd</span><br><span class="line">print(file.read(-5))  # 参数为负数时读到文件尾 efghijklmn opqrstuvwxyz</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">print(&#x27;-&#x27; * 18)</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file.readline())  # 1234567890\n</span><br><span class="line">print(file.readline(7))  # abcdefg</span><br><span class="line">print(file.readline(10))  # hijklmn\n</span><br><span class="line">print(file.readline(-5))  # opqrstuvwxyz</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">print(&#x27;-&#x27; * 18)</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file.readlines())  # [&#x27;1234567890\n&#x27;, &#x27;abcdefghijklmn\n&#x27;, &#x27;opqrstuvwxyz&#x27;]</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">print(file.readlines(8))  # [&#x27;1234567890\n&#x27;]</span><br><span class="line">print(file.readlines(50))  # [&#x27;abcdefghijklmn\n&#x27;, &#x27;opqrstuvwxyz&#x27;]</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">print(file.readlines(13))  # [&#x27;1234567890\n&#x27;, &#x27;abcdefghijklmn\n&#x27;]</span><br><span class="line">print(file.readlines(-5))  # [&#x27;opqrstuvwxyz&#x27;]</span><br><span class="line">print(file.readlines())  # []</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="3-写文件"><a href="#3-写文件" class="headerlink" title="3. 写文件"></a>3. 写文件</h3><ul><li>简介：<strong>写文件之前，必须先打开文件</strong>。可以调用内置函数open()并以只写、追加或读写方式打开文件，返回的文件对象有两个用于写文件的方法，分别为<strong>write()、writelines()</strong></li><li>write(str)：<strong>用于将指定的字符串写入到文件中，返回写入的字符数，即指定的字符串的长度</strong></li><li>writelines(seq)：<strong>用于将指定的字符串序列依次写入到文件中，无返回值</strong><ul><li>原理：调用后，会先将指定的子符串写入到缓存中，手动调用方法flush()或close()之后，或者当写入的数据量大于等于缓存的容量时，缓存中的字符串才会被写入到文件中</li><li><strong>flush()方法：用于刷新内部缓冲区，即将缓冲区中的数据立刻写入文件（一般情况下，文件关闭后会自动刷新缓冲区）</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">print(file.write(&#x27;hello&#x27;))  # 5</span><br><span class="line">file.write(&#x27;python&#x27;)</span><br><span class="line">file.flush()</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;)</span><br><span class="line">file.write(&#x27;hello&#x27;)</span><br><span class="line">file.write(&#x27;python&#x27;)</span><br><span class="line">file.close()</span><br><span class="line"># 追加后，myfile.txt中内容更改为：hellopythonhellopython</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">file.writelines([&#x27;123\t&#x27;, &#x27;456\n&#x27;, &#x27;789&#x27;])</span><br><span class="line">file.close()</span><br><span class="line">&quot;&quot;&quot;myfile.txt中内容更改为：</span><br><span class="line">123 456</span><br><span class="line">789</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="4-关闭文件"><a href="#4-关闭文件" class="headerlink" title="4. 关闭文件"></a>4. 关闭文件</h3><ul><li><p>简介：<strong>文件在使用完毕后必须要关闭</strong>，这是因为文件对象会占用操作系统的资源，并且操作系统在某一时刻所能打开的文件数量也是有限的</p></li><li><p>注意：<strong>读文件或写文件时都有可能发生异常，从而导致方法close()不会被调用，文件没有关闭</strong>。为了保证方法close()总能被调用，可以把读文件或写文件的操作放在try语句块中，把方法close()的调用放在finally从句中</p></li><li><p><strong>重点：由于文件对象实现了特殊方法__enter__()和__exit__()，所以文件对象可以作为上下文管理器。其中特殊方法__enter__()用于返回打开的文件对象，特殊方法__exit__()用于关闭打开的文件，因此操作文件对象常用with语句来实现，因为其与try-finally语句相比更加简洁</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">try:</span><br><span class="line">    file.write(&#x27;hello&#x27;)</span><br><span class="line">finally:</span><br><span class="line">    file.close()</span><br><span class="line"># myfile.txt文件内容更改为：hello</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;) as file:</span><br><span class="line">    file.write(&#x27;python&#x27;)</span><br><span class="line"># myfile.txt文件内容更改为：hellopython</span><br></pre></td></tr></table></figure><h3 id="5-文件指针"><a href="#5-文件指针" class="headerlink" title="5. 文件指针"></a>5. 文件指针</h3><ul><li><p>简介：<strong>任何文件对象都有一个文件指针，指向文件中的某个位置</strong>。读写文件时，是从文件指针的当前位置开始读写的，在读写的过程中，文件指针会随之往后移动</p></li><li><p>打开文件后文件指针的位置：</p><ul><li>以追加方式打开文件后，文件指针指向文件的结尾位置</li><li>以其他方式打开文件后，文件指针指向文件的起始位置</li><li><strong>可以调用文件对象的方法tell()，返回文件指针的当前位置</strong></li></ul></li><li><p>自由移动文件指针：<strong>可以调用文件对象的方法seek(offset[, whence])<strong>，将文件指针自由移动到参数指定的位置，其中参数offset表示偏移量，可以为负数。</strong>参数whence是可选的</strong>，表示相对偏移量，有三种取值：</p><ul><li>os.SEEK_SET：相对文件的起始位置，值为0，默认值</li><li>os.SEEK_CUR：相对文件的当前位置，值为1</li><li>os.SEEK_END：相对文件的结尾位置，值为2</li><li><strong>注意：以文本方式打开的文件，不支持使用参数whence，只支持相对文件的起始位置</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def reset(data):</span><br><span class="line">    with open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;) as file:</span><br><span class="line">        file.write(data)</span><br><span class="line"></span><br><span class="line">reset(&#x27;0123456789&#x27;)  # 创建或覆盖数据为 0123456789 的文本文件&#x27;myfile.txt&#x27;</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 10</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 0</span><br><span class="line">    file.read(3)</span><br><span class="line">    print(file.tell())  # 3</span><br><span class="line">    file.read()</span><br><span class="line">    print(file.tell())  # 10</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 10</span><br><span class="line">    file.write(&#x27;hello&#x27;)</span><br><span class="line">    print(file.tell())  # 15</span><br><span class="line"></span><br><span class="line">reset(&#x27;0123456789&#x27;)  # 将文件内数据复原到0123456789</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;rb+&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 0</span><br><span class="line"></span><br><span class="line">    # file.seek(3, os.SEEK_SET)</span><br><span class="line">    # file.seek(3, 0)</span><br><span class="line">    file.seek(3)</span><br><span class="line">    print(file.tell())  # 3</span><br><span class="line"></span><br><span class="line">    # os.SEEK_CUR表示相对于当前位置的寻址，</span><br><span class="line">    # 文本文件对象并不支持这种操作，所以一定要确保以二进制读写模式打开文件</span><br><span class="line">    file.seek(4, os.SEEK_CUR)</span><br><span class="line">    print(file.tell())  # 7</span><br><span class="line"></span><br><span class="line">    file.seek(-2, os.SEEK_END)</span><br><span class="line">    print(file.tell())  # 8，即此时指针移动到了数字7后面</span><br><span class="line"></span><br><span class="line">    file.write(b&#x27;Python&#x27;)  # 在二进制模式下打开的文件，写入数据也一定要是二进制数据</span><br><span class="line">    print(file.tell())  # 14，写入数据时将从数字7后面开始覆盖</span><br><span class="line"></span><br><span class="line"># 最终myfile.txt中的内容为：01234567Python</span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    print(file.read())  # 01234567Python</span><br></pre></td></tr></table></figure><h2 id="八、函数进阶"><a href="#八、函数进阶" class="headerlink" title="八、函数进阶"></a>八、函数进阶</h2><h3 id="1-函数的重要特性"><a href="#1-函数的重要特性" class="headerlink" title="1. 函数的重要特性"></a>1. 函数的重要特性</h3><ul><li><strong>在Python中，一切皆为对象</strong>。所以，<strong>函数也是对象</strong>，以下是函数的重要特性：<ol><li><strong>一个函数可以被赋值给一个变量</strong></li><li><strong>一个函数可以作为另一个函数的实参</strong></li><li><strong>一个函数可以作为另一个函数的返回值</strong></li><li><strong>一个函数可以嵌套定义在另一个函数中</strong></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 1. 函数也是对象，可以被赋值给变量</span><br><span class="line">def add(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line">print(add)  # `&lt;function add at 0x100ccb2e0&gt;`</span><br><span class="line">f = add</span><br><span class="line">print(f(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 2. 一个函数可以作为另一个函数的实参</span><br><span class="line">def eval_square(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line">result = map(eval_square, [1, 2, 3, 4])</span><br><span class="line">print(list(result))  # [1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line"># 3. 一个函数可以作为另一个函数的返回值</span><br><span class="line">def do_sth():</span><br><span class="line">    return add</span><br><span class="line"></span><br><span class="line">print(do_sth()(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 4. 一个函数可以嵌套定义在另一个函数中</span><br><span class="line">def outer():</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;This is inner.&quot;)</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">outer()()  # This is inner.</span><br></pre></td></tr></table></figure><h3 id="2-Lambda匿名函数"><a href="#2-Lambda匿名函数" class="headerlink" title="2. Lambda匿名函数"></a>2. Lambda匿名函数</h3><ul><li><p>简介：当函数中只有一行return语句时，函数的定义可以用一个lambda表达式来代替</p></li><li><p><strong>语法：<code>lambda arguments: expression</code>（arguments是参数，expression是函数的返回值）</strong></p></li><li><p><strong>闭包：</strong> Lambda函数也涉及到闭包的概念，因为<strong>其可以捕获和引用定义在其周围作用域中的变量</strong>，形成闭包</p></li><li><p><strong>重点用法：将某个操作直接包装成一个可调用对象，即直接return某个函数并带有实参，这也是因为其可以捕获和引用定义在其周围作用域中的变量，例：<code>lambda: requests.get(url, headers=headers)</code></strong></p></li><li><p><strong>lambda表达式的特点：</strong></p><ol><li><strong>没有函数名</strong></li><li><strong>没有关键字def</strong></li><li><strong>没有小括号</strong></li><li><strong>关于形式参数的表达式相当于函数的返回值</strong></li></ol></li><li><p>在Python中，一切皆为对象，lambda表达式也是对象，又属于函数，所以也拥有函数的部分重要特性</p><ol><li><strong>lambda表达式可以被赋值给变量</strong></li><li><strong>lambda表达式可以作为函数的实参</strong></li><li><strong>lambda表达式可以作为函数的返回值</strong></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># &gt; 函数与lambda表达式的区别</span><br><span class="line">def add(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line">print(add(1, 2))  # 3</span><br><span class="line">print((lambda num1, num2: num1 + num2)(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 1、lambda表达式可以被赋值给变量</span><br><span class="line">le = lambda num1, num2: num1 + num2</span><br><span class="line">print(le(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 2、lambda表达式可以作为函数的实参</span><br><span class="line">result = map(lambda x: x * x, [1, 2, 3, 4])</span><br><span class="line">print(list(result))  # [1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line"># 3、lambda表达式可以作为函数的返回值</span><br><span class="line">def do_sth():</span><br><span class="line">    return lambda num1, num2: num1 + num2</span><br><span class="line"></span><br><span class="line">print(do_sth()(1, 2))  # 3</span><br></pre></td></tr></table></figure><h3 id="3-partial偏函数"><a href="#3-partial偏函数" class="headerlink" title="3. partial偏函数"></a>3. partial偏函数</h3><ul><li><p>简介：偏函数可以将某个已有的函数转换为一个新函数，在<strong>转换的过程中指定最前面的若干个位置实参以及关键字实参</strong>，这样，当调用新函数的时候，在其内部调用的仍然是转换前的函数，在<strong>传递实参时只需要传递剩余的位置实参和关键字实参</strong>即可，从而<strong>简化函数的调用</strong>。转换后的新函数被称为转换前的函数的<strong>偏函数</strong>。</p></li><li><p>应用：**可以调用标准库模块functools中的函数partial(func, *args, **kwargs)**，将某个已有的函数转换为其偏函数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line"># 案例1</span><br><span class="line">def f1(a, b=5, *args, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;args =&#x27;, args, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f1_new = partial(f1, 1, 3, 6, m=8)</span><br><span class="line">f1_new(2, 4, n=9)  # a = 1 b = 3 args = (6, 2, 4) kwargs = &#123;&#x27;m&#x27;: 8, &#x27;n&#x27;: 9&#125;</span><br><span class="line"></span><br><span class="line"># 案例2</span><br><span class="line">def f2(a, b=5, *, c, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f2_new = partial(f2, 1, m=8)</span><br><span class="line">f2_new(3, c=9)  # a = 1 b = 3 c = 9 kwargs = &#123;&#x27;m&#x27;: 8&#125;</span><br><span class="line"></span><br><span class="line"># 案例3</span><br><span class="line">def eval_sum(*args):</span><br><span class="line">    s = 0</span><br><span class="line">    for n in args:</span><br><span class="line">        s += n</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line">eval_sum_new = partial(eval_sum, 20, 30)</span><br><span class="line">print(eval_sum_new(1, 2, 3, 4, 5))  # 65</span><br></pre></td></tr></table></figure><h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h3><ul><li><p>简介：如果在一个函数的内部嵌套定义了另外一个函数（暂且将外部的函数和内部的函数分别称为外函数和内函数），同时满足<strong>内函数引用了外函数中的变量</strong>、<strong>外函数的返回值是内函数</strong>这两点，那么就构成了一个<strong>闭包</strong></p></li><li><p>应用：通常情况下，在函数调用结束后，函数内定义的变量将不再可用。但是，<strong>对于闭包而言，在外函数调用结束后，外函数中被内函数引用的变量仍然是可用的，因为此变量并没有被释放，而是被绑定到了内函数的特殊属性__closure__中，可以通过__closure__[i].cell_contents打印其值</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 一个简单典型的闭包结构</span><br><span class="line">def outer():</span><br><span class="line">    a = 10</span><br><span class="line">    def inner():  # 一个函数的内部嵌套定义了另外一个函数</span><br><span class="line">        print(a)  # 内函数引用了外函数中的变量</span><br><span class="line">    return inner  # 外函数的返回值是内函数</span><br><span class="line"></span><br><span class="line">outer()()  # 10</span><br><span class="line"></span><br><span class="line"># 此时打印内函数的特殊属性__closure__，返回了一个只包含一个元素的元组</span><br><span class="line">print(outer().__closure__)  # (`&lt;cell at 0x10107f430: int object at 0x100f20210&gt;`,)</span><br><span class="line">print(outer().__closure__[0].cell_contents)  # 10，即outer函数中的变量a</span><br></pre></td></tr></table></figure><ul><li><p><strong>重点：默认情况下，在内函数中不能修改外函数中变量的引用（如果引用的对象是可变类型的，可以修改对象的值）</strong>。如果想在内函数中修改外函数中变量的引用，<strong>可以在内函数中使用关键字nonlocal对变量进行声明</strong>；声明即意味着在内函数中不会再重新定义一个新的同名变量，而是使用了外函数中该名称的变量</p></li><li><p><strong>注意：对于内函数中引用的外函数中的变量， 在调用内函数后对该变量的修改，在下一次调用内函数时仍然是有效的，因为该变量会被绑定到内函数的特殊属性__closure__中</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    a, b, c = 1, [2], [3]</span><br><span class="line">    print(f&quot;a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;, 调用内函数前id(c)=&#123;id(c)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def inner():</span><br><span class="line">        # 在内函数中不能修改外函数中变量的引用，如果在内函数直接给变量a重新赋值，相当于重新定义</span><br><span class="line">        # a += 1  # 抛出异常，直接使用 += 会导致等号右边的变量a还没赋值</span><br><span class="line">        # b = [8]  # 同理，这里是重新定义了一个变量b，把外函数中的变量b给屏蔽了</span><br><span class="line">        b[0] = 8  # 外函数中变量b的引用是列表为可变类型的，所以这里是内函数引用了外函数中的变量</span><br><span class="line"></span><br><span class="line">        nonlocal a, c</span><br><span class="line">        a += 1  # 声明后即操作的是外函数中变量</span><br><span class="line">        c = [9]  # 与b[0]=8不同，c是改变了外函数中变量c的引用，而b仅仅是改变了其值</span><br><span class="line">        print(f&quot;a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;, 调用内函数前id(c)=&#123;id(c)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"># 在调用内函数后对该变量的修改，在下一次调用内函数时仍然是有效的</span><br><span class="line">inner = outer()  # a=1, b=[2], c=[3], 调用内函数前id(c)=4333769536</span><br><span class="line">inner()  # a=2, b=[8], c=[9], 调用内函数前id(c)=4333774272</span><br><span class="line">inner()  # a=3, b=[8], c=[9], 调用内函数前id(c)=4333769536</span><br><span class="line"></span><br><span class="line">print(inner.__closure__)  # 此时特殊属性__closure__中存放了三个cell对象所组成的元组</span><br><span class="line">for i in range(3):</span><br><span class="line">    print(inner.__closure__[i].cell_contents)  # 3 [8] [9]</span><br></pre></td></tr></table></figure><h3 id="5-变量的作用域"><a href="#5-变量的作用域" class="headerlink" title="5. 变量的作用域"></a>5. 变量的作用域</h3><blockquote><p><strong>变量的作用域指的是变量起作用的范围，是由定义变量的位置决定的。</strong></p><p>变量的作用域有4种：</p><ol><li>局部作用域（Local）<ul><li>每次调用函数时都会创建一个<strong>局部作用域</strong>，局部作用域（函数）中定义的变量称为<strong>局部变量</strong></li><li>局部变量的作用域为：<strong>从定义变量处开始到函数结束</strong></li><li>函数调用结束后，其对应的<strong>局部作用域中的所有变量都会被销毁</strong></li></ul></li><li>嵌套作用域（Enclosing）<ul><li>每次调用嵌套函数中的外函数时都会创建一个<strong>嵌套作用域</strong></li><li>当在外函数内定义变量时，该变量的作用域为：<strong>从定义变量处开始到函数结束</strong></li><li>外函数调用结束后，其对应的<strong>嵌套作用域中的所有变量都会被销毁（闭包除外）</strong></li></ul></li><li>全局作用域（Global）<ul><li>每次运行模块时都会创建一个<strong>全局作用域</strong>，全局作用域（模块）中定义的变量称之为<strong>全局变量</strong></li><li>全局变量的作用域为：<strong>从定义变量处开始到模块结束</strong></li><li>程序运行结束后，<strong>全局作用域中的所有变量都会被销毁</strong></li></ul></li><li>内置作用域（Built-in）<ul><li>每次启动Python解释器都会自动加载内置模块，从而创建一个<strong>内置作用域</strong></li><li>内置模块中的函数（内置函数），<strong>可以在程序中直接使用</strong></li><li><strong>停止解释器后，内置作用域中的所有变量都会被销毁</strong></li></ul></li></ol></blockquote><ul><li><strong>重点1：当在某个作用域中访问变量时，会按照LEGB的顺序依次搜索该作用域及其后面的所有作用域</strong>，只要找到了则停止搜索，如果没找到则抛出NameError。因此，如果不同的作用域中定义了同名的变量，根据LEGB的搜索顺序，<strong>前面作用域中的变量会屏蔽掉后面作用域中定义的同名变量</strong></li><li><strong>重点2：与闭包原理类似，在局部作用域或嵌套作用域中不能修改全局变量的引用（如果引用的对象是可变类型的，可以修改对象的值）</strong>。如果想要修改，<strong>可以在局部作用域或嵌套作用域中使用关键字global对变量进行声明</strong>；声明即意味着在局部作用域或嵌套作用域中不会再重新定义一个新的同名变量，而是使用了该名称的全局变量</li><li><strong>注意：流程控制语句和异常处理语句不会创建对应的作用域。因此，对于流程控制语句和异常处理语句中定义的变量，在语句执行结束后仍然是可以用的</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">id = &quot;Global&quot;</span><br><span class="line"></span><br><span class="line">def outside():</span><br><span class="line">    id = &quot;Enclosing&quot;</span><br><span class="line"></span><br><span class="line">    def inside():</span><br><span class="line">        id = &quot;Local&quot;</span><br><span class="line">        # global id  # 使用global关键字声明后，打印id的值就为Global</span><br><span class="line">        print(id)</span><br><span class="line"></span><br><span class="line">    inside()</span><br><span class="line"></span><br><span class="line">outside()  # 按照LEGB的顺序依次注释掉函数中的属性id值，</span><br><span class="line"># 会依次输出：Local、Enclosing、Global、`&lt;built-in function id&gt;`</span><br><span class="line"></span><br><span class="line"># 重要问题：关于作用域的典型问题！</span><br><span class="line">def fun():</span><br><span class="line">    # 按照LEGB的顺序会先到局部作用域中搜索变量id，而局部变量id却定义在了访问print之后，</span><br><span class="line">    # 意味着局部变量id还没有赋值，这样就会抛出异常，而如果没有定义局部变量id，反而不会抛出异常</span><br><span class="line">    # 因为按照LEGB的搜索顺序，会在全局作用域中搜索到已赋值的全局变量id = &#x27;Global&#x27;</span><br><span class="line">    print(id)  # UnboundLocalError: ......</span><br><span class="line">    # id = 5</span><br><span class="line"></span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line"># 流程控制语句和异常处理语句不会创建对应的作用域</span><br><span class="line">if True:</span><br><span class="line">    temp = 18</span><br><span class="line">print(temp)  # 18</span><br><span class="line"></span><br><span class="line">for item in [1, 2, 3]:</span><br><span class="line">    print(item)  # 1 2 3</span><br><span class="line">print(item)  # 3</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    result = 5</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line">print(result)  # 5</span><br></pre></td></tr></table></figure><h3 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6. 命名空间"></a>6. 命名空间</h3><ul><li>简介：<strong>命名空间指的是某个作用域内所有名字和值的映射，用字典表示</strong><ul><li>内置函数locals()可以返回其所在局部作用域的命名空间</li><li>内置函数globals()可以返回其所在全局作用域的命名空间</li></ul></li><li><strong>重点：</strong><ul><li><strong>对于可变类型，使用locals()或者globals()返回的字典与实际命名空间是共享的，通过该字典修改可变类型的值会在实际命名空间中反映出来。需要注意的是，此时locals()返回的字典只能改变变量的值，而globals()返回的字典既可以改变变量的值，还可以改变其引用</strong></li><li><strong>对于不可变类型，是无法通过修改locals()返回的字典来改变实际的命名空间中的不可变类型的值的，但是globals()可以</strong></li></ul></li><li><strong>总结：locals() 和 globals() 都用于查看当前作用域内的命名空间，但是 locals() 返回的是一个只读的字典副本，而 globals() 返回的是实际命名空间的引用。</strong>在局部命名空间中，对于可变类型的变量，使用 locals() 返回的字典修改其值会影响实际的命名空间，但对于不可变类型的变量，使用 locals() 修改值是无效的。对于 globals()，无论变量的类型是可变还是不可变，修改都会影响实际的命名空间。</li><li>**内置函数vars()**：返回对象的属性和属性值的字典对象<ul><li>当函数不接收参数时，返回当前作用域内的局部变量，其功能和locals()函数类似</li><li>当函数接收一个参数时，参数可以是模块、类、类实例或者定义了__dict__属性的对象，其功能和object.__dict__属性类似</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># eg1：</span><br><span class="line">school_students = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 18,</span><br><span class="line">    &#x27;Bob&#x27;: 19,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def class_students(students):</span><br><span class="line">    print(f&quot;局部命名空间中的变量：&#123;locals()&#125;&quot;)  # &#123;&#x27;students&#x27;: &#123;&#x27;Alice&#x27;: 18, &#x27;Bob&#x27;: 19&#125;&#125;</span><br><span class="line"></span><br><span class="line">    # 在局部命名空间中，添加一个新的学生</span><br><span class="line">    locals()[&#x27;students&#x27;][&#x27;Emily&#x27;] = 20  # 添加</span><br><span class="line">    locals()[&#x27;students&#x27;][&#x27;Alice&#x27;] = 17  # 修改</span><br><span class="line"></span><br><span class="line">    print(f&quot;局部命名空间中的变量：&#123;locals()&#125;&quot;)  # &#123;&#x27;students&#x27;: &#123;&#x27;Alice&#x27;: 17, &#x27;Bob&#x27;: 19, &#x27;Emily&#x27;: 20&#125;&#125;</span><br><span class="line">    print(f&quot;当前作用域内的局部变量：&#123;vars()&#125;&quot;)  # &#123;&#x27;students&#x27;: &#123;&#x27;Alice&#x27;: 17, &#x27;Bob&#x27;: 19, &#x27;Emily&#x27;: 20&#125;&#125;</span><br><span class="line"></span><br><span class="line">class_students(school_students)</span><br><span class="line">print(&quot;全局命名空间中的变量students：&quot;, globals()[&#x27;school_students&#x27;])  # &#123;&#x27;Alice&#x27;: 17, &#x27;Bob&#x27;: 19, &#x27;Emily&#x27;: 20&#125;</span><br><span class="line"></span><br><span class="line"># eg2：</span><br><span class="line">def f():</span><br><span class="line">    x, y = [123], &#x27;hello&#x27;</span><br><span class="line">    print(locals())  # &#123;&#x27;x&#x27;: [123], &#x27;y&#x27;: &#x27;hello&#x27;&#125;</span><br><span class="line">    locals()[&#x27;x&#x27;][0] = 333  # 可变类型，locals()可以修改值，但不能修改其引用</span><br><span class="line">    # locals()[&#x27;x&#x27;] = 333  # 没有效果</span><br><span class="line">    locals()[&#x27;y&#x27;] = &#x27;xfblog&#x27;  # 不可变类型，locals()修改值无效</span><br><span class="line">    locals()[&#x27;z&#x27;] = &#x27;world&#x27;  # 可以添加值</span><br><span class="line">    print(x, y)  # [333] hello，z未定义所以不能访问，只能通过locals()访问</span><br><span class="line">    print(locals())  # &#123;&#x27;x&#x27;: [333], &#x27;y&#x27;: &#x27;hello&#x27;, &#x27;z&#x27;: &#x27;world&#x27;&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure><h3 id="7-函数装饰器"><a href="#7-函数装饰器" class="headerlink" title="7. 函数装饰器"></a>7. 函数装饰器</h3><ul><li><p>简介：对于某个函数，如果希望<strong>在不改变该函数代码的前提下，为该函数增加额外的功能</strong>，那么就可以使用装饰器来装饰该函数</p></li><li><p>原理：装饰器是一个函数，装饰器接收一个函数作为参数（传入的实参是被装饰的函数），装饰器的内部嵌套定义另一个函数，内函数中会引用装饰器的参数，并且装饰器的返回值是内函数，这样就<strong>构成了一个闭包</strong>。为了让内函数接收任意类型的参数，将内函数的形参定义为(*args, **kwargs)。 <strong>在内函数中，首先完成为被装饰函数添加的新功能，然后返回调用被装饰的函数</strong></p></li><li><p>把装饰器应用到被装饰函数的语法为：<strong>在被装饰函数的前面添加”@装饰器的函数名”<strong>。在被装饰函数add的前面添加@log后，相当于执行了语句：</strong>add &#x3D; log(add)<strong>， 首先被装饰的函数add会作为实参传递给装饰log，然后返回装饰器的内函数wrapper，最后将内函数wrapper赋值给add（被装饰函数的函数名），</strong>这样再调用被装饰的函数add时，其实调用的是装饰器的内函数wrapper</strong><br><img                         lazyload                       alt="image"                       data-src="https://xfblog.cn/images/1667144165-4475f40809afcf1.jpg"                                        ></p></li><li><p>知识点1：如果希望被装饰函数的特殊属性__name__的值为其函数名add， 而不是装饰器的内函数函数名wrapper，可以在装饰器的内函数前面添加另外一个装饰器：**@functools.wraps(装饰器的形参名)<strong>。</strong>其中functools.wraps指的是标准库模块functools中的函数wraps**</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&quot;函数%s被调用了&quot; % func.__name__)</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line">def add(sum1, sum2):</span><br><span class="line">    return sum1 + sum2</span><br><span class="line"></span><br><span class="line">print(add(1, 2))  # 函数add被调用了 3</span><br><span class="line"># print(add.__name__)  # 若注释掉&quot;@functools.wraps(func)&quot;，则打印wrapper</span><br><span class="line">print(add.__name__)  # add</span><br></pre></td></tr></table></figure><ul><li>知识点2：<strong>把装饰器应用到递归函数时，装饰器会执行多次。如果只想装饰器正常执行一次，可以在递归函数前都加上单下划线，并重新定义一个新函数调用此递归函数，最后再将装饰器应用到新函数上即可</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 汉诺塔问题</span><br><span class="line">def zhuangshiqi(func):</span><br><span class="line">    def wrapper(*a, **b):</span><br><span class="line">        print(&quot;移动开始&quot;)</span><br><span class="line">        func(*a, **b)</span><br><span class="line">        print(&quot;移动结束&quot;)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def _hanoi(n, a, b, c):</span><br><span class="line">    if n &gt; 0:</span><br><span class="line">        _hanoi(n - 1, a, c, b)</span><br><span class="line">        print(&quot;移动%s最上方的盘子至%s&quot; % (a, c))</span><br><span class="line">        _hanoi(n - 1, b, a, c)</span><br><span class="line"></span><br><span class="line">@zhuangshiqi</span><br><span class="line">def hanoi(n):</span><br><span class="line">    _hanoi(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br><span class="line"></span><br><span class="line">hanoi(3)</span><br><span class="line">&quot;&quot;&quot;如果递归函数特殊处理装饰器，则会打印多次移动开始和移动结束</span><br><span class="line">移动开始</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动A最上方的盘子至B</span><br><span class="line">移动C最上方的盘子至B</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动B最上方的盘子至A</span><br><span class="line">移动B最上方的盘子至C</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>知识点3：<strong>把装饰器应用到被装饰函数时，还可以传递额外的参数；此时，需要编写一个三层嵌套的装饰器</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def logs(year, month, day):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            print(&quot;%s年%s月%s日, 函数%s被调用了&quot; % (year, month, day, func.__name__))</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@logs(2099, 10, 30)  # 同理，对于@logs(2099, 10, 30)，相当于执行语句：adds = logs(2099, 10, 30)(adds)</span><br><span class="line">def adds(sum1, sum2):</span><br><span class="line">    return sum1 + sum2</span><br><span class="line"></span><br><span class="line">print(adds(1, 2))  # 2099年10月30日, 函数adds被调用了 3</span><br></pre></td></tr></table></figure><h3 id="8-内置函数property"><a href="#8-内置函数property" class="headerlink" title="8. 内置函数property"></a>8. 内置函数property</h3><ul><li>简介：在Python中定义类时，希望控制类的属性的访问和修改方式，property()函数可以<strong>将方法转化为静态的属性（变量）</strong>，使得属性的获取、设置和删除可以通过方法调用来实现，从而提供更多的控制。这样一来，当访问这个属性时，实际上是调用了这个方法</li><li>语法：<strong>property(getx, setx, delx, doc)，函数设有4个参数，即获取属性值的函数、设置属性值的函数、删除属性值的函数和属性描述信息</strong></li><li>应用1：<strong>定义一个可控属性值，即在类中定义值为property对象的类属性</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Circle:</span><br><span class="line">    def __init__(self, radius):</span><br><span class="line">        self._radius = radius  # 使用下划线前缀表示这是一个受保护的属性</span><br><span class="line"></span><br><span class="line">    def get_radius(self):</span><br><span class="line">        print(&quot;获取半径&quot;)</span><br><span class="line">        return self._radius</span><br><span class="line"></span><br><span class="line">    def set_radius(self, value):</span><br><span class="line">        if value &lt; 0:</span><br><span class="line">            raise ValueError(&quot;半径不能为负数&quot;)</span><br><span class="line">        print(&quot;设置半径&quot;)</span><br><span class="line">        self._radius = value</span><br><span class="line"></span><br><span class="line">    def del_radius(self):</span><br><span class="line">        print(&quot;删除半径&quot;)</span><br><span class="line">        del self._radius</span><br><span class="line"></span><br><span class="line">    # 使用property()将get_radius方法转化为属性</span><br><span class="line">    radius = property(get_radius, set_radius, del_radius, &quot;圆的半径&quot;)</span><br><span class="line"></span><br><span class="line"># 创建一个Circle对象</span><br><span class="line">circle = Circle(5)</span><br><span class="line"></span><br><span class="line"># 访问属性（调用get_radius方法）</span><br><span class="line">print(circle.radius)  # 5</span><br><span class="line"></span><br><span class="line"># 设置属性（调用set_radius方法）</span><br><span class="line">circle.radius = 10</span><br><span class="line"></span><br><span class="line"># 获取属性的文档字符串</span><br><span class="line">print(Circle.radius.__doc__)  # 需要通过类名来获取，因为属性是属于类的</span><br><span class="line"></span><br><span class="line"># 删除属性（调用del_radius方法）</span><br><span class="line">del circle.radius</span><br></pre></td></tr></table></figure><ul><li>应用2：<strong>将property函数用作装饰器，可以直接创建只读属性</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.__x = name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def myfun(self):</span><br><span class="line">        &quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span><br><span class="line">        return self.__x</span><br><span class="line"></span><br><span class="line">    @myfun.setter</span><br><span class="line">    def myfun(self, value):</span><br><span class="line">        self.__x = value</span><br><span class="line"></span><br><span class="line">    @myfun.deleter</span><br><span class="line">    def myfun(self):</span><br><span class="line">        del self.__x</span><br><span class="line"></span><br><span class="line">c = C(&#x27;wcf&#x27;)</span><br><span class="line">print(c.myfun)  # 自动执行@property修饰的myfun方法，并获取方法的返回值</span><br><span class="line">c.myfun = &#x27;zxc&#x27;  # 自动执行@myfun.setter修饰的myfun方法，并将&#x27;zxc&#x27;赋值给方法的参数</span><br><span class="line">print(C.myfun.__doc__)  # 自动获取@property修饰的myfun方法的__doc__属性：I&#x27;m the &#x27;x&#x27; property.</span><br><span class="line">del c.myfun  # 自动执行@myfun.deleter修饰的myfun方法</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、函数&quot;&gt;&lt;a href=&quot;#一、函数&quot; class=&quot;headerlink&quot; title=&quot;一、函数&quot;&gt;&lt;/a&gt;一、函数&lt;/h2&gt;&lt;h3 id=&quot;1-函数的定义与调用&quot;&gt;&lt;a href=&quot;#1-函数的定义与调用&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_1_基础语法</title>
    <link href="http://example.com/2023/04/01/Python_1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/04/01/Python_1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2023-03-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Python简介：</strong>Python是由荷兰数学和计算机科学研究学会的吉多·范罗苏姆于1990年代初设计，作为一门叫做ABC语言的替代品。Python提供了高效的高级数据结构，还能简单有效地面向对象编程。Python语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言，随着版本的不断更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。</p><p><strong>注意：</strong></p><ol><li><strong>Python是一门强类型的编程语言</strong></li><li><strong>Python中一切皆为对象</strong></li><li><strong>Python语言是动态的</strong></li><li><strong>Python在2022年至今编程语言热度排行榜第一！</strong></li></ol></blockquote><h2 id="一、关键字和标识符"><a href="#一、关键字和标识符" class="headerlink" title="一、关键字和标识符"></a>一、关键字和标识符</h2><h3 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1. 关键字"></a>1. 关键字</h3><ul><li><strong>关键字：</strong>由 python 语言定义的、具有特殊用途的单词<ul><li>在 python 交互式命令行中，运行内置函数 help() 进入帮助模式，通过 keywords 变量输出所有关键字</li><li>通过导入模块 keyword 查看所有关键字</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import keyword</span><br><span class="line"></span><br><span class="line">print(keyword.kwlist)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;,</span><br><span class="line"> &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;,</span><br><span class="line"> &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;,</span><br><span class="line"> &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h3 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2. 标识符"></a>2. 标识符</h3><ul><li><p><strong>标识符：</strong>所谓标识符，就是给程序中的变量、函数、方法、类等命名的名字</p></li><li><p><strong>组成：</strong>数字、字母、下划线</p></li><li><p><strong>命名规则：</strong></p><ol><li>区分大小写</li><li>不能是关键字</li><li>不能以数字开头</li><li>不能包含空格、制表符、数字符号、中划线、箭头</li></ol></li><li><p><strong>命名规范：</strong></p><ol><li>见名知意</li><li>所有单词全部小写，单词之间用下划线进行分隔</li></ol></li></ul><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote><p><strong>获取数据的数据类型</strong>：调用**内置函数 type **可以获取数据的数据类型</p></blockquote><h3 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1. 整数类型"></a>1. 整数类型</h3><ul><li>整数的进制：十进制（默认）、二进制以 0b 开头、八进制以 0o 开头、十六进制以 0x 开头</li><li><strong>整数转换为不同进制的字符串：</strong><ul><li><p><strong>bin()：</strong>将十进制整数转换为2进制（binary）字符串</p></li><li><p><strong>oct()：</strong>将十进制整数转换为8进制（octal）字符串</p></li><li><p><strong>hex()：</strong>将十进制整数转换为16进制（hexadecimal）字符串</p></li></ul></li><li><strong>整数的创建：</strong>可以直接创建一个整数，也可以调用内置函数 int 创建整数<ul><li><p>不传递任何参数时，返回整数0</p></li><li><p>只传递一个参数时，将传递的参数转换为整数</p></li><li><p>传递两个参数时，第一个参数必须是字符串，第二个参数指定几进制</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(118)  # 118</span><br><span class="line">print(0b1110110)  # 118</span><br><span class="line">print(0o166)  # 118</span><br><span class="line">print(0x76)  # 118</span><br><span class="line"></span><br><span class="line">print(bin(118))  # 0b1110110</span><br><span class="line">print(oct(118))  # 0o166</span><br><span class="line">print(hex(118))  # 0x76</span><br><span class="line"></span><br><span class="line">print(int())  # 0</span><br><span class="line">print(int(118.2))  # 118</span><br><span class="line">print(int(&#x27;118&#x27;))  # 118</span><br><span class="line">print(int(&#x27;1110110&#x27;, 2))  # 118</span><br><span class="line">print(int(&#x27;0o166&#x27;, 8))  # 118</span><br><span class="line">print(int(&#x27;0x76&#x27;, 16))  # 118</span><br></pre></td></tr></table></figure><h3 id="2-浮点数类型"><a href="#2-浮点数类型" class="headerlink" title="2. 浮点数类型"></a>2. 浮点数类型</h3><ul><li><strong>浮点数的创建：</strong>可以使用小数创建浮点数，也可以调用内置函数 float 创建浮点数<ul><li>不传递任何参数时，返回浮点数0.0</li><li>只传递一个参数时，将传递的参数转换为浮点数</li></ul></li><li><strong>科学计数法：</strong>很大或很小的浮点数一般使用科学计数法 mEn 表示（m乘以10的n次方）</li><li><strong>注意：计算机采用二进制存储浮点数时是不精确的，可能会存在误差，因此对于浮点数的运算需要格外小心</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">print(float())  # 0.0</span><br><span class="line">print(float(118))  # 118.0</span><br><span class="line">print(float(&#x27;118&#x27;))  # 118.0</span><br><span class="line"></span><br><span class="line">print(1.8e5)  # 180000.0</span><br><span class="line">print(1.8e-4)  # 0.00018</span><br><span class="line">print(1.8E5)</span><br><span class="line">print(1.8E-4)  # 0.00018</span><br><span class="line"></span><br><span class="line"># 浮点数存储的不精确性</span><br><span class="line">print(1.1 + 2.2 - 3.3)  # 4.440892098500626e-16</span><br><span class="line">print(1.1 + 2.2)  # 3.3000000000000003</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    解决方案：导入模块decimal或fractions</span><br><span class="line">    其中，模块decimal用于处理十进制的浮点数，模块fractions用于处理分数</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from decimal import Decimal</span><br><span class="line">from fractions import Fraction</span><br><span class="line"></span><br><span class="line">print(Decimal(&#x27;1.1&#x27;) + Decimal(&#x27;2.2&#x27;) - Decimal(&#x27;3.3&#x27;))  # 0.0</span><br><span class="line">print(Fraction(11, 10) + Fraction(22, 10) - Fraction(33, 10))  # 0</span><br></pre></td></tr></table></figure><h3 id="3-布尔类型"><a href="#3-布尔类型" class="headerlink" title="3. 布尔类型"></a>3. 布尔类型</h3><ul><li><p><strong>布尔类型只有两种取值：True、Flase（首字母必须大写）</strong></p></li><li><p><strong>运算：</strong>在进行数学运算时，True会被视为整数1，False会被视为整数0（<strong>bool类是int类的子类</strong>）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(5 &gt; 3)  # True</span><br><span class="line">print(6 &lt; 3)  # False</span><br><span class="line">print(True + False + 5)  # 6</span><br><span class="line"></span><br><span class="line"># isinstance用于检查一个对象是否是指定类（或指定类的子类）的实例</span><br><span class="line">print(isinstance(True, bool))  # True</span><br><span class="line">print(isinstance(True, int))  # True</span><br><span class="line">print(True == 1)  # True</span><br><span class="line">print(False == 0)  # True</span><br></pre></td></tr></table></figure><h3 id="4-对象None"><a href="#4-对象None" class="headerlink" title="4. 对象None"></a>4. 对象None</h3><blockquote><p><strong>注意：对象 None 是占据一定的内存空间的，它并不意味着“空”或“没有定义”</strong></p></blockquote><ul><li><strong>使用场景：</strong><ul><li><p>用于变量的初始化</p></li><li><p>将定义过的变量重置为<strong>数据值不存在</strong>的状态</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = None</span><br><span class="line">print(a)  # None</span><br><span class="line"></span><br><span class="line">b = 18</span><br><span class="line">b = None</span><br><span class="line">print(b)  # None</span><br></pre></td></tr></table></figure><h3 id="5-数据类型之间的转换"><a href="#5-数据类型之间的转换" class="headerlink" title="5. 数据类型之间的转换"></a>5. 数据类型之间的转换</h3><ul><li><strong>与 js 不同：</strong>python 中数值类型不能直接和字符串使用+进行拼接，<strong>不存在隐性转换</strong>，需要进行类型转换</li><li><strong>注意：</strong>C 语言中类型转换语法为**(类型名)变量<strong>：<code>(int)a</code>，而 Python 中则是使用</strong>函数转换**：<code>int(a)</code></li></ul><h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><blockquote><p><strong>对于包含多个运算符的复杂表达式：</strong>可以使用<strong>小括号</strong>指定运算顺序，也可以将复杂表达式拆分成几步来完成</p></blockquote><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><ul><li><p><strong>注意：python不支持自增++和自减–，可使用 <code>i+=1</code> 的方式</strong></p></li><li><p><strong>运算符：</strong>加+、减-、乘<em>、除&#x2F;、整除&#x2F;&#x2F;、取余%、幂</em>*</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(10 * &#x27;-&#x27;)  # ----------，乘法还可以用于字符串，打印分割线</span><br><span class="line"></span><br><span class="line">print(5 / 3)  # 1.6666666666666667，正常除法有小数</span><br><span class="line">print(5 // 3)  # 1，一般用于计算一个数值是另一个数值的多少倍，无小数</span><br><span class="line">print(9 // -4)  # -3，9 = (-4) * (-3) + (-3)</span><br><span class="line">print(-9 // 4)  # -3，-9 = 4 * (-3) + 3</span><br><span class="line">print(-9 // -4)  # 2，-9 = (-4) * 2 + (-1)</span><br><span class="line"></span><br><span class="line">print(9 % -4)  # -3，9 = (-4) * (-3) + (-3)</span><br><span class="line">print(-9 % 4)  # 3，-9 = 4 * (-3) + 3</span><br><span class="line">print(-9 % -4)  # -1，-9 = (-4) * 2 + (-1)</span><br><span class="line"></span><br><span class="line">print(-2 ** 3)  # -8，幂，等价于pow(-2, 3)</span><br></pre></td></tr></table></figure><h3 id="2-布尔运算符"><a href="#2-布尔运算符" class="headerlink" title="2. 布尔运算符"></a>2. 布尔运算符</h3><ul><li><strong>注意：</strong><ol><li><strong>python中布尔运算符只支持关键字不支持符号</strong></li><li><strong>逻辑运算结果不一定只是 True 或者 False，还有可能是数值（谁决定结果则返回谁的值）</strong></li></ol></li><li><strong>运算符：</strong><ul><li><p><strong>and：</strong>当两个运算符都为True时，运算结果才为True</p></li><li><p><strong>or：</strong>只要有一个运算符为True，运算结果就为True</p></li><li><p><strong>not：</strong>如果运算数为True（False），运算结果就为False（True）</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 3</span><br><span class="line">y = 5</span><br><span class="line">print(x and y)  # 5，如果ｘ为True，则返回y；否则返回x</span><br><span class="line">print(x or y)  # 3，如果x为True，则返回x；否则返回y</span><br><span class="line">print(not x)  # False，如果x为True，则返回False，否则返回True</span><br></pre></td></tr></table></figure><h3 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3. 赋值运算符"></a>3. 赋值运算符</h3><ul><li><p><strong>运算符：</strong>&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、**&#x3D;</p></li><li><p><strong>应用：赋值运算符支持链式赋值</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = 18</span><br><span class="line">print(a, b, c)  # 18 18 18</span><br></pre></td></tr></table></figure><blockquote><p><strong>重点：在Python中，变量是没有固定的数据类型的，但是它们引用的对象是有数据类型的</strong></p><p><strong>原因：</strong>由于 python 是一种动态类型语言，这意味着变量可以随时引用不同类型的对象。但在操作变量之前，通常需要确保变量引用了我们所期望的对象类型，以避免出现错误。这就是为什么在 Python 中经常使用 <code>type()</code> 函数来检查对象的类型，以及为什么要遵循适当的编程实践，以确保变量的数据类型正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">print(a)  # 5</span><br><span class="line">print(type(a))  # `&lt;class &#x27;int&#x27;&gt;`</span><br><span class="line"></span><br><span class="line">a = &quot;Hello&quot;</span><br><span class="line">print(a)  # Hello</span><br><span class="line">print(type(a))  # `&lt;class &#x27;str&#x27;&gt;`</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4. 比较运算符"></a>4. 比较运算符</h3><ul><li><p><strong>运算符：</strong>&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;、is、is not</p><ul><li><p><strong>&#x3D;&#x3D;：</strong>用于比较两个运算数是否相等，主要用于<strong>相等性</strong>测试（**&#x3D;&#x3D; 判断值是否相等**）</p></li><li><p><strong>is：</strong>用于比较两个运算数是否是同一个对象，主要用于<strong>同一性</strong>测试（<strong>is 判断地址是否相等</strong>）</p></li></ul></li><li><p><strong>不可变类型对象的 is 比较：</strong></p></li></ul><ul><li><strong>对于不可变类型的对象，其内存可能会被重用，比如数值较小的整数对象</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = b = [1, 2, 3]</span><br><span class="line">c = [1, 2, 3]</span><br><span class="line">print(a == b == c)  # True，比较运算符也可以使用链式比较</span><br><span class="line"></span><br><span class="line"># 使用内置函数id可以返回对象的唯一标识（内存地址）</span><br><span class="line">print(a is b, id(a), id(b))  # True 4439667456 4439667456</span><br><span class="line">print(b is c, id(b), id(c))  # False 4439667456 4439476352</span><br><span class="line"></span><br><span class="line"># 不可变类型对象的 is 比较</span><br><span class="line">a = 18</span><br><span class="line">b = 18</span><br><span class="line">print(id(a), id(b))  # 4455988560 4455988560</span><br><span class="line">print(a is b)  # True</span><br></pre></td></tr></table></figure><h3 id="5-条件运算符"><a href="#5-条件运算符" class="headerlink" title="5. 条件运算符"></a>5. 条件运算符</h3><ul><li><p><strong>注意：Python中不支持三目运算符 ? :</strong></p></li><li><p><strong>运算符：</strong>‘True’ if 条件 else ‘False’</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;aaa&#x27; if &#x27;abc&#x27; &gt; &#x27;acd&#x27; else &#x27;bbb&#x27;)  # bbb</span><br></pre></td></tr></table></figure><h3 id="6-成员运算符"><a href="#6-成员运算符" class="headerlink" title="6. 成员运算符"></a>6. 成员运算符</h3><ul><li><strong>运算符：</strong>in、not in（<strong>返回布尔值</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = [3, 5, 12, 15, 7, 2]</span><br><span class="line">d = 5</span><br><span class="line">print(d not in c)  # False</span><br></pre></td></tr></table></figure><h3 id="7-位运算符"><a href="#7-位运算符" class="headerlink" title="7. 位运算符"></a>7. 位运算符</h3><ul><li><strong>运算符：</strong>与&amp;、或|、非~、异或^、左移&lt;&lt;、右移&gt;&gt;<ul><li><strong>&amp;：</strong>两位都是1才为1，否则为0</li><li><strong>|：</strong>只要有一位为1，则为1，否则为0</li><li><strong>~：</strong>如果为1，则为0，如果为0，则为1</li><li><strong>^：</strong>如果两位相同，则为0，不同为1</li><li><strong>&lt;&lt;：</strong>左移数值扩大两倍</li><li><strong>&gt;&gt;：</strong>右移数值缩小两倍</li></ul></li></ul><h2 id="四、range序列类型"><a href="#四、range序列类型" class="headerlink" title="四、range序列类型"></a>四、range序列类型</h2><blockquote><p><strong>range序列类型：</strong>用于表示<strong>不可变</strong>的整数序列，其返回值是一个<strong>可迭代对象</strong></p><p><strong>注意：range对象虽然不是生成器，但它支持惰性运算，在需要时按需生成序列中的元素，而不会一次性占用大量的内存空间</strong></p></blockquote><ul><li>创建 range 类型的对象（<strong>左闭右开</strong>）：调用内置函数 range（类 range 的构造方法）<ul><li>range(stop)</li><li>range(strat, stop)</li><li>range(strat, stop, step)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_range_1 = range(10)</span><br><span class="line">print(list(my_range_1))  # 输出: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">my_range_2 = range(5, 15)</span><br><span class="line">print(list(my_range_2))  # 输出: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span><br><span class="line"></span><br><span class="line">my_range_3 = range(1, 20, 3)</span><br><span class="line">print(list(my_range_3))  # 输出: [1, 4, 7, 10, 13, 16, 19]</span><br></pre></td></tr></table></figure><h2 id="五、列表"><a href="#五、列表" class="headerlink" title="五、列表"></a>五、列表</h2><blockquote><p><strong>列表的特点：</strong></p><ol><li>列表中的所有数据都有两个整数类型的索引，通过指定的索引总能映射到唯一确定的数据</li><li>列表中可以保存任何类型的数据，多种类型的数据可以混合存储在一个列表中（但不建议）</li><li>列表可以根据需要动态地伸缩，系统会根据需要动态地分配和回收内存，因此，在使用前无须预先声明列表的容量</li></ol><p><strong>注意：列表相当于其他编程语言中的数组，是有序的、可重复的、可变的！</strong></p></blockquote><h3 id="1-列表的创建"><a href="#1-列表的创建" class="headerlink" title="1. 列表的创建"></a>1. 列表的创建</h3><ul><li><strong>列表的两种创建方式：</strong><ol><li>使用中括号</li><li>调用内置函数 list（类 list 的构造方法）</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;python&#x27;, 18, True]</span><br><span class="line">print(L)  # [&#x27;python&#x27;, 18, True]</span><br><span class="line">print([])  # []，空列表</span><br><span class="line"></span><br><span class="line">print(list(range(3, 7)))  # [3, 4, 5, 6]</span><br><span class="line">print(list([&#x27;python&#x27;, 18, True]))  # [&#x27;python&#x27;, 18, True]</span><br><span class="line">print(list())  # []，空列表</span><br></pre></td></tr></table></figure><h3 id="2-列表的查操作"><a href="#2-列表的查操作" class="headerlink" title="2. 列表的查操作"></a>2. 列表的查操作</h3><ol><li><strong>获得指定元素的索引，</strong>语法：<code>L.index(val, start, stop)</code>（<strong>左闭右开，返回的索引值是大于零的</strong>）<ul><li><p>若列表中存在多个指定元素，方法 index 只返回第 1 个指定元素的索引值</p></li><li><p>若列表中不存在指定的元素，方法 index 抛出 ValueError 异常</p></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [5, 3, 7, 9, 1, 7, 6]</span><br><span class="line">print(L.index(9))  # 3</span><br><span class="line">print(L.index(7))  # 2</span><br><span class="line"># print(L.index(8))  # ValueError: 8 is not in list</span><br><span class="line"></span><br><span class="line">print(L.index(7, 3))  # 5</span><br><span class="line">print(L.index(7, 3, 6))  # 5</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>通过索引获取元素</strong>，语法：<code>L[index]</code>（<strong>一次只能获取一个元素</strong>）</p></li><li><p><strong>通过切片获取元素</strong>，语法：<code>L[start:stop:step]</code>（<strong>一次可以获取多个元素，左闭右开</strong>）</p><ul><li><strong>注意：<span style="color:red;">切片得到的仍然是列表，是原始列表的片段的一份拷贝</span></strong></li><li><strong>使用：</strong>三个参数均可根据要求省略，step 为步长，可以为负数，为负数时即从后往前获取元素，且<strong>切片操作是允许索引越界的</strong></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L = [5, 3, 9, 4, 0, 6, 8, 1, 7, 2]</span><br><span class="line">print(L[1:7:2])  # [3, 4, 6]，每隔一个取一值</span><br><span class="line">print(L[1:7])  # [3, 9, 4, 0, 6, 8]</span><br><span class="line">print(L[::])  # [5, 3, 9, 4, 0, 6, 8, 1, 7, 2]</span><br><span class="line"></span><br><span class="line"># step步长为负数，同样是左闭右开</span><br><span class="line">print(L[::-1])  # [2, 7, 1, 8, 6, 0, 4, 9, 3, 5]</span><br><span class="line">print(L[6:0:-2])  # [8, 0, 9]</span><br><span class="line">print(L[0:6:-2])  # []</span><br><span class="line"></span><br><span class="line"># 允许索引越界</span><br><span class="line">print(L[:100])  # [5, 3, 9, 4, 0, 6, 8, 1, 7, 2]</span><br><span class="line">print(L[-100:])  # [5, 3, 9, 4, 0, 6, 8, 1, 7, 2]</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于内置函数 slice（类 slice 的构造方法）创建 slice 类型的对象，三种调用方式：</strong></p><ol><li>slice(stop)</li><li>slice(start, stop)</li><li>slice(start, stop, step)</li></ol><p>其中：start、stop 的默认值都是None，但均不可省略，只有 step 的值可以省略</p><p>注意：<strong>slice(start, stop, step) 与 start:stop:step 是等价的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = [5, 3, 9, 4, 0, 6, 8, 1, 7, 2]</span><br><span class="line"></span><br><span class="line">print(L[slice(1, 7, 2)])  # [3, 4, 6]</span><br><span class="line">print(L[slice(None, None, None)])  # [5, 3, 9, 4, 0, 6, 8, 1, 7, 2]</span><br><span class="line">print(L[slice(None, None, )])  # [5, 3, 9, 4, 0, 6, 8, 1, 7, 2]</span><br><span class="line">print(L[slice(5, 7, None)])  # [6, 8]</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-列表的改操作"><a href="#3-列表的改操作" class="headerlink" title="3. 列表的改操作"></a>3. 列表的改操作</h3><ul><li><strong>索引操作：</strong>为指定索引的元素赋予一个新值（<strong>一次只修改一个元素</strong>）</li><li><strong>切片操作：</strong>为指定的切片赋予一个新值（<strong>一次至少修改一个元素</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 索引操作</span><br><span class="line">L = [3, 4, 5, 6, 7]</span><br><span class="line">L[2] = 8</span><br><span class="line">print(L)  # [3, 4, 8, 6, 7]</span><br><span class="line"></span><br><span class="line"># 切片操作</span><br><span class="line">L = [3, 4, 5, 6, 7]</span><br><span class="line">L[1:4] = [9, 8, 7]</span><br><span class="line">print(L)  # [3, 9, 8, 7, 7]</span><br><span class="line"></span><br><span class="line"># 等号左右的元素个数可以不同</span><br><span class="line">L = [3, 4, 5, 6, 7]</span><br><span class="line">L[1:] = [2, 1]</span><br><span class="line">print(L)  # [3, 2, 1]</span><br></pre></td></tr></table></figure><h3 id="4-列表的增操作"><a href="#4-列表的增操作" class="headerlink" title="4. 列表的增操作"></a>4. 列表的增操作</h3><ul><li>调用方法append（<strong>在列表的末尾一次只添加一个元素</strong>）</li><li>调用方法extend（<strong>在列表的末尾一次至少添加一个元素</strong>）</li><li>调用方法insert（<strong>在列表的任意索引位置一次只添加一个元素</strong>）</li><li>为指定的切片赋予一个新值（<strong>在列表的任意索引位置一次至少添加一个元素</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个空列表</span><br><span class="line">my_list = []</span><br><span class="line"></span><br><span class="line"># 使用 append 方法在列表的末尾添加一个元素</span><br><span class="line">my_list.append(1)</span><br><span class="line">my_list.append([2, 3])</span><br><span class="line">print(my_list)  # [1, [2, 3]]</span><br><span class="line"></span><br><span class="line"># 使用 extend 方法在列表的末尾添加至少一个元素</span><br><span class="line">my_list.extend([4, 5])</span><br><span class="line">print(my_list)  # [1, [2, 3], 4, 5]</span><br><span class="line"></span><br><span class="line"># 使用 insert 方法在列表的任意索引位置添加一个元素</span><br><span class="line">my_list.insert(2, 3)  # 在索引为 2 的位置添加一个元素</span><br><span class="line">my_list.insert(len(my_list), 6)  # 在最后一个元素的后一个索引添加</span><br><span class="line">print(my_list)  # [1, [2, 3], 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line"># 为指定的切片赋予一个新值</span><br><span class="line">my_list[1:1] = [2]</span><br><span class="line">my_list[len(my_list):] = [7, 8]</span><br><span class="line">print(my_list)  # [1, 2, [2, 3], 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h3 id="5-列表的删操作"><a href="#5-列表的删操作" class="headerlink" title="5. 列表的删操作"></a>5. 列表的删操作</h3><ul><li>调用方法remove（<strong>一次只删除一个指定的元素</strong>）<ul><li>存在多个指定元素，则只删除第一个</li><li>不存在需要删除的指定元素，则抛出异常</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L = [3, 4, 5, 6, 7, 8]</span><br><span class="line"></span><br><span class="line">L.remove(4)</span><br><span class="line"># L.remove(9)  # ValueError: list.remove(x): x not in list</span><br><span class="line">print(L)  # [3, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><ul><li>调用方法pop（<strong>一次只删除一个指定索引的元素</strong>）<ul><li><p><strong>返回值：</strong>该方法返回被删除的元素</p></li><li><p>指定的索引不存在，则抛出异常</p></li><li><p>不指定索引，则默认删除列表的最后一个元素</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line">print(L.pop(2))  # 5</span><br><span class="line">print(L)  # [3, 4, 6, 7]</span><br><span class="line"></span><br><span class="line">print(L.pop())  # 7</span><br><span class="line">print(L)  # [3, 4, 6]</span><br></pre></td></tr></table></figure><ul><li>使用del语句（<strong>一次至少删除一个元素</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">del L[2]</span><br><span class="line">print(L)  # [3, 4, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">del L[1:4]</span><br><span class="line">print(L)  # [3, 8, 9]</span><br></pre></td></tr></table></figure><ul><li>为指定的切片赋值一个空列表（<strong>一次至少删除一个元素</strong>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">L[1:4] = []</span><br><span class="line">print(L)  # [3, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">L[:] = []  # 清空列表</span><br><span class="line">print(L)  # []</span><br></pre></td></tr></table></figure><ul><li>调用方法clear清空列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line">L.clear()</span><br><span class="line">print(L)  # []</span><br></pre></td></tr></table></figure><h3 id="6-列表的运算符操作"><a href="#6-列表的运算符操作" class="headerlink" title="6. 列表的运算符操作"></a>6. 列表的运算符操作</h3><ol><li><strong>使用加法运算符操作列表：</strong></li></ol><ul><li><p>将两个列表合并后生成一个新列表，<strong>被合并的两个列表本身不发生变化</strong></p></li><li><p><strong>参数赋值运算符 +&#x3D; 会对列表本身进行修改</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># L1 对象和 L2 对象是同一个引用</span><br><span class="line">L1 = L2 = [1, 2]</span><br><span class="line">L1 = L1 + [3, 4]</span><br><span class="line">print(L1, L2)  # [1, 2, 3, 4] [1, 2]</span><br><span class="line"></span><br><span class="line">L1 = L2 = [1, 2]</span><br><span class="line">L1 += [3, 4]</span><br><span class="line">print(L1, L2)  # [1, 2, 3, 4] [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用乘法运算符操作列表：</strong><ul><li>将列表中的所有元素重复 n 次后生成一个新列表，<strong>被乘的列表不发生变化</strong></li><li><strong>参数赋值运算符 *&#x3D; 也会对列表本身进行修改</strong></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># L1对象和L2对象是同一个引用</span><br><span class="line">L1 = L2 = [1, 2]</span><br><span class="line">L1 = L1 * 3</span><br><span class="line">print(L1, L2)  # [1, 2, 1, 2, 1, 2] [1, 2]</span><br><span class="line"></span><br><span class="line">L1 = L2 = [1, 2]</span><br><span class="line">L1 *= 3</span><br><span class="line">print(L1, L2)  # [1, 2, 1, 2, 1, 2] [1, 2, 1, 2, 1, 2]</span><br><span class="line"></span><br><span class="line"># 常用于初始化多个固定元素列表</span><br><span class="line">L = [0] * 5</span><br><span class="line">print(L)  # [0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用比较运算符比较两个列表：</strong><ul><li><strong>比较规则：</strong>依次比较两个列表中的每一个元素，相等则继续，不等则得出结果，<strong>且后续元素将不再被比较</strong></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print([2, 3, 7, 2, ] &lt; [2, 3, 6, 8])  # False</span><br><span class="line">print([7, [2, 6]] &gt; [7, [2, 5]])  # True</span><br></pre></td></tr></table></figure><h3 id="7-列表的反转"><a href="#7-列表的反转" class="headerlink" title="7. 列表的反转"></a>7. 列表的反转</h3><ul><li>调用方法 reverse，无返回值，<strong>直接改变列表本身</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [1, 2, 3, 4, 5]</span><br><span class="line">L.reverse()</span><br><span class="line">print(L)  # [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><ul><li>调用内置函数 reversed，返回值是一个<strong>迭代器对象</strong>，<strong>且列表本身不会被改变</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">iterator = reversed(L)</span><br><span class="line">print(iterator)  # &lt;list_reverseiterator object at 0x10aa387c0&gt;</span><br><span class="line"># print(list(iterator))  # [5, 4, 3, 2, 1]</span><br><span class="line">print(next(iterator))  # 5</span><br><span class="line">print(L)  # [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h3 id="8-列表的排序"><a href="#8-列表的排序" class="headerlink" title="8. 列表的排序"></a>8. 列表的排序</h3><ul><li>调用方法 sort，无返回值，<strong>直接改变列表本身</strong><ul><li>默认按照从小到大排序，可以指定参数 reverse &#x3D; True，从而按照逆序进行排序</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [3, 2, 5, 4, 1]</span><br><span class="line"></span><br><span class="line">L.sort()</span><br><span class="line">print(L)  # [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">L.sort(reverse=True)</span><br><span class="line">print(L)  # [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><ul><li>调用内置函数 sorted，<strong>返回一个新的排好序的列表，且列表本身不会被改变</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L = [3, 2, 5, 4, 1]</span><br><span class="line"></span><br><span class="line">print(sorted(L))  # [1, 2, 3, 4, 5]</span><br><span class="line">print(sorted(L, reverse=True))  # [5, 4, 3, 2, 1]</span><br><span class="line">print(L)  # [3, 2, 5, 4, 1]</span><br></pre></td></tr></table></figure><blockquote><p><strong>内置函数 sorted 延伸：</strong></p><p><strong>作用</strong>：sorted() 函数的作用是对可迭代对象（例如列表、元组、字符串、集合等）进行排序，并返回一个新的排好序的列表</p><p><strong>特点：不会修改原始可迭代对象，而是返回一个新的有序列表</strong></p><p><strong>注意：无论是对什么类型的数据使用 sorted 函数排序，返回的都一定是列表</strong></p><p><strong>语法</strong>：<code>sorted(iterable, key=None, reverse=False)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 处理 range 对象</span><br><span class="line">my_range = range(10, 5, -1)</span><br><span class="line">sorted_range = sorted(my_range)</span><br><span class="line">print(sorted_range)  # [6, 7, 8, 9, 10]</span><br><span class="line"></span><br><span class="line"># 处理任何可迭代对象</span><br><span class="line">class MyIterable:</span><br><span class="line"> def __init__(self, data):</span><br><span class="line">     self.data = data</span><br><span class="line"></span><br><span class="line"> def __iter__(self):</span><br><span class="line">     return iter(self.data)</span><br><span class="line"></span><br><span class="line">my_iterable = MyIterable([7, 2, 6, 3, 1])</span><br><span class="line">sorted_iterable = sorted(my_iterable)</span><br><span class="line">print(sorted_iterable)  # [1, 2, 3, 6, 7]</span><br><span class="line"></span><br><span class="line"># 处理字典，Python3.7+版本中的字典是有序的，它保持元素的插入顺序</span><br><span class="line">my_dict = &#123;&#x27;b&#x27;: 2, &#x27;a&#x27;: 1, &#x27;c&#x27;: 3&#125;</span><br><span class="line">new_dict = &#123;&#125;</span><br><span class="line"># 对字典的键进行排序</span><br><span class="line">for key in sorted(my_dict):</span><br><span class="line"> new_dict[key] = my_dict[key]</span><br><span class="line">print(my_dict)  # &#123;&#x27;b&#x27;: 2, &#x27;a&#x27;: 1, &#x27;c&#x27;: 3&#125;</span><br><span class="line">print(new_dict)  # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="9-多维列表"><a href="#9-多维列表" class="headerlink" title="9. 多维列表"></a>9. 多维列表</h3><ul><li><strong>多维列表的初始化：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 初始化多维列表：[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><br><span class="line">print([[0] * 3] * 4)</span><br><span class="line">print([[0 for i in range(3)] for j in range(4)])</span><br><span class="line">print([[0] * 3 for j in range(4)])</span><br></pre></td></tr></table></figure><ul><li><strong>一维列表的基础操作也适用于多维列表：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = [[3, 4], [1, 5, 2], [6, 8, 9, 7]]</span><br><span class="line"></span><br><span class="line">L[1] = 9</span><br><span class="line">print(L)  # [[3, 4], 9, [6, 8, 9, 7]]</span><br><span class="line"></span><br><span class="line">L.append([2, 0])</span><br><span class="line">print(L)  # [[3, 4], 9, [6, 8, 9, 7], [2, 0]]</span><br><span class="line"></span><br><span class="line">L.pop(2)</span><br><span class="line">print(L)  # [[3, 4], 9, [2, 0]]</span><br></pre></td></tr></table></figure><h2 id="六、元组"><a href="#六、元组" class="headerlink" title="六、元组"></a>六、元组</h2><blockquote><p><strong>为什么设计元组？</strong></p><ul><li>由于元组是不可变类型的对象，对于不可变类型的对象，在多任务环境下同时操作对象时不需要加锁。<strong>因此，在程序中应尽量使用不可变类型的对象</strong></li></ul><p><strong>特点：元组是有序的、可重复的、不可变的（但存储的可变类型数据对象是可改其值而不可改其引用的）！</strong></p></blockquote><h3 id="1-元组与列表的区别"><a href="#1-元组与列表的区别" class="headerlink" title="1. 元组与列表的区别"></a>1. 元组与列表的区别</h3><ul><li><strong>元组用小括号表示，列表用中括号表示：</strong>元组的小括号是可省略的</li><li><strong>元组是不可变类型，列表是可变类型：</strong>对于元组中存在的可变类型数据，<strong>元组中储存的是其引用（在内存中的地址）</strong>，即引用不能被改变，但引用所指向的可变类型的数据值是可以被改变的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t = (&#x27;python&#x27;, 18, True)</span><br><span class="line">tw = 20, &#x27;xfblog&#x27;, &#x27;嘿嘿&#x27;  # 小括号可省略</span><br><span class="line">print(t, tw)  # (&#x27;python&#x27;, 18, True) (20, &#x27;xfblog&#x27;, &#x27;嘿嘿&#x27;)</span><br><span class="line"></span><br><span class="line"># 空元组的两种表示方式：</span><br><span class="line">print(())  # ()</span><br><span class="line">print(tuple())  # ()</span><br><span class="line"></span><br><span class="line"># 不能更改元组中的引用，但可以更改其值</span><br><span class="line">t = (6, [88, 99], 3)</span><br><span class="line"># t[2] = 77  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br><span class="line">t[1][1] = 77</span><br><span class="line">print(t)  # (6, [88, 77], 3)</span><br></pre></td></tr></table></figure><h3 id="2-单个元素的元组"><a href="#2-单个元素的元组" class="headerlink" title="2. 单个元素的元组"></a>2. 单个元素的元组</h3><ul><li><strong>只包含一个元素的元组：</strong>即使元组只有一个元素，也<strong>至少要包含一个逗号</strong>，否则小括号会被看做是数学公式中的小括号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (18)</span><br><span class="line">print(t, type(t))  # 18 `&lt;class &#x27;int&#x27;&gt;`</span><br><span class="line"></span><br><span class="line">tw = (18,)</span><br><span class="line">print(tw, type(tw))  # (18,) `&lt;class &#x27;tuple&#x27;&gt;`</span><br></pre></td></tr></table></figure><h3 id="3-解构赋值（所有类型）"><a href="#3-解构赋值（所有类型）" class="headerlink" title="3. 解构赋值（所有类型）"></a>3. 解构赋值（所有类型）</h3><ul><li><strong>解构赋值：</strong><ol><li>赋值运算符的左边是一个所有元素都为变量的元组或其余数据类型，此时左右两边的元素个数必须相同</li><li>在赋值运算符左边的某个变量前加上 * 星号，可以匹配赋值运算符右边的 0 个或多个元素</li><li>可以直接通过解构赋值，解决经典的交换两个变量值，需要借助第三个变量的的问题</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 1. 元组解构赋值</span><br><span class="line">tuple1 = (1, 2, 3)</span><br><span class="line">a, b, c = tuple1</span><br><span class="line"># a, b = tuple1  # ValueError: too many values to unpack (expected 2)</span><br><span class="line">print(a, b, c)  # 输出: 1 2 3</span><br><span class="line"></span><br><span class="line"># 2. 元组解构赋值中使用 * 可以匹配多个元素</span><br><span class="line">tuple2 = (1, 2, 3, 4, 5)</span><br><span class="line">first, *rest, last = tuple2</span><br><span class="line">print(first, rest, last)  # 输出: 1 [2, 3, 4] 5</span><br><span class="line"></span><br><span class="line"># 3. 解构赋值实现变量交换</span><br><span class="line"># + 经典交换两个变量的值</span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br><span class="line">print(a, b)  # 2 1</span><br><span class="line"># + 解构赋值交换两个变量的值</span><br><span class="line"># 赋值运算符的左边是变量的元组，右边是表达式的元组；</span><br><span class="line"># 先将右边的所有表达式都计算完之后，再分别赋值给左边的所有变量</span><br><span class="line">a, b = b, a</span><br><span class="line">print(a, b)  # 1 2，再次交换</span><br></pre></td></tr></table></figure><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><blockquote><p><strong>字符串的特点：</strong></p><ol><li>字符串也是序列类型，是字符的有序集合</li><li><strong>对字符串进行修改时会开辟一块新的内存空间，其内存地址也会发生改变</strong></li><li><strong>字符串的单引号和双引号都无法取消特殊字符的含义</strong></li><li>python 没有单独的字符类型，字符就是只包含一个元素的字符串</li></ol><p><strong>总结：字符串是有序的、可重复的、不可变的！</strong></p></blockquote><h3 id="1-字符串的创建"><a href="#1-字符串的创建" class="headerlink" title="1. 字符串的创建"></a>1. 字符串的创建</h3><ul><li><strong>字符串的两种创建方式：</strong><ol><li>使用单引号或双引号直接创建，一般使用单引号（引号可以嵌套，可以在单引号中嵌套双引号，或反之）</li><li>调用内置函数 str（类 str 的构造方法）</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;abc&quot;ABC&quot;&#x27;)  # abc&quot;ABC&quot;</span><br><span class="line">print(&quot;abc&#x27;ABC&#x27;&quot;)  # abc&#x27;ABC&#x27;</span><br><span class="line">print(&#x27;&#x27;)  # 空字符串</span><br><span class="line"></span><br><span class="line">print(str(&#x27;abcd&#x27;))  # abcd</span><br><span class="line">print(str(123))  # 123，相当于类型转换为str了</span><br><span class="line">print(str())  # 空字符串</span><br></pre></td></tr></table></figure><h3 id="2-原始字符串"><a href="#2-原始字符串" class="headerlink" title="2. 原始字符串"></a>2. 原始字符串</h3><ul><li><strong>原始字符串：</strong>可以在字符串前面添加 r 或 R 使其转义字符失效，从而将字符串声明为原始字符串</li><li><strong>注意：</strong><ol><li><strong>原始字符串的最后一个字符不能是反斜杠，但是可以最后两个都是反斜杠</strong></li><li><strong>最后两个字符都是反斜杠代表原始字符串结束</strong></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 问题：字符串的单引号和双引号都无法取消特殊字符的含义</span><br><span class="line">print(&#x27;\tC:\\Program Files&#x27;)  # C:\Program Files</span><br><span class="line"></span><br><span class="line"># 解决：将字符串声明原始字符串</span><br><span class="line">print(r&#x27;\tC:\\Program Files&#x27;)  # \tC:\\Program Files</span><br><span class="line">print(R&#x27;\tC:\\Program Files&#x27;)  # \tC:\\Program Files</span><br><span class="line"></span><br><span class="line"># 最后一个字符不能是反斜杠 print(r&#x27;HelloWorld\&#x27;)，语法直接错误</span><br><span class="line">print(&#x27;HelloWorld\\&#x27;)  # HelloWorld\</span><br><span class="line"></span><br><span class="line"># 最后两个字符都是反斜杠代表原始字符串结束</span><br><span class="line"># print(r&#x27;What\\&#x27;s your name&#x27;)  # 语法直接错误，双反斜杠代表字符串结束</span><br><span class="line">print(r&#x27;What\&#x27;s your name&#x27;)  # What\&#x27;s your name</span><br></pre></td></tr></table></figure><h3 id="3-字符串的运算符操作"><a href="#3-字符串的运算符操作" class="headerlink" title="3. 字符串的运算符操作"></a>3. 字符串的运算符操作</h3><ol><li><strong>使用加法运算符操作字符串：</strong><ul><li>将两个字符串连接后生成一个新字符串</li><li>将多个字符串常量放在一起会自动连接然后生成一个新字符串，写在多行则需在每行末尾添加一个反斜杠</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;Hello,&#x27; + &#x27;World!&#x27;)  # Hello,World!</span><br><span class="line"></span><br><span class="line">s = &#x27;Hello&#x27; &#x27;,&#x27; &#x27;World&#x27;&#x27;!&#x27;</span><br><span class="line">print(s)  # Hello,World!</span><br><span class="line"></span><br><span class="line">s = &#x27;Hello&#x27; &#x27;,&#x27; \</span><br><span class="line"> &#x27;World&#x27; \</span><br><span class="line"> &#x27;!&#x27;</span><br><span class="line">print(s)  # Hello,World!</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用乘法运算符操作字符串：</strong><ul><li>将字符串中的所有字符重复 n 次后生成一个新字符串</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;Hello&#x27; * 3)  # HelloHelloHello</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用比较运算符比较两个字符串：</strong><ul><li><p>两个字符进行比较时，比较的是其 ordinal value（ASCll码值）</p></li><li><p>调用内置函数 ord 可以得到指定字符的 ordinal value</p></li><li><p>调用内置函数 chr 时指定 ordinal value 可以得到其对应的字符</p></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ord(&#x27;a&#x27;), chr(97))  # 97 a</span><br><span class="line">print(ord(&#x27;A&#x27;), chr(65))  # 65 A</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：同数值较小的整数对象一样，字符串常量也会被缓存和重用，以至于 is 比较时即使不是同一引用也会返回 True</strong></p></blockquote><h3 id="4-字符串的查操作"><a href="#4-字符串的查操作" class="headerlink" title="4. 字符串的查操作"></a>4. 字符串的查操作</h3><ul><li><strong>方法 index、find、rindex、rfind ：</strong><ul><li><p>当字符串中存在多个被查找的子串时，方法 index 和 find 返回第一个子串的索引， 方法 rindex 和 rfind 返回最后一个子串的索引</p></li><li><p>当字符串中不存在指定的子串时，方法 index 和 rindex 抛出 ValueError，方法 find 和 rfind 返回 -1</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;5739182186&#x27;</span><br><span class="line"></span><br><span class="line">print(s.index(&#x27;18&#x27;), s.find(&#x27;18&#x27;))  # 4 4</span><br><span class="line">print(s.rindex(&#x27;18&#x27;), s.rfind(&#x27;18&#x27;))  # 7 7</span><br><span class="line"></span><br><span class="line"># 同样遵循 左闭右开 规则</span><br><span class="line"># print(s.index(&#x27;18&#x27;, 1, 5)) # ValueError: substring not found</span><br><span class="line">print(s.find(&#x27;18&#x27;, 1, 5))  # -1</span><br></pre></td></tr></table></figure><blockquote><p>此外，<strong>字符串没有”改”操作、”增”操作和”删”操作</strong>，因为字符串是不可变类型</p><p>如果想要得到需要字符串，可以使用切片操作后配合 + 加号将其拼接起来，从而得到需要的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;Hello,World&#x27;</span><br><span class="line">print(s[:5] + &#x27;!&#x27; + s[6:])  # Hello!World</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-字符串的反转"><a href="#5-字符串的反转" class="headerlink" title="5. 字符串的反转"></a>5. 字符串的反转</h3><ul><li>调用内置函数 reversed，返回值是一个<strong>迭代器对象，字符串本身不会被改变</strong>（由于字符串是不可变类型，所以不存在方法 reverse）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;12345&#x27;</span><br><span class="line"></span><br><span class="line">iterator = reversed(s)</span><br><span class="line">print(iterator)  # `&lt;reversed object at 0x10ac7d940&gt;`</span><br><span class="line">print(list(iterator))  # [&#x27;5&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;]</span><br><span class="line">print(s)  # 12345，s并没有被改变</span><br></pre></td></tr></table></figure><h3 id="6-字符串的排序"><a href="#6-字符串的排序" class="headerlink" title="6. 字符串的排序"></a>6. 字符串的排序</h3><ul><li>调用内置函数 sorted，<strong>返回一个新的排好序的字符串列表（默认按照ascll排序的），且字符串本身不会被改变</strong>（由于字符串是不可变类型，所以不存在方法sort）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;DBeFac&#x27;</span><br><span class="line">print(sorted(s))  # [&#x27;B&#x27;, &#x27;D&#x27;, &#x27;F&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;]</span><br><span class="line">print(sorted(s, reverse=True))  # [&#x27;e&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;F&#x27;, &#x27;D&#x27;, &#x27;B&#x27;]</span><br><span class="line">print(s)  # DBeFac</span><br></pre></td></tr></table></figure><ul><li><strong>自定义排序规则：</strong>调用内置函数 sorted 时，还可以指定参数 <code>key=函数名</code> 或 <code>key=类名.方法名</code>，这样会对字符串中的所有字符分别调用指定的方法进行处理，然后按照函数的返回值进行排序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;DBeFac&#x27;</span><br><span class="line">print(sorted(s, key=str.lower))  # [&#x27;a&#x27;, &#x27;B&#x27;, &#x27;c&#x27;, &#x27;D&#x27;, &#x27;e&#x27;, &#x27;F&#x27;]</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：参数 key 同样适用于列表和元组，且调用列表的方法 sort 时，也可以指定参数 key</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Python&#x27;, &#x27;java&#x27;, &#x27;Swift&#x27;]</span><br><span class="line"></span><br><span class="line">print(sorted(L, key=len))  # [&#x27;java&#x27;, &#x27;Swift&#x27;, &#x27;Python&#x27;]</span><br><span class="line">print(sorted(L, key=str.lower))  # [&#x27;java&#x27;, &#x27;Python&#x27;, &#x27;Swift&#x27;]</span><br><span class="line"></span><br><span class="line">L.sort(key=len)</span><br><span class="line">print(L)  # [&#x27;java&#x27;, &#x27;Swift&#x27;, &#x27;Python&#x27;]</span><br></pre></td></tr></table></figure></blockquote><h3 id="7-字符串的三种占位符"><a href="#7-字符串的三种占位符" class="headerlink" title="7. 字符串的三种占位符"></a>7. 字符串的三种占位符</h3><ul><li><strong>使用百分号 % 作为占位符，并以百分号 % 为操作符：</strong><ul><li><p>%s：表示字符串，可以把任何数据类型转换为字符串</p></li><li><p>%d或者%i：表示整数</p></li><li><p>%f：表示浮点数</p></li><li><p><strong>%%：将%转义为普通字符，即表示%</strong></p></li><li><p>%Y-%m-%d %H:%M:%S：表示年月日时分秒（注意区分大小写）</p></li><li><p><strong>用法1：</strong>可以指定宽度和精度，其中<strong>数字和字符串都是右对齐</strong></p></li><li><p><strong>用法2：</strong>当定义的格式化字符串中包含两个及两个以上的占位符时，<strong>所有的实际值必须封装在元组中</strong></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">print(&#x27;我买了一本%s&#x27; % &#x27;西游记&#x27;)  # 我买了一本西游记</span><br><span class="line">print(&#x27;我的工作已经完成了%d%%&#x27; % 80)  # 我的工作已经完成了80%</span><br><span class="line">print(datetime(2022, 8, 18, 18, 18, 18))  # 2022-08-18 18:18:18</span><br><span class="line">print(datetime(2018, 8, 18, 18, 18, 18).strftime(&#x27;%Y-%m-%d %H-%M-%S&#x27;))  # 2018-08-18 18-18-18</span><br><span class="line"></span><br><span class="line">print(&#x27;%10d&#x27; % 58)  #         58</span><br><span class="line">print(&#x27;%10s&#x27; % &#x27;58&#x27;)  #         58</span><br><span class="line">print(&#x27;%.3f&#x27; % 3.1415926)  # 3.142，四舍五入</span><br><span class="line">print(&#x27;%.5s&#x27; % &#x27;HelloWorld&#x27;)  # Hello</span><br><span class="line">print(&#x27;%8.3f&#x27; % 3.1415926)  #    3.142，四舍五入</span><br><span class="line"></span><br><span class="line">book = &#x27;《数据结构与算法》&#x27;</span><br><span class="line">price = 68.88</span><br><span class="line">s = &#x27;花了%s元，买了一本书：%s&#x27; % (price, book)</span><br><span class="line">print(s)  # 花了68.88元，买了一本书：《数据结构与算法》</span><br></pre></td></tr></table></figure><ul><li><strong>使用花括号 {} 作为占位符，以方法 format() 格式化字符串：</strong><ul><li>占位符 {} 中不指定参数，方法 format 的参数会按顺序依次匹配所有的占位符</li><li>占位符 {} 中指定位置参数，0 表示方法 format 的第 1 个参数，1 表示第2个参数，以此类推</li><li>占位符 {} 中指定关键字参数的名称，在方法 format 中对应指定关键字参数的名称和值</li><li>占位符 {} 中使用冒号指定整数的<strong>表现形式</strong>，其中位置参数和关键字参数的名称放在冒号前面</li><li>占位符 {} 中也可以使用冒号<strong>指定宽度和精度</strong>，其中<strong>数字是右对齐，字符串是左对齐</strong></li><li>占位符 {} 中还可以使用冒号指定其他格式（日期格式）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">aaa = &#x27;Python&#x27;</span><br><span class="line">bbb = &#x27;awesome&#x27;</span><br><span class="line"></span><br><span class="line"># 占位符 &#123;&#125; 中不指定参数</span><br><span class="line">print(&quot;Hello, &#123;&#125;!&quot;.format(aaa))</span><br><span class="line"># 占位符 &#123;&#125; 中指定位置参数</span><br><span class="line">print(&quot;&#123;0&#125; is &#123;1&#125;, &#123;0&#125;&quot;.format(aaa, bbb))</span><br><span class="line"># 占位符 &#123;&#125; 中指定关键字参数的名称</span><br><span class="line">print(&quot;&#123;a&#125; is &#123;b&#125;, &#123;a&#125;&quot;.format(a=aaa, b=bbb))</span><br><span class="line"></span><br><span class="line"># 占位符 &#123;&#125; 中使用冒号指定整数的表现形式</span><br><span class="line">print(&#x27;&#123;:d&#125;&#x27;.format(58))  # 58，十进制</span><br><span class="line">print(&#x27;&#123;:b&#125;&#x27;.format(58))  # 111010，二进制</span><br><span class="line">print(&#x27;&#123;:x&#125;&#x27;.format(58))  # 3a，十六进制（a-f是小写）</span><br><span class="line">print(&#x27;&#123;:X&#125;&#x27;.format(58))  # 3A，十六进制（A-F是小写）</span><br><span class="line">print(&#x27;&#123;:f&#125;&#x27;.format(58))  # 58.000000，浮点数</span><br><span class="line">print(&#x27;&#123;:,&#125;&#x27;.format(12345678))  # 12,345,678，使用逗号作为千位分隔符</span><br><span class="line">print(&#x27;&#123;0:b&#125;&#x27;.format(58))  # 111010，0表示位置参数</span><br><span class="line">print(&#x27;&#123;num:X&#125;&#x27;.format(num=58))  # 3A，num表示关键字参数</span><br><span class="line"></span><br><span class="line"># 占位符 &#123;&#125; 中使用冒号指定宽度和精度</span><br><span class="line">print(&#x27;&#123;:10&#125;&#x27;.format(58))  #         58</span><br><span class="line">print(&#x27;&#123;:10&#125;&#x27;.format(&#x27;58&#x27;))  # 58</span><br><span class="line">print(&#x27;&#123;:.3&#125;&#x27;.format(3.1415926))  # 3.14</span><br><span class="line">print(&#x27;&#123;:.3f&#125;&#x27;.format(3.1415926))  # 3,142</span><br><span class="line">print(&#x27;&#123;:.5&#125;&#x27;.format(&#x27;HelloWorld&#x27;))  # Hello</span><br><span class="line">print(&#x27;&#123;:8.3f&#125;&#x27;.format(3.1415926))  #    3.142，同时指定宽度和精度，且四舍五入</span><br><span class="line"></span><br><span class="line"># 占位符 &#123;&#125; 中使用冒号指定其他格式（日期格式）</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">date = datetime.now()</span><br><span class="line">print(&quot;Today&#x27;s date is: &#123;:%Y-%m-%d&#125;&quot;.format(date))  # Today&#x27;s date is: 2018-08-18</span><br><span class="line">print(&#x27;&#123;:%Y-%m-%d %H:%M:%S&#125;&#x27;.format(datetime(2018, 8, 18, 18, 18, 18)))  # 2018-08-18 18:18:18</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：调用内置函数 format 格式化字符串，与字符串的 format 方法是等价的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;&#123;:8.3f&#125;&#x27;.format(3.1415926))  #    3.142</span><br><span class="line">print(format(3.1415926, &#x27;8.3f&#x27;))  #    3.142</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>使用美元符 $ 作为占位符，以方法 substitute() 格式化字符串：</strong><ul><li><strong>用法：</strong>导入模块 string 中的类 Template，并创建 Template 实例，再调用 substitute 或 safe_substitute 方法用于格式化字符串</li><li>其中 substitute 方法没有匹配的实际值时，会抛出异常；而 safe_substitute 不会抛出 KeyError，而是直接输出未格式化字符串</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from string import Template</span><br><span class="line"></span><br><span class="line">price = 68.88</span><br><span class="line">book = &#x27;《数据结构与算法》&#x27;</span><br><span class="line">tmpl = Template(&#x27;花了$p，买了一本书：$b&#x27;)</span><br><span class="line"></span><br><span class="line">s = tmpl.substitute(p=price, b=book)</span><br><span class="line">print(s)  # 花了68.88，买了一本书：《数据结构与算法》</span><br><span class="line">s = tmpl.substitute(&#123;&#x27;p&#x27;: price, &#x27;b&#x27;: book&#125;)</span><br><span class="line">print(s)  # 花了68.88，买了一本书：《数据结构与算法》</span><br><span class="line"></span><br><span class="line"># tmpl.substitute(p=price)  # KeyError: &#x27;b&#x27;</span><br><span class="line">s = tmpl.safe_substitute(p=price)</span><br><span class="line">print(s)  # 花了68.88，买了一本书：$b</span><br></pre></td></tr></table></figure><h3 id="8-字符串常用方法"><a href="#8-字符串常用方法" class="headerlink" title="8. 字符串常用方法"></a>8. 字符串常用方法</h3><ul><li><strong>字符串的大小写转换：</strong><ul><li><p>upper：把所有字符全部转换为大写</p></li><li><p>isupper：判断所有字符是否全为大写</p></li><li><p>lower：把所有字符全部转换为小写</p></li><li><p>islower：判断所有字符是否全为小写</p></li><li><p>title：把<strong>每个单词</strong>的第一个字符转换为大写，其余字符转换为小写</p></li><li><p>istitle：判断每个单词的第一个字符是否为大写并且每个单词的剩余字符为小写</p></li><li><p>swapcase：把所有小写字符转换为大写，所有大写字符转换为小写</p></li><li><p>capitalize：把<strong>整个字符串</strong>的第一个字符转换为大写，其余字符转换为小写</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;he is learning PYTHON&#x27;</span><br><span class="line"></span><br><span class="line">print(s.upper())  # HE IS LEARNING PYTHON</span><br><span class="line">print(s.isupper())  # False</span><br><span class="line">print(s.upper().isupper())  # True</span><br><span class="line"></span><br><span class="line">print(s.lower())  # he is learning python</span><br><span class="line">print(s.title())  # He Is Learning Python</span><br><span class="line">print(s.swapcase())  # HE IS LEARNING python</span><br><span class="line">print(s.capitalize())  # He is learning python</span><br></pre></td></tr></table></figure><ul><li><strong>字符串的对齐：</strong><ul><li><p>center：<strong>中心对齐</strong>，第一个参数指定字符串的宽度，第二个参数指定填充字符</p></li><li><p>ljust：<strong>左对齐</strong>，第一个参数指定字符串的宽度，第二个参数指定填充字符</p></li><li><p>rjust：<strong>右对齐</strong>，第一个参数指定字符串的宽度，第二个参数指定填充字符</p></li><li><p>zfill：<strong>右对齐，左边用0填充</strong>，仅一个参数，用于指定字符串的宽度</p></li><li><p><strong>注意：如果指定的宽度小于等于字符串的长度，则返回字符串本身；且默认填充字符为空格，是可选的</strong></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;HelloWorld&#x27;.center(18, &#x27;*&#x27;))  # ****HelloWorld****</span><br><span class="line">print(&#x27;HelloWorld&#x27;.center(18))  #     HelloWorld    </span><br><span class="line">print(&#x27;HelloWorld&#x27;.center(8))  # HelloWorld</span><br><span class="line"></span><br><span class="line">print(&#x27;HelloWorld&#x27;.ljust(18, &#x27;*&#x27;))  # HelloWorld********</span><br><span class="line">print(&#x27;HelloWorld&#x27;.rjust(18, &#x27;*&#x27;))  # ********HelloWorld</span><br><span class="line"></span><br><span class="line">print(&#x27;578&#x27;.zfill(6), &#x27;578&#x27;.zfill(2))  # 000578 578</span><br><span class="line">print(&#x27;-578&#x27;.zfill(6), &#x27;-578&#x27;.zfill(3))  # -00578 -578</span><br></pre></td></tr></table></figure><ul><li><strong>字符串的子串替换：</strong><ul><li><p><strong>replace：</strong>将字符串中的某个子串替换为指定的字符串</p></li><li><p><strong>使用：</strong>replace可以接受3个参数，参数1指定被替换的子串，参数2指定替换子串的字符串，参数3指定最大替换次数，是可选的</p></li><li><p><strong>注意：该方法返回替换后得到的字符串，替换前的字符串不发生变化</strong></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;Hello-Hello-Hello&#x27;</span><br><span class="line"></span><br><span class="line">print(s.replace(&#x27;Hello&#x27;, &#x27;Hi&#x27;))  # Hi-Hi-Hi</span><br><span class="line">print(s.replace(&#x27;Hello&#x27;, &#x27;Hi&#x27;, 2))  # Hi-Hi-Hello</span><br><span class="line">print(s)  # Hello-Hello-Hello</span><br></pre></td></tr></table></figure><ul><li><strong>字符串的字符转换：</strong><ul><li><p><strong>maketrans + translate：</strong>对字符串中的某些字符进行字符转换，通常用于执行字符替换或删除操作</p></li><li><p>使用：**str.maketrans() <strong>方法用于创建一个字符映射表，该方法接受 3 个参数，参数 1 与参数 2 长度必须相同，用于指定源字符和目标字符的映射关系；参数 3 用于指定字符串中需要删除的字符，是可选的。</strong>text.translate() **方法用于执行实际的字符转换或删除操作</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 以下是三种创建转换表的方式：</span><br><span class="line"># table = str.maketrans(&#123;&#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: &#x27;3&#x27;, &#x27;d&#x27;: &#x27;4&#x27;&#125;)</span><br><span class="line"># table = str.maketrans(&#123;98: 50, 99: 51, 100: 52&#125;)</span><br><span class="line">table = str.maketrans(&#x27;bcd&#x27;, &#x27;234&#x27;)  # 常用</span><br><span class="line">print(table)  # &#123;98: 50, 99: 51, 100: 52&#125;</span><br><span class="line">s = &#x27;incredible&#x27;</span><br><span class="line">print(s.translate(table))  # in3re4i2le</span><br><span class="line"></span><br><span class="line">table = str.maketrans(&#x27;bcd&#x27;, &#x27;234&#x27;, &#x27;ie&#x27;)</span><br><span class="line">print(table)  # &#123;98: 50, 99: 51, 100: 52, 105: None, 101: None&#125;</span><br><span class="line">print(s.translate(table))  # n3r42l</span><br><span class="line"></span><br><span class="line"># 不转换，只指定要删除的所有字符</span><br><span class="line">table = str.maketrans(&#x27;&#x27;, &#x27;&#x27;, &#x27;ie&#x27;)</span><br><span class="line">print(table)  # &#123;105: None, 101: None&#125;</span><br><span class="line">print(s.translate(table))  # ncrdbl</span><br></pre></td></tr></table></figure><ul><li><strong>字符串的劈分与合并：</strong><ul><li><strong>split：</strong>从字符串的左边开始劈分，默认的劈分符是空格字符，返回值是一个列表</li><li><strong>rsplit：</strong>从字符串的右边开始劈分，默认的劈分符是空格字符，返回值是一个列表</li><li>**参数：sep <strong>用于指定劈分符，</strong>maxsplit **用于指定最大劈分次数，在经过最大次劈分后，剩余的子串会单独作为一部分</li><li><strong>注意：split 和 rsplit 的结果的索引都是相同的，它们的区别仅在于分割的顺序不同</strong></li><li><strong>partition：</strong>从字符串的左边第一个劈分符开始劈分，调用时必须指定劈分符，返回值是一个元组</li><li><strong>rpartition：</strong>从字符串的右边第一个劈分符开始劈分，调用时必须指定劈分符，返回值是一个元组</li><li><strong>注意：</strong>方法 partition 和 rpartition 的是将字符串<strong>固定劈分为三部分</strong>，即劈分符 + 被劈分符分开的两部分</li><li><strong>字符串的合并：</strong>调用 join 方法合并多个字符串</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;Python|Swift|Kotlin|Java&#x27;</span><br><span class="line">print(s.split(sep=&#x27;|&#x27;, maxsplit=2))  # [&#x27;Python&#x27;, &#x27;Swift&#x27;, &#x27;Kotlin|Java&#x27;]</span><br><span class="line">print(s.rsplit(sep=&#x27;|&#x27;, maxsplit=2))  # [&#x27;Python|Swift&#x27;, &#x27;Kotlin&#x27;, &#x27;Java&#x27;]</span><br><span class="line"></span><br><span class="line">print(s.partition(&#x27;|&#x27;))  # (&#x27;Python&#x27;, &#x27;|&#x27;, &#x27;Swift|Kotlin|Java&#x27;)</span><br><span class="line">print(s.rpartition(&#x27;|&#x27;))  # (&#x27;Python|Swift|Kotlin&#x27;, &#x27;|&#x27;, &#x27;Java&#x27;)</span><br><span class="line"># 字符串中不存在指定的劈分符时</span><br><span class="line">print(s.partition(&#x27;-&#x27;))  # (&#x27;Python|Swift|Kotlin|Java&#x27;, &#x27;&#x27;, &#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">print(&#x27;|&#x27;.join([&#x27;Python&#x27;, &#x27;Swift&#x27;, &#x27;Kotlin&#x27;]))  # Python|Swift|Kotlin，列表</span><br><span class="line">print(&#x27; &#x27;.join((&#x27;Python&#x27;, &#x27;Swift&#x27;, &#x27;Kotlin&#x27;)))  # Python Swift Kotlin，元组</span><br><span class="line">print(&#x27;|&#x27;.join(&#x27;Python&#x27;))  # P|y|t|h|o|n，可以把字符串看做是字符的列表</span><br></pre></td></tr></table></figure><ul><li><strong>以 is 开头的字符串方法：</strong><ul><li><p>isidentifier：判断指定的字符是否是<strong>合法的标识符</strong></p></li><li><p>iskeyword：判断一个字符串是否是<strong>关键字</strong>（模块keyword中的方法iskeyword）</p></li><li><p>isspace：判断指定字符串是否全部由<strong>空白字符</strong>组成（\t、\r、 、\n都属于空白字符）</p></li><li><p>isalpha：判断指定字符串是否全部由<strong>字母</strong>组成</p></li><li><p>isdecimal：判断指定字符串是否全部由<strong>十进制的数字</strong>组成</p></li><li><p>isnumeric：判断指定字符串是否全部由<strong>数字</strong>组成</p></li><li><p>isalnum：判断指定字符串是否全部由<strong>字母和数字</strong>组成</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import keyword</span><br><span class="line"></span><br><span class="line">print(&#x27;123abc&#x27;.isidentifier())  # False</span><br><span class="line"></span><br><span class="line">print(keyword.iskeyword(&#x27;if&#x27;))  # True</span><br><span class="line">print(keyword.iskeyword(&#x27;IF&#x27;))  # False</span><br><span class="line"></span><br><span class="line">print(&#x27;\t  \r   \n&#x27;.isspace())  # True</span><br><span class="line">print(&#x27;abc&#x27;.isalpha())  # True</span><br><span class="line">print(&#x27;123&#x27;.isdecimal())  # True</span><br><span class="line">print(&#x27;123六Ⅵ&#x27;.isnumeric())  # True，中文数字和罗马数字都算数字</span><br><span class="line">print(&#x27;abc123六Ⅵ&#x27;.isalnum())  # True</span><br></pre></td></tr></table></figure><ul><li><strong>去除字符串的前导字符串或后续字符串方法：</strong><ul><li><p><strong>lstrip：</strong>去除字符串的前导字符串，默认为空格字符串</p></li><li><p><strong>rstrip：</strong>去除字符串的后续字符串，默认为空格字符串</p></li><li><p><strong>strip：</strong>去除字符串的前导字符串和后续字符串，默认均为空格字符串</p></li><li><p><strong>指定参数（可选）：</strong>对于 lstrip 的作用是从左边第1个字符开始依次往后，直到某个字符不在指定的字符串中；对于 rstrip 的作用是从右边第1个字符开始依次往前，直到某个字符不再指定的字符串中</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;    Hello World       &#x27;</span><br><span class="line">print(s.lstrip())  # Hello World       </span><br><span class="line">print(s.rstrip())  #     Hello World</span><br><span class="line">print(s.strip())  # Hello World</span><br><span class="line"></span><br><span class="line">s = &#x27;www.example.com&#x27;</span><br><span class="line">print(s.lstrip(&#x27;cmowz.&#x27;))  # example.com</span><br><span class="line">print(s.rstrip(&#x27;cmowz.&#x27;))  # www.example</span><br><span class="line">print(s.strip(&#x27;cmowz.&#x27;))  # example</span><br></pre></td></tr></table></figure><h2 id="八、字典"><a href="#八、字典" class="headerlink" title="八、字典"></a>八、字典</h2><blockquote><p><strong>字典的特点：</strong></p><ol><li>字典可以根据需要动态地伸缩，系统会根据需要动态地分配和回收内存，因此在使用前无须预先声明字典的容量</li><li>字典会浪费较大的内存，与列表相比，是用空间换取了时间</li></ol><p><strong>总结：字典是无序的、不可重复的（key不可重复，value可以重复）、可变的（key必须是不可变对象）！</strong></p></blockquote><h3 id="1-字典的创建"><a href="#1-字典的创建" class="headerlink" title="1. 字典的创建"></a>1. 字典的创建</h3><ul><li><strong>字典的三种创建方式：</strong><ol><li>使用花括号直接创建，或使用内置函数 dict（类 dict 的构造方法）</li><li>调用 dict 的方法 fromKeys，可以通过参数统一指定所有的 key 或 value 值，value 默认值为None</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(&#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">print(&#123;&#125;)  # &#123;&#125; 空字典</span><br><span class="line"></span><br><span class="line">print(dict(&#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;))  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">print(dict(name=&#x27;Jack&#x27;, age=18))  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">print(dict([(&#x27;name&#x27;, &#x27;Jack&#x27;), (&#x27;age&#x27;, 18)]))  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">print(dict(zip(range(3), &#x27;ABC&#x27;)))  # &#123;0: &#x27;A&#x27;, 1: &#x27;B&#x27;, 2: &#x27;C&#x27;&#125;</span><br><span class="line">print(dict())  # &#123;&#125; 空字典</span><br><span class="line"></span><br><span class="line">print(dict.fromkeys([&#x27;name&#x27;, &#x27;age&#x27;]))  # &#123;&#x27;name&#x27;: None, &#x27;age&#x27;: None&#125;</span><br><span class="line">print(dict.fromkeys((&#x27;name&#x27;, &#x27;age&#x27;)))  # &#123;&#x27;name&#x27;: None, &#x27;age&#x27;: None&#125;</span><br><span class="line">print(dict.fromkeys([&#x27;name&#x27;, &#x27;age&#x27;], &#x27;N/A&#x27;))  # &#123;&#x27;name&#x27;: &#x27;N/A&#x27;, &#x27;age&#x27;: &#x27;N/A&#x27;&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>扩展：调用 setdefault 方法可以为字典中指定的 key 设置默认的 value 值</strong></p><p><strong>目的：</strong>为了确保字典中指定的 key 总是存在的</p><p><strong>作用：</strong>如果指定的 key 不存在于字典中，则会自动创建该键，并将其对应的值设置为提供的默认值；如果指定的键已经存在于字典中，则不会进行任何更改，并返回该键对应的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;&#125;</span><br><span class="line">print(d.setdefault(&#x27;name&#x27;, &#x27;defaultName&#x27;))  # Jack</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;&#125;</span><br><span class="line"></span><br><span class="line">d.clear()  # 调用clear()方法会同时删除字典中的所有键和对应的值</span><br><span class="line">print(d.setdefault(&#x27;name&#x27;, &#x27;defaultName&#x27;))  # defaultName</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;defaultName&#x27;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-字典的查操作"><a href="#2-字典的查操作" class="headerlink" title="2. 字典的查操作"></a>2. 字典的查操作</h3><ol><li><p>使用中括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">print(d[&#x27;name&#x27;])  # Jack</span><br><span class="line"># print(d[&#x27;gender&#x27;])  # KeyError: &#x27;gender&#x27; 不存在指定的key则报错</span><br></pre></td></tr></table></figure></li><li><p>调用方法get</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line"></span><br><span class="line">print(d.get(&#x27;name&#x27;))  # Jack</span><br><span class="line">print(d.get(&#x27;gender&#x27;))  # None 不存在指定的key则返回None</span><br><span class="line">print(d.get(&#x27;gender&#x27;, &#x27;男&#x27;))  # 男 可以通过参数设置默认的value</span><br></pre></td></tr></table></figure></li><li><p>此外，可以使用运算符in（not in）检查字典中是否存在（不存在）指定的key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line"></span><br><span class="line">print(&#x27;age&#x27; in d)  # True</span><br><span class="line">print(&#x27;gender&#x27; in d)  # False</span><br><span class="line">print(&#x27;name&#x27; not in d)  # False</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-字典的改操作"><a href="#3-字典的改操作" class="headerlink" title="3. 字典的改操作"></a>3. 字典的改操作</h3><ol><li><p>为已经存在的key赋予一个新的value值（<strong>一次只修改一个key对应的value</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br><span class="line">d[&#x27;age&#x27;] = 20</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用方法update（<strong>一次至少修改一个key对应的value</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># d.update(&#123;&#x27;name&#x27;: &#x27;Mike&#x27;, &#x27;age&#x27;: 20&#125;)</span><br><span class="line"># d.update([(&#x27;name&#x27;, &#x27;Mike&#x27;), (&#x27;age&#x27;, 20)])</span><br><span class="line">d.update(name=&#x27;Mike&#x27;, age=20)</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Mike&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-字典的增操作"><a href="#4-字典的增操作" class="headerlink" title="4. 字典的增操作"></a>4. 字典的增操作</h3><ol><li><p>为不存在的key赋予一个value值（<strong>一次只添加一个key-value对</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">d[&#x27;gender&#x27;] = &#x27;男&#x27;</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用方法update（<strong>一次至少添加一个key-value对</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line"></span><br><span class="line"># d.update(&#123;&#x27;gender&#x27;: &#x27;男&#x27;, &#x27;score&#x27;: 90&#125;)</span><br><span class="line"># d.update([(&#x27;gender&#x27;, &#x27;男&#x27;), (&#x27;score&#x27;, 90)])</span><br><span class="line">d.update(gender=&#x27;男&#x27;, score=90)</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;score&#x27;: 90&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-字典的删操作"><a href="#5-字典的删操作" class="headerlink" title="5. 字典的删操作"></a>5. 字典的删操作</h3><ol><li><p>调用方法pop，返回值为被删除的value（<strong>一次只删除一个指定key的key-value对</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br><span class="line">print(d.pop(&#x27;age&#x27;))  # 18</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># d.pop(&#x27;score&#x27;)  # KeyError: &#x27;score&#x27; 指定的key不存在，则报错</span><br><span class="line">print(d.pop(&#x27;score&#x27;, 90))  # 90 为了防止报错，可以通过参数指定一个默认返回的value</span><br></pre></td></tr></table></figure></li><li><p>使用del语句（<strong>一次只删除一个指定key的key-value对</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br><span class="line">del d[&#x27;age&#x27;]</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用方法popitem（<strong>一次只删除一任意的key-value对</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br><span class="line">print(d.popitem())  # (&#x27;gender&#x27;, &#x27;男&#x27;)</span><br><span class="line">print(d)  # &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用方法clear（<strong>清空字典</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br><span class="line">d.clear()</span><br><span class="line">print(d)  # &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-字典的视图"><a href="#6-字典的视图" class="headerlink" title="6. 字典的视图"></a>6. 字典的视图</h3><ul><li><p>得到字典相关视图的三个办法（<strong>视图会同步字典的变化</strong>）：</p><ol><li><p>Keys：返回字典所有key的视图</p></li><li><p>Values：返回字典所有value的视图</p></li><li><p>Items：返回字典所有key-value对的视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;Jack&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line"></span><br><span class="line">print(d.keys())  # `dict_keys([&#x27;name&#x27;, &#x27;age&#x27;])`</span><br><span class="line">print(list(d.keys()))  # [&#x27;name&#x27;, &#x27;age&#x27;]</span><br><span class="line">print(list(d.values()))  # [&#x27;Jack&#x27;, 18]</span><br><span class="line">print(list(d.items()))  # [(&#x27;name&#x27;, &#x27;Jack&#x27;), (&#x27;age&#x27;, 18)]</span><br><span class="line"></span><br><span class="line">d.pop(&#x27;age&#x27;)</span><br><span class="line">print(list(d.keys()))  # [&#x27;name&#x27;] 视图会随字典的变化而随之变化</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="7-借助字典创建格式化字符串"><a href="#7-借助字典创建格式化字符串" class="headerlink" title="7. 借助字典创建格式化字符串"></a>7. 借助字典创建格式化字符串</h3><ol><li><p>使用百分号作为占位符</p><ul><li>解释：当格式化字符串中的占位符的值来自于某个字典的value时，可以在占位符中添加一对括号，即**(字典的key)<strong>，在百分号后面直接使用字典名完成赋值（</strong>注意，括号中的值会被隐式添加一对引号，因此，如果字典中key是字符串，则在括号中需要去掉key自带的引号**）</li></ul></li><li><p>使用花括号作为占位符</p><ul><li>与使用百分号作为占位符同理，但需要<strong>调用方法format_map并把该字典直接作为方法的参数</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">phonebook = &#123;&#x27;张三&#x27;: &#x27;13333333333&#x27;,</span><br><span class="line">             &#x27;李四&#x27;: &#x27;14444444444&#x27;,</span><br><span class="line">             &#x27;王五&#x27;: &#x27;15555555555&#x27;,</span><br><span class="line">             &#x27;赵六&#x27;: &#x27;16666666666&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># 两种方式格式化字符串：王五的号码：15555555555，张三的号码：13333333333</span><br><span class="line">print(&#x27;王五的号码：%s，张三的号码：%s&#x27; % (phonebook[&#x27;王五&#x27;], phonebook[&#x27;张三&#x27;]))</span><br><span class="line">print(&#x27;王五的号码：%(王五)s，张三的号码：%(张三)s&#x27; % phonebook)</span><br><span class="line"></span><br><span class="line">print(&#x27;王五的号码：&#123;&#125;，张三的号码：&#123;&#125;&#x27;.format(phonebook[&#x27;王五&#x27;], phonebook[&#x27;张三&#x27;]))</span><br><span class="line">print(&#x27;王五的号码：&#123;王五&#125;，张三的号码：&#123;张三&#125;&#x27;.format_map(phonebook))</span><br></pre></td></tr></table></figure></li></ol><h2 id="九、集合"><a href="#九、集合" class="headerlink" title="九、集合"></a>九、集合</h2><blockquote><p><strong>集合的特点：</strong></p><ol><li>集合，简而言之，即<strong>没有value的字典</strong></li><li><strong>集合存储的数据一定是不可变类型的，所以只有增删查操作，而没有改操作</strong></li><li>集合可以根据需要动态地伸缩，系统会根据需要动态地分配和回收内存，因此在使用前无须预先声明集合的容量</li><li>集合不包含重复元素，内存占用相对较小，适合用于去重操作和快速判断元素是否存在</li></ol><p><strong>集合是无序的、不可重复的（重复则自动剔除）、可变的！</strong></p></blockquote><h3 id="1-集合的创建"><a href="#1-集合的创建" class="headerlink" title="1. 集合的创建"></a>1. 集合的创建</h3><ol><li><p>使用花括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 5, 9, 2, 6&#125;</span><br><span class="line">print(s)  # &#123;2, 3, 5, 6, 9&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">虽然集合是无序的，但Python内部对于小型集合（具有较少元素）通常会进行优化，</span><br><span class="line">使其在输出时以一种类似于排序的方式显示。</span><br><span class="line">这不是真正的排序，而只是一种显示优化，旨在提供更美观和易于阅读的输出。</span><br><span class="line">但这种优化只适用于小型集合，对于大型集合或者在不同环境下，可能不会有相同的顺序。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print(type(&#123;&#125;))  # &lt;class &#x27;dict&#x27;&gt; 不能使用&#123;&#125;表示空集合，因为&#123;&#125;表示空字典</span><br><span class="line">print(&#123;3, 5, 3, 9, 2, 9, 3, 6&#125;)  # &#123;2, 3, 5, 6, 9&#125; 重复被自动剔除</span><br></pre></td></tr></table></figure></li><li><p>调用内置函数set（类set的构造方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(set(range(1, 6)))  # &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">print(set([3, 5, 9, 2, 6]))  # &#123;2, 3, 5, 6, 9&#125;</span><br><span class="line">print(set((3, 5, 9, 2, 6)))  # &#123;2, 3, 5, 6, 9&#125;</span><br><span class="line">print(set(&#123;3, 5, 9, 2, 6&#125;))  # &#123;2, 3, 5, 6, 9&#125;</span><br><span class="line">print(set(&#x27;35926&#x27;))  # &#123;&#x27;9&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;5&#x27;, &#x27;6&#x27;&#125;</span><br><span class="line">print(set())  # set() 空集合</span><br><span class="line">print(set([3, 5, 3, 9, 2, 9, 3, 6]))  # &#123;2, 3, 5, 6, 9&#125; 重复被剔除</span><br></pre></td></tr></table></figure><blockquote><p><strong>对list去重的小技巧</strong>：调用set()函数将list列表转换为set集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [4, 23, 1, 23, 4, 23]</span><br><span class="line">print(set(nums))  # &#123;1, 4, 23&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h3 id="2-集合间的关系"><a href="#2-集合间的关系" class="headerlink" title="2. 集合间的关系"></a>2. 集合间的关系</h3><ol><li><p>两个集合是否相等（使用运算符&#x3D;&#x3D;和!&#x3D;）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;3, 7, 9, 5, 1&#125;</span><br><span class="line"></span><br><span class="line">print(s1 == s2)  # True</span><br><span class="line">print(s1 != s2)  # False</span><br></pre></td></tr></table></figure></li><li><p>一个集合是否是另一个集合的子集（调用方法issubset）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line">s3 = &#123;1, 3, 5, 6, 7, 9&#125;</span><br><span class="line"></span><br><span class="line">print(s1.issubset(s2))  # False</span><br><span class="line">print(s1.issubset(s3))  # True</span><br></pre></td></tr></table></figure></li><li><p>一个集合是否是另一个集合的超集（调用方法issuperset）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line">s3 = &#123;1, 3, 5, 6, 7, 9&#125;</span><br><span class="line"></span><br><span class="line">print(s2.issuperset(s1))  # False</span><br><span class="line">print(s3.issuperset(s1))  # True</span><br></pre></td></tr></table></figure></li><li><p>两个集合是否没有交集（调用方法isdisjoint）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line">s3 = &#123;2, 4, 6, 8, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.isdisjoint(s2))  # False</span><br><span class="line">print(s1.isdisjoint(s3))  # True</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-集合的数学操作"><a href="#3-集合的数学操作" class="headerlink" title="3. 集合的数学操作"></a>3. 集合的数学操作</h3><ol><li><p>交集（调用方法intersection或使用运算符&amp;）</p><ul><li><p>做交集操作后生成一个新集合，做交集操作的两个集合不变</p></li><li><p>也可以调用方法intersection_update，其返回值为None，但会使用intersection的返回值（交集操作后生成的新集合）更新调用者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.intersection(s2))  # &#123;3, 7&#125;</span><br><span class="line">print(s1 &amp; s2)  # &#123;3, 7&#125;</span><br><span class="line">print(s1, s2)  # &#123;1, 3, 5, 7, 9&#125; &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.intersection_update(s2))  # None</span><br><span class="line">print(s1, s2)  # &#123;3, 7&#125; &#123;2, 3, 6, 7, 10&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>并集（调用方法union或使用运算符|）</p><ul><li><p>做并集操作后生成一个新集合，做并集操作的两个集合不变</p></li><li><p>不存在方法union_update</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.union(s2))  # &#123;1, 2, 3, 5, 6, 7, 9, 10&#125;</span><br><span class="line">print(s1 | s2)  # &#123;1, 2, 3, 5, 6, 7, 9, 10&#125;</span><br><span class="line">print(s1, s2)  # &#123;1, 3, 5, 7, 9&#125; &#123;2, 3, 6, 7, 10&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>差集（调用方法difference或使用运算符-）</p><ul><li><p>做差集操作后生成一个新集合，做差集操作的两个集合不变</p></li><li><p>也可以调用方法difference_update，其返回值为None，但会使用difference的返回值（差集操作后生成的新集合）更新调用者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.difference(s2))  # &#123;1, 5, 9&#125;</span><br><span class="line">print(s1 - s2)  # &#123;1, 5, 9&#125;</span><br><span class="line">print(s1, s2)  # &#123;1, 3, 5, 7, 9&#125; &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.difference_update(s2))  # None</span><br><span class="line">print(s1, s2)  # &#123;1, 5, 9&#125; &#123;2, 3, 6, 7, 10&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对称差集（调用方法symmetric_difference或使用运算符^）</p><ul><li><p>做对称差集操作后生成一个新集合，做对称差集操作的两个集合不变</p></li><li><p>也可以调用方法symmetric_difference_update，其返回值为None，但会使用symmetric_difference的返回值更新调用者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">s2 = &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.symmetric_difference(s2))  # &#123;1, 2, 5, 6, 9, 10&#125;</span><br><span class="line">print(s1 ^ s2)  # &#123;1, 2, 5, 6, 9, 10&#125;</span><br><span class="line">print(s1, s2)  # &#123;1, 3, 5, 7, 9&#125; &#123;2, 3, 6, 7, 10&#125;</span><br><span class="line"></span><br><span class="line">print(s1.symmetric_difference_update(s2))  # None</span><br><span class="line">print(s1, s2)  # &#123;1, 2, 5, 6, 9, 10&#125; &#123;2, 3, 6, 7, 10&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="4-集合的查操作"><a href="#4-集合的查操作" class="headerlink" title="4. 集合的查操作"></a>4. 集合的查操作</h3><ul><li><p>可以使用运算符in（not in）检查集合中是否存在（不存在）指定的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 4, 5, 6, 7&#125;</span><br><span class="line"></span><br><span class="line">print(5 in s)  # True</span><br><span class="line">print(8 in s)  # False</span><br><span class="line">print(5 not in s)  # False</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-集合的增操作"><a href="#5-集合的增操作" class="headerlink" title="5. 集合的增操作"></a>5. 集合的增操作</h3><ol><li><p>调用方法add（<strong>一次只添加一个元素</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 4, 5, 6, 7&#125;</span><br><span class="line">s.add(8)</span><br><span class="line">print(s)  # &#123;3, 4, 5, 6, 7, 8&#125;</span><br><span class="line">s.add(8)  # 集合中已存在的元素不会被添加</span><br><span class="line">print(s)  # &#123;3, 4, 5, 6, 7, 8&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用方法update（<strong>一次至少添加一个元素</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 4, 5, 6, 7&#125;</span><br><span class="line"># s.update(&#123;2, 8&#125;)</span><br><span class="line"># s.update([2, 8])</span><br><span class="line">s.update((2, 8, 5, 7))  # 集合中已存在的元素不会被添加</span><br><span class="line">print(s)  # &#123;2, 3, 4, 5, 6, 7, 8&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-集合的删操作"><a href="#6-集合的删操作" class="headerlink" title="6. 集合的删操作"></a>6. 集合的删操作</h3><ol><li><p>调用方法remove（<strong>一次只删除一个指定的元素</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 4, 5, 6, 7&#125;</span><br><span class="line">s.remove(5)</span><br><span class="line">print(s)  # &#123;3, 4, 6, 7&#125;</span><br><span class="line"># s.remove(8)  # 若指定的元素不存在，则会报错</span><br></pre></td></tr></table></figure></li><li><p>调用方法discard（<strong>一次只删除一个指定的元素</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 4, 5, 6, 7&#125;</span><br><span class="line">s.discard(5)</span><br><span class="line">print(s)  # &#123;3, 4, 6, 7&#125;</span><br><span class="line">s.discard(8)  # 与方法remove不同的是：若指定的元素不存在，不会报错</span><br><span class="line">print(s)  # &#123;3, 4, 6, 7&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用方法pop（<strong>一次只删除一个任意的元素</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 4, 5, 6, 7&#125;</span><br><span class="line">print(s.pop())  # 3 改方法返回被删除的元素</span><br><span class="line">print(s)  # &#123;4, 5, 6, 7&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用方法clear（<strong>清空集合</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;3, 4, 5, 6, 7&#125;</span><br><span class="line">s.clear()</span><br><span class="line">print(s)  # set()</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-不可变集合frozenset"><a href="#7-不可变集合frozenset" class="headerlink" title="7. 不可变集合frozenset"></a>7. 不可变集合frozenset</h3><ul><li><p>可变性：不可变集合 (frozenset) 是不可变的数据结构，一旦创建后就不能再修改，不能添加、删除或更新元素（<strong>frozenset之于set就好比tuple之于list</strong>）</p></li><li><p>哈希性：不可变集合 (frozenset) 是可哈希的，因为它是不可变的，可以作为字典的key或<strong>其他集合中的元素（集合中存储的数据一定是不可变类型的）</strong></p></li><li><p>frozenset对象的创建：调用内置函数frozenset（类frozenset的构造方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(frozenset())  # frozenset()</span><br><span class="line">print(frozenset(range(1, 6)))  # frozenset(&#123;1, 2, 3, 4, 5&#125;)</span><br><span class="line">print(frozenset([3, 5, 9, 2, 6]))  # frozenset(&#123;2, 3, 5, 6, 9&#125;)</span><br><span class="line">print(frozenset((3, 5, 9, 2, 6)))  # frozenset(&#123;2, 3, 5, 6, 9&#125;)</span><br><span class="line">print(frozenset(&#123;3, 5, 9, 2, 6&#125;))  # frozenset(&#123;2, 3, 5, 6, 9&#125;)</span><br><span class="line">print(frozenset(&#x27;35926&#x27;))  # frozenset(&#123;&#x27;6&#x27;, &#x27;2&#x27;, &#x27;9&#x27;, &#x27;5&#x27;, &#x27;3&#x27;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="十、流程控制"><a href="#十、流程控制" class="headerlink" title="十、流程控制"></a>十、流程控制</h2><blockquote><p><strong>任何简单或复杂的算法都可以由顺序结构、选择结构和循环结构这三种基本结构组合而成</strong></p><ul><li>顺序结构：程序从上到下顺序地执行代码，中间没有任何判断和跳转，直到程序结束</li><li>选择结构：程序根据判断条件的布尔值选择性地执行部分代码</li><li>循环结构：程序根据循环条件反复执行某段代码，直到不满足循环条件为止</li></ul></blockquote><h3 id="1-对象的布尔值"><a href="#1-对象的布尔值" class="headerlink" title="1. 对象的布尔值"></a>1. 对象的布尔值</h3><ul><li><p>任何对象都可被直接用作布尔值，解释器会自动调用内置函数bool进行转换</p></li><li><p><strong>以下对象的布尔值为Flase：False、数值零、None、空字符串、空列表、空元组、空字典、空集合</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(bool(False))  # False</span><br><span class="line">print(bool(0))  # False</span><br><span class="line">print(bool(None))  # False</span><br><span class="line">print(bool(&#x27;&#x27;))  # False</span><br><span class="line">print(bool(&#123;&#125;))  # False</span><br><span class="line"></span><br><span class="line">if &#x27; &#x27;:  # 注意：空格字符串不是空字符串，其值True</span><br><span class="line">    print(18, True)  # 18 True</span><br></pre></td></tr></table></figure><h3 id="2-if语句"><a href="#2-if语句" class="headerlink" title="2. if语句"></a>2. if语句</h3><ul><li>语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">    if语句的语法格式（其中elif和else均是可选的）：</span><br><span class="line">if 判断条件1:</span><br><span class="line">    条件执行体1</span><br><span class="line">elif 判断条件2:</span><br><span class="line">    条件执行体2</span><br><span class="line">elif 判断条件3:</span><br><span class="line">    条件执行体3</span><br><span class="line">......</span><br><span class="line">elif 判断条件n-1:</span><br><span class="line">    条件执行体n-1</span><br><span class="line">else:</span><br><span class="line">    条件执行体n</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">score = 88</span><br><span class="line"></span><br><span class="line">if score &lt; 60:</span><br><span class="line">    print(&#x27;没过60&#x27;)</span><br><span class="line">elif score &lt; 70:</span><br><span class="line">    print(&#x27;过60啦&#x27;)</span><br><span class="line">elif score &lt; 80:</span><br><span class="line">    print(&#x27;过70啦&#x27;)</span><br><span class="line">elif score &lt; 90:</span><br><span class="line">    print(&#x27;过80啦&#x27;)  # 过80啦</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;过90啦&#x27;)</span><br></pre></td></tr></table></figure><h3 id="3-条件表达式"><a href="#3-条件表达式" class="headerlink" title="3. 条件表达式"></a>3. 条件表达式</h3><ul><li><p>条件表达式是包含if-else语句的表达式，类似于C语言中的三目运算符</p></li><li><p>语法格式：<strong>x if 判断条件 else y</strong></p></li><li><p>运算规则：如果判断条件的布尔值为True，则整个式子返回值为x；否则，返回值为y</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">score = 88</span><br><span class="line">result = &#x27;及格了&#x27; if score &gt;= 60 else &#x27;没及格&#x27;</span><br><span class="line">print(result)  # 及格了</span><br><span class="line"></span><br><span class="line">a = 6</span><br><span class="line">b = 8</span><br><span class="line"># 嵌套条件表达式的解析一定是先看外层，由外向内解析</span><br><span class="line">print(&#x27;a大于b&#x27; if a &gt; b else (&#x27;a小于b&#x27; if a &lt; b else &#x27;a等于b&#x27;))  # a小于b</span><br></pre></td></tr></table></figure><h3 id="4-while语句"><a href="#4-while语句" class="headerlink" title="4. while语句"></a>4. while语句</h3><ul><li>语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">初始化部分</span><br><span class="line">while 循环条件:</span><br><span class="line">    循环体</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>while-True-break结构</strong>：通过while True构造一个无限循环，在循环体中满足某个条件时通过break退出循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    word = input(&#x27;请输入一个单词:&#x27;)</span><br><span class="line">    print(type(word))  # input接受到任何东西都会转换成字符型，只有空字符才是False</span><br><span class="line">    if not word: break</span><br><span class="line">    print(&#x27;输入的单词是:&#x27;, word)</span><br></pre></td></tr></table></figure><h3 id="5-for-in语句"><a href="#5-for-in语句" class="headerlink" title="5. for-in语句"></a>5. for-in语句</h3><ul><li>语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 当迭代次数已知时，推荐使用for-in语句；当迭代次数未知时，推荐使用while语句</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">for 自定义的变量 in 要遍历的可迭代对象</span><br><span class="line">    循环体</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>注意：如果循环体内不需要访问自定义的变量，可以将自定义的变量替代为下划线_</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 遍历range、列表、元素、字符串等序列</span><br><span class="line">for number in range(1, 4):</span><br><span class="line">    print(number)  # 1 2 3</span><br><span class="line"></span><br><span class="line">for _ in range(1, 4):</span><br><span class="line">    print(&#x27;Hello&#x27;)  # Hello Hello Hello</span><br><span class="line"></span><br><span class="line">for char in &#x27;123&#x27;:</span><br><span class="line">    print(char)  # 1 2 3</span><br><span class="line"></span><br><span class="line"># 在遍历序列的过程中，如果需要对序列进行修改，最好先通过切片操作生成一份序列的拷贝</span><br><span class="line">words = [&#x27;Java&#x27;, &#x27;Python&#x27;, &#x27;Kotlin&#x27;, &#x27;Swift&#x27;, &#x27;Go&#x27;]</span><br><span class="line">for word in words[:]:</span><br><span class="line">    if len(word) &lt; 5:</span><br><span class="line">        words.remove(word)</span><br><span class="line">print(words)  # [&#x27;Python&#x27;, &#x27;Kotlin&#x27;, &#x27;Swift&#x27;]</span><br><span class="line"></span><br><span class="line"># 遍历集合，使用sorted排序不改变集合本身，set无sort()方法</span><br><span class="line">s = &#123;2, 3, 1&#125;</span><br><span class="line">for number in sorted(s):</span><br><span class="line">    print(number)  # 1 2 3</span><br><span class="line"></span><br><span class="line"># &quot;自定义的变量自动被赋予当前迭代的元素值&quot;中的&quot;元素值&quot;指的是字典的key</span><br><span class="line">d = &#123;&#x27;Fruits&#x27;: 86, &#x27;Books&#x27;: 88, &#x27;Videos&#x27;: 83&#125;</span><br><span class="line">for elem in d:</span><br><span class="line">    print(elem)  # Fruits Books Videos</span><br><span class="line">for key in d.keys():</span><br><span class="line">    print(key)  # Fruits Books Videos</span><br><span class="line">for value in d.values():</span><br><span class="line">    print(value)  # 86 88 83</span><br><span class="line">for key, value in d.items():</span><br><span class="line">    print(key, &#x27;-&gt;&#x27;, value)  # Fruits -&gt; 86   Books -&gt; 88   Videos -&gt; 83</span><br></pre></td></tr></table></figure><h3 id="6-enumerate对象的遍历"><a href="#6-enumerate对象的遍历" class="headerlink" title="6. enumerate对象的遍历"></a>6. enumerate对象的遍历</h3><ul><li><p>作用：在遍历序列的过程中需要访问元素的索引</p></li><li><p>方法：调用内置函数enumerate（类enumerate的构造方法），将要遍历的对象转换为enumerate对象</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L = [&#x27;Java&#x27;, &#x27;Python&#x27;, &#x27;Swift&#x27;, &#x27;Kotlin&#x27;]</span><br><span class="line"></span><br><span class="line">print(enumerate(L))  # &lt;enumerate object at 0x10089f980&gt;</span><br><span class="line">print(list(enumerate(L)))  # [(0, &#x27;Java&#x27;), (1, &#x27;Python&#x27;), (2, &#x27;Swift&#x27;), (3, &#x27;Kotlin&#x27;)]</span><br><span class="line"># 可以通过第二个参数指定索引的起始值</span><br><span class="line">print(list(enumerate(L, 1)))  # [(1, &#x27;Java&#x27;), (2, &#x27;Python&#x27;), (3, &#x27;Swift&#x27;), (4, &#x27;Kotlin&#x27;)]</span><br><span class="line"></span><br><span class="line"># 可以直接遍历enumerate对象，也可以遍历enumerate对象转换后的列表</span><br><span class="line">for index, item in enumerate(L):</span><br><span class="line">    print(f&#x27;L[&#123;index&#125;] = &#123;item&#125;&#x27;)  # L[0] = Java L[1] = Python L[2] = Swift L[3] = Kotlin</span><br><span class="line"></span><br><span class="line">for index, item in list(enumerate(L)):</span><br><span class="line">    print(f&#x27;L[&#123;index&#125;] = &#123;item&#125;&#x27;)  # L[0] = Java L[1] = Python L[2] = Swift L[3] = Kotlin</span><br></pre></td></tr></table></figure><h3 id="7-break-else结构"><a href="#7-break-else结构" class="headerlink" title="7. break-else结构"></a>7. break-else结构</h3><ul><li>作用：需要在循环正常结束后执行某些操作</li><li>执行：循环中如果没有执行循环体中的break语句，即没有因为break提前退出循环，则会执行else从句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = 0</span><br><span class="line">while n &lt; 5:</span><br><span class="line">    if n == 6:</span><br><span class="line">        break</span><br><span class="line">    n += 1</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;循环正常结束，没有执行循环体中的break语句，else部分会输出&#x27;)</span><br><span class="line"></span><br><span class="line">for n in range(5):</span><br><span class="line">    if n == 4:</span><br><span class="line">        break</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;循环因为break提前退出循环，而没有正常结束，else部分不会输出&#x27;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>break与continue</strong></p><ol><li>在嵌套的循环语句中，break和continue默认作用于当前循环</li><li>break用于结束整个循环，continue用于结束循环中的当前迭代，继续下一个迭代</li></ol></blockquote><h2 id="十一、常用内置函数"><a href="#十一、常用内置函数" class="headerlink" title="十一、常用内置函数"></a>十一、常用内置函数</h2><h3 id="1-内置函数zip"><a href="#1-内置函数zip" class="headerlink" title="1. 内置函数zip"></a>1. 内置函数zip</h3><ul><li>作用：<strong>并行遍历</strong>。将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的类</li></ul><ul><li><strong>注意：如果两个可迭代对象的长度不同，那么较长的会被截断；可以使用*对zip对象解压，返回二维矩阵式</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Jack&#x27;, &#x27;Mike&#x27;, &#x27;Tom&#x27;]</span><br><span class="line">ages = [16, 32, 43]</span><br><span class="line"></span><br><span class="line">print(zip(names, ages))  # `&lt;zip object at 0x1032cb9c0&gt;` 压缩</span><br><span class="line">print(list(zip(names, ages)))  # [(&#x27;Jack&#x27;, 16), (&#x27;Mike&#x27;, 32), (&#x27;Tom&#x27;, 43)]</span><br><span class="line"></span><br><span class="line"># 既可以直接遍历zip对象，也可以遍历zip对象转换后的列表</span><br><span class="line">for name, age in zip(names, ages):</span><br><span class="line">    print(name, age)  # Jack 16   Mike 32   Tom 43</span><br><span class="line">for name, age in list(zip(names, ages)):</span><br><span class="line">    print(name, age)  # Jack 16   Mike 32   Tom 43</span><br><span class="line"></span><br><span class="line">print(list(zip(range(3), range(5))))  # [(0, 0), (1, 1), (2, 2)] 按短的标准</span><br><span class="line"></span><br><span class="line">print(zip(*zip(names, ages)))  # &lt;zip object at 0x10098fac0&gt; 解压</span><br><span class="line">print(list(zip(*zip(names, ages))))  # [(&#x27;Jack&#x27;, &#x27;Mike&#x27;, &#x27;Tom&#x27;), (16, 32, 43)]</span><br><span class="line">x, y = zip(*zip(names, ages))</span><br><span class="line">print(x, y)  # (&#x27;Jack&#x27;, &#x27;Mike&#x27;, &#x27;Tom&#x27;) (16, 32, 43)</span><br></pre></td></tr></table></figure><h3 id="2-内置函数map"><a href="#2-内置函数map" class="headerlink" title="2. 内置函数map"></a>2. 内置函数map</h3><ul><li><p>作用：会使用指定的函数名作用于指定的可迭代对象的<strong>每个元素</strong>，然后<strong>生成新的可迭代对象</strong></p></li><li><p>参数：参数1指定函数名，参数2指定可迭代对象</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(map(ord, &#x27;abcd&#x27;))  # &lt;map object at 0x100cc7d90&gt;</span><br><span class="line">print(list(map(ord, &#x27;abcd&#x27;)))  # [97, 98, 99, 100]</span><br><span class="line"></span><br><span class="line">print(map(str.upper, &#x27;abcd&#x27;))  # &lt;map object at 0x100cc7d90&gt;</span><br><span class="line">print(list(map(str.upper, &#x27;abcd&#x27;)))  # [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;]</span><br><span class="line">for i in map(str.upper, &#x27;abcd&#x27;):</span><br><span class="line">    print(i)  # A B C D</span><br></pre></td></tr></table></figure><h3 id="3-内置函数Filter"><a href="#3-内置函数Filter" class="headerlink" title="3. 内置函数Filter"></a>3. 内置函数Filter</h3><ul><li><p>作用：<strong>与内置函数map相似</strong>，会使用指定的函数名作用于指定的可迭代对象的每个元素，<strong>同时过滤掉函数返回值为False的相关元素</strong>，然后生成新的可迭代对象</p></li><li><p>参数：参数1指定函数名，参数2指定可迭代对象</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = filter(str.isalpha, &#x27;123abc&#x27;)</span><br><span class="line">print(result)  # `&lt;filter object at 0x10487aef0&gt;`</span><br><span class="line"># print(list(result))  # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line">for i in result:</span><br><span class="line">    print(i)  # a b c</span><br></pre></td></tr></table></figure><h2 id="十二、生成式"><a href="#十二、生成式" class="headerlink" title="十二、生成式"></a>十二、生成式</h2><blockquote><p>由于累计基础知识在此阶段掌握并不足以理解<strong>元组生成式</strong>，所以以下暂时没有关于<strong>元组生成式</strong>的记录；</p><p>并在后续将其记录在了《Python_2_高级语法》的 <a class="link"   href="https://xfblog.cn/2023/05/01/Python_2_%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/#%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"  target="_blank" rel="noopener">五、生成器与迭代器<i class="fas fa-external-link-alt"></i></a> 中。</p></blockquote><h3 id="1-列表生成式"><a href="#1-列表生成式" class="headerlink" title="1. 列表生成式"></a>1. 列表生成式</h3><ul><li><p>语法格式：**[ 表示列表元素的表达式 for 自定义的变量 in 可迭代对象 [if语句] ]**</p><ul><li>其中，”表示列表元素的表达式”中通常包含”自定义的变量”</li></ul></li><li><p>使用规则：凡是可以通过for-in循环创建的列表，均可以使用列表生成式来创建</p><ul><li><p>列表生成式中可以使用双重循环</p></li><li><p>列表生成式支持嵌套，即一个列表生成式中嵌套另一个列表生成式</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">L = [i * i for i in range(1, 7)]  # 简单的列表生成式</span><br><span class="line">print(L)  # [1, 4, 9, 16, 25, 36]</span><br><span class="line"></span><br><span class="line">L = [i * i for i in range(1, 7) if not i % 2]  # 增加了if语句，限制偶数</span><br><span class="line">print(L)  # [4, 16, 36]</span><br><span class="line"></span><br><span class="line">L = [(i, j) for i in range(1, 4) for j in range(5, 8)]  # 双重循环</span><br><span class="line">print(L)  # [(1, 5), (1, 6), (1, 7), (2, 5), (2, 6), (2, 7), (3, 5), (3, 6), (3, 7)]</span><br><span class="line">L = [(i, j) for i in range(1, 4) for j in range(1, 4) if i != j]</span><br><span class="line">print(L)  # [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]</span><br><span class="line"></span><br><span class="line">matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]</span><br><span class="line">L = [[row[i] for row in matrix] for i in range(4)]  # 列表生成式的嵌套</span><br><span class="line">print(L)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br><span class="line">&quot;&quot;&quot;追根溯源回去：</span><br><span class="line">L = []</span><br><span class="line">for i in range(4):</span><br><span class="line">    L_row = []</span><br><span class="line">    for row in matrix:</span><br><span class="line">        L_row.append(row[i])</span><br><span class="line">    L.append(L_row)</span><br><span class="line">print(L)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br><span class="line">由结果来看：外层循环变量是i，内层循环变量是row</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="2-集合生成式"><a href="#2-集合生成式" class="headerlink" title="2. 集合生成式"></a>2. 集合生成式</h3><ul><li>语法格式：**{ 表示集合元素的表达式 for 自定义的变量 in 可迭代对象 [if语句] }**<ul><li>其中，”表示集合元素的表达式”中通常包含”自定义的变量”</li><li>与列表生成式其余用法均相同，唯一的不同是使用花括号创建</li></ul></li></ul><h3 id="3-字典生成式"><a href="#3-字典生成式" class="headerlink" title="3. 字典生成式"></a>3. 字典生成式</h3><ul><li><p>语法格式：**{ 表示字典key的表达式: 表示字典value的表达式 for 自定义的表示key的变量, 自定义的表示value的变量 in 可迭代对象 [if语句] }**</p><ul><li><p>其中，”表示字典key的表达式”中通常包含”自定义的表示key的变量”，”表示字典value的表达式”中通常包含”自定义的表示value的变量”</p></li><li><p>与列表生成式其余用法均相同，不同是使用花括号创建，且使用key:value表示</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">items = [&#x27;Fruits&#x27;, &#x27;Books&#x27;, &#x27;Others&#x27;]</span><br><span class="line">prices = [96, 78, 83]</span><br><span class="line"></span><br><span class="line">d = &#123;k: v for k, v in zip(items, prices)&#125;  # 简单的字典生成式</span><br><span class="line">print(d)  # &#123;&#x27;Fruits&#x27;: 96, &#x27;Books&#x27;: 78, &#x27;Others&#x27;: 83&#125;</span><br><span class="line"></span><br><span class="line">d = &#123;item.upper(): price for item, price in zip(items, prices) if price &gt; 80&#125;</span><br><span class="line">print(d)  # &#123;&#x27;FRUITS&#x27;: 96, &#x27;OTHERS&#x27;: 83&#125;  # 复杂的字典生成式</span><br><span class="line"></span><br><span class="line">d = &#123;i: j for i in range(1, 4) for j in range(1, 4)&#125;  # 双重循环</span><br><span class="line">print(d)  # &#123;1: 3, 2: 3, 3: 3&#125;</span><br><span class="line">&quot;&quot;&quot;追根溯源回去：</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">for i in range(1, 4):</span><br><span class="line">    for j in range(1, 4):</span><br><span class="line">        d[i] = j</span><br><span class="line"></span><br><span class="line">print(d)  # &#123;1: 3, 2: 3, 3: 3&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">d = &#123;i: j for i in range(1, 4) for j in range(1, 4) if i != j&#125;</span><br><span class="line">print(d)  # &#123;1: 3, 2: 3, 3: 2&#125;</span><br><span class="line">&quot;&quot;&quot;原理：key是不可重复的，一个新的value值会覆盖原来的value值&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Python简介：&lt;/strong&gt;Python是由荷兰数学和计算机科学研究学会的吉多·范罗苏姆于1990年代初设计，作为一门叫做ABC语言的替代品。Python提供了高效的高级数据结构，还能简单有效地面向对象编程。Python语法</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据库</title>
    <link href="http://example.com/2023/03/01/Database_Redis/"/>
    <id>http://example.com/2023/03/01/Database_Redis/</id>
    <published>2023-02-28T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Redis数据库"><a href="#一、Redis数据库" class="headerlink" title="一、Redis数据库"></a>一、Redis数据库</h2><blockquote><p><strong>Redis数据库和MySQL数据库的区别:</strong></p><ul><li><strong>mysql是将数据存储在磁盘中的，而redis是将数据存在内存中的</strong></li></ul><ul><li><strong>mysql：3306</strong></li><li><strong>redis：6379</strong></li></ul><ul><li><strong>mongodb：27017</strong></li></ul></blockquote><ul><li>简介：Redis（Remote Dictionary Server）是一种开源、高性能、<strong>内存存储的键值数据库</strong>。它支持多种数据结构，如字符串、列表、集合、有序集合、散列和发布订阅，使其成为一个多用途的数据库和缓存系统</li><li><strong>说明：</strong><ol><li><strong>redis没有数据表和数据库的概念，redis默认有16个仓库，可以将数据分别存储在16个仓库中的任意一个，默认情况下redis位于0号库</strong></li><li><strong>redis是以键值对的形式存储数据的，且存储数据是按照二进制的模式进行存储的，即redis中储存的任意数据全部都是string字符串类型的（二进制字符）</strong></li></ol></li><li><strong>服务器端命令：</strong><ul><li><strong>启动redis服务：<code>redis-server</code></strong></li><li><strong>查看redis服务器进程：<code>ps aux | grep redis</code></strong></li><li><strong>杀死redis服务器：<code>sudo kill -9 pid</code></strong></li></ul></li><li><strong>客户端命令：</strong><ul><li><strong>连接到redis服务器：<code>redis-cli</code> 或者 <code>redis-cli -h hostname -p port</code></strong></li><li><strong>测试redis服务器连接是否正常：<code>ping</code>，正常则返回<code>PONG</code></strong></li></ul></li><li><strong>存储一个字符串并设置过期时间（最常用）：<code>set key seconds value</code></strong></li><li>redis命令手册：<a class="link"   href="https://www.redis.net.cn/order/"  target="_blank" rel="noopener">https://www.redis.net.cn/order/<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><blockquote><p>键命令：</p><ul><li>切换仓库命令：**<code>select 仓库编号</code>**</li><li>查询指定的key对应的value的类型：**<code>type key</code>**</li></ul></blockquote><h3 id="1-字符串string"><a href="#1-字符串string" class="headerlink" title="1. 字符串string"></a>1. 字符串string</h3><ul><li>存储：**<code>set key value</code>**<ul><li>批量存储：**<code>mset key1 val1 key2 val2 ...</code>**</li><li>设置过期时间：**<code>setex key seconds value</code>**</li></ul></li><li>获取：**<code>get key</code>**<ul><li>批量获取：**<code>mget key1 key2 ...</code>**</li><li>获取所有存在的key：**<code>keys *</code>**</li><li>根据key单词首字母选择查询：**<code>keys n*</code>**</li></ul></li><li>修改（即覆盖）：**<code>set key new_value</code>**</li><li>判断key是否存在（可多个）：**<code>exists key1 key2 ...</code>**</li><li>删除键值对（可多个）：**<code>del key1 key2 ...</code>**</li></ul><h3 id="2-散列hash"><a href="#2-散列hash" class="headerlink" title="2. 散列hash"></a>2. 散列hash</h3><ul><li><p>设置字段值：**<code>hset key field value</code>**</p><ul><li>批量设置：**<code>hmset key1 field1 value1 field2 value2 ...</code>**</li></ul></li><li><p>获取字段值：**<code>hget key field</code>**</p><ul><li><p>批量获取字段值：**<code>hmget key filed1 field2 ...</code>**</p></li><li><p>获取所有字段：**<code>hkeys key</code>**</p></li><li><p>不通过key直接获取所有字段值：**<code>hvals key</code>**</p></li><li><p>获取所有字段和值：**<code>hgetall key</code>**</p></li></ul></li><li><p>删除字段：**<code>hdel key field1 field2 ...</code>**</p><ul><li>删除整个hash：**<code>del key</code>**</li></ul></li></ul><h3 id="3-列表list"><a href="#3-列表list" class="headerlink" title="3. 列表list"></a>3. 列表list</h3><ul><li>左插入：**<code>lpush key value1 value2 ...</code>**（左插入，数据倒序）</li><li>右插入：**<code>rpush key value1 value2 ...</code>**（右插入，数据顺序，常用）</li><li>获取数据（<strong>只有左获取</strong>）：**<code>lrange key start stop</code><strong>（</strong>左闭右闭区间，区别python中的左闭右开**）</li><li>删除指定元素：**<code>lrem key count value</code>**<ul><li>count &gt; 0：从左往右删</li><li>count &lt; 0：从右往左删</li><li>count &#x3D; 0：删除所有</li></ul></li><li>删除列表：<code>del key</code></li></ul><h3 id="4-集合set"><a href="#4-集合set" class="headerlink" title="4. 集合set"></a>4. 集合set</h3><ul><li>添加元素：**<code>sadd key[:folder] member1 member2 ...</code><strong>（</strong>加上<code>:folder</code>则表示创建一个名为key的文件夹**）</li><li>查询元素：**<code>smembers key</code>**</li><li>删除元素：**<code>srem key member1 member2 ...</code>**</li><li>检查成员是否存在：**<code>sismember key member</code>**</li><li>删除集合：<code>del key</code></li></ul><h3 id="5-有序集合sorted-set"><a href="#5-有序集合sorted-set" class="headerlink" title="5. 有序集合sorted set"></a>5. 有序集合sorted set</h3><ul><li>添加元素：**<code>zadd key score1 member1 score2 member2 ...</code>**</li><li>查询元素：**<code>zrange key start stop</code>**</li><li>获取成员的分数（<strong>权重</strong>）：**<code>zscore key member</code>**</li><li>按分数范围获取元素：**<code>zrangebyscore key min max</code>**（左闭右闭区间）</li><li>删除元素：**<code>zrem key member1 member2 ...</code>**</li><li>删除有序集合：<code>del key</code></li></ul><h2 id="三、Python操作Redis"><a href="#三、Python操作Redis" class="headerlink" title="三、Python操作Redis"></a>三、Python操作Redis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from redis import Redis</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        # 连接本地redis数据库时，可以不用指定参数，因为其参数都有默认值</span><br><span class="line">        redis_cli = Redis()</span><br><span class="line">        # python中封装的方法名和redis中的方法基本一致</span><br><span class="line">        redis_cli.set(&#x27;name&#x27;, &#x27;黑魔仙&#x27;)</span><br><span class="line">        # python中使用utf-8，mysql中使用utf8</span><br><span class="line">        result = redis_cli.get(&#x27;name&#x27;).decode(&#x27;utf-8&#x27;)  # 解码</span><br><span class="line">        print(result)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;异常捕获：&#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Redis数据库&quot;&gt;&lt;a href=&quot;#一、Redis数据库&quot; class=&quot;headerlink&quot; title=&quot;一、Redis数据库&quot;&gt;&lt;/a&gt;一、Redis数据库&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Redis数据库和MySQL数据库</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 数据库</title>
    <link href="http://example.com/2023/02/01/Database_MongoDB/"/>
    <id>http://example.com/2023/02/01/Database_MongoDB/</id>
    <published>2023-01-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MongoDB数据库"><a href="#一、MongoDB数据库" class="headerlink" title="一、MongoDB数据库"></a>一、MongoDB数据库</h2><blockquote><p>MongoDB 是一个流行的 NoSQL 数据库，它以文档为基础的方式存储数据，不需要事先定义库表结构</p><p>MongoDB 中的指令结尾一般不加分号</p></blockquote><h3 id="1-基础指令"><a href="#1-基础指令" class="headerlink" title="1. 基础指令"></a>1. 基础指令</h3><ul><li>进入mongo数据库交互环境：**<code>mongosh</code>**</li></ul><h3 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h3><blockquote><p><strong>db对象：代表当前进入的数据库，删除数据库时，也要先进入数据库</strong></p></blockquote><ul><li><p>查询已存在的数据库：**<code>show dbs</code>** 或 <strong><code>show databases</code></strong></p></li><li><p>进入到指定数据库中：**<code>use db_name</code>**</p><ul><li><strong>注意：在mongodb数据库中，没有新建数据库的指令，可以使用use直接进入需要新建的数据库，mongo会自动创建。此时只是先创建一个虚拟数据库并进入，只有当数据库中存在具体数据时，才会真正创建此数据库</strong>（<strong>集合也是一样的机制</strong>）</li></ul></li><li><p>删除数据库：**<code>db.dropDatabase()</code>**</p></li><li><p>查询当前位于的数据库：**<code>db</code>**</p></li></ul><h3 id="3-集合操作"><a href="#3-集合操作" class="headerlink" title="3. 集合操作"></a>3. 集合操作</h3><blockquote><p>MongoDB中的数据表通常被称为”集合”（Collection），而不是传统关系型数据库中的”表”。</p><p>MongoDB的数据模型使用文档来组织数据，这些文档以JSON样式的BSON格式存储在集合中。</p><p>MongoDB中，集合的命名是大小写敏感的。</p></blockquote><ul><li><p>查询当前数据库中的所有集合：**<code>show tables</code>** 或 <strong><code>show collections</code></strong></p></li><li><p><strong>自动创建集合（即直接使用）</strong></p></li><li><p>手动创建集合：**<code>db.createCollection(set_name, options)</code>**</p></li><li><p>删除集合：**<code>db.集合名称.drop()</code>**</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 自动创建集合：向不存在的集合中第一次加入数据时，集合会被创建出来</span><br><span class="line"></span><br><span class="line">// 手动创建集合 语法</span><br><span class="line">db.createCollection(set_name, options)</span><br><span class="line"></span><br><span class="line">/* 限制集合存储大小，设置为10</span><br><span class="line">* db.createCollection(&quot;stu&quot;)</span><br><span class="line">* db.createCollection(&quot;sub&quot;, &#123;capped: true, size: 10&#125;)</span><br><span class="line">* 参数capped: 默认值为false表示不设置上限，值为true表示设置上限</span><br><span class="line">* 参数size: 当capped值为true时，需要指定此参数，表示上限大小</span><br><span class="line">* </span><br><span class="line">* 注意：当文档达到上限时，会将之前的数据覆盖，单位为字节</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="二、关于数据"><a href="#二、关于数据" class="headerlink" title="二、关于数据"></a>二、关于数据</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><blockquote><p>每个文档都有自己的属性，为_id。保证每个文档的唯一性</p><p>可以自己设置_id插入文档，如果没有设置，那么mongodb为每个文档提供一个独特的_id，类型为<strong>object ID</strong></p></blockquote><ul><li><strong>String（字符串）</strong>：用于表示文本数据。可以存储字符串值，例如文本消息、用户名等</li><li><strong>Integer（整数）</strong>：用于表示整数值。MongoDB支持32位和64位整数</li><li><strong>Double（双精度浮点数）</strong>：用于表示双精度浮点数值，通常用于存储小数值</li><li><strong>Boolean（布尔值）</strong>：用于表示布尔值，即<code>true</code>或<code>false</code></li><li><strong>Date（日期时间）</strong>：用于表示日期和时间。MongoDB存储日期时间值为UTC时间，并可以在查询时进行时区转换</li><li><strong>Array（数组）</strong>：用于表示数组或列表，可以包含多个值，这些值可以是不同的数据类型</li><li><strong>Object（嵌套文档）</strong>：用于表示嵌套文档或子文档，允许在文档中嵌套其他文档</li><li><strong>ObjectId</strong>：是一个12字节的唯一标识符，通常<strong>用于文档的主键</strong>。每个ObjectId包含一个时间戳（4字节）、机器标识（3字节）、进程ID（2字节）和计数器（3字节）</li><li><strong>Binary Data（二进制数据）</strong>：用于存储二进制数据，如图像、音频文件等</li><li><strong>Regular Expression（正则表达式）</strong>：用于存储正则表达式模式</li><li><strong>Null（空值）</strong>：用于表示空值或缺失的字段</li><li><strong>Timestamp（时间戳）</strong>：用于表示特定时间的32位整数，通常与ObjectId一起使用</li><li><strong>Min&#x2F;Max Keys（最小键&#x2F;最大键）</strong>：用于特殊查询操作</li></ul><h3 id="2-数据操作"><a href="#2-数据操作" class="headerlink" title="2. 数据操作"></a>2. 数据操作</h3><blockquote><p>插入数据时，数据中的key键可以省略双引号</p></blockquote><ul><li><p>插入数据：**<code>db.集合名称.insert(document)</code>**</p><ul><li>当使用insert插入，并且手动指定文档_id时，如果_id重复则插入失败</li></ul></li><li><p>查询数据，数据中包括_id：**<code>db.集合名称.find()</code>**</p></li><li><p>保存数据：**<code>db.集合名称.save(document)</code>**</p><ul><li>如果手动指定文档_id，那么如果文档_id已存在则更新数据，文档_id不存在则添加数据</li><li><strong>注意：在较新的 MongoDB 版本中，save方法已被弃用</strong></li></ul></li><li><p>更新数据：<strong>指定两个参数，必须使用 $set 操作符来指定要更新的字段和新的值</strong></p><ul><li>**<code>db.集合名称.update(document, &#123;$set:document&#125;)</code>**：只会更新第一个匹配的文档</li><li>**<code>db.集合名称.updateOne(document, &#123;$set:document&#125;)</code>**：只会更新第一个匹配的文档</li><li>**<code>db.集合名称.update(document, &#123;$set:document&#125;, &#123;multi:true&#125;)</code>**：会更新所有匹配的文档</li><li>**<code>db.集合名称.updateMany(document, &#123;$set:document&#125;)</code>**：会更新所有匹配的文档</li></ul></li><li><p>删除数据：**<code>db.集合名称.remove(document, &#123;justOne:true&#125;)</code>**</p><ul><li>默认删除所有匹配的文档，将justOne设置为ture则限制只删除第一个匹配的文档</li></ul></li></ul><h2 id="三、查询专项"><a href="#三、查询专项" class="headerlink" title="三、查询专项"></a>三、查询专项</h2><blockquote><p><strong>数据准备</strong></p><ul><li>创建products集合，商品数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(&quot;products&quot;).insert([ &#123;</span><br><span class="line">    _id: 100,</span><br><span class="line">    sku: &quot;abc123&quot;,</span><br><span class="line">    description: &quot;Single line description&quot;</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;products&quot;).insert([ &#123;</span><br><span class="line">    _id: 101,</span><br><span class="line">    sku: &quot;abc789&quot;,</span><br><span class="line">    description: &quot;First line\nSecond line&quot;</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;products&quot;).insert([ &#123;</span><br><span class="line">    _id: 102,</span><br><span class="line">    sku: &quot;xyz456&quot;,</span><br><span class="line">    description: &quot;Many spaces before    line&quot;</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;products&quot;).insert([ &#123;</span><br><span class="line">    _id: 103,</span><br><span class="line">    sku: &quot;xyz789&quot;,</span><br><span class="line">    description: &quot;Multiple\nline description&quot;</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;products&quot;).insert([ &#123;</span><br><span class="line">    _id: 104,</span><br><span class="line">    sku: &quot;abc123&quot;,</span><br><span class="line">    description: &quot;Single line description&quot;</span><br><span class="line">&#125; ]);</span><br></pre></td></tr></table></figure><ul><li>创建stu_info集合，学生数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(&quot;stu_info&quot;).insert([ &#123;</span><br><span class="line">    _id: ObjectId(&quot;626ba04fce0a56f10342b6f3&quot;),</span><br><span class="line">    name: &quot;郭靖&quot;,</span><br><span class="line">    hometown: &quot;蒙古&quot;,</span><br><span class="line">    age: 20,</span><br><span class="line">    gender: true</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;stu_info&quot;).insert([ &#123;</span><br><span class="line">    _id: ObjectId(&quot;626ba07cce0a56f10342b6f4&quot;),</span><br><span class="line">    name: &quot;黄蓉&quot;,</span><br><span class="line">    hometown: &quot;桃花岛&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: false</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;stu_info&quot;).insert([ &#123;</span><br><span class="line">    _id: ObjectId(&quot;626ba0acce0a56f10342b6f5&quot;),</span><br><span class="line">    name: &quot;华筝&quot;,</span><br><span class="line">    hometown: &quot;蒙古&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: false</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;stu_info&quot;).insert([ &#123;</span><br><span class="line">    _id: ObjectId(&quot;626ba0d2ce0a56f10342b6f6&quot;),</span><br><span class="line">    name: &quot;黄药师&quot;,</span><br><span class="line">    hometown: &quot;桃花岛&quot;,</span><br><span class="line">    age: 40,</span><br><span class="line">    gender: true</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;stu_info&quot;).insert([ &#123;</span><br><span class="line">    _id: ObjectId(&quot;626ba0f1ce0a56f10342b6f7&quot;),</span><br><span class="line">    name: &quot;段誉&quot;,</span><br><span class="line">    hometown: &quot;大理&quot;,</span><br><span class="line">    age: 16,</span><br><span class="line">    gender: true</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;stu_info&quot;).insert([ &#123;</span><br><span class="line">    _id: ObjectId(&quot;626ba10bce0a56f10342b6f8&quot;),</span><br><span class="line">    name: &quot;段王爷&quot;,</span><br><span class="line">    hometown: &quot;大理&quot;,</span><br><span class="line">    age: 45,</span><br><span class="line">    gender: true</span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection(&quot;stu_info&quot;).insert([ &#123;</span><br><span class="line">    _id: ObjectId(&quot;626ba12cce0a56f10342b6f9&quot;),</span><br><span class="line">    name: &quot;洪七公&quot;,</span><br><span class="line">    hometown: &quot;华山&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: true</span><br><span class="line">&#125; ]);</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-find方法"><a href="#1-find方法" class="headerlink" title="1. find方法"></a>1. find方法</h3><ul><li>语法：<strong>db.集合名称.find({条件文档})</strong></li><li>注意：如果脚本混用在python代码中，则条件文档中的key是一定要加单双引号的，写做字符串形式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询stu_info集合中，年龄为18的文档</span><br><span class="line">db.stu_info.find(&#123;age:18&#125;)</span><br><span class="line"></span><br><span class="line">// 查询一条使用findOne()，并将结果格式化输出</span><br><span class="line">db.stu_info.findOne(&#123;age:18&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><ul><li><p><strong>注意：在MongoDB中，数学中的比较运算符是无法使用的</strong></p></li><li><p>等于：$eq</p></li><li><p>小于：$lt</p></li><li><p>小于等于：$lte</p></li><li><p>大于：$gt</p></li><li><p>大于等于：$gte</p></li><li><p>不等于：$ne</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询stu_info集合中，年龄大于18的文档</span><br><span class="line">db.stu_info.find(&#123;age: &#123;$gt: 18&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 查询年龄大于等于16岁，小于等于18岁的文档</span><br><span class="line">db.stu_info.find(&#123;age: &#123;$gte: 16, $lte: 18&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-范围运算符"><a href="#3-范围运算符" class="headerlink" title="3. 范围运算符"></a>3. 范围运算符</h3><ul><li>$in：包含在数组中，用于匹配字段值在指定数组中的文档</li><li>$nin：不包含在数组中，用于匹配字段值不在指定数组中的文档</li><li>$exists：检查字段是否存在，用于匹配具有或不具有指定字段的文档</li><li>$type：检查字段类型，用于匹配具有指定字段类型的文档</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 首先添加部分测试数据</span><br><span class="line">db.stu_info.insertMany([&#123;name:27017,age:1&#125;,&#123;name:3306,age:2&#125;,&#123;name:6379,age:3&#125;])</span><br><span class="line"></span><br><span class="line">// 查询stu_info集合中，所有年龄为16或20的文档</span><br><span class="line">db.stu_info.find(&#123;age: &#123;$in: [20, 1]&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 查询没有hometown值的文档</span><br><span class="line">db.stu_info.find(&#123;hometown: &#123;$exists: false&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 查询name值为int类型的文档</span><br><span class="line">db.stu_info.find(&#123;name: &#123;$type: &quot;int&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><ul><li>并且查询：<strong>db.集合名称.find({条件1, 条件2})</strong></li><li>或者查询：<strong>db.集合名称.find({$or: [{条件1}, {条件2}]})</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 并且查询</span><br><span class="line">db.stu_info.find(&#123;age:18,hometown:&#x27;蒙古&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">// 或者查询</span><br><span class="line">db.stu_info.find(&#123;$or: [&#123;age:1&#125;, &#123;hometown:&#x27;大理&#x27;&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">// 复杂查询，查询年龄大于45岁，或者name类型为int的文档</span><br><span class="line">db.stu_info.find(&#123;$or: [&#123;age: &#123;$gt: 20&#125;&#125;, &#123;name: &#123;$type: &#x27;int&#x27;&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h3><ul><li>简介：使用正则表达式进行模糊查询，可以使用&#x2F;&#x2F;或者$regex操作符来执行正则表达式查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 查找字段中包含特殊字符串&#x27;c1&#x27;的文档</span><br><span class="line">db.products.find(&#123;sku: /c1/&#125;)</span><br><span class="line"></span><br><span class="line">// 查找以特定字符串&#x27;abc&#x27;开头的文档</span><br><span class="line">db.products.find(&#123;sku: /^abc/&#125;)</span><br><span class="line"></span><br><span class="line">// 查找以特定字符串&#x27;789&#x27;结尾的文档</span><br><span class="line">db.products.find(&#123;sku: /789$/&#125;)</span><br><span class="line">db.products.find(&#123;sku: &#123;$regex: &#x27;789$&#x27;&#125;&#125;)  // 表达式有引号</span><br><span class="line"></span><br><span class="line">// 使用i选项进行不区分大小写的查询</span><br><span class="line">db.products.find(&#123;description: /first/i &#125;)</span><br><span class="line">db.products.find(&#123;description: &#123;$regex: /first/i&#125;&#125;)  // 表达式无引号</span><br></pre></td></tr></table></figure><h3 id="6-分页方法"><a href="#6-分页方法" class="headerlink" title="6. 分页方法"></a>6. 分页方法</h3><ul><li><strong>skip操作符：用于指定从查询结果集中跳过多少个文档开始返回结果，通常与find方法一起使用</strong></li><li><strong>limit操作符：用于指定要返回的文档数量，通常与find方法一起使用</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const pageNumber = 2; // 第2页</span><br><span class="line">const pageSize = 20; // 每页显示的文档数量</span><br><span class="line">const skipAmount = (pageNumber - 1) * pageSize; // 计算要跳过的文档数量</span><br><span class="line"></span><br><span class="line">// 按照每页20个文档计算，查询第2页的所有文档</span><br><span class="line">db.collectionName.find().skip(skipAmount).limit(pageSize);</span><br></pre></td></tr></table></figure><h3 id="7-自定义查询"><a href="#7-自定义查询" class="headerlink" title="7. 自定义查询"></a>7. 自定义查询</h3><ul><li>简介：<strong>MongoDB支持在查询中使用自定义JavaScript函数来进行数据筛选，通过使用$where操作符来实现</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查询stu_info集合中，年龄小于等于18的文档（函数返回true的文档将被包括在查询结果中）</span><br><span class="line">db.stu_info.find(&#123;$where: function()&#123;return this.age &lt;= 18;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="8-投影"><a href="#8-投影" class="headerlink" title="8. 投影"></a>8. 投影</h3><ul><li>简介：投影类似于MySQL中的select查询，允许从查询结果中选择要返回的字段，而不是返回文档的全部内容</li><li>语法：<strong>db.集合名称.find({条件}, {字段1, 字段2, …})</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 返回指定字段，设置为1</span><br><span class="line">// 查询年龄大于18岁的文档，只显示name字段值，默认显示_id字段</span><br><span class="line">db.stu_info.find(&#123;age: &#123;$gt: 18&#125;&#125;, &#123;name: 1&#125;)</span><br><span class="line"></span><br><span class="line">// 2. 不返回特定字段，设置为0（仅对_id生效）。其余字段不想显示就不写</span><br><span class="line">// 查询年龄大于18岁的文档，只显示name字段值，且不显示_id字段</span><br><span class="line">db.stu_info.find(&#123;age: &#123;$gt: 18&#125;&#125;, &#123;name: 1, _id: 0&#125;)</span><br></pre></td></tr></table></figure><h3 id="9-排序方法"><a href="#9-排序方法" class="headerlink" title="9. 排序方法"></a>9. 排序方法</h3><ul><li>升序排序：使用sort方法并指定字段名称，其值设置为数字1</li><li>降序排序：使用sort方法并指定字段名称，其值设置为数字-1</li><li>多字段排序：如果有多个字段的值相同，MongoDB 将按照后续字段的顺序进行排序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. 升序排序，按照年龄升序排序</span><br><span class="line">db.stu_info.find(&#123;&#125;,&#123;age:1&#125;).sort(&#123;age:1&#125;)</span><br><span class="line"></span><br><span class="line">// 2. 多字段排序，先按照_id升序排序，再按照age降序排序</span><br><span class="line">db.stu_info.find(&#123;age: &#123;$gt: 3&#125;&#125;, &#123;age: 1&#125;).sort(&#123;_id: 1,age: -1&#125;)</span><br></pre></td></tr></table></figure><h3 id="10-统计方法"><a href="#10-统计方法" class="headerlink" title="10. 统计方法"></a>10. 统计方法</h3><ul><li><strong>countDocuments方法</strong>：用于计算满足查询条件的文档数量</li><li><strong>estimatedDocumentCount方法</strong>：用于估计满足查询条件的文档数量，但它更快速，不一定是精确的，因此适用于大型集合</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 旧版本，使用count()方法统计文档个数</span><br><span class="line">db.stu_info.find().count()</span><br><span class="line">db.stu_info.count()</span><br><span class="line"></span><br><span class="line">// 新版本，使用countDocuments()方法统计文档个数</span><br><span class="line">db.stu_info.countDocuments()</span><br><span class="line">db.stu_info.estimatedDocumentCount()</span><br><span class="line"></span><br><span class="line">// 统计年龄大于18的文档个数</span><br><span class="line">db.stu_info.countDocuments(&#123;age: &#123;$gt: 18&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="11-数据去重方法"><a href="#11-数据去重方法" class="headerlink" title="11. 数据去重方法"></a>11. 数据去重方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 对年龄进行去重输出</span><br><span class="line">db.stu_info.distinct(&#x27;age&#x27;)</span><br><span class="line"></span><br><span class="line">// 结合条件对数据去重输出，对年龄大于18的地址文档进行去重输出</span><br><span class="line">db.stu_info.distinct(&#x27;hometown&#x27;, &#123;age: &#123;$gt: 18&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="四、聚合操作"><a href="#四、聚合操作" class="headerlink" title="四、聚合操作"></a>四、聚合操作</h2><blockquote><ul><li><strong>管道（Pipeline）</strong>：聚合操作是基于管道的，你可以定义一系列处理步骤，每个步骤都是一个操作符，用于处理文档数据。这些操作符按照指定的顺序依次应用于文档数据</li><li><strong>阶段（Stage）</strong>：管道中的每个操作符都是一个阶段，它执行特定的操作，例如$match（筛选文档）、$project（投影字段）、$group（分组）、$sort（排序）等都是阶段</li></ul></blockquote><h3 id="1-聚合操作"><a href="#1-聚合操作" class="headerlink" title="1. 聚合操作"></a>1. 聚合操作</h3><ul><li><p><strong>语法：db.集合名称.aggregate({管道: {表达式}})</strong></p></li><li><p><strong>常用管道：</strong></p><ol><li><strong>$match</strong>：过滤文档，只输出符合条件的⽂档</li><li><strong>$project</strong>：投影字段，可以修改文档的结构，允许你选择要包含或排除的字段</li><li><strong>$group</strong>：分组文档，通常与<strong>累积器操作符</strong>一起使用</li><li><strong>$sort</strong>：排序文档</li><li><strong>$limit</strong>：限制聚合管道返回的⽂档数</li><li><strong>$skip</strong>：跳过指定数量的⽂档， 并返回余下的⽂档</li><li><strong>$unwind</strong>：将数组类型的字段进⾏拆分，使其每个元素成为一个单独的文档</li></ol></li><li><p>累积器操作符：</p><ul><li><strong>$sum</strong>：用于计算给定字段的总和。例如，<code>&#123; $sum: &quot;$amount&quot; &#125;</code>将计算”amount”字段的总和</li><li><strong>$avg</strong>：计算给定字段的平均值。例如，<code>&#123; $avg: &quot;$price&quot; &#125;</code>将计算”price”字段的平均值</li><li><strong>$min</strong>：找到给定字段的最小值。例如，<code>&#123; $min: &quot;$quantity&quot; &#125;</code>将找到”quantity”字段的最小值</li><li><strong>$max</strong>：找到给定字段的最大值。例如，<code>&#123; $max: &quot;$score&quot; &#125;</code>将找到”score”字段的最大值</li><li><strong>$first</strong>：返回每个分组的第一个文档中指定字段的值。通常与$group一起使用</li><li><strong>$last</strong>：返回每个分组的最后一个文档中指定字段的值。也通常与$group一起使用</li><li><strong>$addToSet</strong>：将指定字段的唯一值添加到一个集合中，通常用于消除重复值</li><li><strong>$push</strong>：将指定字段的值添加到一个数组中，可用于构建包含某个字段所有值的数组</li></ul></li></ul><h3 id="2-group分组"><a href="#2-group分组" class="headerlink" title="2. $group分组"></a>2. $group分组</h3><ul><li><strong>_id：$group中的_id指的是要使用什么字段作为分组的依据</strong></li><li><strong>$sum：$group中的$sum的值表示输出分组后当前每一组文档数的倍数</strong></li><li><strong>注意：分组中所有被取的字段前都要加上$符号！例如：<code>$gendeer</code>，<code>$age</code></strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询按照性别分组，统计男女生人数和平均年龄</span><br><span class="line">db.stu_info.aggregate(&#123;$group: &#123;_id: &#x27;$gender&#x27;, counter: &#123;$sum: 1&#125;, avg_age: &#123;$avg: &#x27;$age&#x27;&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 将集合中所有的文档分为一组，统计个数和平均年龄</span><br><span class="line">db.stu_info.aggregate(&#123;$group: &#123;_id: null, count: &#123;$sum: 1&#125;, avgAge: &#123;$avg: &#x27;$age&#x27;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-project投影"><a href="#3-project投影" class="headerlink" title="3. $project投影"></a>3. $project投影</h3><ul><li>简介：直接使用$project类似于投影，0表示不显示，1表示显示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查询学生的姓名和年龄，只显示姓名和年龄</span><br><span class="line">db.stu_info.aggregate(&#123;$project: &#123;_id: 0, name: 1, age: 1&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 查询按照性别分组，统计男女生人数和平均年龄，并以中文显示</span><br><span class="line">db.stu_info.aggregate(</span><br><span class="line">&#123;$group: &#123;_id: &#x27;$gender&#x27;, count: &#123;$sum: 1&#125;, avgAge: &#123;$avg: &#x27;$age&#x27;&#125;&#125;&#125;,</span><br><span class="line">&#123;$project: &#123;&quot;性别&quot;: &#x27;$_id&#x27;, &quot;人数统计&quot;: &#x27;$count&#x27;, &#x27;平均年龄&#x27;: &#x27;$avgAge&#x27;, _id: 0&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="4-match过滤"><a href="#4-match过滤" class="headerlink" title="4. $match过滤"></a>4. $match过滤</h3><ul><li>简介：match是管道命令，能将结果交给下一个管道，find()无法实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 查询年龄大于20岁的学生</span><br><span class="line">db.stu_info.aggregate(&#123;$match: &#123;age: &#123;$gt: 20&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 查询年龄大于20或者归属地在蒙古或大理的人数</span><br><span class="line">db.stu_info.aggregate(</span><br><span class="line">&#123;$match: &#123;$or: [&#123;age: &#123;$gt: 20&#125;&#125;, &#123;hometown: &#123;$in: [&#x27;蒙古&#x27;, &#x27;大理&#x27;]&#125;&#125;]&#125;&#125;,</span><br><span class="line">&#123;$group: &#123;_id: null, count: &#123;$sum: 1&#125;&#125;&#125;,</span><br><span class="line">&#123;$project: &#123;&quot;查询的总人数&quot;: &#x27;$count&#x27;, _id: 0&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="5-sort排序"><a href="#5-sort排序" class="headerlink" title="5. $sort排序"></a>5. $sort排序</h3><ul><li>简介：1位顺序排序，-1为倒序排序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询男生和女生人数，按人数降序</span><br><span class="line">db.stu_info.aggregate(</span><br><span class="line">&#123;$group: &#123;_id: &#x27;$gender&#x27;, count: &#123;$sum: 1&#125;&#125;&#125;,</span><br><span class="line">&#123;$sort: &#123;count: -1&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="6-limit与-skip"><a href="#6-limit与-skip" class="headerlink" title="6. $limit与$skip"></a>6. $limit与$skip</h3><ul><li><strong>$limit</strong>：限制聚合管道返回的⽂档数</li><li><strong>$skip</strong>：跳过指定数量的⽂档， 并返回余下的⽂档</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取前两个文档</span><br><span class="line">db.stu_info.aggregate(&#123;$limit: 2&#125;)</span><br><span class="line">// 获取除了前两个文档的剩余文档</span><br><span class="line">db.stu_info.aggregate(&#123;$skip: 2&#125;)</span><br><span class="line">// 跳过第一个文档，再获取一个文档，即第2个文档</span><br><span class="line">db.stu_info.aggregate(&#123;$skip: 1&#125;, &#123;$limit: 1&#125;)</span><br></pre></td></tr></table></figure><h2 id="五、-PyMongo"><a href="#五、-PyMongo" class="headerlink" title="五、 PyMongo"></a>五、 PyMongo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"></span><br><span class="line"># 1. 连接本地mongo数据库</span><br><span class="line">client = MongoClient(host=&#x27;localhost&#x27;, port=27017)</span><br><span class="line"></span><br><span class="line"># 2. 进入指定数据库，数据库或者集合不存在都不影响</span><br><span class="line">coll = client[&#x27;test_db&#x27;][&#x27;test_python&#x27;]</span><br><span class="line"></span><br><span class="line"># 3. 插入文档</span><br><span class="line">coll.insert_one(&#123;&#x27;name&#x27;: &#x27;xfblog&#x27;, &#x27;age&#x27;: 18&#125;)</span><br><span class="line">data_list = [</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;, &#x27;age&#x27;: 22&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;xiaohong&#x27;, &#x27;age&#x27;: 20&#125;</span><br><span class="line">]</span><br><span class="line">coll.insert_many(data_list)</span><br><span class="line"></span><br><span class="line"># 4. 查询文档（可添加条件）</span><br><span class="line">fcoll = coll.find_one()  # 返回一个字典类型的文档</span><br><span class="line">print(fcoll)</span><br><span class="line"># find()返回一个可迭代的游标对象，包含所有文档</span><br><span class="line">fcolls = coll.find(&#123;&#125;, &#123;&#x27;_id&#x27;: 0, &#x27;name&#x27;: 1, &#x27;age&#x27;: 1&#125;)</span><br><span class="line">for coll in fcolls:</span><br><span class="line">    print(coll)</span><br><span class="line"></span><br><span class="line"># 5. 更新文档</span><br><span class="line">coll.update_one(&#123;&#x27;name&#x27;: &#x27;xfblog&#x27;&#125;, &#123;&#x27;$set&#x27;: &#123;&#x27;name&#x27;: &#x27;xiaofu&#x27;&#125;&#125;)</span><br><span class="line">coll.update_many(&#123;&#x27;age&#x27;: 18&#125;, &#123;&#x27;$set&#x27;: &#123;&#x27;age&#x27;: 17&#125;&#125;)  # 数字不能加引号</span><br><span class="line"></span><br><span class="line"># 6.删除文档（可添加条件）</span><br><span class="line">coll.delete_one(&#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;&#125;)  # 删除匹配的第一个文档</span><br><span class="line">coll.delete_many(&#123;&#125;)  # 清空此集合内的所有文档</span><br><span class="line"></span><br><span class="line">coll.drop()  # 删除集合</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、MongoDB数据库&quot;&gt;&lt;a href=&quot;#一、MongoDB数据库&quot; class=&quot;headerlink&quot; title=&quot;一、MongoDB数据库&quot;&gt;&lt;/a&gt;一、MongoDB数据库&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MongoDB 是一个流行的 No</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MongoDB" scheme="http://example.com/tags/MongoDB/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库</title>
    <link href="http://example.com/2023/01/01/Database_MySql/"/>
    <id>http://example.com/2023/01/01/Database_MySql/</id>
    <published>2022-12-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MySQL数据库"><a href="#一、MySQL数据库" class="headerlink" title="一、MySQL数据库"></a>一、MySQL数据库</h2><blockquote><p>MySQL是什么：<strong>mysql就是一个基于socket编写的C&#x2F;S架构的软件</strong></p><ul><li>数据库管理软件分类：<ul><li>关系型数据库：<strong>有表结构的</strong>。例：sqllite、db2、oracle、access、sql(通用)、server、<strong>MySQL</strong></li><li>非关系型数据库：<strong>没有表结构的</strong>，是以key-value存储的。例：mongodb、redis、memcache</li></ul></li></ul><blockquote><p> <strong>注意：由于作者电脑为mac系统，全篇mysql笔记以mac系统为背景，望理解谢谢！</strong></p><p> <strong>mysql修改密码</strong>：<code>https://www.cnblogs.com/chloneda/p/12449819.html</code></p></blockquote></blockquote><h3 id="1-变量设置"><a href="#1-变量设置" class="headerlink" title="1. 变量设置"></a>1. 变量设置</h3><ul><li><strong>局部变量session（可省略session关键字）：</strong><ol><li>查找匹配的局部变量：<code>show [session] variables like &#39;%xxx%&#39;;</code></li><li>设置局部变量：<code>set [session] 变量=值;</code></li></ol></li><li><strong>全局变量global（不可省略global关键字）：</strong><ol><li>查找匹配的全局变量：<code>show global variables like &#39;%xxx%&#39;;</code></li><li>设置全局变量：<code>set global 变量=值;</code></li></ol></li></ul><h3 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h3><ul><li><p>简介：<strong>数据库中的表有不同的类型，表的类型不同，会对应mysql不同的存取机制，表类型又称为存储引擎</strong>。存储引擎就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以<strong>存储引擎也可以称为表类型</strong>（即存储和操作此表的类型）。<strong>在Oracle和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种存储引擎</strong>。</p></li><li><p>mysql支持的存储引擎</p><ul><li>查看所有支持的存储引擎：<code>show engines;</code></li><li>查看正在使用的存储引擎：<code>show variables like &#39;%storage_engine%&#39;;</code></li></ul></li><li><p>使用存储引擎</p><ol><li><p>建表时指定：<code>create table tb1(id int)engine=innodb</code>，<code>show create table tb1;</code></p></li><li><p>在配置文件 &#x2F;etc&#x2F;my.cnf 中指定默认的存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">innodb_file_per_table=1</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote><p><strong>重要概念</strong>：</p><ul><li><strong>字节</strong>：一字节(Byte)等于八位(bit)。例如int的存储宽度是4个Bytes，即32个bit，存储范围到2**32</li><li><strong>字符</strong>：一个英文字符等于一个字节，一个中文字符等于三个字节（utf8字符集）</li><li><strong>数据类型后指定的宽度</strong>：<strong>此指定的宽度为字符（除整型外），而不是字节！</strong></li></ul></blockquote><h3 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1. 数值类型"></a>1. 数值类型</h3><ul><li><p>关于整数：整数类型int()的显示宽度默认值为存储范围的最大值的宽度上加1位，<strong>因为数值类型默认都是有符号的</strong>，符号位也占1宽度。<strong>为整数类型指定宽度时，仅仅只是指定查询结果的显示宽度，与存储范围无关，因为整数类型的存储宽度是固定的</strong></p></li><li><p>关于浮点数：在浮点类型中，对于float[(m, d)]、double[(m, d)]和decimal[(m, d)]，<strong>m表示的是数字总个数，d表示的是小数点后个数</strong>。其中，<strong>float和double的m最大值为255，decimal的m最大值为65，但它们的d最大值都为30</strong></p></li></ul><h3 id="2-日期类型"><a href="#2-日期类型" class="headerlink" title="2. 日期类型"></a>2. 日期类型</h3><ul><li><p>字段分类：</p><ul><li>year：YYYY（1901&#x2F;2155）</li><li>date：YYYY-MM-DD（1000-01-01&#x2F;9999-12-31）</li><li>time：HH:MM:SS（’-838:59:59’&#x2F;‘838:59:59’）</li><li>datetime：YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59）</li><li>timestamp：YYYYMMDD HHMMSS（1970-01-01 00:00:00&#x2F;2037 年某时）</li></ul></li><li><p><strong>datetime与timestamp的区别</strong>：</p><ol><li>datetime的日期范围是1001&#x2F;9999年，timestamp的时间范围是1970&#x2F;2038年</li><li><strong>datetime存储时间与时区无关，timestamp存储时间与时区有关，显示的值也依赖于时区</strong>。在mysql服务器、操作系统以及客户端连接都有时区的设置</li><li><strong>datetime使用8字节的存储空间，timestamp的存储空间为4字节</strong>。因此，timestamp比datetime的空间利用率更高</li><li><strong>datetime的默认值为null，timestamp的默认值为当前时间current_timestamp</strong>，如果不做特殊处理，并且update语句中没有指定该列的更新值，则默认更新为当前时间</li></ol></li><li><p>注意：<strong>针对datetime和timestamp如果是用作注册时间，那么前者指定not null default now()，后者不指定任何值，即可自动填充时间；如果是用作更新时间那么需要额外指定on update now()，该配置timestamp自带，所以也只需datetime指定（mysql版本不同会导致explicit_defaults_for_timestamp值不同，只有当其值为off时，以上结论才有效）</strong></p><ul><li>查询当前explicit_defaults_for_timestamp值：<code>show [global] variables like &#39;%timestamp%&#39;;</code></li><li>设置当前explicit_defaults_for_timestamp值：<code>set [global] explicit_defaults_for_timestamp=off;</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t1(x datetime not null default now()); # 需要指定传入空值时默认取当前时间</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table t2(x timestamp); # 无需任何设置，在传空值的情况下自动传入当前时间</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t1;</span><br><span class="line">+-------+----------+------+-----+-------------------+-------------------+</span><br><span class="line">| Field | Type     | Null | Key | Default           | Extra             |</span><br><span class="line">+-------+----------+------+-----+-------------------+-------------------+</span><br><span class="line">| x     | datetime | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED |</span><br><span class="line">+-------+----------+------+-----+-------------------+-------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Field: x</span><br><span class="line">   Type: timestamp</span><br><span class="line">   Null: NO</span><br><span class="line">    Key: </span><br><span class="line">Default: CURRENT_TIMESTAMP</span><br><span class="line">  Extra: DEFAULT_GENERATED on update CURRENT_TIMESTAMP</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; create table t3(x datetime not null default now() on update now());</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table t4(x timestamp);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t3\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Field: x</span><br><span class="line">   Type: datetime</span><br><span class="line">   Null: NO</span><br><span class="line">    Key: </span><br><span class="line">Default: CURRENT_TIMESTAMP</span><br><span class="line">  Extra: DEFAULT_GENERATED on update CURRENT_TIMESTAMP</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t4\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Field: x</span><br><span class="line">   Type: timestamp</span><br><span class="line">   Null: NO</span><br><span class="line">    Key: </span><br><span class="line">Default: CURRENT_TIMESTAMP</span><br><span class="line">  Extra: DEFAULT_GENERATED on update CURRENT_TIMESTAMP</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="3-字符类型"><a href="#3-字符类型" class="headerlink" title="3. 字符类型"></a>3. 字符类型</h3><blockquote><p><strong>char和varchar指定的参数都是字符的长度，而不是字节！（一个英文字符占1个字节，一个中文字符占3个字节）</strong></p><ol><li><strong><code>length()</code>：查看字节数</strong></li><li><strong><code>char_length()</code>：查看字符数</strong></li></ol></blockquote><ul><li><p>char类型：定长，简易，浪费空间，存取速度快，存取字符长度0-255</p><ul><li>存储：存储char类型的值时，会往右填充空格来补足长度</li><li>检索：在检索（查询）时，查询出的结果会自动删除尾部的空格（<strong>可以通过设置<code>set sql_mode=&#39;PAD_CHAR_TO_FULL_LENGTH&#39;;</code>以查询<code>char_length()</code>正常值</strong>）</li></ul></li><li><p>varchar类型：变长，精准，节省空间，存取速度慢，存取字符长度0-65535</p><ul><li>存储：存储varchar类型的值时，不会用空格填充，会精准存储，字符串是什么就存什么</li><li>检索：在检索（查询）时，也会精准查询，包括字符串尾部的空格也会保存下来</li></ul></li><li><p><strong>char和varchar存储方式的区别（重点）：</strong></p><ul><li><p>varchar类型会在真实数据前加1-2bytes的前缀，该前缀用来表示真实数据的bytes字节数（1-2bytes最大表示65535个数字，正好符合mysql对row的最大字节限制，即已经足够使用）</p><table><thead><tr><th>Value</th><th>char(4)</th><th>Storage Required</th><th>varchar(4)</th><th>Storage Required</th></tr></thead><tbody><tr><td>‘’</td><td>‘    ‘</td><td>4 bytes</td><td>‘’</td><td>1 bytes</td></tr><tr><td>‘ab’</td><td>‘ab  ‘</td><td>4 bytes</td><td>‘ab’</td><td>3 bytes</td></tr><tr><td>‘abcd’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr><tr><td>‘abcdefg’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr></tbody></table></li></ul></li><li><p><strong>重点：即使char和varchar的存储方式不太相同，但是对于两个字符串的比较，都只比较其值，会忽略char值存在的右填充（即使设置了<code>set sql_mode=&#39;PAD_CHAR_TO_FULL_LENGTH&#39;;</code>也一样）。但这不适用于模糊查询like，like不会仅比较其值，还包括其末尾空格等</strong></p></li></ul><blockquote><p>建议与技巧：</p><ol><li>在不缺存取空间的今天，我们更应该使用char类型存储，以提高存取性能。但对于不要求存取性能的数据，更应该使用varchar类型存储，例如存入过后长时间不需要使用的数据，使用varchar更能节省空间</li><li>当我们创建表时，应该将char类型数据创建于varchar类型数据之前，且在同一张表中，尽量不要char和varchar混合用，能只用一种就只用一种</li><li>在数据库中，不建议存储容量特别大的文件，所以其余字符串类型也很少使用，效率也不高：char&gt;varchar&gt;text</li><li>对于innodb存储引擎，建议使用varchar类型。因为对于innodb数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的char列不一定比使用可变长度varchar列性能要好。所以，主要的性能因素是数据行使用的存储总量。由于char平均占用的空间多于varchar，因此使用varchar来最小化需要处理的数据行的存储总量和磁盘I&#x2F;O是比较好的。</li></ol></blockquote><h3 id="4-枚举类型与集合类型"><a href="#4-枚举类型与集合类型" class="headerlink" title="4. 枚举类型与集合类型"></a>4. 枚举类型与集合类型</h3><ul><li>enum：单选，只能在给定范围内选一个值，若不是给定范围内的值则变成空值</li><li>set：多选，在给定范围内可以选择一个或一个以上的值</li></ul><h2 id="三、字段约束类型"><a href="#三、字段约束类型" class="headerlink" title="三、字段约束类型"></a>三、字段约束类型</h2><ul><li><strong>not null与default</strong>：一般配合使用，即<code>not null default &#39;xxx&#39;</code>表示不传值或传空值则使用默认值</li><li>**unique [key]**：<ul><li>单列唯一：限制单个字段唯一。创建表时可以直接在字段后添加约束条件，也可以在字段创建完后使用多个<code>unique(字段名)</code>声明单列唯一</li><li>联合唯一：限制多个字段唯一，即两个字段值的组合要保证唯一。创建表时不在字段后跟约束条件，而是在字段创建完后使用一个<code>unique(字段1,字段2,...)</code>声明联合唯一，此时字段1的key在数据库中为MUL</li></ul></li><li><strong>primary key</strong>：主键，限制不为空且唯一（not null unique）。对于innodb存储引擎，一张表必须要有一个主键，如果没有设置主键，则将表中不为空且唯一的字段作为主键，如果没有这样的字段，则将一个隐藏的字段作为主键，只是无意义<ul><li>单列主键：创建表时可以直接在字段后添加约束条件，也可以在字段创建完后使用<code>parmary key(字段名)</code>声明单列主键</li><li>复合主键：创建表时不在字段后跟约束条件，而是在字段创建完后使用<code>parmary key(字段1,字段2,...)</code>声明复合主键，此时约束即为联合唯一</li></ul></li><li><strong>auto_increment</strong>：自增长的字段必须是一个key。可以自己指定自增长字段的值，则下次自增长从指定的值开始。<ul><li>查看auto_increment相关的变量：<code>show variables like &#39;auto_inc%&#39;</code></li><li>步长：<code>auto_increment_increment</code></li><li>起始偏移量：<code>auto_increment_offset</code>（<strong>起始偏移量的设置一定要小于等于步长，因为第一步不能迈过步长</strong>）</li></ul></li></ul><blockquote><p><strong>重点：删除表后auto_increment值并未重置？清空表</strong></p><ul><li>问题：对于使用了auto_increment字段的表，如果用<code>delete from tbname</code>清空表，并不会将表中auto_increment的值重置为1（可通过<code>show create table tbname</code>查看），所以清空表最好不用delete语句，因为delete语句一般搭配where使用</li><li>解决：使用<code>truncate tbname</code>清空表，可以将表中auto_increment的值重置为1</li></ul></blockquote><ul><li><strong>foreign key</strong>：外键，用于建立表之间的关系。使用时，将主表的字段通过约束条件<code>foreign key(字段) references tb2(tb2的字段)</code>与被关联表的字段进行绑定（<strong>必须保证被关联的字段唯一才能关联</strong>）。<ul><li>插入数据时，先往被关联表插数据，主表才能插入数据成功</li><li>删除数据时，先删除主表的数据，才能删除被关联表对应的数据。而这样删除太繁琐，可以在建立外键约束条件时加入条件<code>on delete cascade on update cascade</code>，即删除同步与更新同步，这样当删除被关联表数据时，主表的对应数据会被自动同步删除</li></ul></li></ul><h2 id="四、数据库-表-记录操作"><a href="#四、数据库-表-记录操作" class="headerlink" title="四、数据库&#x2F;表&#x2F;记录操作"></a>四、数据库&#x2F;表&#x2F;记录操作</h2><blockquote><p><strong>SQL语言主要用于存储数据、查询数据、更新数据和管理关系数据库系统</strong></p><p>SQL语言由IBM开发，分为三类：</p><ol><li><strong>DDL语句 - 数据库定义语言</strong>：数据库、表、视图、索引、存储过程，例如CREATE、DROP、ALTER等</li><li><strong>DML语句 - 数据库操纵语句</strong>：插入数据INSERT、删除数据DELETE、更新数据UPDATE、查询数据SELECT</li><li><strong>DCL语句 - 数据库控制语言</strong>：例如控制用户的访问权限GRANT、REVOKE等</li></ol></blockquote><h3 id="1-数据库（database）"><a href="#1-数据库（database）" class="headerlink" title="1. 数据库（database）"></a>1. 数据库（database）</h3><ul><li><strong>系统数据库（不允许操作）：</strong><ul><li><strong>information_schema</strong>：虚拟库，不占用磁盘空间，存储的是数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等</li><li><strong>mysql</strong>：授权库，主要存储系统用户的权限信息</li><li><strong>performance_schema</strong>：主要用于收集数据库服务器性能参数，记录处理查询请求时发生的各种事件、锁等现象</li><li><strong>sys</strong>：通过这个库可以快速的了解系统的元数据信息</li></ul></li><li><strong>数据库命名规则：</strong><ul><li><p><strong>唯一性</strong>：在同一MySQL服务器上，每个数据库的名称必须是唯一的，不能重复</p></li><li><p><strong>组成</strong>：数字、字母（区分大小写）和下划线，<strong>必须以字母开头</strong>，不能以数字或下划线开头</p></li><li><p><strong>保留字</strong>：避免使用MySQL的保留字（例SELECT、INSERT等）作为数据库名，以防止与SQL查询语句产生冲突</p></li></ul></li><li><strong>数据库使用注意：</strong><ol><li>对数据库进行任何操作，应首先指定数据库：<strong>use 数据库名;</strong></li><li><strong>在mysql中正确的设置字符集，应该是utf8，而不是utf-8！</strong></li></ol></li></ul><h3 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h3><ul><li>增：<code>create database 数据库名 charset [=] utf8;</code></li><li>删：<code>drop database 数据库名;</code></li><li>改：<code>alter database 数据库名 charset utf8;</code>（只能修改字符集，<strong>不能修改数据库名</strong>）</li><li>查：<ul><li><code>show databases;</code>（查看所有数据库）</li><li><code>show create database 数据库名;</code></li><li><code>select database();</code>（查看当前正在使用的数据库）</li></ul></li></ul><h3 id="3-数据表（table）"><a href="#3-数据表（table）" class="headerlink" title="3. 数据表（table）"></a>3. 数据表（table）</h3><ul><li><strong>创建表的注意事项：</strong><ol><li>在同一张表中，字段名不能相同</li><li>宽度和约束条件是可选的</li><li>字段名和类型是必选的</li><li>表中的最后一个字段不要加逗号</li></ol></li><li><strong>数据表之间的关系：</strong><ul><li><strong>多对一</strong>：表1的多条记录能对应表2的一条记录，但表2的多条记录不能对应表1的一条记录</li><li>外键设置：在表1下对需要关联的字段设置外键 <code>foreign key(tb2_id) references tb2(id)</code></li><li><strong>多对多</strong>：表1的多条记录能对应表2的一条记录，表2的多条记录也能对应表1的一条记录</li><li>外键设置：此时两张表都需要设置外键，那么先建哪张表都不对，而是再<strong>创建第三张表专门用于存储这两张表的关系</strong>，并且在 tb3 中分别对 tb1_id 和 tb2_id 设置外键 tb1(id) 和 tb2(id)</li><li><strong>一对一</strong>：表1的一条记录只能对应表2的一条记录，表2的一条记录也只能对应表1的一条记录</li><li>设置外键：按照逻辑分析出对应关系，在其中一张表中建立外键，但由于外键是可以重复的，所以外键本身就是多对一的关系，所以在<strong>创建外键字段时应该添加约束条件唯一（unique）</strong></li></ul></li></ul><h3 id="4-数据表操作"><a href="#4-数据表操作" class="headerlink" title="4. 数据表操作"></a>4. 数据表操作</h3><ul><li><p>增：<code>cerate table 表名(字段名 类型[(宽度) 约束条件],...);</code></p></li><li><p>删：<code>drop table 表名;</code></p></li><li><p>改：</p><ul><li><code>alter table 表名 rename 新表名;</code></li><li><code>alter table 表名 add 字段名 数据类型 [完整性约束条件...] frist;</code></li><li><code>alter table 表名 add 字段名 数据类型 [完整性约束条件...] after 字段名;</code></li><li><code>alter table 表名 drop 字段名;</code></li><li><strong><code>alter table 表名 modify 字段名 数据类型 [完整性约束条件...];</code></strong></li><li><strong><code>alter table 表名 change 旧字段名 新字段名 新/旧数据类型 [完整性约束条件...];</code></strong></li></ul></li><li><p>查：</p><ul><li><code>desc 表名;</code>（查看表结构）</li><li><code>show create table 表名\G;</code>（查看表详细结构，<strong>可加\G</strong>）</li></ul></li><li><p>复制表：</p><ul><li>复制表结构+记录，<strong>key（主键、外键和索引）不会复制</strong>：<code>create table new_tb1 selete * from tb1;</code></li><li>只复制表结构，<strong>使用like</strong>：**<code>create table new_tb1 like tb1;</code>**</li><li>只复制表结构：使用where限制数据：<code>create table new_tb1 selete * from tb1 where 1&gt;2;</code></li></ul></li></ul><h3 id="5-数据记录操作"><a href="#5-数据记录操作" class="headerlink" title="5. 数据记录操作"></a>5. 数据记录操作</h3><blockquote><p><strong>注意：主键列id是自动增长，但是在全列插入时必须需要占位，通常使用0、default或null来占位，插入成功后以实际数据为准</strong></p></blockquote><ul><li><p>增：</p><ul><li><p>插入一条记录：<code>insert into 表名[(字段1,字段2,...,字段n)] values(值1,值2,...,值n);</code></p></li><li><p>插入多条记录：<code>insert into 表名 values(值1,值2,...,值n),(值1,值2,...,值n),...;</code></p></li><li><p>插入查询结果：<code>insert into 表名(字段1,字段2...) select (字段1,字段2...) from 表2 where ...;</code></p></li></ul></li><li><p>删：</p><ul><li>物理删除：<code>delete from 表名 where 条件;</code></li><li>逻辑删除：<code>update 表 set is_delete=1 where 条件</code></li><li><strong>注意：逻辑删除本质是修改is_delete字段操作，然后通过python代码处理后隐藏</strong></li></ul></li><li><p>改：<code>update 表名 set 字段1=值1,字段2=值2,...,字段n=值n where 条件;</code></p></li><li><p>查：</p><ul><li>查询所有数据：<code>select \* from 表名</code></li><li><strong>查询完整语法：select distinct 字段 from 表 where 条件 group by 分组条件 having 过滤语句 order by 排序字段 limit n;</strong></li></ul></li></ul><h2 id="五、单表查询"><a href="#五、单表查询" class="headerlink" title="五、单表查询"></a>五、单表查询</h2><blockquote><p><strong>查询时定义显示格式（字符串函数）：</strong></p><ul><li>concat( )：函数用于连接字符串，和python打印一样，实参之间用逗号分隔</li><li>concat_ws( )：函数用于连接字符串，第一个参数为分隔符，实参之间用逗号分隔</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select concat_ws(&#x27;：&#x27;,name,age) as 姓名年龄 from students;</span><br><span class="line"></span><br><span class="line">mysql&gt; select concat_ws(&#x27;：&#x27;,name,age) as 姓名年龄 from students;</span><br><span class="line">+----------------+</span><br><span class="line">| 姓名年龄       |</span><br><span class="line">+----------------+</span><br><span class="line">| 小明：18       |</span><br><span class="line">| 小红：12       |</span><br><span class="line">| 李华：34       |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-where过滤"><a href="#1-where过滤" class="headerlink" title="1. where过滤"></a>1. where过滤</h3><ul><li><p>语法：<strong>select * from 表名 where 条件;</strong></p></li><li><p>比较运算符：&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D; !&#x3D;或&lt;&gt;</p></li><li><p>逻辑运算符：and、or、not</p></li><li><p>模糊查询like：%表示任意多个任意字符，_表示一个任意字符</p></li><li><p>范围查询：</p><ul><li>in 表示在一个非连续的范围内（成员运算符）</li><li>between … and … 表示在一个连续的范围内，闭区间（左闭右闭）</li></ul></li><li><p>空判断：is null、is not null（<strong>null与’’是不同的</strong>）</p></li></ul><blockquote><p><strong>优先级：小括号 &gt; not &gt; 比较运算符 &gt; 逻辑运算符</strong></p><p><strong>注意：and比or先运算，如果同时出现并希望先算or，需要结合()使用</strong></p></blockquote><h3 id="2-order-by排序"><a href="#2-order-by排序" class="headerlink" title="2. order by排序"></a>2. order by排序</h3><ul><li>语法：<strong>select * from 表名 order by 字段1 asc|desc [,字段2 asc|desc ,…];</strong></li><li>解释：将数据按照字段1进行排序，如果某些字段1的值相同时，则按照字段2排序，以此类推</li></ul><ul><li>asc：从小到大排序，即升序（<strong>mysql默认是从小到大排序的</strong>）</li><li>desc：从大到小排序，即降序</li><li><strong>组合排序</strong>：<strong>order by 字段1 desc,字段2 asc</strong>，即先按照字段1降序排，当字段1相同时，按照字段2升序排</li></ul><h3 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3. 聚合函数"></a>3. 聚合函数</h3><ul><li><strong>总数</strong>：count(*)表示计算总行数，括号中写星号或列名，结果是相同的</li><li><strong>最大数</strong>：max(列)表示求此列的最大值</li><li><strong>最小值</strong>：min(列)表示求此列的最小值</li><li><strong>求和</strong>：sum(列)表示求此列的和</li><li><strong>平均值</strong>：avg(列)表示求此列的平均值</li></ul><h3 id="4-group-by分组"><a href="#4-group-by分组" class="headerlink" title="4. group by分组"></a>4. group by分组</h3><ul><li>含义：将查询结果按照1个或多个字段进行分组，字段值相同的为一组</li><li>用法：group by一般不单独使用，单独对于某个字段使用类似于distinct去重，一般<strong>配合group_concat()使用</strong></li><li>**group_concat()**：表示分组之后，根据分组结果来放置每一组的某字段的值的集合，作为输出字段来使用</li></ul><ul><li><strong>group by + 聚合函数</strong>：聚合函数是对分组后的每一组的内容计算，若是没有分组，则默认为一组</li><li><strong>group by + having</strong>：having用来分组查询后指定一些条件来查询结果，其作用和where一样，但having只能用于group by</li><li><strong>group by + with rollup</strong>：with rollup的作用是在最后新增一行，来记录当前列里所有记录的总和</li></ul><blockquote><p><strong>having过滤与where约束的区别：</strong></p><ol><li>执行优先级从高到低：where &gt; group by &gt; having &gt; select<ul><li><strong>where</strong> 子句在数据从表中检索之前进行过滤，它用于筛选行</li><li><strong>group by</strong> 子句用于分组数据</li><li><strong>having</strong> 子句在分组之后对分组数据进行过滤</li><li><strong>select</strong> 子句用于选择要包含在结果集中的列</li></ul></li><li>where发生在分组group by之前，可以包含任意字段，通常用于对原始数据进行过滤，而不涉及聚合函数</li><li>having发生在分组group by之后，只有分组后的字段和聚合函数可以在having中使用，并且可以包含聚合函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select distinct post,count(id) as emp_count from employee</span><br><span class="line">where salary&gt;1000</span><br><span class="line">group by post</span><br><span class="line">having count(id)&gt;1</span><br><span class="line">order by emp_count desc</span><br><span class="line"># 注意：其中别名emp_count在having中是无法使用的，emp_count只能在比select后执行的语句中使用！</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-limit分页"><a href="#5-limit分页" class="headerlink" title="5. limit分页"></a>5. limit分页</h3><ul><li><p>语法：<strong>select * from 表名 limit start,offset;</strong></p></li><li><p><strong>limit offset &#x3D;&#x3D; limit 0,offset</strong>：默认初始位置为0（可省略），然后往后查几条（offset）</p></li><li><p><strong>limit start,offset</strong>：从第几条开始（start），即先查询出第几条，然后包含这一条在内往后查几条（offset）</p></li><li><p>*<em>注意：start依然是页数的意思，只是需要通过计算得出start的值，计算公式为 <em>(第N页-1)*每页的个数</em>*</em></p></li></ul><h3 id="6-执行顺序"><a href="#6-执行顺序" class="headerlink" title="6. 执行顺序"></a>6. 执行顺序</h3><ul><li><p>语法顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select distinct 字段1,字段2,... from 表名</span><br><span class="line">where 过滤</span><br><span class="line">group by 分组</span><br><span class="line">having 过滤</span><br><span class="line">order by 排序</span><br><span class="line">limit 分页</span><br></pre></td></tr></table></figure></li><li><p><strong>关键字执行优先级（重点）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行顺序：from &gt; join &gt; where &gt; group by &gt; having &gt; select &gt; distinct &gt; order by &gt; limit</span><br><span class="line"></span><br><span class="line">mysql&gt; select gender,count(*) as con from students group by gender having con&gt;2;</span><br><span class="line">+--------+-----+</span><br><span class="line">| gender | con |</span><br><span class="line">+--------+-----+</span><br><span class="line">| 女     |   7 |</span><br><span class="line">| 男     |   5 |</span><br><span class="line">+--------+-----+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line">-- 在标准SQL中，having子句在select之前执行，所以按理说having中是不能使用select中设置的别名的，</span><br><span class="line">-- 但是这里允许，这个特性是 MySQL 的一个扩展，可能不适用于所有数据库管理系统，所以要具体考虑是否可以使用</span><br></pre></td></tr></table></figure></li></ul><h2 id="六、单表查询训练"><a href="#六、单表查询训练" class="headerlink" title="六、单表查询训练"></a>六、单表查询训练</h2><blockquote><ul><li>创建数据库和数据表：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">create database python_test_1 charset=utf8;</span><br><span class="line"></span><br><span class="line">-- 使用数据库</span><br><span class="line">use python_test_1;</span><br><span class="line"></span><br><span class="line">-- students表</span><br><span class="line">create table students(</span><br><span class="line">    id int unsigned primary key auto_increment not null,</span><br><span class="line">    name varchar(20) default &#x27;&#x27;,</span><br><span class="line">    age tinyint unsigned default 0,</span><br><span class="line">    height decimal(5,2),</span><br><span class="line">    gender enum(&#x27;男&#x27;,&#x27;女&#x27;,&#x27;中性&#x27;,&#x27;保密&#x27;) default &#x27;保密&#x27;,</span><br><span class="line">    cls_id int unsigned default 0,</span><br><span class="line">    is_delete bit default 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- classes表</span><br><span class="line">create table classes (</span><br><span class="line">    id int unsigned auto_increment primary key not null,</span><br><span class="line">    name varchar(30) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>准备数据：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 向students表中插入数据</span><br><span class="line">insert into students values</span><br><span class="line">(0,&#x27;小明&#x27;,18,180.00,2,1,0),</span><br><span class="line">(0,&#x27;小月月&#x27;,18,180.00,2,2,1),</span><br><span class="line">(0,&#x27;彭于晏&#x27;,29,185.00,1,1,0),</span><br><span class="line">(0,&#x27;刘德华&#x27;,59,175.00,1,2,1),</span><br><span class="line">(0,&#x27;黄蓉&#x27;,38,160.00,2,1,0),</span><br><span class="line">(0,&#x27;凤姐&#x27;,28,150.00,4,2,1),</span><br><span class="line">(0,&#x27;王祖贤&#x27;,18,172.00,2,1,1),</span><br><span class="line">(0,&#x27;周杰伦&#x27;,36,NULL,1,1,0),</span><br><span class="line">(0,&#x27;程坤&#x27;,27,181.00,1,2,0),</span><br><span class="line">(0,&#x27;刘亦菲&#x27;,25,166.00,2,2,0),</span><br><span class="line">(0,&#x27;金星&#x27;,33,162.00,3,3,1),</span><br><span class="line">(0,&#x27;静香&#x27;,12,180.00,2,4,0),</span><br><span class="line">(0,&#x27;郭靖&#x27;,12,170.00,1,4,0),</span><br><span class="line">(0,&#x27;周杰&#x27;,34,176.00,2,5,0);</span><br><span class="line"></span><br><span class="line">-- 向classes表中插入数据</span><br><span class="line">insert into classes values (0, &quot;python_01期&quot;), (0, &quot;python_02期&quot;);</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>多表查询（联合查询）中区分字段是属于哪个表的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select stus.id as 学生编号,stus.name as 学生姓名 from students as stus</span><br></pre></td></tr></table></figure></li><li><p>在select后面列前使用distinct可以消除重复的行（<strong>distinct去重</strong>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct gender from students;</span><br></pre></td></tr></table></figure></li><li><p><strong>枚举类型enum</strong>的值是有索引的，<strong>索引从1开始</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- gender enum(&#x27;男&#x27;,&#x27;女&#x27;,&#x27;中性&#x27;,&#x27;保密&#x27;)，定义时&#x27;男&#x27;的索引为1</span><br><span class="line">select * from students where id&gt;3 and gender=&#x27;男&#x27;;</span><br><span class="line">select * from students where id&gt;3 and gender=1;</span><br></pre></td></tr></table></figure></li><li><p>通过下划线<strong>模糊匹配</strong>对应字数的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 周杰伦和周杰</span><br><span class="line">select * from students where name like &#x27;周%&#x27;;</span><br><span class="line">-- 周杰</span><br><span class="line">select * from students where name like &#x27;周_&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><strong>order by组合排序</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 显示所有的学生信息，先按照年龄降序排序，当年龄相同时，按照身高降序排序</span><br><span class="line">select * from students order by age desc,height desc;</span><br></pre></td></tr></table></figure></li><li><p>**group by + group_concat() **也支持取别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select gender,group_concat(name) from students group by gender;</span><br><span class="line">select gender as 性别分组,group_concat(name) as 学生姓名 from students group by gender;</span><br></pre></td></tr></table></figure></li><li><p><strong>group by + 聚合函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 分别统计不同性别的人的个数</span><br><span class="line">select gender,count(*) from students group by gender;</span><br></pre></td></tr></table></figure></li><li><p><strong>group by + having</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 分别统计不同性别的人的个数大于2的数据</span><br><span class="line">select gender,count(*) from students group by gender having count(*)&gt;2;</span><br></pre></td></tr></table></figure></li><li><p><strong>group by + with rollup</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 当having和with rollup一起使用时，having语句应位于with rollup语句后</span><br><span class="line">select gender,count(*) from students group by gender with rollup having count(*)&gt;2;</span><br><span class="line">-- 当使用group_concat(age)将每一组的年龄全部输出后，with rollup则将所有组的全部年龄记录输出</span><br><span class="line">select gender,group_concat(age) from students group by gender with rollup;</span><br></pre></td></tr></table></figure></li><li><p><strong>limit分页</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第6-10条数据</span><br><span class="line">select * from students limit 5,5;</span><br></pre></td></tr></table></figure></li></ul><h2 id="七、连接查询"><a href="#七、连接查询" class="headerlink" title="七、连接查询"></a>七、连接查询</h2><ul><li><p><strong>内连接查询（inner join…on…）</strong>：</p><ul><li>作用：用于返回两个表中匹配的数据，类似于两个表的交集，仅返回同时在两个表中存在的行</li><li>语法：<strong>select * from 表1 inner join 表2 on 表1.列 &#x3D; 表2.列;</strong></li></ul></li><li><p><strong>左连接查询（left join…on…）</strong>：</p><ul><li>作用：用于返回左表的所有行和右表中匹配的行，如果右表没有匹配行，将为右表的那部分返回 NULL 值</li><li>语法：<strong>select * from 表1 left join 表2 on 表1.列 &#x3D; 表2.列;</strong></li></ul></li><li><p><strong>右连接查询（right join…on…）</strong>：</p><ul><li>作用：用于返回右表的所有行和左表中匹配的行，如果左表没有匹配行，将为左表的那部分返回 NULL 值</li><li>语法：<strong>select * from 表1 right join 表2 on 表1.列 &#x3D; 表2.列;</strong></li></ul></li><li><p>用法：inner join用于获取精确匹配数据，而left join和right join用于保留一个表（基准表）的所有数据，同时合并另一个表的匹配数据<strong>（不管什么连接查询，都可以使用as给表取别名）</strong></p></li><li><p><strong>注意：左连接查询完全可以实现右连接查询的功能，所以右连接查询一般不常用</strong></p></li><li><p>实战案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 左连接实现右连接查询</span><br><span class="line">select * from classes left join students on students.cls_id=classes.id;</span><br><span class="line">-- 直接右连接查询，与上面等价，查询数据结果一致，只是数据显示方向不一样</span><br><span class="line">select * from students as stu right join classes as cls on stu.cls_id=cls.id;</span><br></pre></td></tr></table></figure></li></ul><h2 id="八、自关联查询"><a href="#八、自关联查询" class="headerlink" title="八、自关联查询"></a>八、自关联查询</h2><ul><li><p>简介：自关联是一种在同一表内连接不同行的技术，通常用于处理具有父子关系或层级关系的数据。在这种情况下，表中的每一行可以与表中的其他行建立关联，以形成层次结构</p></li><li><p><strong>自关联的表结构：</strong> 要实现自关联，需要在同一表中创建至少两个列，其中一个列用于引用另一个列中的数据。通常，这两列是在同一表中的外键和主键</p></li><li><p>实战案例：</p><ul><li><p>创建areas表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table tb_areas(</span><br><span class="line">    aid int primary key,</span><br><span class="line">    atitle varchar(20),</span><br><span class="line">    pid int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">mysql&gt; desc tb_areas;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| aid    | int         | NO   | PRI | NULL    |       |</span><br><span class="line">| atitle | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| pid    | int         | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure></li><li><p>从sql文件中导入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source areas.sql;</span><br></pre></td></tr></table></figure></li><li><p><strong>自关联查询</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询一共有多少省</span><br><span class="line">select count(*) from tb_areas where pid is null;</span><br><span class="line"></span><br><span class="line">-- 查询省的名称为“山西省”的所有城市（自关联查询实质就是内连接查询）</span><br><span class="line">select city.* from tb_areas as city inner join tb_areas as province on city.pid=province.aid where province.atitle=&#x27;山西省&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询市的名称为“广州市”的所有区县</span><br><span class="line">select 区县.* from tb_areas as 区县 inner join tb_areas as 城市 on 区县.pid=城市.aid where 城市.atitle=&#x27;广州市&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="九、子查询"><a href="#九、子查询" class="headerlink" title="九、子查询"></a>九、子查询</h2><ul><li><p>概念：子查询是一种在SQL查询中嵌套的查询，它可以用于从一个查询中获取数据，并将其作为另一个查询的一部分；通常嵌套在select、from、where、having或in等子句中，以获取或筛选数据</p></li><li><p><strong>注意：数据量过大时，使用子查询可能会导致性能问题（使用时最好用括号括起来，表示为条件）</strong></p></li><li><p><strong>标量子查询</strong>：返回单个值，通常用于比较运算或在主查询中的某个列中设置值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询大于平均年龄的学生</span><br><span class="line">select * from students where age &gt; (select avg(age) from students);</span><br></pre></td></tr></table></figure></li><li><p><strong>列级子查询</strong>：返回一个列，通常用于选择主查询中的一个或多个列的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询学生表中所有的班级id对应的班级表中的班级名称</span><br><span class="line">select name from classes where id in (select cls_id from students);</span><br></pre></td></tr></table></figure></li><li><p><strong>行级子查询</strong>：返回一行数据，通常用于与主查询中的一行或多行进行比较或联接</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">insert into students values(0,&#x27;小傅&#x27;,59,185,&#x27;男&#x27;,1,0);</span><br><span class="line"></span><br><span class="line">-- 查询身高和年龄同时满足所有学生里最大身高和最大年龄的学生</span><br><span class="line">select * from students where (height,age) = (select max(height),max(age) from students);</span><br><span class="line"></span><br><span class="line">+----+--------+------+--------+--------+--------+----------------------+</span><br><span class="line">| id | name   | age  | height | gender | cls_id | is_delete            |</span><br><span class="line">+----+--------+------+--------+--------+--------+----------------------+</span><br><span class="line">| 15 | 小傅   |   59 | 185.00 | 男     |      1 | 0x00                 |</span><br><span class="line">+----+--------+------+--------+--------+--------+----------------------+</span><br></pre></td></tr></table></figure><h2 id="十、MySQL视图"><a href="#十、MySQL视图" class="headerlink" title="十、MySQL视图"></a>十、MySQL视图</h2><ul><li><p>简介：MySQL视图（View）是一种虚拟的数据库对象，它是一个由一个或多个基本表（或其他视图）的查询结果组成的结果集，可以像表一样被查询</p></li><li><p><strong>创建视图：create view v_视图名称 as select语句;（视图名称一般以v_开头命名）</strong></p></li><li><p><strong>查看视图：show tables;（查看表会将所有的视图也列出来）</strong></p></li><li><p><strong>使用视图：视图的用途就是查询，可以像查询普通表一样使用 select 语句来查询视图</strong></p></li><li><p><strong>删除视图：drop view 视图名称;</strong></p></li><li><p><strong>视图的作用：</strong></p><ol><li>视图常用于对select语句封装，类似python中的函数，提高了查询语句重用性</li><li>视图可以用来隐藏底层表的复杂性，提供一个更简单和安全的数据访问层</li><li>视图可以用于限制用户对数据的访问权限，只允许他们看到特定列或行</li><li>视图还可以用于在多个应用程序组件之间共享数据，提供一种抽象的数据接口</li></ol></li><li><p><strong>注意：</strong></p><ul><li>视图是虚拟的，查询视图时实际上是在运行视图定义的查询，因此可能会引入一些性能开销</li><li>对于频繁使用的查询，考虑将它们转化为物理表以提高性能</li></ul></li><li><p>实战案例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询省的名称为“山西省”的所有城市（自关联查询实质就是内连接查询）</span><br><span class="line">select city.* from tb_areas as city inner join tb_areas as province on city.pid=province.aid where province.atitle=&#x27;山西省&#x27;;</span><br><span class="line"></span><br><span class="line">-- 创建视图</span><br><span class="line">create view v_sxs as select city.* from tb_areas as city inner join tb_areas as province on city.pid=province.aid where province.atitle=&#x27;山西省&#x27;;</span><br><span class="line"></span><br><span class="line">-- 使用视图</span><br><span class="line">mysql&gt; select * from v_sxs;</span><br></pre></td></tr></table></figure><h2 id="十一、事务"><a href="#十一、事务" class="headerlink" title="十一、事务"></a>十一、事务</h2><ul><li><p><strong>事务的特性：</strong></p><ul><li><strong>原子性：事务是一个不可分割的工作单元，要么全部执行成功，要么全部回滚</strong></li><li><strong>一致性</strong>：事务在执行前后，数据库必须保持一致性状态。如果事务开始时数据库是一致的，那么在事务结束后，数据库仍然必须是一致的</li><li><strong>隔离性</strong>：多个事务同时执行时，它们应该被隔离开来，一个事务的修改不应影响其他事务的执行。MySQL支持不同级别的隔离度，如读未提交、读提交、可重复读和串行化</li><li><strong>持久性</strong>：一旦事务成功提交，其结果应该持久保存在数据库中，即使发生了系统故障也不应丢失</li></ul></li><li><p><strong>事务的控制语句</strong>：</p><ul><li><strong>begin 或 start transaction</strong>：开始一个新的事务</li><li><strong>commit</strong>：提交事务，将所有已执行的操作永久保存到数据库中</li><li><strong>rollback</strong>：回滚事务，撤销所有已执行的操作</li><li><strong>savepoint</strong>：设置保存点，用于在事务中部分回滚</li><li><strong>rollback to</strong>：回滚到指定的保存点</li></ul></li><li><p><strong>事务的自动提交</strong>：默认情况下，MySQL是以自动提交模式运行的，这意味着每个SQL语句都被视为一个单独的事务，并且在执行后立即提交（<strong>使用 set autocommit &#x3D; 0; 可以禁用自动提交</strong>）</p></li></ul><h2 id="十二、PyMySQL"><a href="#十二、PyMySQL" class="headerlink" title="十二、PyMySQL"></a>十二、PyMySQL</h2><h3 id="1-数据库链接"><a href="#1-数据库链接" class="headerlink" title="1. 数据库链接"></a>1. 数据库链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">def db_connect():</span><br><span class="line">    # 1. 创建pymysql的数据库链接的实例对象</span><br><span class="line">    db = pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;123456&quot;, db=&quot;python_test_1&quot;)</span><br><span class="line"></span><br><span class="line">    # 2. 使用链接对象创建游标对象，链接对象无法执行sql语句，游标对象才可以</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">    # 3. 使用游标对象执行sql语句</span><br><span class="line">    cursor.execute(&quot;select version();&quot;)</span><br><span class="line"></span><br><span class="line">    # 4. 获取结果，返回的类型是元组</span><br><span class="line">    result = cursor.fetchone()  # 获取一条结果</span><br><span class="line">    print(result)  # (&#x27;8.0.33&#x27;,)</span><br><span class="line"></span><br><span class="line">    # 5. 关闭数据库链接</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">db_connect()</span><br></pre></td></tr></table></figure><h3 id="2-创建数据表"><a href="#2-创建数据表" class="headerlink" title="2. 创建数据表"></a>2. 创建数据表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">def create_table():</span><br><span class="line">    db = pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;123456&quot;, db=&quot;python_test_1&quot;)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">    # 1. 保证函数执行多次不发生异常，可以提前执行sql语句&quot;如果表存在就删除&quot;</span><br><span class="line">    # cursor.execute(&quot;drop table if exists employee;&quot;)</span><br><span class="line"></span><br><span class="line">    # 创建sql语句，后使用游标对象执行</span><br><span class="line">    sql = &quot;&quot;&quot;</span><br><span class="line">        -- 2. create table if not exists employee，也可以防止异常发生</span><br><span class="line">        create table employee(</span><br><span class="line">            first_name varchar(20) not null,</span><br><span class="line">            last_name varchar(20),</span><br><span class="line">            age tinyint,</span><br><span class="line">            gender varchar(2),</span><br><span class="line">            income float,</span><br><span class="line">            create_time datetime</span><br><span class="line">        );</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 使用异常处理执行sql，以捕获异常</span><br><span class="line">    try:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        print(&quot;表创建成功...&quot;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # 为了演示异常存在的情况，则注释掉1、2步防止异常发生的代码</span><br><span class="line">        # 表创建失败，异常为： (1050, &quot;Table &#x27;employee&#x27; already exists&quot;)</span><br><span class="line">        print(&quot;表创建失败，异常为：&quot;, e)</span><br><span class="line">    finally:</span><br><span class="line">        cursor.close()</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line">create_table()</span><br></pre></td></tr></table></figure><h3 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3. 插入数据"></a>3. 插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def insert_data():</span><br><span class="line">    with pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;123456&quot;, db=&quot;python_test_1&quot;) as db:</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">        # 1. 可以直接在sql语句后使用%运算符匹配实参，即&quot;元组打包&quot;，</span><br><span class="line">        # 这样就不必再在下面cursor.execute()方法中为sql语句传入实参了</span><br><span class="line">        # sql = &quot;&quot;&quot;</span><br><span class="line">        #     insert into employee(first_name, last_name, age, gender, income, create_time) values(</span><br><span class="line">        #         %s, %s, %s, %s, %s, %s</span><br><span class="line">        #     );</span><br><span class="line">        # &quot;&quot;&quot; % (&#x27;小&#x27;, &#x27;明&#x27;, 18, &#x27;男&#x27;, 20000, datetime.datetime.now())</span><br><span class="line"></span><br><span class="line">        # 2. 使用f直接格式化字符串传值</span><br><span class="line">        # sql = f&quot;&quot;&quot;</span><br><span class="line">        #     insert into employee values(&#x27;小&#x27;, &#x27;明&#x27;, 18, &#x27;男&#x27;, 20000, &#x27;&#123;datetime.datetime.now()&#125;&#x27;);</span><br><span class="line">        # &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        # 3. 使用%s作为占位符格式化字符串</span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            insert into employee(first_name, last_name, age, gender, income, create_time) values(</span><br><span class="line">                %s, %s, %s, %s, %s, %s</span><br><span class="line">            );</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            # 3. cursor.execute()方法可以为sql语句传参，参数默认值=None</span><br><span class="line">            cursor.execute(sql, (&#x27;小&#x27;, &#x27;明&#x27;, 18, &#x27;男&#x27;, 20000, datetime.datetime.now()))</span><br><span class="line"></span><br><span class="line">            # 数据操作(除了查询)需要进行事务提交，pymysql默认开启事务，所以当修改、添加和删除数据时均需要提交</span><br><span class="line">            db.commit()  # 调用的对象是链接对象，不是游标对象！</span><br><span class="line">            print(&quot;数据插入成功...&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;数据插入失败，异常为：&quot;, e)</span><br><span class="line">            db.rollback()  # 如果插入失败，则需要事务回滚</span><br><span class="line"></span><br><span class="line">insert_data()</span><br></pre></td></tr></table></figure><h3 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="4. 查询数据"></a>4. 查询数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">def query_data():</span><br><span class="line">    with pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;123456&quot;, db=&quot;python_test_1&quot;) as db:</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            select * from employee where income &gt; 10000;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            # 注意：数据查询不需要进行提交，以为并没有操作数据</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">            # cursor.fetchone()用于逐行获取数据，适用于单个结果或处理小型结果集</span><br><span class="line">            # result=cursor.fetchone()</span><br><span class="line"></span><br><span class="line">            # cursor.fetchall()用于一次性获取结果集中的所有行，</span><br><span class="line">            # 适用于结果集较小的情况，但对于大型结果集，可能会导致内存占用过多</span><br><span class="line">            # result=cursor.fetchall()</span><br><span class="line"></span><br><span class="line">            # cursor.fetchmany(size)用于获取指定数量的行(size参数指定)，可以有效地控制内存占用</span><br><span class="line">            result = cursor.fetchmany(2)</span><br><span class="line">            print(result)</span><br><span class="line"></span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;查询失败，异常为：&quot;, e)</span><br><span class="line"></span><br><span class="line">query_data()</span><br></pre></td></tr></table></figure><h3 id="5-更新数据"><a href="#5-更新数据" class="headerlink" title="5. 更新数据"></a>5. 更新数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">def update_data():</span><br><span class="line">    with pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;123456&quot;, db=&quot;python_test_1&quot;) as db:</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">        sql = &quot;&quot;&quot;</span><br><span class="line">            update employee set age=age+1 where gender=&quot;男&quot;;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line">            db.commit()</span><br><span class="line">            print(&quot;更新数据成功...&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;更新数据失败，异常为：&quot;, e)</span><br><span class="line">            db.rollback()</span><br><span class="line"></span><br><span class="line">update_data()</span><br></pre></td></tr></table></figure><h2 id="十三、索引"><a href="#十三、索引" class="headerlink" title="十三、索引"></a>十三、索引</h2><ul><li>简介：索引是一种数据结构，它存储了表中一列或多列的值以加速数据的检索，这提供了一种更快速地查找数据行的方法，而不必扫描整个表</li><li><strong>作用：</strong><ol><li><strong>提高查询性能</strong>：索引可以加速查询操作，使其更快</li><li><strong>唯一性约束</strong>：索引可以确保表中某一列的值是唯一的</li><li><strong>外键关联</strong>：索引可以用于实现表之间的外键关联</li><li><strong>排序</strong>：索引可用于加速排序操作</li></ol></li><li><strong>索引分类：</strong><ul><li>主键索引（Primary Key Index）：用于唯一标识每一行的索引</li><li>唯一索引（Unique Index）：确保索引列中的值是唯一的</li><li>普通索引（Normal Index）：最基本的索引类型，用于加速查询</li><li>全文索引（Full-Text Index）：用于全文搜索操作</li><li>组合索引（Composite Index）：多个列上的索引，用于加速复合条件查询</li><li>空间索引（Spatial Index）：用于空间数据类型（如地理信息数据）的查询</li><li>全局索引（Global Index）和局部索引（Local Index）：针对分区表的索</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、MySQL数据库&quot;&gt;&lt;a href=&quot;#一、MySQL数据库&quot; class=&quot;headerlink&quot; title=&quot;一、MySQL数据库&quot;&gt;&lt;/a&gt;一、MySQL数据库&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL是什么：&lt;strong&gt;mysql就是一</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>C11_位运算</title>
    <link href="http://example.com/2022/11/01/C11_%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2022/11/01/C11_%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、位的概念"><a href="#一、位的概念" class="headerlink" title="一、位的概念"></a>一、位的概念</h2><blockquote><p>简介：一个字节是由8个二进制位(8位)组成，最左边的是最高位，最右边的是最低位</p></blockquote><h3 id="1-位运算符（针对二进制位进行运算）"><a href="#1-位运算符（针对二进制位进行运算）" class="headerlink" title="1. 位运算符（针对二进制位进行运算）"></a>1. 位运算符（针对二进制位进行运算）</h3><ul><li>&amp; 按位与运算符：参加运算的两个运算量，如果两个相应的位都为1即结果为1，否则为0</li><li>按位或运算符：参加运算的两个运算量，两个相应的位有一个为1结果就为1，否则为0</li><li>^ 按位异或运算符：参加运算的两个运算量，两个相应的位相同结果就为0，否则为1<ul><li>用法：0111 1010 跟1做异或，就能翻转某些位；跟0做异或，就能保留某些位</li></ul></li><li>~ 按位非运算符(单目运算符)：用来对一个数字进行按位取反，把1变成0，把0变成1</li><li>&lt;&lt; 左移运算符：将一个数的二进制位左移若干位，右侧补0（每左移一位，相当于十进制数*2）</li><li>&gt;&gt; 右移运算符：将一个数的二进制位右移若干位，超出最低位的被舍弃，左边最高位补0（每左移一位，相当于十进制数&#x2F;2）</li></ul><h3 id="2-位运算符和赋值运算符可以结合使用"><a href="#2-位运算符和赋值运算符可以结合使用" class="headerlink" title="2. 位运算符和赋值运算符可以结合使用"></a>2. 位运算符和赋值运算符可以结合使用</h3><ul><li>即复合运算符：&amp;&#x3D; &#x3D; ^&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;</li></ul><h2 id="二、本文案例"><a href="#二、本文案例" class="headerlink" title="二、本文案例"></a>二、本文案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 宏定义</span><br><span class="line">#define BIT(X) (1&lt;&lt;(X))</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 例1：</span><br><span class="line">    unsigned int fei = ~38;</span><br><span class="line">    unsigned int zuo = 7 &lt;&lt; 3;  //0111 =&gt; 1110 =&gt; 11100 =&gt; 111000</span><br><span class="line">    unsigned int you = 15 &gt;&gt; 2; //1111 =&gt; 0111 =&gt; 0011</span><br><span class="line">    printf(&quot;例1：fei=%u；zuo=%u；you=%u\n&quot;, fei, zuo, you);</span><br><span class="line"></span><br><span class="line">    // 例2：位运算符和赋值运算符构成复合运算符</span><br><span class="line">    int a = 3, b = 11;</span><br><span class="line">    a &amp;= b; //a = a &amp; b;</span><br><span class="line">    b &lt;&lt;= a;</span><br><span class="line">    printf(&quot;例2：a=%u；b=%u\n&quot;, a, b);</span><br><span class="line"></span><br><span class="line">    // 例3：</span><br><span class="line">    printf(&quot;例3：\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        printf(&quot;BIT(%d)=%d\n&quot;,i,BIT(i));</span><br><span class="line">    // 十进制数    二进制数</span><br><span class="line">    // 1          1</span><br><span class="line">    // 2          10</span><br><span class="line">    // 4          100</span><br><span class="line">    // 8          1000</span><br><span class="line">    // 16         10000</span><br><span class="line">    // 32         100000</span><br><span class="line">    // 64         1000000</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、位的概念&quot;&gt;&lt;a href=&quot;#一、位的概念&quot; class=&quot;headerlink&quot; title=&quot;一、位的概念&quot;&gt;&lt;/a&gt;一、位的概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;简介：一个字节是由8个二进制位(8位)组成，最左边的是最高位，最右边的是最低位&lt;/</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C10_结构体与共用体</title>
    <link href="http://example.com/2022/10/01/C10_%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/"/>
    <id>http://example.com/2022/10/01/C10_%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/</id>
    <published>2022-09-30T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C语言结构体（Struct）从本质上讲是一种自定义的数据类型，只不过这种数据类型比较复杂，是由 int、char、float 等基本类型组成的；你可以认为结构体是一种聚合类型。 在实际开发中，我们可以将一组类型不同、但是用来描述同一件事物的变量放到结构体中。例如：在校学生有姓名、年龄、身高、成绩等属性，有了结构体后，我们就不需要再定义多个变量了，可以将它们都放到结构体中。 结构体与共用体这一章的概念比较抽象，请大家结合案例一起学习，不然只看笔记可能会比较容易理解错误或混淆概念</p></blockquote><h2 id="一、结构体"><a href="#一、结构体" class="headerlink" title="一、结构体"></a>一、结构体</h2><h3 id="1-结构体概述"><a href="#1-结构体概述" class="headerlink" title="1. 结构体概述"></a>1. 结构体概述</h3><ul><li>语法：struct 结构体名{ 成员列表 };</li><li>作用：用于定义一些复杂数据类型，把一些有内在联系的不同变量放在一起，封装成一个整体</li><li>说明：<ol><li>结构体也是一种数据类型，叫做结构体类型</li><li>定义结构体时，末尾的分号不可以省略！</li></ol></li></ul><h3 id="2-定义结构体类型变量的方法"><a href="#2-定义结构体类型变量的方法" class="headerlink" title="2. 定义结构体类型变量的方法"></a>2. 定义结构体类型变量的方法</h3><ul><li>语法：<ol><li>先再前面定义结构体类型，再定义结构体类型变量：struct 结构体名 变量名列表;</li><li>定义结构体类型时，一起定义结构体类型变量，即：struct 结构体名{…}变量名表列;</li></ol></li><li>说明：<ol><li>定义结构体变量时，[struct+结构体名]就可以看成一个类型名，是一个整体，同int,char等类型名是一个意思</li><li>如果定义时省略结构体名且同时定义了结构体变量，那后续就不能再定义结构体变量了</li><li>使用结构体，一般先定义结构体，再定义结构体类型变量</li><li>结构体内也是可以嵌套结构体的</li><li>结构体内的成员名，可以与程序中的变量名相同，是一个局部概念</li></ol></li></ul><h3 id="3-结构体类型变量的引用"><a href="#3-结构体类型变量的引用" class="headerlink" title="3. 结构体类型变量的引用"></a>3. 结构体类型变量的引用</h3><ul><li>引用方式：结构体变量名.成员名</li><li>注意：不能将结构体的所有成员当做一个整体被结构体变量引用，只能对结构体中的各个成员分别引用</li><li>说明：<ol><li>“.”号叫结构成员运算符，优先级与()相同</li><li>如果成员也有结构体类型，则需要使用若干个成员运算符，只能对最低级成员进行赋值或存取</li><li>成员变量就可以像普通变量一样进行各种运算</li><li>成员变量也是有地址的，可以使用指针</li></ol></li></ul><h3 id="4-结构体变量的初始化"><a href="#4-结构体变量的初始化" class="headerlink" title="4. 结构体变量的初始化"></a>4. 结构体变量的初始化</h3><ul><li>struct jgtdy c3 &#x3D; {1001, “张三”, 1, 18, 4, 22, 2021};</li></ul>### 5\. 结构体数组*   定义结构体数组：    1.  在定义结构体的时候一起定义结构体数组，即：struct 结构体名{...}数组名\[\];    2.  单独在函数中定义，即：struct 结构体名 数组名\[\];    3.  定义结构体数组时初始化：struct 结构体名 数组名\[3\]={{...},{...},{...}};<h3 id="6-结构体指针"><a href="#6-结构体指针" class="headerlink" title="6. 结构体指针"></a>6. 结构体指针</h3><ul><li>说明：结构体变量的指针，指向该结构体变量所占内存段的起始地址，可以直接通过结构体变量访问成员，也可以通过结构体变量的指针来访问成员：<ol><li>(_ps).age &#x3D; 18; &#x2F;&#x2F;因为.优先级高于\_，所以要用括号括起来</li><li>ps-&gt;sex &#x3D; 0; &#x2F;&#x2F;其中-&gt;叫做”指向结构体运算符”，优先级也是最高的</li></ol></li><li>注意：指针可以指向数组首地址，也可以指向数组某一个元素的地址，但是不能指向数组元素中的结构体成员</li></ul><h3 id="7-用指向结构体的指针做函数参数"><a href="#7-用指向结构体的指针做函数参数" class="headerlink" title="7. 用指向结构体的指针做函数参数"></a>7. 用指向结构体的指针做函数参数</h3><ul><li>见例子</li></ul><h2 id="二、共用体-联合"><a href="#二、共用体-联合" class="headerlink" title="二、共用体(联合)"></a>二、共用体(联合)</h2><h3 id="1-结构体与共用体的区别："><a href="#1-结构体与共用体的区别：" class="headerlink" title="1. 结构体与共用体的区别："></a>1. 结构体与共用体的区别：</h3><ul><li>结构体的各个成员会占用不同的内存，互相之间没有影响，其内存是所有成员之和；而共用体中所有成员占用的是同一段内存，修改一个成员会影响其余所有成员，其内存是最长的成员长度</li></ul><h3 id="2-共用体概述"><a href="#2-共用体概述" class="headerlink" title="2. 共用体概述"></a>2. 共用体概述</h3><ul><li>语法：union 共用体名{ 成员列表 };</li><li>作用：把几种不同类型的变量存放到同一段内存单元中(同一个内存地址开始的单元中)</li><li>说明：共用体与结构体的定义、引用均相似，也可单独定义变量，且也用.号引用</li></ul><h3 id="3-共用体类型的特点"><a href="#3-共用体类型的特点" class="headerlink" title="3. 共用体类型的特点"></a>3. 共用体类型的特点</h3><ol><li>共用体变量的地址和其成员的地址都是同一地址</li><li>同一段内存存放的是几种不同类型的成员，但每一个瞬间只能存放其中一种，即只有一个能起作用，并不能都存在或都起作用</li><li>在程序代码中，最后给哪一个共用体成员赋值，哪个成员就起作用，能够访问的只是最后一次被赋值的成员，在对一个新的成员赋值后原有的成员就失去作用</li><li>共用体变量不能在定义时初始化，也不能对共用体变量名赋值；不能企图引用变量名来得到一个值</li><li>不能把共用体变量作为函数参数，也不能让函数带回共用体变量</li></ol><h2 id="三、枚举类型"><a href="#三、枚举类型" class="headerlink" title="三、枚举类型"></a>三、枚举类型</h2><ul><li>语法：定义关键字为enum，定义方式与结构体共用体相似，这里就不再次介绍</li><li>说明：<ol><li>枚举：就是将值一一列出来</li><li>定义枚举时里面的成员叫”枚举常量”，值不能改变</li><li>枚举常量可以看成整型常量，占4个字节，且系统会对其进行从0开始的对应值</li><li>可以直接给枚举变量类型赋值</li><li>定义枚举类型时，里面的枚举常量可以直接赋值(整数)，其后面的常量值会依次加一</li><li>枚举值也可以作比较，其实枚举值就是整型值，是可以互通的</li><li>枚举值可以被赋给一个整型</li></ol></li></ul><h2 id="四、用typedef定义类型"><a href="#四、用typedef定义类型" class="headerlink" title="四、用typedef定义类型"></a>四、用typedef定义类型</h2><ul><li>语法：typedef 原类型名 新类型名;</li><li>作用：定义新的类型名代替已有的类型名</li><li>说明：<ol><li>类型别名一般用大写</li><li>typedef是用来定义类型名的，不是用来定义变量的</li><li>typedef是编译的时候处理的</li><li>typedef主要作用：提高程序的通用性和可移植性</li></ol></li></ul><h2 id="五、本文案例"><a href="#五、本文案例" class="headerlink" title="五、本文案例"></a>五、本文案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 声明：本文件函数 + 外部函数 + 外部全局变量(extern)</span><br><span class="line">struct date</span><br><span class="line">&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;;</span><br><span class="line">struct jgtdy</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char name[100];</span><br><span class="line">    int sex;</span><br><span class="line">    int age;</span><br><span class="line">    struct date birthday; //结构体内嵌套结构体，定义(struct date)结构体变量作为此结构体成员</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void func(struct jgtdy *pp); //由于形参里包含结构体指针，要用到结构体，所以这个函数声明必须写在结构体声明下面</span><br><span class="line"></span><br><span class="line">union person</span><br><span class="line">&#123;</span><br><span class="line">    int phone;</span><br><span class="line">    char add[255];</span><br><span class="line">    char name[30];</span><br><span class="line">&#125;;</span><br><span class="line">enum color</span><br><span class="line">&#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE = 37,</span><br><span class="line">    YELLOW</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 例1：</span><br><span class="line">    struct jgtdy a1, b2;                                  //定义两个结构体变量</span><br><span class="line">    a1.num = 195562140;                                   //结构体成员的引用赋值</span><br><span class="line">    a1.birthday.day = 15;                                 //嵌套结构体成员的引用赋值</span><br><span class="line">    int *p = &amp;a1.num;                                     //使用指针变量指向结构体成员，以引用赋值</span><br><span class="line">    struct jgtdy c3 = &#123;1001, &quot;张三&quot;, 1, 18, 2021, 4, 22&#125;; //结构体变量的定义初始化</span><br><span class="line">    printf(&quot;例1：a1.num=%d；a1.birthday.day=%d；*p=%d；c3.name=%s\n&quot;, a1.num, a1.birthday.day, *p, c3.name);</span><br><span class="line"></span><br><span class="line">    // 例2：</span><br><span class="line">    struct jgtdy stu[3]; //定义结构体数组，同普通数组一样可以引用stu[0]--stu[2]</span><br><span class="line">    struct jgtdy stu1[] = &#123;</span><br><span class="line">        &#123;1111, &quot;小明&quot;, 1, 20, 2001, 5, 19&#125;,</span><br><span class="line">        &#123;2222, &quot;小红&quot;, 0, 20, 2001, 5, 21&#125;,</span><br><span class="line">        &#123;3333, &quot;小李&quot;, 1, 20, 2001, 7, 15&#125;&#125;; //结构体数组的定义初始化</span><br><span class="line">    printf(&quot;例2：小红明年的年龄为%d岁\n&quot;, ++stu1[1].age);</span><br><span class="line"></span><br><span class="line">    // 例3：</span><br><span class="line">    struct jgtdy ss;</span><br><span class="line">    struct jgtdy *ps = &amp;ss;</span><br><span class="line">    strcpy(ss.name, &quot;小傅&quot;); //由于上面定义的name为字符串数组，所以不能直接对其赋值，因为name代表的是数组首地址</span><br><span class="line">    // strcpy(dest,src); strcpy函数作用是把src的字符串复制到dest，如果dest长度小于src，则会造成缓冲溢出的情况</span><br><span class="line">    (*ps).sex = 0; //因为.优先级高于*，所以要用括号括起来</span><br><span class="line">    ps-&gt;age = 18;  //这里的&quot;-&gt;&quot;叫做&quot;指向结构体运算符&quot;，优先级也是最高的，只有地址可以指向，可以用这个符号，变量不行！</span><br><span class="line">    printf(&quot;例3：ss.name=%s；(*ps).sex=%d；ps-&gt;age=%d\n&quot;, ss.name, ss.sex, ss.age);</span><br><span class="line"></span><br><span class="line">    // 例4：</span><br><span class="line">    struct jgtdy *pa = stu1; //定义结构体指针指向例2定义的结构体数组首地址</span><br><span class="line">    printf(&quot;例4：循环输出数组每个元素的name值：&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sizeof(stu1) / sizeof(stu1[0]); i++)</span><br><span class="line">        printf(&quot;%s  &quot;, (pa++)-&gt;name);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 例5：</span><br><span class="line">    func(pa); //指向结构体的指针做函数参数</span><br><span class="line">    printf(&quot;例5：pa-&gt;age=%d\n&quot;, pa-&gt;age);</span><br><span class="line"></span><br><span class="line">    // 例6：</span><br><span class="line">    union person per; //共用体变量的定义赋值引用</span><br><span class="line">    per.phone = 123456789;</span><br><span class="line">    strcpy(per.add, &quot;四川省成都市&quot;);</span><br><span class="line">    printf(&quot;例6：per.phone=%d；per.add=%s\n&quot;, per.phone, per.add);</span><br><span class="line">    //通过运行结果很清楚的知道，per.phone赋值已经失去作用，原因是因为对per,add进行了赋值，他们的地址为同一地址</span><br><span class="line"></span><br><span class="line">    // 例7：</span><br><span class="line">    enum color cor; //枚举类型的定义赋值</span><br><span class="line">    cor = BLUE; //可以直接给枚举变量类型赋值</span><br><span class="line">    printf(&quot;例7：cor = %d\n&quot;, cor);</span><br><span class="line"></span><br><span class="line">    // typedef定义新的类型名代替已有的类型名</span><br><span class="line">    typedef int INTEDER;</span><br><span class="line">    INTEDER num = 20; // 定义一个整型变量</span><br><span class="line">    typedef struct date</span><br><span class="line">    &#123;</span><br><span class="line">        int year;</span><br><span class="line">        int month;</span><br><span class="line">        int day;</span><br><span class="line">    &#125; DATE;     // 定义结构体类型并将类型名struct date替换为DATE</span><br><span class="line">    DATE birth; // 定义一个结构体变量</span><br><span class="line">    DATE *pp;   // 定义一个结构体指针</span><br><span class="line"></span><br><span class="line">    // typedef特殊常用定义</span><br><span class="line">    typedef int NUM[100];     // 定义NUM为整型数组类型</span><br><span class="line">    NUM n = &#123;2001, 7, 15&#125;;    // 即int n[100] = &#123;2001, 7, 15&#125;;</span><br><span class="line">    typedef int *POINT;       // 定义POINT为整型指针类型</span><br><span class="line">    POINT pint = n;           // 即char *p = n;</span><br><span class="line">    typedef int (*POINTER)(); // 定义POINTER为指向函数的指针类型，返回值是整型值</span><br><span class="line">    POINTER pfunc;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void func(struct jgtdy *pp)</span><br><span class="line">&#123;</span><br><span class="line">    pp-&gt;age = 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C语言结构体（Struct）从本质上讲是一种自定义的数据类型，只不过这种数据类型比较复杂，是由 int、char、float 等基本类型组成的；你可以认为结构体是一种聚合类型。 在实际开发中，我们可以将一组类型不同、但是用来描述同一件事物的变量放到</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C9_5_main函数参数和指向指针的指针_总结</title>
    <link href="http://example.com/2022/09/01/C9_5_main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88_%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/09/01/C9_5_main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88_%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2024-12-09T02:26:09.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、本章小结"><a href="#一、本章小结" class="headerlink" title="一、本章小结"></a>一、本章小结</h2><ul><li>指针变量可以为空值，表示不指向任何变量，例：int *p &#x3D; NULL;<ul><li>NULL就是整数0；使p指向地址为零的单元</li><li>系统会保证地址为零这个单元不存放任何有效数据</li><li>常用写法：if(p &#x3D;&#x3D; NULL){p &#x3D; &a;}</li></ul></li><li>void *型指针（万能型指针变量）<ul><li>能够指向任意数据类型</li><li>优点：效率高</li><li>缺点：没有缺点</li></ul></li></ul><h2 id="二、本文案例"><a href="#二、本文案例" class="headerlink" title="二、本文案例"></a>二、本文案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[]) //主函数</span><br><span class="line">// 参数1：argv是指针数组的元素个数；参数2为指针数组，其中argv[0]保存的是可执行文件的完整路径名，argv[argv]为NULL，中间的其他值则为传入的字符串</span><br><span class="line">&#123;</span><br><span class="line">    // 例1：指向指针的指针：用来指向指针变量的变量</span><br><span class="line">    int num = 5;</span><br><span class="line">    int *pnum = &amp;num;</span><br><span class="line">    int **ppnum = &amp;pnum; //定义了一个指向字符串指针变量的指针变量</span><br><span class="line">    printf(&quot;例1：num=%d，*pnum=%d，**ppnum=%d\n&quot;, num, *pnum, **ppnum);</span><br><span class="line"></span><br><span class="line">    // 例2：指针数组做main函数形参：可以通过命令行给main传入不同参数</span><br><span class="line">    printf(&quot;例2：argc=%d，argv[0]=%s，argv[argc]=%s\n&quot;, argc, argv[0], argv[argc]);</span><br><span class="line">    /* for (int i = 0; i &lt; argc; i++)</span><br><span class="line">        printf(&quot;%s，&quot;,*argv++); //使用循环直接输出argv里的每一个值 */</span><br><span class="line"></span><br><span class="line">    // 例3：void *万能型指针</span><br><span class="line">    int a = 3;</span><br><span class="line">    float b = 5.67f;</span><br><span class="line">    void *wn = NULL;</span><br><span class="line">    wn = &amp;a;</span><br><span class="line">    printf(&quot;例3：&amp;a=%p，&quot;, wn);</span><br><span class="line">    wn = &amp;b;</span><br><span class="line">    printf(&quot;&amp;b=%p\n&quot;, wn);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、本章小结&quot;&gt;&lt;a href=&quot;#一、本章小结&quot; class=&quot;headerlink&quot; title=&quot;一、本章小结&quot;&gt;&lt;/a&gt;一、本章小结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;指针变量可以为空值，表示不指向任何变量，例：int *p &amp;#x3D; NULL;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
