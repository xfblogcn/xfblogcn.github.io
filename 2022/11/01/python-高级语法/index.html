<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="xfblog">
    
    <title>
        
            02_Python_高级语法 |
        
        XFBLOG.CN
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/favicon.webp">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/brands.min.css">
    
        
            
                
<link rel="stylesheet" href="/css/custom-1.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"XFBLOG.CN","author":"xfblog","avatar":"/images/avatar.webp","logo":"/images/logo.webp","favicon":"/images/favicon.webp"},"menu":{"home":"/ || fa-solid fa-home","archives":"/archives || fa-solid fa-box-archive","categories":"/categories || fa-solid fa-layer-group","links":"/links || fa-solid fa-link","about":"/about || fa-solid fa-circle-info"},"first_screen":{"enable":true,"background_img":"/images/home_light.webp","background_img_dark":"/images/home_dark.webp","description":null,"hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/xfblogcn","weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":true,"hide_header":true},"home":{"announcement":"版权声明：本站所有文章均为 xfblog.cn 小傅原创，请遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。","category":true,"tag":true,"post_datetime":"created","post_datetime_format":"YYYY-MM-DD"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD","copyright_info":true,"share":true,"reward":{"enable":true,"img_link":"/images/zfb.webp","text":"创作不易，打赏随意，您的支持是我更新的动力💪！"}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":false,"site_pv":false,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":true},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"jsdelivr"},"pjax":{"enable":true},"footer":{"since":2021,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":true,"list":[{"code":"蜀ICP备2021021033号-1","link":"https://beian.miit.gov.cn"},{"code":"川公网安备 51138102000134号","link":"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51138102000134"}]}},"inject":{"enable":true,"css":["/css/custom-1.css"],"js":["/js/run_time.js","/js/code_click_copy.js","/js/copyrightpro.js"]},"root":"","source_data":{},"version":"4.2.5"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Keep" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.webp">
                </a>
            
            <a class="site-name border-box" href="/">
               XFBLOG.CN
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-home"></i>
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                
                                分类
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/links">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-link"></i>
                                
                                友链
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/about">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-circle-info"></i>
                                
                                关于
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-home"></i>
                                </span>
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                </span>
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                </span>
                            
                            分类
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/links">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-link"></i>
                                </span>
                            
                            友链
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/about">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-circle-info"></i>
                                </span>
                            
                            关于
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        02_Python_高级语法
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.webp">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">xfblog</span>
                                
                                    <span class="author-badge">Lv3</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2022-11-01</span>
            </span>

            
                <span class="meta-info-item post-update-date">
                    <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                    <span class="datetime" data-updated="Wed Nov 27 2024 16:23:37 GMT+0800">2024-11-27</span>
                </span>
            
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/Python/">Python</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Python/">Python</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>28.3k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>115 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h2 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h2><h4 id="1-函数的定义与调用"><a href="#1-函数的定义与调用" class="headerlink" title="1. 函数的定义与调用"></a>1. 函数的定义与调用</h4><ul>
<li>简介：def是Python定义的关键字，用于定义函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;语法格式：</span><br><span class="line"></span><br><span class="line">def 函数名([形参1, 形参2, ... , 形参n]):</span><br><span class="line">    函数体</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def decide_args(arg1, arg2):</span><br><span class="line">    if arg1 and arg2:</span><br><span class="line">        return arg1, arg2</span><br><span class="line">    elif (not arg1) and (not arg2):</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        result = arg1 or arg2</span><br><span class="line"></span><br><span class="line">print(decide_args)  # `&lt;function decide_args at 0x100613eb0&gt;`</span><br><span class="line">print(type(decide_args))  # `&lt;class &#x27;function&#x27;&gt;`</span><br><span class="line"></span><br><span class="line">print(decide_args(18, &#x27;Hello&#x27;))  # (18, &#x27;Hello&#x27;)</span><br><span class="line">print(decide_args([], &#123;&#125;))  # None return返回值什么都没有时，返回值为None</span><br><span class="line">print(decide_args(18, []))  # None 函数正常结束无return时，返回值也为None</span><br></pre></td></tr></table></figure>

<h4 id="2-函数的多个返回值"><a href="#2-函数的多个返回值" class="headerlink" title="2. 函数的多个返回值"></a>2. 函数的多个返回值</h4><ul>
<li>简介：在调用函数后需要有多个返回值，可以在定义函数时在函数体内使用return语句返回由多个返回值组成的元组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 把列表中所有数分成奇数和偶数两类</span><br><span class="line">def classify_numbers(numbers):</span><br><span class="line">    odds = []</span><br><span class="line">    evens = []</span><br><span class="line">    for number in numbers:</span><br><span class="line">        if number % 2:</span><br><span class="line">            odds.append(number)</span><br><span class="line">        else:</span><br><span class="line">            evens.append(number)</span><br><span class="line">    return odds, evens</span><br><span class="line"></span><br><span class="line">print(classify_numbers([15, 86, 39, 26, 53, 68]))  # ([15, 39, 53], [86, 26, 68])</span><br></pre></td></tr></table></figure>

<h4 id="3-函数的两种实参与传递"><a href="#3-函数的两种实参与传递" class="headerlink" title="3. 函数的两种实参与传递"></a>3. 函数的两种实参与传递</h4><ul>
<li><strong>位置实参</strong>：调用函数时，根据每个形参在所有形参中的位置传递对应位置的实参，从而用每个实参初始化对应位置的形参</li>
<li><strong>关键字实参</strong>：调用函数时，传递的实参的形式可以为：<strong>形参名 &#x3D; 实参值</strong>，从而用指定的实参值初始化指定名称的形参</li>
<li>注意：<strong>每个关键字实参在所有关键字实参中的位置是任意的；但当位置实参和关键字实参组合使用时，位置实参必须位于关键字实参之前</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def f(a, b, c):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c)</span><br><span class="line"></span><br><span class="line"># 函数的调用之位置实参</span><br><span class="line">f(2, 5, 8)  # a = 2 b = 5 c = 8</span><br><span class="line"># 函数的调用之关键字实参</span><br><span class="line">f(a=2, b=5, c=8)  # a = 2 b = 5 c = 8</span><br><span class="line"># 位置实参必须位关键字实参之前，否则报错</span><br><span class="line"># f(2, c=8, 5)  # SyntaxError: positional argument follows keyword argument</span><br><span class="line">f(2, 5, c=8)  # a = 2 b = 5 c = 8</span><br></pre></td></tr></table></figure>

<ul>
<li>实参的传递：<strong>如果实参对象是可变类型，在函数体内对形参对象的任何修改就是对实参对象本身的修改</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def f(arg1, arg2):</span><br><span class="line">    print(&#x27;初始化形参后：arg1 =&#x27;, arg1, &#x27;arg2 =&#x27;, arg2)</span><br><span class="line">    arg1 *= 2</span><br><span class="line">    arg2.append(4)</span><br><span class="line">    print(&#x27;修改形参后：arg1 =&#x27;, arg1, &#x27;arg2 =&#x27;, arg2)</span><br><span class="line"></span><br><span class="line">i = 10  # 整数类型是不可变对象</span><br><span class="line">L = [1, 2, 3]  # 列表是可变对象</span><br><span class="line"></span><br><span class="line">print(&#x27;调用函数前实参：i =&#x27;, i, &#x27;L =&#x27;, L)  # 调用函数前实参：i = 10 L = [1, 2, 3]</span><br><span class="line">f(i, L)</span><br><span class="line">print(&#x27;调用函数后实参：i =&#x27;, i, &#x27;L =&#x27;, L)  # 调用函数后实参：i = 10 L = [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h4 id="4-函数的默认值形参"><a href="#4-函数的默认值形参" class="headerlink" title="4. 函数的默认值形参"></a>4. 函数的默认值形参</h4><ul>
<li>简介：定义函数时可以给形参设置默认值，在调用函数时如果不传递对应的实参，就会使用默认值初始化形参</li>
<li>注意：<strong>定义函数时，普通形参必须位于设置了默认值的形参之前，否则无法根据位置来匹配位置实参和对应的形参</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fun(a, b=5):</span><br><span class="line">    # 技巧：当函数有多个形参时，把变化大的形参放前面，变化小的形参放后面，则变化小的形参就可以设置默认值</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b)</span><br><span class="line"></span><br><span class="line"># 定义默认值形参后，可以有多种调用形式</span><br><span class="line">fun(3)  # a = 3 b = 5</span><br><span class="line">fun(a=3)  # a = 3 b = 5</span><br><span class="line">fun(3, 6)  # a = 3 b = 6</span><br><span class="line">fun(a=3, b=6)  # a = 3 b = 6</span><br><span class="line">fun(b=6, a=3)  # a = 3 b = 6</span><br><span class="line">fun(3, b=6)  # a = 3 b = 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>问题抛出：在定义函数时，给形参设置的默认值就已经被计算出来了</strong></p>
<p>问题解释：如果给形参设置的默认值是可变类型的对象，且前一次调用函数时在函数体内修改了形参的默认值，则修改后的值将作为下一次调用函数时形参的默认值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fun1(L=[]):  # 定义的默认值为列表（可变对象），且在函数中改变了列表</span><br><span class="line"> L.append(18)</span><br><span class="line"> print(L)</span><br><span class="line"></span><br><span class="line">fun1()  # [18]</span><br><span class="line">fun1()  # [18, 18]</span><br><span class="line">fun1()  # [18, 18, 18]</span><br></pre></td></tr></table></figure>

<p>解决问题：<strong>不要把形参的默认值设置为可变类型的对象，可以设置为不可变对象None</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fun2(L=None):</span><br><span class="line"> if L is None:</span><br><span class="line">     L = []</span><br><span class="line"> L.append(18)</span><br><span class="line"> print(L)</span><br><span class="line"></span><br><span class="line">fun2()  # [18]</span><br><span class="line">fun2()  # [18]</span><br><span class="line">fun2()  # [18]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-函数中-对参数的用法"><a href="#5-函数中-对参数的用法" class="headerlink" title="5. 函数中*对参数的用法"></a>5. 函数中*对参数的用法</h4><ol>
<li>*_使用_定义关键字形参**<ul>
<li>简介：定义函数时，可以在所有形参的某个位置添加一个*，则*后面的所有参数都会被定义为关键字形参</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def f(a, b, *, c, d):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d)</span><br><span class="line"></span><br><span class="line">f(1, 2, c=3, d=4)  # a = 1 b = 2 c = 3 d = 4</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>*_使用_定义个数可变的位置形参**</p>
<ul>
<li><p>简介：定义函数时，在形参前添加一个*，可将形参定义为个数可变的位置形参，可以接受0个或任意多个位置实参，这些位置实参会将个数可变的位置形参初始化为一个<strong>元组</strong></p>
</li>
<li><p>注意：<strong>一个函数最多只能定义一个个数可变的位置形参</strong></p>
</li>
<li><p>知识点1：*_当个数可变的位置形参不是最后一个形参时，则其后的所有形参也都会被定义为关键字形参，此时相当于覆盖了第一点“使用_定义关键字形参”的用法**</p>
</li>
<li><p>知识点2：如果传递的实参全为位置实参，则所有传递过去的<strong>位置实参</strong>都会被位于前面的<strong>个数可变的位置形参</strong>所接收，这会导致其后的<strong>关键字形参</strong>接收实参缺失，<strong>抛出异常</strong></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def fun1(a, b, *c):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c)</span><br><span class="line"></span><br><span class="line">fun1(1, 2, 3, 4, 5)  # a = 1 b = 2 c = (3, 4, 5)</span><br><span class="line"></span><br><span class="line">def fun2(a, *b, c, d):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d)</span><br><span class="line"></span><br><span class="line">fun2(1, 2, 3, 4, c=5, d=6)  # a = 1 b = (2, 3, 4) c = 5 d = 6</span><br><span class="line">&quot;&quot;&quot;fun2(1, 2, 3, 4, 5, 6)</span><br><span class="line">解释：此时实参1传递给了形参a，而剩余所有位置实参都被*b所接收，从而导致关键字实参缺失</span><br><span class="line">抛出异常：TypeError: fun2() missing 2 required keyword-only arguments: &#x27;c&#x27; and &#x27;d&#x27;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>*_使用_将序列中的每个元素都转换为位置实参（解包）**<ul>
<li>简介：调用函数时，可以在序列前加一个*，从而将序列中的每个元素都转换为一个单独的位置实参</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">def fun(a, b, c):</span><br><span class="line">    print(a, b, c)</span><br><span class="line"></span><br><span class="line">fun(L[0], L[1], L[2])  # 1 2 3</span><br><span class="line">fun(*L)  # 1 2 3 等价上式</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>使用**定义个数可变的关键字形参</strong><ul>
<li>简介：定义函数时，在形参前添加上**，可将形参定义为个数可变的关键字形参，可以接受0个或任意多个关键字实参，这些关键字实参会将个数可变的关键字形参初始化为一个<strong>字典</strong></li>
<li>注意：<strong>一个函数最多只能定义一个个数可变的关键字形参；且个数可变的位置形参必须位于个数可变的关键字形参之前</strong></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def f(**kwargs):</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">f()  # &#123;&#125;</span><br><span class="line">f(a=1)  # &#123;&#x27;a&#x27;: 1&#125;</span><br><span class="line">f(a=1, b=2, c=3)  # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line"></span><br><span class="line">def fun(*args, **kwargs):</span><br><span class="line">    print(kwargs, args)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;可变位置形参必须位于可变关键字形参之前，否则报错</span><br><span class="line">def fun(**kwargs, *args):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">抛出异常：SyntaxError: arguments cannot follow var-keyword argument</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用**将字典中的每个健值对都转换为关键字实参（解包）</strong><ul>
<li>简介：调用函数时，可以在字典前加上**，从而将字典中的每个健值对都转换为一个单独的关键字实参</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line"></span><br><span class="line">def fun(**kwargs):</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">fun(a=d[&#x27;a&#x27;], b=d[&#x27;b&#x27;], c=d[&#x27;c&#x27;])  # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line">fun(**d)  # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>综合案例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 案例1</span><br><span class="line">def f1(a, b=5, *args, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;args =&#x27;, args, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f1(2)  # a = 2 b = 5 args = () kwargs = &#123;&#125;</span><br><span class="line">f1(2, 6, 7, 8, c=9)  # a = 2 b = 6 args = (7, 8) kwargs = &#123;&#x27;c&#x27;: 9&#125;</span><br><span class="line"></span><br><span class="line"># 案例2</span><br><span class="line">def f2(a, b=5, *, c, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f2(3, c=8, d=10)  # a = 3 b = 5 c = 8 kwargs = &#123;&#x27;d&#x27;: 10&#125;</span><br><span class="line">my_list = (3, 6)</span><br><span class="line">my_dict = &#123;&#x27;c&#x27;: 8, &#x27;d&#x27;: 10&#125;</span><br><span class="line">f2(*my_list, **my_dict)  # a = 3 b = 6 c = 8 kwargs = &#123;&#x27;d&#x27;: 10&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-递归函数"><a href="#6-递归函数" class="headerlink" title="6. 递归函数"></a>6. 递归函数</h4><ul>
<li>简介：如果在一个函数体内调用了该函数本身，则该函数就是递归函数</li>
<li>注意：<strong>当递归超过最大深度时，系统会抛出异常。可调用标准库模块sys中的函数setrecursionlimit(n)设置递归最大深度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(10000)  # 设置递归深度为10000</span><br><span class="line"></span><br><span class="line">def fac(n):</span><br><span class="line">    &quot;&quot;&quot;使用递归计算阶乘&quot;&quot;&quot;</span><br><span class="line">    if n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fac(n - 1)</span><br><span class="line"></span><br><span class="line">print(&#x27;fac(6) =&#x27;, fac(6))  # fac(6) = 720</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    &quot;&quot;&quot;使用递归计算斐波那切数列</span><br><span class="line">    F0=0, F1=1, Fn=F(n-1)+F(n-2)(n&gt;=2)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 0</span><br><span class="line">    if n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    return fib(n - 1) + fib(n - 2)</span><br><span class="line"></span><br><span class="line">print(&#x27;fib(6) =&#x27;, fib(6))  # fib(6) = 8</span><br></pre></td></tr></table></figure>

<h4 id="7-pass语句、文档字符串、函数注解"><a href="#7-pass语句、文档字符串、函数注解" class="headerlink" title="7. pass语句、文档字符串、函数注解"></a>7. pass语句、文档字符串、函数注解</h4><ul>
<li>pass语句：只是一个占位符，什么都不做，用在语法上需要占位的地方：if、for-in、函数体等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = 21</span><br><span class="line">if age &gt; 18:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def do_something():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文档字符串</p>
<ul>
<li><p>简介：对于函数、模块、类或方法，位于其第一行的字符串被称为文档字符串，通常用三个引号表示</p>
</li>
<li><p>知识点：通过**属性__doc__<strong>可以访问文档字符串；通过</strong>内置函数help()**得到的帮助信息中也包含文档字符串</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;函数的文档字符串的常见内容和格式约定</span><br><span class="line">1. 第一行时简明扼要的总结</span><br><span class="line">2. 第一行的首字母大写，第一行以句号结尾</span><br><span class="line">3. 如果文档字符串包含多行，第二行是空行，从第三行开始是详细的描述</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def form_complex(real=0.0, imag=0.0):</span><br><span class="line">    &quot;&quot;&quot;Form a complex number.</span><br><span class="line"></span><br><span class="line">    Keyword arguments:</span><br><span class="line">    real -- the real part（default 0.0）</span><br><span class="line">    imag -- the imaginary part（default 0.0）</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(form_complex.__doc__)  # ......</span><br><span class="line">print(help(form_complex))  # ......</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数注解</p>
<ul>
<li><p>简介：定义函数时，为了让形参或返回值的类型或作用更加清晰，可以给形参或返回值添加函数注解，以帮助函数文档化</p>
</li>
<li><p>注意：<strong>解释器会忽略函数注解，因此解释器并不会使用函数注解来检查实参的类型和返回值的类型</strong></p>
</li>
<li><p>知识点：通过**属性__annotations__<strong>可以访问函数注解；通过</strong>内置函数help()**得到的帮助信息中也包含函数注解</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;添加函数注解的方式</span><br><span class="line">给形参添加函数注解：在形参后面添加:和任意的表达式</span><br><span class="line">给返回值添加函数注解：在)的后面添加-&gt;和任意的表达式</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def f(a: &#x27;string type&#x27;, b: int) -&gt; &#x27;join a with b&#x27;:</span><br><span class="line">    return a + str(b)</span><br><span class="line"></span><br><span class="line">print(f(&#x27;hello&#x27;, 12.3))  # hello12.3</span><br><span class="line">print(f.__annotations__)  # &#123;&#x27;a&#x27;: &#x27;string type&#x27;, &#x27;b&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;return&#x27;: &#x27;join a with b&#x27;&#125;</span><br><span class="line">print(help(f))  # ......</span><br></pre></td></tr></table></figure>

<h2 id="二、浅拷贝和深拷贝"><a href="#二、浅拷贝和深拷贝" class="headerlink" title="二、浅拷贝和深拷贝"></a>二、浅拷贝和深拷贝</h2><h4 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1. 浅拷贝"></a>1. 浅拷贝</h4><ul>
<li><p>简介：对于某个对象，创建与该对象具有相同值的一个新引用，但是<strong>这两个对象内部嵌套的对应子对象全都是同一个引用</strong></p>
</li>
<li><p>应用：</p>
<ol>
<li>切片操作[ : ]</li>
<li>调用列表、字典、集合的方法copy()</li>
<li>调用内置函数list()、dict()、set()</li>
<li>调用标准库模块copy中的函数copy()</li>
</ol>
</li>
<li><p><strong>重点：对于没有嵌套子对象的不可变对象，例如：整数、字符串和元组对象等，不会进行拷贝，即不会创建新引用</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">L = [[3, 6], 8]</span><br><span class="line"></span><br><span class="line">L1 = L[:]</span><br><span class="line">L2 = L.copy()</span><br><span class="line">L3 = list(L)</span><br><span class="line">L4 = copy.copy(L)</span><br><span class="line"></span><br><span class="line">print(id(L), id(L[0]), id(L[1]))  # 4335878976 4335878848 4334207440</span><br><span class="line">print(id(L1), id(L1[0]), id(L1[1]))  # 4335878912 4335878848 4334207440</span><br><span class="line">print(id(L2), id(L2[0]), id(L2[1]))  # 4335881600 4335878848 4334207440</span><br><span class="line">print(id(L3), id(L3[0]), id(L3[1]))  # 4335879168 4335878848 4334207440</span><br><span class="line">print(id(L4), id(L4[0]), id(L4[1]))  # 4335881984 4335878848 4334207440</span><br><span class="line"># 结论：4种方法都是浅拷贝，仅拷贝了最外部的L对象，没有拷贝内部对象，此时内部对象依然指向同一对象（地址相同）</span><br><span class="line"></span><br><span class="line">L[0][1] = 7</span><br><span class="line">L[1] = 9</span><br><span class="line">print(L, L1)  # [[3, 7], 9] [[3, 7], 8]</span><br><span class="line"># 解释：虽然子对象列表和整数都没有被拷贝，但是由于列表是可变对象，</span><br><span class="line"># 而整数是不可变对象，所以L1中的列表被同步修改了，而整数并没有被改变</span><br><span class="line"></span><br><span class="line"># 重点：对于没有嵌套子对象的不可变对象，是不会进行拷贝的</span><br><span class="line">i = 8</span><br><span class="line">ip = int(i)</span><br><span class="line">ip1 = copy.copy(i)</span><br><span class="line">print(id(i), id(ip), id(ip1))  # 4380836304 4380836304 4380836304</span><br><span class="line"></span><br><span class="line">t = (1, 2, 3)</span><br><span class="line">tp = tuple(t)</span><br><span class="line">tp1 = copy.copy(t)</span><br><span class="line">print(id(t), id(tp), id(tp1))  # 4382390208 4382390208 4382390208</span><br></pre></td></tr></table></figure>

<h4 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2. 深拷贝"></a>2. 深拷贝</h4><ul>
<li><p>简介：对于某个对象，创建与该对象具有相同值的一个新引用，同时<strong>这两个对象内部嵌套的对应可变子对象全都不是同一个引用，而对应不可变子对象依然是同一个引用</strong></p>
</li>
<li><p>应用：可以调用标准库模块copy中的函数deepcopy()实现深拷贝</p>
</li>
<li><p><strong>重点1：对于没有嵌套子对象的不可变对象，例如：整数、字符串和元组对象等，不会进行拷贝，即不会创建新引用</strong></p>
</li>
<li><p><strong>重点2：对于嵌套了可变子对象的不可变对象，深拷贝时会进行拷贝，即会创建一个与该不可变对象具有相同值的新引用</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">L1 = [[3, 6], 8]</span><br><span class="line">L2 = copy.deepcopy(L1)</span><br><span class="line">print(L1, L2)  # [[3, 6], 8] [[3, 6], 8]</span><br><span class="line"></span><br><span class="line">print(id(L1), id(L1[0]), id(L1[1]))  # 4365312512 4365312256 4363764176</span><br><span class="line">print(id(L2), id(L2[0]), id(L2[1]))  # 4365312192 4365421056 4363764176</span><br><span class="line"># 结论：这里深拷贝中内部元素，仅对列表进行了拷贝，这是因为对于没有嵌套子对象的不可变对象是不会进行拷贝的</span><br><span class="line"></span><br><span class="line">L1[0][1] = 7</span><br><span class="line">L1[1] = 9</span><br><span class="line">print(L1, L2)  # [[3, 7], 9] [[3, 6], 8]</span><br><span class="line"># 解释：L2的列表没有改变是因为子对象进行了拷贝，而整数由于是不可变对象，所以即使没有拷贝，也不会被改变</span><br><span class="line"></span><br><span class="line"># 重点1：对于没有嵌套子对象的不可变对象，是不会进行拷贝的</span><br><span class="line">i = 18</span><br><span class="line">ic = copy.deepcopy(i)</span><br><span class="line">print(ic)  # 18</span><br><span class="line">print(id(i), id(ic))  # 4299146000 4299146000</span><br><span class="line"></span><br><span class="line">t = (1, 2, 3)</span><br><span class="line">tc = copy.deepcopy(t)</span><br><span class="line">print(tc)  # (1, 2, 3)</span><br><span class="line">print(id(t), id(tc))  # 4302305216 4302305216</span><br><span class="line"></span><br><span class="line"># 重点2：不可变对象内部又嵌套了可变子对象的情况</span><br><span class="line">t1 = ([3, 6], 8)</span><br><span class="line">t2 = copy.deepcopy(t1)</span><br><span class="line"></span><br><span class="line">print(id(t1), id(t1[0]), id(t1[1]))  # 4365418624 4365585088 4363764176</span><br><span class="line">print(id(t2), id(t2[0]), id(t2[1]))  # 4365421184 4365585344 4363764176</span><br></pre></td></tr></table></figure>

<h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><blockquote>
<p><strong>面向对象程序设计</strong>（Object Oriented Programming，<strong>简称OOP</strong>）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP&#x3D;对象+类+继承+多态+消息，其中核心概念是<strong>类和对象</strong>。</p>
</blockquote>
<h4 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h4><p>操作</p>
<p>在类对象的内部（方法中）</p>
<p>在类对象的外部</p>
<p>实例属性</p>
<p>绑定</p>
<p>self.属性名&#x3D;属性值</p>
<p>实例对象.属性名&#x3D;属性值（已存在则是修改值）</p>
<p>访问</p>
<p>self.属性名</p>
<p>实例对象.属性名</p>
<p>类属性</p>
<p>绑定</p>
<p>属性名&#x3D;属性值</p>
<p>类对象.属性名&#x3D;属性值（已存在则是修改值）</p>
<p>访问</p>
<p>类对象.属性名</p>
<p>类对象.属性名 或 实例对象.属性名</p>
<p>实例方法</p>
<p>解释</p>
<p>实例方法指的是只有实例对象才可以调用的方法，定有参数为self</p>
<p>调用</p>
<p>self.方法名([实参])</p>
<p>实例对象.方法名([实参])</p>
<p>类方法</p>
<p>解释</p>
<p>类方法指的是类对象中使用装饰器@classmethod进行装饰的方法，定有参数为cls</p>
<p>调用</p>
<p>cls.方法名([实参]) 或 self.方法名([实参])</p>
<p>类对象.方法名([实参]) 或 实例对象.方法名([实参])</p>
<p>静态方法</p>
<p>解释</p>
<p>静态方式指的是类对象中使用装饰器@staticmethod进行装饰的方法，只是一个普通函数，无定有参数</p>
<p>调用</p>
<p>cls.方法名([实参]) 或 self.方法名([实参])</p>
<p>类对象.方法名([实参]) 或 实例对象.方法名([实参])</p>
<ul>
<li>注意：<strong>访问实例属性和类属性都可以通过“实例对象.属性名”的方式访问</strong>。但其优先级是<strong>实例属性&gt;类属性</strong>（实例属性存在则会屏蔽类属性的值，实例属性不存在则输出类属性的值）</li>
<li><strong>重点：</strong><ol>
<li><strong>由于类对象的所有实例对象都有一个指向类对象的指针，所以类对象的所有实例对象都可以调用类对象中定义的实例方法和类方法（若两者方法名相同，则下面的覆盖上面的）！</strong></li>
<li><strong>python不能重载构造方法！但可以利用设置默认值形参和多选来达到java中重载的目的，而不用再次重载定义构造方法</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Student:</span><br><span class="line"></span><br><span class="line">    # 定义初始化方法（构造方法），用于初始化对象属性（不支持重载），创建实例对象时会自动调用</span><br><span class="line">    def __init__(self, playgame=None):</span><br><span class="line">        self.sex = &#x27;男&#x27;</span><br><span class="line">        self.playgame = playgame</span><br><span class="line"></span><br><span class="line">    # 类属性</span><br><span class="line">    hobby = &#x27;睡觉&#x27;</span><br><span class="line"></span><br><span class="line">    # 实例方法</span><br><span class="line">    def fun(self, name=&#x27;匿名者&#x27;):  # name如果给默认值就不是必选参数了，没有默认值则是必选参数</span><br><span class="line">        print(&#x27;我叫&#x27; + name + &#x27;，性别&#x27; + self.sex + &#x27;，爱好&#x27; + self.hobby)</span><br><span class="line">        # print(self.fun1())  # 在实例方法可以中调用类方法</span><br><span class="line">        # print(self.fun2(&#x27;我喜欢&#x27;))  # 在实例方法中可以调用静态方法</span><br><span class="line"></span><br><span class="line">    # 类方法</span><br><span class="line">    @classmethod</span><br><span class="line">    def fun1(cls):</span><br><span class="line">        print(cls.hobby)  # 只能访问类属性</span><br><span class="line">        # print(cls.fun2(&#x27;我爱&#x27;))  # 在类方法中可以调用静态方法</span><br><span class="line"></span><br><span class="line">    # 静态方法</span><br><span class="line">    @staticmethod</span><br><span class="line">    def fun2(aaa):  # 静态方法中无`定有参数`，aaa只是普通参数</span><br><span class="line">        print(aaa, Student.hobby)  # 只能通过类名访问类属性</span><br><span class="line"></span><br><span class="line"># 创建实例对象</span><br><span class="line">tom = Student(&quot;lol&quot;)</span><br><span class="line">alice = Student()</span><br><span class="line">print(tom.playgame, alice.playgame)  # lol None</span><br><span class="line"></span><br><span class="line"># 访问-类属性（优先级问题）</span><br><span class="line">print(Student.hobby)  # 通过类访对象问类属性，睡觉</span><br><span class="line">tom.hobby = &#x27;干饭&#x27;  # 为tom添加了一个实例属性，并不会改变类属性中hobby的值</span><br><span class="line">print(tom.hobby)  # 由于tom已经有实例属性，优先级高于类属性，所以这里是访问的实例属性，干饭</span><br><span class="line">print(alice.hobby)  # alice访问时，由于没有实例属性hobby，所以访问的是类属性，睡觉</span><br><span class="line"></span><br><span class="line"># 访问-实例方法</span><br><span class="line">tom.fun()  # 我叫匿名者，性别男，爱好睡觉</span><br><span class="line">tom.fun(&#x27;汤姆&#x27;)  # 我叫汤姆，性别男，爱好睡觉</span><br><span class="line"></span><br><span class="line"># 访问-类方法</span><br><span class="line">Student.fun1()  # 通过类对象访问类方法，睡觉</span><br><span class="line">tom.fun1()  # 通过实例对象访问类方法，睡觉</span><br><span class="line"></span><br><span class="line"># 访问-静态方法</span><br><span class="line">Student.fun2(&#x27;嘿嘿嘿&#x27;)  # 通过类对象访问静态方法，嘿嘿嘿 睡觉</span><br><span class="line">tom.fun2(&#x27;哈哈哈&#x27;)  # 通过实例对象访问静态方法，哈哈哈 睡觉</span><br></pre></td></tr></table></figure>

<h4 id="2-Python的动态性"><a href="#2-Python的动态性" class="headerlink" title="2. Python的动态性"></a>2. Python的动态性</h4><ul>
<li><strong>动态地创建类：</strong><ul>
<li><strong>type是Python的内建元类</strong>，是用来创建所有类的元类，所以可以通过type函数创建类</li>
<li><strong>任何对象最终的所属类都是type</strong>，可通过type函数验证，也可以通过多级__class__属性验证</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">MyDog = type(&quot;Dog&quot;, (object,), &#123;&quot;role&quot;: &quot;dog&quot;, &quot;__init__&quot;: __init__&#125;)</span><br><span class="line">d = MyDog(&quot;pig&quot;)</span><br><span class="line">print(MyDog)  # `&lt;class &#x27;__main__.Dog&#x27;&gt;`</span><br><span class="line">print(d.__class__)  # `&lt;class &#x27;__main__.Dog&#x27;&gt;`</span><br><span class="line">print(d.__class__.__class__)  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line">print(d.role, d.name)  # dog pig</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态地绑定实例方法：</strong><ul>
<li>在实例对象或类对象创建之后，也可以通过<strong>标准库types中的类MethodType</strong>对其动态地绑定实例方法</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from types import MethodType</span><br><span class="line"></span><br><span class="line">def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">MyDog = type(&quot;Dog&quot;, (object,), &#123;&quot;role&quot;: &quot;dog&quot;, &quot;__init__&quot;: __init__&#125;)</span><br><span class="line">m1 = MyDog(&quot;jack&quot;)</span><br><span class="line">m2 = MyDog(&quot;alice&quot;)</span><br><span class="line"></span><br><span class="line">def my_pow(self, x, y):</span><br><span class="line">    result = x</span><br><span class="line">    for i in range(y - 1):</span><br><span class="line">        result *= x</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># 给实例对象m1动态地绑定实例方法</span><br><span class="line">m1.my_pow = MethodType(my_pow, m1)</span><br><span class="line">print(m1.my_pow(2, 3))  # 8</span><br><span class="line"></span><br><span class="line"># 删除m1的my_pow方法</span><br><span class="line">del m1.my_pow</span><br><span class="line"># 访问特殊属性__dict__可以获得实例对象所绑定的所有属性和属性对应值的一个字典</span><br><span class="line">print(m1.__dict__)  # &#123;&#x27;name&#x27;: &#x27;jack&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># 给类对象动态地绑定实例方法，这样所有实例都能访问my_pow()方法</span><br><span class="line">MyDog.my_pow = my_pow</span><br><span class="line">print(m1.my_pow(3, 2))  # 9</span><br><span class="line">print(m2.my_pow(2, 4))  # 16</span><br></pre></td></tr></table></figure>

<h4 id="3-访问控制"><a href="#3-访问控制" class="headerlink" title="3. 访问控制"></a>3. 访问控制</h4><ul>
<li>简介：目的是为了控制类对象的属性和方法在类对象的外部是否可以直接访问</li>
<li>应用：在类对象的某个属性或方法前<strong>添加两个下划线“_”</strong>，那么在类对象的外部就<strong>不能直接访问</strong>该属性或方法了；在类对象的某个属性或方法前<strong>添加单个下划线”_“<strong>，表示</strong>依然可以在类对象的外部直接访问</strong>该属性或方法，但<strong>最好不要直接访问</strong></li>
<li>原理：因为Python解释器对外把__xxx的属性或方法改成了另一个名字：_类名__xxx，虽然也可以通过此访问，但强烈不建议这样访问，因为不同版本的Python解释器可能更换的名字不同</li>
<li><strong>注意：在类对象的外部动态绑定名为__xxx的属性或方法，这与类对象内部名为__xxx的属性或方法的含义是不同的</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__pia = 18</span><br><span class="line">        self._pib = &#x27;abc&#x27;</span><br><span class="line"></span><br><span class="line">    def __pim(self):</span><br><span class="line">        print(&quot;__pim()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">    def _pin(self):</span><br><span class="line">        print(&quot;_pin()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">    # 通过实例方法访问不能直接访问的属性和方法</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(self.__pia)</span><br><span class="line">        self.__pim()</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line"># print(mc.__pia)  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;__pia&#x27;</span><br><span class="line"># mc.__pim()  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;__pim&#x27;</span><br><span class="line">print(mc._pib)  # abc</span><br><span class="line">mc._pin()  # _pin()被调用了</span><br><span class="line">mc.do_sth()  # 18 __pim()被调用了</span><br><span class="line"></span><br><span class="line"># Python为我们更改的名字，但最好不这样方法</span><br><span class="line"># print(mc._MyClass__pia)  # 18</span><br><span class="line"># mc._MyClass__pim()  # __pim()被调用了</span><br><span class="line">print(dir(mc))  # [&#x27;_MyClass__pia&#x27;, &#x27;_MyClass__pim&#x27;, ......]</span><br><span class="line">print(mc.__dict__)  # &#123;&#x27;_MyClass__pia&#x27;: 18, &#x27;_pib&#x27;: &#x27;abc&#x27;&#125;</span><br><span class="line">&quot;&quot;&quot;dir()和__dict__的区别：</span><br><span class="line">1. 调用内置函数dir()获得指定对象所有可以访问的属性和方法的一个列表</span><br><span class="line">   用于列出对象的所有属性和方法，主要是一个用于查阅对象的工具</span><br><span class="line">2. 访问特殊属性__dict__可以获得实例对象所绑定的所有属性和属性对应值的一个字典，是一个属性字典</span><br><span class="line">   用于保存对象的所有成员变量和对应的值，可以用于直接访问和操作对象的属性</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 在外部直接绑定__xxx属性，和内部意义是不一样的</span><br><span class="line">mc.__pia = &quot;Hi&quot;</span><br><span class="line">print(mc.__pia)  # Hi</span><br><span class="line">print(dir(mc))  # [&#x27;_MyClass__pia&#x27;, &#x27;_MyClass__pim&#x27;, &#x27;__pia&#x27;, ......]</span><br></pre></td></tr></table></figure>

<h4 id="4-封装、继承、重写、多态"><a href="#4-封装、继承、重写、多态" class="headerlink" title="4. 封装、继承、重写、多态"></a>4. 封装、继承、重写、多态</h4><ul>
<li><p><strong>封装</strong>：将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象外部调用方法，这样，就无需关心方法内部的具体实现细节，从而隔离了复杂度</p>
</li>
<li><p>应用：<strong>对隐藏的信息进行保护</strong>。在类对象的内部通过访问控制把某些属性和方法隐藏起来，不允许在类对象的外部直接访问，而是在类对象的内部对外提供公开的接口方法（例如getter和setter）以访问隐藏的信息</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__score = 90</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&quot;成绩必须在0~100之间&quot;)</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line"></span><br><span class="line">s.set_score(88)</span><br><span class="line"># s.set_score(123)  # ValueError: 成绩必须在0~100之间</span><br><span class="line">print(s.get_score())  # 88</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>继承：继承是实现代码复用的重要手段</strong>。把几个类对象中共同的属性和方法抽象并提取到一个基类中，每个类对象特有的属性和方法还是在本类对象中定义，这样，只需要让每个类对象都继承这个基类，就可以访问基类中的属性和方法了。其中，继承基类的每个类对象被称为<strong>派生类</strong>，基类也被称为<strong>父类</strong>或<strong>超类</strong>，派生类也被称为<strong>子类</strong></p>
</li>
<li><p>注意：<strong>Python中的所有类对象都继承自一个统一的基类：object</strong></p>
</li>
<li><p>知识点：子类可以有一个直接父类或多个直接父类，分别称为单继承和多继承。<strong>子类会继承父类（所有直接父类和所有间接父类）的所有属性和方法</strong>；子类可以添加父类中没有的属性和方法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ParentClassA(object):</span><br><span class="line">    ca = 18</span><br><span class="line"></span><br><span class="line">    def im(self):</span><br><span class="line">        print(&quot;im()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ParentClassB(object):</span><br><span class="line">    __pca = 23</span><br><span class="line"></span><br><span class="line">    def __pim(self):</span><br><span class="line">        print(&quot;__pim()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ParentClassC(ParentClassA, ParentClassB):</span><br><span class="line">    @classmethod</span><br><span class="line">    def cm(cls):</span><br><span class="line">        print(&quot;cm()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ParentClassD(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def sm():</span><br><span class="line">        print(&quot;sm()被调用了&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass(ParentClassC, ParentClassD):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 子类会继承父类（所有直接父类和所有间接父类）的所有属性和方法</span><br><span class="line">print(dir(ChildClass))  # [&#x27;_ParentClassB__pca&#x27;, &#x27;_ParentClassB__pim&#x27;, ......, &#x27;ca&#x27;, &#x27;cm&#x27;, &#x27;im&#x27;, &#x27;sm&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>重写</strong>：如果子类对继承自父类的某个属性或方法不满意，可以在子类中对其进行重写从而提供自定义的实现</p>
</li>
<li><p>应用：在子类中定义与父类中同名的属性或方法（包括装饰器）</p>
</li>
<li><p>注意：在子类中重写父类中的属性或方法后，通过子类或实例对象直接访问只能访问到重写后的属性或方法，想要再访问父类中的属性或方法，<strong>可以在子类重写后的方法中可以通过super( ).xxx( )进行调用</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ParentClass(object):</span><br><span class="line">    ca = &quot;ca（父类）&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;__init__()被调用了（父类）&quot;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def cm(cls):</span><br><span class="line">        print(&quot;cm()被调用了（父类）&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass(ParentClass):</span><br><span class="line">    ca = &quot;ca（子类）&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(&quot;__init__()被调用了（子类）&quot;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def cm(cls):</span><br><span class="line">        print(&quot;cm()被调用了（子类）&quot;)</span><br><span class="line"></span><br><span class="line">cc = ChildClass()  # __init__()被调用了（父类） __init__()被调用了（子类）</span><br><span class="line"></span><br><span class="line">print(ChildClass.ca)  # ca（子类）</span><br><span class="line">print(cc.ca)  # ca（子类）</span><br><span class="line">ChildClass.cm()  # cm()被调用了（子类）</span><br><span class="line">cc.cm()  # cm()被调用了（子类）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>多态：多态就是“具有多种形态”</strong>，即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法，<strong>在运行过程中根据变量所引用对象的类型，动态地决定调用哪个对象中的方法</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ParentClass:</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in ParentClass&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass1(ParentClass):</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in ChildClass1&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass2(ParentClass):</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in ChildClass2&quot;)</span><br><span class="line"></span><br><span class="line">class ChildClass3(ParentClass):</span><br><span class="line">    pass  # 子类中不存在指定方法时，会到父类中查找并调用</span><br><span class="line"></span><br><span class="line">class SomeClass(object):</span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth() in SomeClass&quot;)</span><br><span class="line"></span><br><span class="line">def f(parent):</span><br><span class="line">    parent.do_sth()</span><br><span class="line"></span><br><span class="line">f(ParentClass())  # do_sth() in ParentClass</span><br><span class="line">f(ChildClass1())  # do_sth() in ChildClass1</span><br><span class="line">f(ChildClass2())  # do_sth() in ChildClass2</span><br><span class="line">f(ChildClass3())  # do_sth() in ParentClass</span><br><span class="line">f(SomeClass())  # do_sth() in SomeClass</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>（重点）动态语言与静态语言多态的区别：</strong></p>
<ul>
<li><strong>Python是动态语言</strong>，在调用函数时不会检查参数的类型，从而导致与<strong>静态语言（例如Java）</strong>的多态 是有区别的。对于静态语言，实现多态有三个必要条件：<ol>
<li>继承</li>
<li>重写</li>
<li><strong>父类类型的变量引用父类或子类类型的实例对象</strong></li>
</ol>
</li>
</ul>
<p><strong>因此，对于静态语言，在上面的程序中，要限定形参parent的类型是ParentClass，传入的实参只能是</strong> <strong>ParentClass、ChildClass1、ChildClass2或ChildClass3的实例对象</strong></p>
<ul>
<li>动态语言的多态崇尚”<strong>鸭子类型</strong>“：当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子, 那么这只鸟就可以被称为鸭子。<strong>在鸭子类型中，我们并不关心对象是什么类型，到底是不是鸭子，只关心对象的行为</strong></li>
</ul>
<p><strong>因此，对于动态语言，在上面的程序中，我们并不关心变量parent所引用的对象是什么类型，到底是不是ParentClass或其子类类型，只关心变量parent所引用的对象是否有do_sth( )这个方法</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://osswcf.oss-cn-shanghai.aliyuncs.com/2022/12/1671017104-13bfb99460c4f1d.jpeg"
                       
                 ></p>
</blockquote>
<h4 id="5-MRO"><a href="#5-MRO" class="headerlink" title="5. MRO"></a>5. MRO</h4><ul>
<li><p>简介：MRO的全称是<strong>Method Resolution Order（方法解析顺序）</strong>，指的是对于一颗类继承树，当调用最底层类对象所对应实例对象的方法时，Python解释器在类继承树上搜索方法的顺序</p>
</li>
<li><p>应用：对于一颗类继承树，可以调用最底层类对象的方法<strong>mro( )<strong>或访问最底层类对象的特殊属性</strong>__mro__<strong>，</strong>获得这棵类继承树的MRO</strong></p>
</li>
<li><p>知识点：<strong>在子类重写后的方法中通过super( )调用父类中被重写的方法时，在所有父类中搜索方法的顺序基于以该子类为最底层类对象的类继承树的MRO</strong></p>
</li>
<li><p>知识点应用：在调用父类中被重写的方法时，给super( )传入两个实参，即super(type, obj)，其中第一个实参type是类对象，第二个实参obj是实例对象。这样，<strong>指定的对象即是obj所对应类对象的MRO中，type后面的那个类对象</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    def f(self):</span><br><span class="line">        print(&quot;A.f&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def f(self):</span><br><span class="line">        print(&quot;B.f&quot;)</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def f(self):</span><br><span class="line">        print(&quot;C.f&quot;)</span><br><span class="line"></span><br><span class="line">class D(B, C):</span><br><span class="line">    def f(self):</span><br><span class="line">        super().f()  # B.f</span><br><span class="line">        # super(D, self).f()  # B.f</span><br><span class="line">        # super(B, self).f()  # C.f</span><br><span class="line">        # super(C, self).f()  # A.f</span><br><span class="line">        # super(B, B()).f()  # A.f</span><br><span class="line"></span><br><span class="line">print(D.mro())</span><br><span class="line"># [`&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;`]</span><br><span class="line">d = D()</span><br><span class="line">d.f()  # B.f</span><br></pre></td></tr></table></figure>

<h4 id="6-获取对象的信息之内置函数"><a href="#6-获取对象的信息之内置函数" class="headerlink" title="6. 获取对象的信息之内置函数"></a>6. 获取对象的信息之内置函数</h4><ul>
<li><p><strong>内置函数issubclass(subclass, superclass)<strong>：用于</strong>检查类与类之间的继承关系</strong>，接受两个实参，第一个是类对象，第二个是类对象或由类对象组成的元组</p>
</li>
<li><p><strong>内置函数isinstance(object, classinfo)<strong>：用于</strong>检查对象与类之间的实例关系</strong>，接受两个实参，第一个是实例对象，第二个是类对象或由类对象组成的元组</p>
</li>
<li><p><strong>内置函数type(object)<strong>：用于</strong>获取对象的类型</strong>，返回表示对象类型的对象（<strong>使用运算符&#x3D;&#x3D;可以直接判断某个对象的类型是否是指定的类型</strong>，对于基本数据类型，可以直接使用其对应的类名；对于非基本数据类型，需要调用标准库中的模块types中定义的变量）</p>
</li>
<li><p><strong>内置函数dir([object])<strong>：用于</strong>获取对象有效属性和方法（包括从父类继承的属性和方法）的字符串列表</strong>，其中参数object是可选的，如果没有提供，则返回当前作用域内的名称列表。并且类对象与实例对象的结果是有区别的，类对象的结果中不包括实例属性</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Parent:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class AnotherClass:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 1、内置函数issubclass(subclass, superclass)</span><br><span class="line">print(issubclass(Child, Parent))  # True</span><br><span class="line">print(issubclass(bool, int))  # True</span><br><span class="line">print(issubclass(bool, str))  # False</span><br><span class="line">print(issubclass(bool, (str, int, dict)))  # True</span><br><span class="line"></span><br><span class="line"># 2、内置函数isinstance(object, classinfo)</span><br><span class="line">obj = Child()</span><br><span class="line">print(isinstance(obj, Child))  # True</span><br><span class="line">print(isinstance(obj, AnotherClass))  # False</span><br><span class="line">print(isinstance(obj, (Parent, AnotherClass)))  # True</span><br><span class="line"></span><br><span class="line"># 3、内置函数type(object)</span><br><span class="line"># 实例对象的类型是其对应的类对象</span><br><span class="line">mc = Parent()</span><br><span class="line">print(type(mc))  # `&lt;class &#x27;__main__.Parent&#x27;&gt;`</span><br><span class="line">print(type(18))  # `&lt;class &#x27;int&#x27;&gt;`</span><br><span class="line">print(type(&#x27;abc&#x27;))  # `&lt;class &#x27;str&#x27;&gt;`</span><br><span class="line"># 类对象的类型是type，也就是说，类对象都是type的一个实例</span><br><span class="line">print(type(Parent))  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line">print(type(int))  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line">print(type(str))  # `&lt;class &#x27;type&#x27;&gt;`</span><br><span class="line"></span><br><span class="line"># 自定义函数对象的类型是function</span><br><span class="line">def do_sth():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(type(do_sth))  # `&lt;class &#x27;function&#x27;&gt;`</span><br><span class="line"># 内置函数对象的类型是builtin_function_or_method</span><br><span class="line">print(type(print))  # `&lt;class &#x27;builtin_function_or_method&#x27;&gt;`</span><br><span class="line"></span><br><span class="line"># 使用运算符==判断某个对象的类型是否是指定的类型</span><br><span class="line">print(type(18) == int)  # True</span><br><span class="line">print(type(&#x27;abc&#x27;) == str)  # True</span><br><span class="line">import types</span><br><span class="line"></span><br><span class="line">print(type(do_sth) == types.FunctionType)  # True</span><br><span class="line">print(type(print) == types.BuiltinFunctionType)  # True</span><br><span class="line"></span><br><span class="line"># 4、内置函数dir([object])</span><br><span class="line">def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">AnotherClass.do_sth = do_sth</span><br><span class="line">AnotherClass.__init__ = __init__</span><br><span class="line"># 类对象的结果中不包括实例属性</span><br><span class="line">print(dir(AnotherClass))  # [......, &#x27;__init__&#x27;, ......, &#x27;do_sth&#x27;]</span><br><span class="line">print(dir(AnotherClass(&#x27;xfblog&#x27;)))  # [......, &#x27;__init__&#x27;, ......, &#x27;do_sth&#x27;, &#x27;name&#x27;]</span><br></pre></td></tr></table></figure>

<h4 id="7-获取对象的信息之反射"><a href="#7-获取对象的信息之反射" class="headerlink" title="7. 获取对象的信息之反射"></a>7. 获取对象的信息之反射</h4><ul>
<li><p>简介：所谓“反射”，指的是以字符串的形式来操作（增删改查）对象的属性和方法</p>
</li>
<li><p>用于“反射”的内置函数有以下四个（参数name为字符串）：</p>
<ol>
<li>hasattr(object, name)：用于判断指定的对象object是否有参数name指定的属性或方法</li>
<li>getattr(object, name[, default])：用于获取指定的对象object中名为name的属性或方法</li>
<li>setattr(object, name, value)：用于在指定的对象object中添加或修改参数名为name的属性或方法</li>
<li>delattr(object, name)：用于删除指定的对象object中名为参数name的属性或方法</li>
</ol>
</li>
<li><p>注意：<strong>只有在不知道对象信息的情况下，才会去获取对象的信息</strong>。因此，能写object.name，就不要写getattr(object, ‘name’)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 1</span><br><span class="line"></span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth被调用&quot;)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line">print(hasattr(mc, &#x27;x&#x27;))  # True</span><br><span class="line">print(hasattr(MyClass, &#x27;x&#x27;))  # False</span><br><span class="line">print(hasattr(mc, &#x27;do_sth&#x27;))  # True</span><br><span class="line"></span><br><span class="line">print(getattr(mc, &#x27;x&#x27;))  # 1</span><br><span class="line">f = getattr(mc, &#x27;do_sth&#x27;)</span><br><span class="line">f()  # do_sth被调用</span><br><span class="line"># print(getattr(mc, &#x27;y&#x27;))  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;y&#x27;</span><br><span class="line">print(getattr(mc, &#x27;y&#x27;, 2))  # 2 获取时给不存在的属性或方法指定默认值，可以避免抛出异常</span><br><span class="line"></span><br><span class="line">setattr(mc, &#x27;z&#x27;, 3)</span><br><span class="line">print(getattr(mc, &#x27;z&#x27;))  # 3</span><br><span class="line">print(dir(mc))  # [......, &#x27;do_sth&#x27;, &#x27;x&#x27;, &#x27;z&#x27;]</span><br><span class="line">setattr(mc, &#x27;z&#x27;, 4)</span><br><span class="line">print(getattr(mc, &#x27;z&#x27;))  # 4</span><br><span class="line"></span><br><span class="line">delattr(mc, &#x27;z&#x27;)</span><br><span class="line">print(hasattr(mc, &#x27;z&#x27;))  # False</span><br></pre></td></tr></table></figure>

<ul>
<li>知识点：如何反射一个模块下指定的字符串对应的属性，即<strong>通过模块名反射属性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 1、如何使用反射机制来检查和获取&quot;当前模块&quot;对象中的属性</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"># for k,v in sys.modules.items():</span><br><span class="line">#     print(k,v)</span><br><span class="line">mod = sys.modules[__name__]  # 获取当前模块的对象</span><br><span class="line"></span><br><span class="line">if hasattr(mod, &quot;p&quot;):  # 检查在当前模块对象中是否存在属性名为&quot;p&quot;的属性</span><br><span class="line">    o = getattr(mod, &quot;p&quot;)</span><br><span class="line">    print(o)  # `&lt;__main__.Person object at 0x100209a10&gt;`</span><br><span class="line"></span><br><span class="line"># 2、如何使用反射机制来检查和获取&quot;其他模块&quot;对象中的属性</span><br><span class="line"># my_module.py</span><br><span class="line">my_variable = 42</span><br><span class="line"></span><br><span class="line"># main.py</span><br><span class="line">module_name = &quot;my_module&quot;</span><br><span class="line">attribute_name = &quot;my_variable&quot;</span><br><span class="line"></span><br><span class="line"># 动态加载模块</span><br><span class="line">module = __import__(module_name)  # 获取其模块对象</span><br><span class="line"></span><br><span class="line"># 获取属性</span><br><span class="line">if hasattr(module, attribute_name):</span><br><span class="line">    attribute = getattr(module, attribute_name)</span><br><span class="line">    print(attribute)  # 42</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;&#123;module_name&#125; 模块中没有名为 &#123;attribute_name&#125; 的属性&quot;)</span><br><span class="line"></span><br><span class="line"># 3、第2种情况的直接静态导入模块，更加直观简洁</span><br><span class="line">import my_module</span><br><span class="line"></span><br><span class="line">if hasattr(my_module, &quot;my_variable&quot;):</span><br><span class="line">    attribute = getattr(my_module, &quot;my_variable&quot;)</span><br><span class="line">    print(attribute)  # 输出 42</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;&#123;my_module.__name__&#125; 模块中没有名为 my_variable 的属性&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>反射的应用场景：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class User:</span><br><span class="line">    def login(self):</span><br><span class="line">        print(&quot;登录操作&quot;)</span><br><span class="line"></span><br><span class="line">    def register(self):</span><br><span class="line">        print(&quot;注册操作&quot;)</span><br><span class="line"></span><br><span class="line">    def save(self):</span><br><span class="line">        print(&quot;存储操作&quot;)</span><br><span class="line"></span><br><span class="line">obju = User()</span><br><span class="line"></span><br><span class="line"># 没学反射之前，解决根据用户输入进行对应操作</span><br><span class="line"># while True:</span><br><span class="line">#     choose = input(&quot;&gt;&gt;:&quot;).strip()</span><br><span class="line">#     if choose == &#x27;login&#x27;:</span><br><span class="line">#         u.login()</span><br><span class="line">#     elif choose == &#x27;register&#x27;:</span><br><span class="line">#         u.register()</span><br><span class="line">#     else:</span><br><span class="line">#         u.save()</span><br><span class="line"></span><br><span class="line"># 使用反射解决问题</span><br><span class="line">while True:</span><br><span class="line">    choose = input(&quot;&gt;&gt;:&quot;).strip()</span><br><span class="line">    if hasattr(obju, choose):</span><br><span class="line">        fun = getattr(obju, choose)</span><br><span class="line">        fun()</span><br></pre></td></tr></table></figure>

<h4 id="8-特殊属性和魔术方法"><a href="#8-特殊属性和魔术方法" class="headerlink" title="8. 特殊属性和魔术方法"></a>8. 特殊属性和魔术方法</h4><blockquote>
<p>简介：调用内置函数dir()后的返回值中，很多属性和方法都是以双下划线__开头和结尾的，其中绝大多数都继承自类object：</p>
<ul>
<li>特殊属性：即以双下划线__开头和结尾的属性</li>
<li>特殊方法：即以双下划线__开头和结尾的方法</li>
</ul>
<p>注意：<strong>特殊属性和特殊方法都是系统预定义的</strong>，自定义时尽量不要以双下划线开头和结尾。我们常会重写一个或多个特殊方法，<strong>特殊方法一般会在特定的情形下被自动调用</strong>，很少需要手动调用</p>
</blockquote>
<ul>
<li><strong>特殊属性__dict__<strong>：用于获取指定的类对象或实例对象所</strong>绑定</strong>的所有属性方法与其对应值，并打包为一个字典</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    def my_method(self):</span><br><span class="line">        print(&quot;Hello from my_method&quot;)</span><br><span class="line"></span><br><span class="line"># 创建类的实例</span><br><span class="line">obj = MyClass(42)</span><br><span class="line"></span><br><span class="line"># 获取类的属性字典</span><br><span class="line">print(MyClass.__dict__)</span><br><span class="line"># &#123;......, &#x27;__init__&#x27;: function..., &#x27;my_method&#x27;: function...&#125;</span><br><span class="line"></span><br><span class="line"># 获取实例的属性字典</span><br><span class="line">print(obj.__dict__)  # &#123;&#x27;x&#x27;: 42&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特殊方法__len__()<strong>：当在一个对象上调用len()函数时，会自动调用对象定义的__len__()方法，用于返回对象的长度。</strong>内置函数len()的实参在默认情况下不能是自定义类对象的实例对象，因此需在自定义类对象中实现特殊方法__len__()</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 之所以len()的实参可以是某些内置类对象的实例对象，是因为这些内置类对象中都实现了特殊方法__len__()</span><br><span class="line">print(len([1, 2, 3, 4, 5]))  # 5</span><br><span class="line">print(len(&#x27;abcde&#x27;))  # 5</span><br><span class="line">print(len(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;))  # 3</span><br><span class="line"></span><br><span class="line"># class MyClass(object):</span><br><span class="line">#     pass</span><br><span class="line"># print(len(MyClass()))  # TypeError: object of type &#x27;MyClass&#x27; has no len()</span><br><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    def __len__(self):</span><br><span class="line">        return 18</span><br><span class="line"></span><br><span class="line">print(len(MyClass()))  # 18</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特殊方法__iter__()和__next__()<strong>：只实现__iter__()的类对象被称为</strong>可迭代类对象</strong>，同时实现__iter__()和__next__()的类对象被称为<strong>迭代器类对象</strong><ul>
<li>应用：<strong>for-in循环语句在默认情况下不能用于自定义类对象的实例对象，因此需在自定义类对象中同时实现特殊方法__iter__()和__next__()</strong></li>
<li>原理：for-in语句首先会调用特殊方法__iter__()返回一个可迭代对象，然后不断调用可迭代对象的特殊方法__next__()返回下一次迭代的值，直到遇到StopIteration时退出循环</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 之所以for-in语句可以直接用于某些内置类对象的实例对象，</span><br><span class="line"># 是因为这些内置类对象中都同时实现了特殊方法__iter__()和__next__()</span><br><span class="line">L = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">for item in L:</span><br><span class="line">    print(item)  # 1 2 3 4 5</span><br><span class="line"></span><br><span class="line"># class MyClass(object):</span><br><span class="line">#     pass</span><br><span class="line"># for item in MyClass():  # TypeError: &#x27;MyClass&#x27; object is not iterable</span><br><span class="line">#     print(item)</span><br><span class="line"></span><br><span class="line">class MyClass:</span><br><span class="line">    def __init__(self, length):</span><br><span class="line">        self.length = length</span><br><span class="line">        self.index = 0</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &gt;= self.length:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        result = self.index</span><br><span class="line">        self.index += 1</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">for item in MyClass(5):</span><br><span class="line">    print(item)  # 0 1 2 3 4</span><br></pre></td></tr></table></figure>

<ul>
<li>**特殊方法__add__()和__radd__()**：<ul>
<li>应用：<strong>标准算术运算符在默认情况下不能用于自定义类对象的实例对象，因此需在自定义类对象中实现标准算术运算符对应的特殊方法</strong></li>
<li>原理：假设两个运算符obj1和obj2，以+为例，则需要在obj1对应的自定义类对象中实现特殊方法__add__()；<strong>或</strong>在obj2对应的自定义类对象中实现特殊方法__radd__()（r是right的缩写），因为obj2位于运算符+的右边</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">+对应的特殊方法是__add__()和__radd__();</span><br><span class="line">-对应的特殊方法是__sub__()和__rsub__();</span><br><span class="line">*对应的特殊方法是__mul__()和__rmul__();</span><br><span class="line">/对应的特殊方法是__truediv__()和__rtruediv__();</span><br><span class="line">//对应的特殊方法是__floordiv__()和__rfloordiv__();</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># class MyClass1(object):</span><br><span class="line">#     pass</span><br><span class="line"># class MyClass2(object):</span><br><span class="line">#     pass</span><br><span class="line"># print(MyClass1() + MyClass2())</span><br><span class="line"># 抛出异常 TypeError: unsupported operand type(s) for +: &#x27;MyClass1&#x27; and &#x27;MyClass2&#x27;</span><br><span class="line"></span><br><span class="line">class C1(object):</span><br><span class="line">    def __add__(self, other):</span><br><span class="line">        print(&quot;特殊方法__add__被调用&quot;)</span><br><span class="line">        # return &quot;xxx&quot;</span><br><span class="line">        return NotImplemented</span><br><span class="line"></span><br><span class="line">class C2(object):</span><br><span class="line">    def __radd__(self, other):</span><br><span class="line">        print(&quot;特殊方法__radd__被调用&quot;)</span><br><span class="line">        return &quot;yyy&quot;</span><br><span class="line">        # return NotImplemented</span><br><span class="line"></span><br><span class="line">obj1 = C1()</span><br><span class="line">obj2 = C2()</span><br><span class="line"># 通常只会调用C1类中的add方法，而因为C1中返回了NotImplemented，所以又调用了C2中的radd方法</span><br><span class="line">print(obj1 + obj2)  # 特殊方法__add__被调用 特殊方法__radd__被调用 yyy</span><br><span class="line">&quot;&quot;&quot;print(obj2 + obj1)</span><br><span class="line">抛出异常：TypeError: unsupported operand type(s) for +: &#x27;C2&#x27; and &#x27;C1&#x27;</span><br><span class="line">原因：第一个对象内部必须定义的是__add__()，而obj2对象的类中定义的是__radd__()</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>**特殊方法__str__()和__repr__()**：用于自定义并返回实例对象的字符串表示形式</li>
</ul>
<ol>
<li><p>在交互式命令行中直接打印一个实例对象：__repr__() &gt; 类对象内存地址</p>
</li>
<li><p>调用内置函数print打印一个实例对象：__str__() &gt; __repr__() &gt; 类对象内存地址</p>
</li>
<li><p>调用内置函数str创建字符串并且实参是一个实例对象：__str__() &gt; __repr__() &gt; 类对象内存地址</p>
</li>
<li><p>调用内置函数repr创建字符串并且实参是一个实例对象：__repr__() &gt; 类对象内存地址</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 两者区别：str()的返回值是给用户看的，更加用户友好；repr()的返回值是给开发者看的，是为调试服务的</span><br><span class="line">class MyClass(object):</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line"># 通常情况下，特殊方法__str__()和__repr__()的实现代码是一样的，因此可以直接把方法名赋值给另一个的方法名</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"># str()和repr()的区别</span><br><span class="line">print(str(&quot;Hello,\nworld!&quot;))  # Hello,（换行）world!</span><br><span class="line">print(repr(&quot;Hello,\nworld!&quot;))  # &#x27;Hello,\nworld!&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>**特殊方法__new__()<strong>：用于创建实例对象，特殊方法__new__()会将创建好的实例对象返回给__init__()方法，并调用__init__()方法。当使用</strong>类名([实参])**创建实例对象时，首先会调用特殊方法__new__()创建实例（没有则在父类依次向上查找），__new__()返回的实例对象会作为实参被自动传递给__init__()的第一个形参self，从而进行初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;父类的__new__()被调用，其形参cls对应实参的id:%s&quot; % id(cls))</span><br><span class="line">        obj = super().__new__(cls)</span><br><span class="line">        print(&quot;创建的实例对象的id:%s&quot; % id(obj))</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        print(&quot;子类的__init__()被调用，其形参self对应实参的id：%s&quot; % id(self))</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">print(&quot;父类Parent的id：%s&quot; % id(Parent))</span><br><span class="line">print(&quot;子类Child的id：%s&quot; % id(Child))</span><br><span class="line"></span><br><span class="line">child = Child(&quot;Mike&quot;)</span><br><span class="line">print(&quot;创建的实例对象的id：%s&quot; % id(child))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;运行结果：</span><br><span class="line">父类Parent的id：4889618576</span><br><span class="line">子类Child的id：4889619520</span><br><span class="line">父类的__new__()被调用，其形参cls对应实参的id:4889619520</span><br><span class="line">创建的实例对象的id:4309941696</span><br><span class="line">子类的__init__()被调用，其形参self对应实参的id：4309941696</span><br><span class="line">创建的实例对象的id：4309941696</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重点：__new__()方法实现单例模式（单例模式是一种设计模式，用于确保一个类只有一个实例，并提供全局访问点以获取该实例）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Printer:</span><br><span class="line"> tasks = []</span><br><span class="line"> instance = None  # 用于存放第一个实例对象</span><br><span class="line"></span><br><span class="line"> def __init__(self, name):</span><br><span class="line">     self.name = name</span><br><span class="line"></span><br><span class="line"> def add_task(self, job):</span><br><span class="line">     self.tasks.append(job)</span><br><span class="line">     print(&quot;[%s]添加任务[%s]到打印机，总任务数[%s]&quot; % (self.name, job, len(self.tasks)))</span><br><span class="line"></span><br><span class="line"> def __new__(cls, *args, **kwargs):</span><br><span class="line">     # 只有第一次创建实例对象时，正常创建，后面每次实例化并不真正创建一个新实例</span><br><span class="line">     if not cls.instance:</span><br><span class="line">         # 第一次创建实例对象时，将实例对象存入cls.instance</span><br><span class="line">         obj = super().__new__(cls)  # 实例化过程</span><br><span class="line">         print(&quot;obj:&quot;, obj)  # obj: &lt;__main__.Printer object at 0x10033ad10&gt;</span><br><span class="line">         cls.instance = obj  # 把成功创建的实例对象存下来</span><br><span class="line">     return cls.instance  # 以后的每次实例化，直接返回第一次存的实例对象</span><br><span class="line">     # 在上一次实例对象的基础上，再执行__init__方法，相当于每次都会覆盖掉上一次的name</span><br><span class="line"></span><br><span class="line">p1 = Printer(&quot;tom&quot;)</span><br><span class="line">p2 = Printer(&quot;jack&quot;)</span><br><span class="line">p3 = Printer(&quot;alice&quot;)</span><br><span class="line"></span><br><span class="line">p1.add_task(&quot;word-app&quot;)  # [alice]添加任务[word-app]到打印机，总任务数[1]</span><br><span class="line">p2.add_task(&quot;pdf-app&quot;)  # [alice]添加任务[pdf-app]到打印机，总任务数[2]</span><br><span class="line">p3.add_task(&quot;excel-app&quot;)  # [alice]添加任务[excel-app]到打印机，总任务数[3]</span><br><span class="line">print(p1, p2, p3)  # &lt;...at 0x10033ad10&gt; &lt;...at 0x10033ad10&gt; &lt;...at 0x10033ad10&gt;</span><br><span class="line">print(p1.name, p2.name, p3.name)  # alice alice alice</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="9-对象的引用计数"><a href="#9-对象的引用计数" class="headerlink" title="9. 对象的引用计数"></a>9. 对象的引用计数</h4><ul>
<li><p>简介：当创建一个对象时，系统会自动分配一块内存以存储该对象的信息，当该对象不再被使用时，系统会进行垃圾回收以自动释放掉其占用的内存；为了确保使用中的对象不会被销毁，<strong>Python使用引用计数来跟踪和计算内存中每个对象被引用的次数</strong>，当对象的引用计数为0时，才可以被销毁</p>
</li>
<li><p>对象的引用计数加1的情形：</p>
<ol>
<li><p>对象赋值给变量</p>
</li>
<li><p>引用对象的变量赋值给另一个变量</p>
</li>
<li><p>对象作为容器（例如：列表、元组、集合等）中的元素</p>
</li>
<li><p>对象作为函数调用时的实参</p>
</li>
</ol>
</li>
<li><p>对象的引用计数减1的情形：</p>
<ol>
<li><p>对象离开它的作用域，例如：对象所在的函数执行完毕</p>
</li>
<li><p>对象的引用被显式销毁</p>
</li>
<li><p>引用对象的变量被赋予新的对象</p>
</li>
<li><p>从容器中删除对象，或对象所在的容器被销毁</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def do_sth(param):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">a = MyClass()  # 对象赋值给变量，引用计数加1，变为1</span><br><span class="line">b = a  # 引用对象的变量赋值给另一个变量，引用计数加1，变为2</span><br><span class="line">L = [1, 2, a]  # 对象作为容器中的元素，引用计数加1，变为3</span><br><span class="line">do_sth(a)  # 对象作为函数调用时的实参，引用计数加1，变为4</span><br><span class="line"># 当函数执行后，对实参的引用会自动销毁，引用计数减1，变为3</span><br><span class="line"></span><br><span class="line">del L  # 从容器中删除对象，或对象所在的容器被销毁，引用计数减1，变为2</span><br><span class="line">del a  # 对象的引用被显式销毁，引用计数减1，变为1</span><br><span class="line">c = b  # 引用计数加1，变为2</span><br><span class="line">b = 18  # 引用对象的变量被赋予新的对象，引用计数减1，变为1</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(c))  # 输出2，这里同样，在函数的执行过程中引用计数加1，变为2</span><br><span class="line"># 当函数执行后，对实参的引用会自动销毁，因此，引用计数减1，变为1</span><br><span class="line">print(sys.getrefcount(c))  # 输出2，所以即使再调用一次引用计数也是2</span><br></pre></td></tr></table></figure>

<h4 id="10-特殊属性和魔术方法（续）"><a href="#10-特殊属性和魔术方法（续）" class="headerlink" title="10. 特殊属性和魔术方法（续）"></a>10. 特殊属性和魔术方法（续）</h4><ul>
<li><strong>特殊方法__del__()<strong>：当内存中的对象被销毁（垃圾回收）之前，会自动调用其对应的特殊方法__del__()。当对象的引用计数为0时，对象并不会立刻被销毁，</strong>何时进行垃圾回收是不确定的</strong>，因此，特殊方法__del__()何时会被调用也是不确定的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;特殊方法__del__被调用&quot;)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">del mc  # 特殊方法__del__被调用</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特殊方法__getattr__()<strong>：当访问实例对象的属性或方法时，如果指定的属性或方法不存在，就会抛出AttributeError，为了避免抛出异常，可以在实例对象对应的类对象中实现特殊方法__getattr__()，</strong>当指定的属性或方法不存在时，会自动调用特殊方法__getattr__()</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line"># print(mc.data)  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;data&#x27;</span><br><span class="line"># mc.do_sth()  # AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;do_sth&#x27;</span><br><span class="line"></span><br><span class="line">class SomeClass(object):</span><br><span class="line">    def __getattr__(self, name):</span><br><span class="line">        if name == &quot;data&quot;:</span><br><span class="line">            return 18</span><br><span class="line">        elif name == &quot;do_sth&quot;:</span><br><span class="line">            return print</span><br><span class="line">        raise AttributeError(&quot;&#x27;SomeClass&#x27; object has no attribute &#x27;%s&#x27;&quot; % name)</span><br><span class="line"></span><br><span class="line">sc = SomeClass()</span><br><span class="line">print(sc.data)  # 18</span><br><span class="line">sc.do_sth(1, 2, 3)  # 1 2 3</span><br><span class="line"># print(sc.score)  # AttributeError: &#x27;SomeClass&#x27; object has no attribute &#x27;score&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>**特殊方法__getitem__()**：对于自定义类对象的实例对象，默认是不能像列表和字典那样使用中括号语法来操作数据的</p>
<ol>
<li><p>__getitem__(self, key)：当执行操作obj[key]时，会自动调用该特殊方法</p>
</li>
<li><p>__setitem__(self, key, value)：当执行操作obj[key] &#x3D; value时，会自动调用该特殊方法</p>
</li>
<li><p>__delitem__(self, key)：当执行操作del obj[key]时，会自动调用该特殊方法</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyDict(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        return self.data[key]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        self.data[key] = value</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        del self.data[key]</span><br><span class="line"></span><br><span class="line">md = MyDict()</span><br><span class="line"></span><br><span class="line">md[&quot;one&quot;] = 18</span><br><span class="line">md[&quot;two&quot;] = 32</span><br><span class="line">print(md[&quot;two&quot;])  # 32</span><br><span class="line">print(md.data)  # &#123;&#x27;one&#x27;: 18, &#x27;two&#x27;: 32&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特殊方法__call__()<strong>：像调用函数一样直接调用这个类对象的实例对象，从而会自动调用类对象中的特殊方法__call__()。</strong>内置函数callable用于判断指定对象是否是可调用的</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(args, kwargs)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">mc()  # () &#123;&#125;</span><br><span class="line">mc(1, 2, x=3, y=4)  # (1, 2) &#123;&#x27;x&#x27;: 3, &#x27;y&#x27;: 4&#125;</span><br><span class="line"></span><br><span class="line">def do_sth():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(callable(MyClass()))  # True</span><br><span class="line">print(callable(do_sth))  # True</span><br><span class="line">print(callable(print))  # True</span><br></pre></td></tr></table></figure>

<ul>
<li>**特殊属性__doc__**：调用内置函数dir()得到的所有属性中包含一个特殊属性__doc__，用于表示类对象的文档字符串，与函数的文档字符串类似，位于类的第一行的字符串被称为类的文档字符串，通常用三对引号表示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    &quot;&quot;&quot;这是类对象的文档字符串&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">me = MyClass()</span><br><span class="line">print(list.__doc__)  # Built-in mutable sequence. ......</span><br><span class="line">print(MyClass.__doc__)  # 这是类对象的文档字符串</span><br><span class="line">print(me.__doc__)  # 这是类对象的文档字符串</span><br><span class="line"></span><br><span class="line"># 通过内置函数help()得到的帮助信息中也会包含类对象的文档字符串</span><br><span class="line">print(help(list))</span><br><span class="line">print(help(MyClass))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>**特殊属性__slots__**：</p>
</li>
<li><p>简介：在类对象中定义特殊属性__slots__用于限制类的实例可以拥有的属性，给__slots__赋值一个所有元素都为字符串的列表或元组，这样，对实例对象动态绑定的属性和方法的名称就只能来自于__slots__中的元素</p>
<ul>
<li>优点：<strong>在类对象中定义特殊属性__slots__既可以防止随意添加新属性，又可以提高属性的访问速度和减少内存</strong></li>
</ul>
</li>
<li><p><strong>注意：特殊属性__slots__只对其所在类对象的实例对象起作用，对其所在类对象的子类的实例对象是不起作用的。如果子类也定义了特殊属性__slots__，那么子类的实例对象可以动态绑定的属性和方法名的限制为子类的__slots__加上父类的__slots__</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from types import MethodType</span><br><span class="line"></span><br><span class="line">class MyClass:</span><br><span class="line">    __slots__ = (&quot;name&quot;, &quot;do_sth&quot;)</span><br><span class="line"></span><br><span class="line">class MyChildClass(MyClass):</span><br><span class="line">    __slots__ = (&quot;age&quot;,)</span><br><span class="line"></span><br><span class="line">def do_sth(self):</span><br><span class="line">    print(&quot;do_sth被调用了&quot;)</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">mcc = MyChildClass()</span><br><span class="line"></span><br><span class="line">mc.name = &#x27;xfblog&#x27;</span><br><span class="line">mc.do_sth = MethodType(do_sth, mc)</span><br><span class="line">mc.do_sth()  # do_sth被调用了</span><br><span class="line"># mc.age = 18  # 抛出异常：AttributeError: &#x27;MyClass&#x27; object has no attribute &#x27;age&#x27;</span><br><span class="line"></span><br><span class="line">mcc.age = 18</span><br><span class="line">mcc.name = &#x27;xf&#x27;  # 子类对象绑定属性被限制为子类的__slots__加上父类的__slots__</span><br><span class="line">mcc.do_sth = MethodType(do_sth, mcc)</span><br><span class="line">mcc.do_sth()  # do_sth被调用了</span><br></pre></td></tr></table></figure>

<h2 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h2><blockquote>
<p><strong>什么是模块：</strong>模块就是Python中的一个.py文件，定义在模块中的变量、函数和类统称为模块的属性</p>
<p><strong>模块的作用</strong>：解决代码重用、避免属性名冲突</p>
<p><strong>模块的组织和管理</strong>：</p>
<ol>
<li>为了更好的组织和管理模块，Python引入了包，在某个目录下添加模块__init__.py后，该目录就变成了包</li>
<li>模块__init__.py的作用是初始化其所在的包，如果不需要初始化，其内容可以为空</li>
<li>由于目录支持嵌套，所以包也支持嵌套，即包中还可以有子包</li>
</ol>
</blockquote>
<h4 id="1-使用标准库中的模块"><a href="#1-使用标准库中的模块" class="headerlink" title="1. 使用标准库中的模块"></a>1. 使用标准库中的模块</h4><ul>
<li><p>简介：Python官方提供了一个标准库，其中有非常多的模块，用以完成各种不同的任务</p>
</li>
<li><p>标准库路径：</p>
<ol>
<li>Mac -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.x&#x2F;lib&#x2F;python3.x</li>
<li>Win -&gt; &lt;Python的安装路径&gt;\Lib</li>
</ol>
</li>
<li><p>导入模块的语法格式：</p>
<ol>
<li><p>导入整个模块：<strong>import [包名.]模块名 [as 模块的别名]</strong></p>
</li>
<li><p>导入模块中的属性：<strong>from [包名.]模块名 import 属性名 [as 属性的别名]（可以同时导入多个属性，用逗号隔开）</strong></p>
</li>
<li><p>将模块中的属性一次性全部导入（<strong>强烈不推荐</strong>）：from [包名.]模块名 import *</p>
</li>
<li><p>导入整个模块时，如果模块在包结构中，也可以使用第二种语法格式导入：from 包名 import 模块名</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 常用标准库模块</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line">from datetime import datetime, timedelta as td</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(sys.version)  # Python版本</span><br><span class="line">print(sys.path)  # 模块搜索路径，包含了Python解析器查找模块的搜索路径</span><br><span class="line">print(sys.modules)  # 显示当前程序中引入的所有模块</span><br><span class="line">print(sys.getdefaultencoding())  # 默认字符集</span><br><span class="line"># sys.exit(&#x27;程序退出&#x27;) # 退出解析器</span><br><span class="line"></span><br><span class="line">print(os.name)  # 操作系统的类型</span><br><span class="line">print(os.environ)  # 系统的环境变量</span><br><span class="line">print(os.listdir(&#x27;/Users/xfblog/Downloads&#x27;))  # 列出指定目录中的内容</span><br><span class="line"># os.system(&#x27;ping www.baidu.com&#x27;)  # 执行系统命令</span><br><span class="line">print(os.path.exists(&#x27;/Users/xfblog/Downloads&#x27;))  # 判断路径是否存在</span><br><span class="line"></span><br><span class="line">print(math.pi)  # 3.141592653589793</span><br><span class="line">print(math.ceil(3.4))  # 向上取整</span><br><span class="line">print(math.floor(3.4))  # 向下取整</span><br><span class="line">print(math.pow(2, 3))  # 幂运算</span><br><span class="line">print(math.trunc(2.6))  # 截尾取整</span><br><span class="line">print(round(2.6))  # 四舍五入</span><br><span class="line">print(round(math.pi, 3))  # 四舍五入，保留三位小数</span><br><span class="line"></span><br><span class="line">print(random.random())  # 返回[0,1)之间的随机浮点数</span><br><span class="line">print(random.randint(1, 101))  # 返回[1,100]之间的随机整数</span><br><span class="line">print(random.sample([1, 21, 54, 23, 6, 2], 2))  # 从列表中返回随机两个元素</span><br><span class="line"></span><br><span class="line">print(datetime.now())  # 返回当前时间</span><br><span class="line">print(datetime.strftime(datetime.now(), &#x27;%Y&#123;0&#125;%m&#123;1&#125;%d&#123;2&#125; %H:%M:%S&#x27;).format(&#x27;年&#x27;, &#x27;月&#x27;, &#x27;日&#x27;))  # # 将datetime转换为指定格式的str</span><br><span class="line">print(datetime.strptime(&#x27;2016-3-11&#x27;, &#x27;%Y-%m-%d&#x27;))  # 将str转换为datetime</span><br><span class="line">print(&#x27;明天：&#x27;, datetime.now() + td(days=1))  # timedelta表示两个时间之间的时间差，可以用来进行日间的加减操作</span><br><span class="line">print(&#x27;前一秒：&#x27;, datetime.now() - td(seconds=1))</span><br><span class="line"></span><br><span class="line">print(time.time())  # 返回当前时间的时间戳</span><br><span class="line">print(int(time.time()))  # 秒级时间戳</span><br><span class="line">print(int(time.time() * 1000))  # 毫秒时间戳</span><br><span class="line">time.sleep(2)  # 休眠2秒</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 重要的文件操作模块</span><br><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line"># 操作文件和目录</span><br><span class="line">print(os.path.exists(&#x27;itany.txt&#x27;))  # 判断文件是否存在</span><br><span class="line">print(os.path.abspath(&#x27;itany.txt&#x27;))  # 输出文件的绝对路径</span><br><span class="line">print(os.path.isfile(&#x27;itany.txt&#x27;))  # 判断是否为文件</span><br><span class="line">print(os.path.isdir(&#x27;itany.txt&#x27;))  # 判断是否为目录</span><br><span class="line">print(os.listdir(&#x27;.&#x27;))  # 列出指定目录下所有内容</span><br><span class="line">print([f for f in os.listdir(&#x27;.&#x27;) if os.path.isdir(f)])  # 找出当前目录下所有的文件夹</span><br><span class="line"></span><br><span class="line">os.mkdir(&#x27;world&#x27;)  # 创建目录</span><br><span class="line">if os.path.exists(&#x27;world&#x27;):</span><br><span class="line">    os.rmdir(&#x27;world&#x27;)  # 删除目录</span><br><span class="line"></span><br><span class="line">os.rename(&#x27;itany.txt&#x27;, &#x27;aaa.txt&#x27;)  # 重命名文件或目录</span><br><span class="line">os.remove(&#x27;aaa.txt&#x27;)  # 删除文件</span><br><span class="line">shutil.copy(&#x27;baidu.png&#x27;, &#x27;bbb.png&#x27;)  # 拷贝文件</span><br></pre></td></tr></table></figure>

<h4 id="2-使用第三方库中的模块"><a href="#2-使用第三方库中的模块" class="headerlink" title="2. 使用第三方库中的模块"></a>2. 使用第三方库中的模块</h4><ul>
<li><p>PyPI简介：<a class="link"   target="_blank" rel="noopener" href="https://pypi.org/" >PyPI<i class="fas fa-external-link-alt"></i></a>全称Python Package Index，是Python官方基于web的、集中管理的第三方软件仓库，所有人都可以从PyPI上下载安装第三方库，或将自己开发的库上传发布到PyPI</p>
</li>
<li><p>pip3简介：pip3全称Package Installer for Python，通常使用工具pip3从PyPI下载安装第三方库</p>
<ul>
<li>验证是否安装：pip3 或 python3 -m pip</li>
<li>查看安装目录：mac -&gt; which pip3，win -&gt; where pip3</li>
</ul>
</li>
<li><p>使用pip3下载安装第三方库：pip3 install xxx 或 python3 -m pip install xxx</p>
<ul>
<li>安装路径：Mac -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">a. 查看pip3的帮助信息：pip3</span><br><span class="line">b. 列出已安装的所有第三方库：pip3 list</span><br><span class="line">c. 模糊搜索某个第三方库（及其版本号）：pip3 install xxx[==y.y]</span><br><span class="line">d. 升级指定的第三方库：pip3 install --upgrade xxx</span><br><span class="line">e. 卸载指定的第三方库（及其版本号）：pip3 uninstall xxx[==y.y]</span><br><span class="line">f. 查看pip3之后某个命令的帮助信息：pip3 &lt;命令&gt; --help</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将自己开发的库发布到PyPI或共享给别人</p>
<ol>
<li><p><strong>创建配置文件setup.py</strong>：在配置文件setup.py中调用setuptools中的函数setup，通过配置各种关键字参数，该位置文件会告诉系统如何打包自己开发的库</p>
</li>
<li><p><strong>创建其他文件</strong>：参考文档<a class="link"   target="_blank" rel="noopener" href="https://setuptools.readthedocs.io/en/latest/index.html" >setuptools的官方文档<i class="fas fa-external-link-alt"></i></a>、<a class="link"   target="_blank" rel="noopener" href="https://packaging.python.org/tutorials/packaging-projects/" >Python的官方文档<i class="fas fa-external-link-alt"></i></a>、<a class="link"   target="_blank" rel="noopener" href="https://github.com/pypa/sampleproject" >Github上的sample-project<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><strong>打包自己开发的库</strong>：将setup.py、其他文件和自己开发的库放到同一个目录中，在命令行中切换到该目录，执行命令python3 setup.py sdist。此时，在dist目录中会生成一个source distribution（sdist）压缩文件，该压缩文件包含了模块的源代码；还会生成一个名为<package name>.egg-info的文件夹</p>
</li>
<li><p><strong>将打包的库发布到PyPI或共享给别人</strong>：参考文档<a class="link"   target="_blank" rel="noopener" href="https://packaging.python.org/tutorials/packaging-projects/" >Python的官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><strong>安装别人共享的库</strong>：切换到dist目录，执行命令pip3 install &lt;dist目录中生成的压缩文件&gt;</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    # 发布到PyPI后的package name</span><br><span class="line">    name=&#x27;my_python_lib&#x27;,</span><br><span class="line">    # 版本号</span><br><span class="line">    version=&#x27;0.1&#x27;,</span><br><span class="line">    # 描述</span><br><span class="line">    description=&#x27;My Python Lib&#x27;,</span><br><span class="line">    # 如果要发布的项目包含包，既可以手动指定要包含的包，也可以调用函数find_packages，例如：</span><br><span class="line">    # packages=find_packages()</span><br><span class="line">    # 如果要发布的项目只包含模块，那就指定py_modules这个关键字参数</span><br><span class="line">    py_modules=[&#x27;my_module&#x27;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>pyecharts是一个用于Echarts图表的类库，便于在Python中根据数据生成可视化的图表；Echarts是百度开源的一个数据可视化JS库，主要用来进行数据可视化；参考: <a class="link"   target="_blank" rel="noopener" href="http://pyecharts.org/" >pyecharts官网<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h4 id="3-安装和配置Anaconda"><a href="#3-安装和配置Anaconda" class="headerlink" title="3. 安装和配置Anaconda"></a>3. 安装和配置Anaconda</h4><ul>
<li><p>简介：<a class="link"   target="_blank" rel="noopener" href="https://www.anaconda.com/download" >Anaconda<i class="fas fa-external-link-alt"></i></a>是一个基于Python的数据处理和科学计算的平台，<strong>Anaconda是跨平台的</strong>，其内置了大量的常用第三方库，安装后即可直接导入需要使用的第三方库的模块</p>
</li>
<li><p>注意：安装程序会把Anaconda安装目录下的bin目录添加到系统环境变量PATH中，因此，安装后会使用其自带的Python。从而：</p>
<ol>
<li>在命令行中输入的python3来自于：&lt;Anaconda的安装目录&gt;&#x2F;bin</li>
<li>使用工具pip3安装的第三方库会被安装到：&lt;Anaconda的安装目录&gt;&#x2F;lib&#x2F;python3.x&#x2F;site-packages</li>
</ol>
</li>
<li><p>Anaconda的第三方管理工具为conda，类似于工具pip3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">a. 查看conda的帮助信息：conda</span><br><span class="line">b. 列出已安装的所有第三方库：conda list</span><br><span class="line">c. 模糊搜索某个第三方库：conda search xxx</span><br><span class="line">d. 安装指定的第三方库（及其版本号）：conda install xxx[=y.y]</span><br><span class="line">e. 升级指定的第三方库：conda update xxx</span><br><span class="line">f. 卸载指定的第三方库（及其版本号）：conda remove xxx[=y.y]</span><br><span class="line">g. 查看conda之后某个命令的帮助信息：conda &lt;命令&gt; --help</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-模块的使用规范"><a href="#4-模块的使用规范" class="headerlink" title="4. 模块的使用规范"></a>4. 模块的使用规范</h4><ul>
<li>使用当前项目中的模块<ol>
<li>直接导入：直接导入当前目录的模块名</li>
<li>绝对导入：导入模块名的绝对路径</li>
<li>相对导入：导入模块名的相对路径。其中一个.表示当前目录，两个.表示当前目录的父目录</li>
<li><strong>重点：当直接运行某个模块时，该模块就变成了主模块，主模块位于最顶层，与同目录下的其他模块无法构成相对关系。因此，当直接运行某个模块时，该模块不能使用相对导入</strong></li>
</ol>
</li>
<li>导入的不同模块中存在相同的属性<ul>
<li>当导入的模块中存在相同的属性时，如果直接导入属性，则后面的属性会把前面导入的属性覆盖掉</li>
<li>正确的导入方式：1. 给导入的属性起一个别名。2. 导入整个模块，使用时带前缀可以区分</li>
</ul>
</li>
</ul>
<h4 id="5-import语句的执行流程"><a href="#5-import语句的执行流程" class="headerlink" title="5. import语句的执行流程"></a>5. import语句的执行流程</h4><blockquote>
<p>当使用import语句导入模块时，解释器会根据sys模块的modules属性值来查找模块是否已经被导入了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pprint, sys</span><br><span class="line">pprint.pprint(sys.modules)</span><br></pre></td></tr></table></figure>

<p>如果模块没有被导入，则执行流程：</p>
<ol>
<li>解释器按照模块sys的变量path中的路径搜索模块</li>
<li>将搜索到的模块编译为pyc字节码文件（可选）</li>
<li>执行编译生成的字节码文件从而运行模块</li>
</ol>
</blockquote>
<ol>
<li><strong>解释器搜索模块的路径存放在模块sys的变量path中</strong></li>
</ol>
<ul>
<li><p>搜索路径主要由<strong>当前目录</strong>、<strong>标准库的目录</strong>、<strong>第三方库的安装目录</strong>三部分组成</p>
</li>
<li><p>修改解释器搜索模块路径的方式：1. 直接修改sys.path列表（<strong>代码运行后失效</strong>）2. 设置环境变量PYTHONPATH，环境变量对应的路径会被自动添加到sys.path中（<strong>代码运行后仍然有效</strong>）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import sys, pprint</span><br><span class="line"></span><br><span class="line">pprint.pprint(sys.path)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[&#x27;/Users/xfblog/Documents/pythonProject（当前目录）&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python310.zip&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload&#x27;,</span><br><span class="line"> &#x27;/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages&#x27;]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 直接修改sys.path列表</span><br><span class="line">sys.path.insert(0, &#x27;/Users/xfblog/Downloads&#x27;)</span><br><span class="line"># mymodule.py文件存在于&#x27;/Users/xfblog/Downloads&#x27;下，</span><br><span class="line"># 如果不修改sys.path搜索路径，那么运行时就会因为搜索不到此模块而抛出异常，</span><br><span class="line"># 加上其搜索路径后，pycharm检查代码也会有红线，但能搜索到模块并正常运行</span><br><span class="line">import mymodule</span><br><span class="line"></span><br><span class="line">mymodule.do_sth()  # do_sth被调用了</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>搜索到的模块被编译为pyc字节码文件</strong></p>
<ul>
<li>解释：当搜索到的模块被第一次导入时，会被编译为pyc字节码文件，即表示被缓存起来了；当再次加载该模块时，如果该模块没有发生变化，就不会再次编译，而是直接读取缓存中的pyc字节码文件，从而提高加载速度</li>
</ul>
</li>
<li><p><strong>执行编译生成的字节码文件从而运行模块</strong></p>
<ul>
<li><strong>导入包中的模块时，会先导入包中的__init__.py</strong>。因此，在运行被导入的模块之前，会从最顶层的父包开始，依次运行所有父包中的__init__.py</li>
<li>使用import语句导入某个模块后，如果对模块做了修改，然后再次使用import语句导入该模块，那么对模块的修改将不会起任何作用。<strong>可以调用标准库importlib中标准函数reload重新加载已经被导入的模块</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">importlib.reload(mod)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-dir查看模块的所有属性"><a href="#6-dir查看模块的所有属性" class="headerlink" title="6. dir查看模块的所有属性"></a>6. dir查看模块的所有属性</h4><ol>
<li><p><strong>调用内置函数dir将模块作为实参</strong>：模块作为参数会返回指定模块的所有属性，其中带双下划线__的为模块的特殊属性</p>
</li>
<li><p><strong>调用内置函数dir时不带任何参数</strong>：不带任何参数时，会返回当前模块的<strong>局部作用域</strong>中的所有属性</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">print(dir(requests))</span><br><span class="line"># [&#x27;ConnectTimeout&#x27;, &#x27;ConnectionError&#x27;, ......, &#x27;warnings&#x27;]</span><br><span class="line"></span><br><span class="line">print(dir())</span><br><span class="line"># [&#x27;__annotations__&#x27;, ......, &#x27;__spec__&#x27;]</span><br><span class="line">age = 18</span><br><span class="line"></span><br><span class="line">def fun():</span><br><span class="line">    print(&#x27;fun被调用&#x27;)</span><br><span class="line"></span><br><span class="line">class SomeClass(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(dir())</span><br><span class="line"># [&#x27;SomeClass&#x27;, &#x27;__annotations__&#x27;, ......, &#x27;__spec__&#x27;, &#x27;fun&#x27;, &#x27;age&#x27;]</span><br><span class="line">del age</span><br><span class="line">print(dir())</span><br><span class="line"># [&#x27;SomeClass&#x27;, &#x27;__annotations__&#x27;, ....., &#x27;__spec__&#x27;, &#x27;fun&#x27;]</span><br></pre></td></tr></table></figure>

<h4 id="7-模块的特殊属性"><a href="#7-模块的特殊属性" class="headerlink" title="7. 模块的特殊属性"></a>7. 模块的特殊属性</h4><ul>
<li><strong>特殊属性__doc__<strong>：模块的特殊属性__doc__，用于表示模块的文档字符串，与函数的文档字符串类似，位于模块的第一行的字符串被称为</strong>模块的文档字符串</strong>，通常用三对引号表示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;本模块的文档字符串，功能对模块功能的简要描述&quot;&quot;&quot;</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">print(__doc__)  # 本模块的文档字符串，功能对模块功能的简要描述</span><br><span class="line">print(base64.__doc__)  # Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings</span><br><span class="line"># 通过内置函数help()得到的帮助信息中也包含模块的文档字符串</span><br><span class="line">print(help(base64))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特殊属性__name__<strong>：模块的特殊属性__name__，</strong>常用其值判断是否执行模块中的测试代码</strong></li>
</ul>
<ol>
<li><p><strong>对于被导入的模块，其特殊属性__name__的值为模块名</strong></p>
</li>
<li><p><strong>对于直接运行的模块，其特殊属性__name__的值为__main__</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;本模块的特殊属性__name__的值为：&#x27;, __name__)  # 本模块的特殊属性__name__的值为：__main__</span><br><span class="line"></span><br><span class="line">def add_num(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line"># 根据__name__的值判断是否执行模块中的测试代码</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;1 + 2 =&#x27;, add_num(1, 2))  # 1 + 2 = 3</span><br><span class="line">    print(&#x27;3 + 5 =&#x27;, add_num(3, 5))  # 3 + 5 = 8</span><br></pre></td></tr></table></figure>

<h4 id="8-模块的数据访问控制"><a href="#8-模块的数据访问控制" class="headerlink" title="8. 模块的数据访问控制"></a>8. 模块的数据访问控制</h4><ul>
<li><strong>在模块内的某些属性前添加单下划线_</strong><ul>
<li>简介：属性前添加单下划线后，就无法使用语句**”from 模块名 import *“<strong>导入相应的属性了，但是使用</strong>“import 模块名”或”form 模块名 import xxx”**仍然可以</li>
</ul>
</li>
<li><strong>模块内的数据访问控制之特殊属性__all__</strong><ul>
<li>简介：使用属性__all__限制访问，使用语句**”from 模块名 import *“<strong>就只能导入特殊属性__all__中定义的属性，但是使用</strong>“import 模块名”或”form 模块名 import xxx”**仍然可以</li>
<li>注意：<strong>若对某个属性既使用了单下划线_，又定义在了特殊属性__all__中，那么__all__比单下划线_优先级更高</strong></li>
</ul>
</li>
</ul>
<h4 id="9-动态加载模块"><a href="#9-动态加载模块" class="headerlink" title="9. 动态加载模块"></a>9. 动态加载模块</h4><ul>
<li>简介：通过字符串形式指定模块名，从而实现动态加载模块，又称为<strong>热加载</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line"># __import__(&quot;property&quot;)  # 解释器用的</span><br><span class="line"></span><br><span class="line">importlib.import_module(&quot;property&quot;)  # import_module函数允许通过字符串形式指定模块名</span><br><span class="line">importlib.import_module(&quot;dao.fib&quot;)  # 加载位于包dao下的fib模块</span><br></pre></td></tr></table></figure>

<h2 id="五、生成器与迭代器"><a href="#五、生成器与迭代器" class="headerlink" title="五、生成器与迭代器"></a>五、生成器与迭代器</h2><blockquote>
<p>关于<strong>元组生成式</strong>：</p>
<p>在前面《01_Python_基础语法》的 <a class="link"   target="_blank" rel="noopener" href="https://xfblog.cn/2022/06/06/python_%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95/#i-11" >十二、生成式<i class="fas fa-external-link-alt"></i></a> 中为元组生成式留下不足，是为了在此更好的引出<strong>生成器</strong></p>
<ol>
<li>根本就<strong>不存在元组生成式</strong>，元组是不可变类型的对象，所以无法在代码中<strong>动态地创建元组对象</strong></li>
<li>将列表生成式的中括号“[]”改成小括号“()”，程序并不会报错，因为得到的是<strong>生成器对象！！！</strong></li>
</ol>
</blockquote>
<h4 id="1-生成器"><a href="#1-生成器" class="headerlink" title="1. 生成器"></a>1. 生成器</h4><ul>
<li><strong>生成器（generator）对象：生成器中保存的并不是其对应的所有元素，而是如何推算出所有元素的算法</strong></li>
<li><strong>原理：惰性推算</strong>，它可以在需要时逐个生成值，而不必一次性加载整个数据集到内存中，这对于处理大型数据集或无限序列等情况非常有用，因为它能够有效地利用内存，并且可以提供高效的迭代操作</li>
<li><strong>获取生成器内的元素</strong>：<ol>
<li>**调用内置函数next()**：每次调用都返回生成器的下一个元素，直到抛出异常StopIteration时表示没有更多元素了</li>
<li><strong>使用for-in语句对生成器进行迭代</strong>：不需要关心StopIteration异常，因为<strong>for-in语句会自动处理StopIteration异常</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ge = (i for i in range(1, 7))</span><br><span class="line">print(ge)  # `&lt;generator object &lt;genexpr&gt; at 0x10127c120&gt;`</span><br><span class="line"></span><br><span class="line">print(next(ge))  # 1</span><br><span class="line">print(next(ge))  # 2</span><br><span class="line">print(next(ge))  # 3</span><br><span class="line">print(next(ge))  # 4</span><br><span class="line">print(next(ge))  # 5</span><br><span class="line">print(next(ge))  # 6</span><br><span class="line"># print(next(ge))  # StopIteration</span><br><span class="line"></span><br><span class="line">ge = (i * i for i in range(1, 7))</span><br><span class="line">for item in ge:</span><br><span class="line">    print(item)  # 1 4 9 16 25 36</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生成器函数</strong>：<strong>当推算的算法比较复杂时，可以使用生成器函数得到生成器</strong>。生成器函数中通过<strong>关键字yield</strong>返回推算出的元素，当进行迭代时，<strong>每执行完yield语句后会将函数挂起</strong>，下次会从挂起的地方继续执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 斐波那契数列</span><br><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    for _ in range(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        yield a</span><br><span class="line"></span><br><span class="line">gf = fib(6)</span><br><span class="line">print(gf)  # `&lt;generator object fib at 0x100d3dd90&gt;`</span><br><span class="line"></span><br><span class="line">for item in gf:</span><br><span class="line">    print(item)  # 1 1 2 3 5 8</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2. 迭代器"></a>2. 迭代器</h4><ul>
<li><strong>可迭代对象</strong>：可以用于for-in语句的对象被称为<strong>可迭代对象</strong>，例如：range、list、str、dict、set、<strong>生成器</strong>都是可迭代对象</li>
<li><strong>迭代器对象</strong>：如果一个<strong>可迭代对象</strong>可以作为内置函数next()的实参从而<strong>支持惰性运算</strong>，那么该对象被称为<strong>迭代器对象</strong></li>
</ul>
<blockquote>
<p><strong>调用内置函数isinstance()可以判断一个对象是否是可迭代对象或者迭代器对象，</strong></p>
<p>其中标准库模块collections中的<strong>类Iterable用于表示可迭代对象，类Iterator用于表示迭代器对象</strong></p>
</blockquote>
<ul>
<li><strong>生成器的特殊性</strong>：<strong>生成器是一种特殊的迭代器对象</strong>，因为生成器本身就支持<strong>惰性运算</strong>，而对于range、list、str、dict、set等可迭代对象都不支持，<strong>对于可迭代对象，可以调用内置函数iter()把不支持惰性运算的可迭代对象转换为迭代器对象</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable, Iterator</span><br><span class="line"></span><br><span class="line"># 判断可迭代对象</span><br><span class="line">print(isinstance([1, 2, 3], Iterable))  # True</span><br><span class="line">print(isinstance(&#x27;abc&#x27;, Iterable))  # True</span><br><span class="line">print(isinstance((i * i for i in range(1, 7)), Iterable))  # True</span><br><span class="line"># 判断迭代器对象</span><br><span class="line">print(isinstance([1, 2, 3], Iterator))  # False</span><br><span class="line">print(isinstance(&#x27;abc&#x27;, Iterator))  # False</span><br><span class="line">print(isinstance((i * i for i in range(1, 7)), Iterator))  # True</span><br><span class="line"># 调用内置函数iter()把不支持惰性推算的可迭代对象转换为迭代器对象</span><br><span class="line">iter_L = iter([1, 2, 3])</span><br><span class="line">iter_s = iter(&#x27;abc&#x27;)</span><br><span class="line">print(isinstance(iter_L, Iterator))  # True</span><br><span class="line">print(isinstance(iter_s, Iterator))  # True</span><br><span class="line">print(next(iter_L))  # 1</span><br><span class="line">print(next(iter_s))  # a</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自定义迭代器对象</strong>：如果一个类对象同时实现了特殊方法<strong>__iter__()<strong>和</strong>__next__()<strong>，那么该对象就被称为</strong>迭代器对象</strong><ul>
<li><strong>执行过程</strong>：如果将该对象用于for- in语句，for-in语句首先会调用特殊方法__iter__()返回一个可迭代对象，然后不断调用该可迭代对象的特殊方法__next__()返回下一次迭代的值，直到遇到StopIteration时退出循环</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 斐波那契数列</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        if self.a &gt; 50:</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a</span><br><span class="line"></span><br><span class="line">for item in Fib():</span><br><span class="line">    print(item)  # 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure>

<h2 id="六、异常处理"><a href="#六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h2><blockquote>
<p><strong>什么是异常？</strong></p>
<p>异常指的是程序在没有语法错误的前提下，在运行期间产生的特定错误，每个特定错误都对应一个异常类对象。当产生某个特定错误时，其对应的异常类对象的实例对象就会被抛出。</p>
<ul>
<li>对于在程序中抛出的异常实例对象，如果不进行捕获和处理，程序就会停止运行，所以要进行捕获和处理</li>
<li>对于异常中的Traceback，指的是异常调用堆栈的跟踪信息，其中列出了程序中的相关行数</li>
<li>对于每个异常类对象所表示的特定错误，参考<a class="link"   target="_blank" rel="noopener" href="https://docs.python.org/3/library/exceptions.html" >Python官方文档<i class="fas fa-external-link-alt"></i></a></li>
<li><strong>重点：所有异常类对象（内置异常类对象和自定义异常类对象）的基类都是Exception！</strong></li>
</ul>
</blockquote>
<h4 id="1-捕获和处理异常"><a href="#1-捕获和处理异常" class="headerlink" title="1. 捕获和处理异常"></a>1. 捕获和处理异常</h4><ul>
<li><strong>注意4点</strong>：<ol>
<li>如果抛出的异常实例对象所对应的类对象是except字句中异常类对象的<strong>子类</strong>，那么该except子句也会被匹配</li>
<li>当try语句块中产生异常时，会<strong>从上到下依次查找</strong>是否有匹配的except子句，只要有一个匹配上，则不会再往下匹配</li>
<li>当多个异常类对象对应的异常处理代码完全相同时，可以把这些异常类对象以<strong>元组</strong>的形式放在一个except子句中</li>
<li>如果想在匹配到的except子句中访问异常实例对象，可以在except子句结束位置<strong>添加关键字as和一个变量</strong></li>
</ol>
</li>
<li><strong>重点：为了在except语句块中能将所有的异常类对象尽可能地覆盖到，可以将最后一个except子句中的异常类对象指定为Exception（或不指定异常类对象也默认为Exception）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">try:</span><br><span class="line">    可能会产生异常的代码</span><br><span class="line">except 异常类对象1:</span><br><span class="line">    当前except字句处理异常的代码</span><br><span class="line">except 异常类对象2:</span><br><span class="line">    当前except字句处理异常的代码</span><br><span class="line">    ......</span><br><span class="line">except 异常类对象n:</span><br><span class="line">    当前except字句处理异常的代码</span><br><span class="line">else:</span><br><span class="line">    try语句块中没有产生异常时执行的代码（有时需要对try语句中部分代码需要进行单独异常捕获，其余代码则需写else）</span><br><span class="line">    # 类似while语句或for-in语句后面添加的else从句，没有执行循环体中的break语句，则会执行else从句</span><br><span class="line">finally:</span><br><span class="line">    总会执行的代码</span><br><span class="line">    # 通常在finally从句中释放资源，例如：关闭文件、关闭网络连接等</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">try:</span><br><span class="line">    result = 1 / 0  # 对应前两个except子句</span><br><span class="line">    # result = int(&#x27;abc&#x27;)  # 对应第三个except子句</span><br><span class="line">    # result = 1 / 2  # 无异常，执行else从句</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    print(&quot;0不能作为除数&quot;)</span><br><span class="line">except ArithmeticError:</span><br><span class="line">    print(&quot;数学错误&quot;)</span><br><span class="line">except (TypeError, ValueError) as err:</span><br><span class="line">    print(type(err))  # `&lt;class &#x27;ValueError&#x27;&gt;`</span><br><span class="line">    # 类对象ValueError实现了特殊方法__str__()</span><br><span class="line">    print(err)  # invalid literal for int() with base 10: &#x27;abc&#x27;</span><br><span class="line">except Exception:</span><br><span class="line">    print(&quot;其他错误&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无异常打印结果：&quot;, result)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;释放资源&quot;)</span><br><span class="line"></span><br><span class="line"># 实现输入一个正确的整数，不正确则重新输入</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        x = int(input(&#x27;请输入一个整数：&#x27;))</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&#x27;无效的输入，请再次输入&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;输入的整数为：&#x27;, x)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h4 id="2-使用raise语句手动抛出异常"><a href="#2-使用raise语句手动抛出异常" class="headerlink" title="2. 使用raise语句手动抛出异常"></a>2. 使用raise语句手动抛出异常</h4><ul>
<li>语法：**raise 异常类对象([参数])**，不传入参数时小括号可以省略</li>
<li>注意：如果在except语句块中不想对异常实例对象进行处理，可以使用关键字raise将其原样抛出，也可以使用raise语句手动抛出另外一个异常类对象的实例对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise ZeroDivisionError(&#x27;0不能作为除数哦&#x27;)  # 模拟异常语句直接抛出异常</span><br><span class="line">except ZeroDivisionError as err:</span><br><span class="line">    print(err)  # 0不能作为除数哦</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    try:</span><br><span class="line">        raise  # 使用关键字raise将异常实例对象原样抛出</span><br><span class="line">    except ZeroDivisionError as ee:</span><br><span class="line">        # raise ValueError(&#x27;输入错误&#x27;)  # 使用raise语句手动抛出另外一个异常类对象的实例对象</span><br><span class="line">        print(ee)  # division by zero</span><br></pre></td></tr></table></figure>

<h4 id="3-自定义异常"><a href="#3-自定义异常" class="headerlink" title="3. 自定义异常"></a>3. 自定义异常</h4><ul>
<li>简介：自定义异常类对象只需要如同所有内置异常类对象一样，继承Exception或其子类即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyException(BaseException):  # BaseException是所有异常的基类</span><br><span class="line">    def __init__(self, msg):</span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    # def __str__(self):  # __str__方法定义不定义都可以</span><br><span class="line">    #     return self.msg</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    raise MyException(&#x27;我的错误&#x27;)</span><br><span class="line"># except Exception as err:  # 继承自BaseException类的自定义异常类，Exception捕捉不到</span><br><span class="line">#     print(err)</span><br><span class="line">except MyException as e:</span><br><span class="line">    print(e)  # 我的错误</span><br></pre></td></tr></table></figure>

<h4 id="4-异常实例err"><a href="#4-异常实例err" class="headerlink" title="4. 异常实例err"></a>4. 异常实例err</h4><ul>
<li>简介：err对象是except语句中捕捉异常的实例，类型是<strong>元组</strong></li>
<li><strong>应用：args是Python内置异常类的一个属性，用于保存异常对象的参数，是一个元组</strong><ol>
<li>当一个异常被抛出时，可以向异常对象传递一些参数，这些参数将作为异常对象的属性来使用</li>
<li>可以通过使用except语句捕获异常，并使用异常对象的args属性来提取异常参数</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyException(Exception):</span><br><span class="line">    def __init__(self, a, b):</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">    # def __str__(self):</span><br><span class="line">    #     return &quot;都是%s和%s的错&quot; % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    raise MyException(&#x27;jack&#x27;, &#x27;alice&#x27;)</span><br><span class="line">except MyException as err:</span><br><span class="line">    print(err)  # (&#x27;jack&#x27;, &#x27;alice&#x27;)</span><br><span class="line">    print(err.args)  # (&#x27;jack&#x27;, &#x27;alice&#x27;)</span><br><span class="line">    # 1、Python会尝试将整个err元组作为一个参数进行格式化，而不是按照元组的元素进行格式化，从而抛出异常</span><br><span class="line">    # print(&quot;都是%s和%s的错&quot; % err)  # 抛出异常</span><br><span class="line">    # 2、类 &#x27;MyException&#x27; 未定义 &#x27;__getitem__&#x27;，所以不能对其实例使用 &#x27;[]&#x27; 运算符</span><br><span class="line">    # print(&quot;都是%s和%s的错&quot; % (err[0], err[1]))  # 抛出异常</span><br><span class="line">    print(&quot;都是%s和%s的错&quot; % (err.args[0], err.args[1]))  # 都是jack和alice的错</span><br></pre></td></tr></table></figure>

<h4 id="5-异常和函数"><a href="#5-异常和函数" class="headerlink" title="5. 异常和函数"></a>5. 异常和函数</h4><ul>
<li>简介：当函数内发生异常时，异常实例对象会被抛给该函数的调用者，如果该函数的调用者没有进行捕获和处理，则继续抛给上一层的调用者，这样一直向上抛，最后会被Python解释器捕获。<strong>在异常实例对象被向上抛的过程中，不需要在每一层都进行捕获和处理，选择合适的层对进行捕获和处理即可</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def f1():</span><br><span class="line">    print(1 / 0)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line">def f3():</span><br><span class="line">    try:</span><br><span class="line">        f2()</span><br><span class="line">    except ZeroDivisionError as err:</span><br><span class="line">        print(err)</span><br><span class="line"></span><br><span class="line">f3()  # division by zero</span><br><span class="line">&quot;&quot;&quot;抛出异常情况</span><br><span class="line">def f1():             # Traceback (most recent call last):</span><br><span class="line">    print(1 / 0)      #    File &quot;/Users/xfblog/Desktop&quot;, line 11, in &lt;module&gt;</span><br><span class="line">                      #        f3()</span><br><span class="line">def f2():             #    File &quot;/Users/xfblog/Desktop&quot;, line 9, in f3</span><br><span class="line">    f1()              #        f2()</span><br><span class="line">                      #    File &quot;/Users/xfblog/Desktop&quot;, line 6, in f2</span><br><span class="line">def f3():             #        f1()</span><br><span class="line">    f2()              #    File &quot;/Users/xfblog/Desktop&quot;, line 3, in f1</span><br><span class="line">                      #        print(1 / 0)</span><br><span class="line">f3()                  # ZeroDivisionError: division by zero</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="6-获取异常信息"><a href="#6-获取异常信息" class="headerlink" title="6. 获取异常信息"></a>6. 获取异常信息</h4><ul>
<li><p>简介：在捕获异常实例对象后，可以<strong>调用标准库模块sys中的函数exc_info以获取异常的相关信息</strong>，其返回值为一个<strong>元组</strong>，其中包含三个元素分别为<strong>异常的类型、异常的错误信息、Traceback对象（包含异常调用堆栈的跟踪信息）</strong></p>
</li>
<li><p>扩展：<strong>进一步从Traceback对象中提取出堆栈帧信息， 可以调用标准库模块traceback中的函数extract_tb()</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">def f1():</span><br><span class="line">    print(1 / 0)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    try:</span><br><span class="line">        f1()</span><br><span class="line">    except ZeroDivisionError:</span><br><span class="line">        ex_type, ex_value, ex_traceback = sys.exc_info()</span><br><span class="line"></span><br><span class="line">        print(ex_type)  # 异常的类型：`&lt;class &#x27;ZeroDivisionError&#x27;&gt;`</span><br><span class="line">        print(ex_value)  # 异常的错误信息：division by zero</span><br><span class="line">        print(ex_traceback)  # 异常调用堆栈的跟踪信息：`&lt;traceback object at 0x1026dca00&gt;`</span><br><span class="line"></span><br><span class="line">        tb = traceback.extract_tb(ex_traceback)  # 进一步从Traceback对象中提取出堆栈帧信息</span><br><span class="line">        print(tb)  # 堆栈帧信息表示代码的执行路径，即函数调用的层次关系和对应的代码位置</span><br><span class="line"></span><br><span class="line">        # tb是一个列表，其中每个元素是一个FrameSummary对象，代表一个堆栈帧的信息，并包含以下4种信息</span><br><span class="line">        for file, line, funcname, source in tb:</span><br><span class="line">            print(&#x27;异常代码的文件路径：%s&#x27; % file)</span><br><span class="line">            print(&#x27;调用堆栈的行号：%s&#x27; % line)</span><br><span class="line">            print(&#x27;函数或方法的名称：%s&#x27; % funcname)</span><br><span class="line">            print(&#x27;源码：%s&#x27; % source)</span><br><span class="line">        &quot;&quot;&quot;循环打印出两个FrameSummary对象中包含的信息</span><br><span class="line">        实际上，输出中的堆栈帧信息是从异常发生的地方开始，逐级追溯调用链，直到最顶层</span><br><span class="line">        所以，第一个堆栈帧对应的是f2函数，第二个堆栈帧对应的是f1函数</span><br><span class="line">        由于堆栈帧信息是从下往上追溯的，所以第一个堆栈帧的行号9表示的是f2函数内部调用f1函数的位置</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure>

<h4 id="7-assert断言"><a href="#7-assert断言" class="headerlink" title="7. assert断言"></a>7. assert断言</h4><ul>
<li>简介：<strong>assert断言用于判断代码是否符合执行预期</strong>。在一个还没完善的程序中，不知道哪里会出错的情况下，与其让程序在运行时崩溃，不如在出现错误条件时就立即崩溃，此时则需要使用到assert断言</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 若代码符合执行预期则无返回值，否则直接抛出异常AssertionError</span><br><span class="line">assert type(1) is int</span><br><span class="line">assert len([&#x27;my boy&#x27;, 12]) &lt; 3</span><br><span class="line">assert list(range(4)) == [0, 1, 2, 3]</span><br><span class="line"># assert 1 + 1 == 3  # 抛出异常AssertionError</span><br><span class="line"></span><br><span class="line"># 应用场景举例，别人调用你的接口，接口要求调用时必须传递指定的关键参数，</span><br><span class="line"># 当接受时，就可以使用assert语句判断传入的参数是否符合你的预期</span><br><span class="line">def my_interfance(name, age, score):</span><br><span class="line">    assert type(name) is str</span><br><span class="line">    assert type(age) is int</span><br><span class="line">    assert type(score) is float</span><br><span class="line"></span><br><span class="line">my_interfance(&quot;jack&quot;, 22, 99.5)</span><br><span class="line">my_interfance(&quot;jack&quot;, 22, 99)  # AssertionError</span><br></pre></td></tr></table></figure>

<ul>
<li>知识点：<strong>可以为assert断言语句添加异常参数，</strong>即在断言表达式后添加字符串信息，用来解释断言异常的原因</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 简单案例：</span><br><span class="line">s = input(&#x27;请输入 --&gt; &#x27;)</span><br><span class="line">assert len(s) &gt;= 3, &quot;输入的长度不能小于3&quot;  # AssertionError: 输入的长度不能小于3</span><br><span class="line"></span><br><span class="line"># 复杂案例：</span><br><span class="line">class ShortInputException(Exception):</span><br><span class="line">    def __init__(self, length, atleast):</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        s = input(&#x27;请输入 --&gt; &#x27;)</span><br><span class="line">        assert len(s) &gt;= 3, ShortInputException(len(s), 3)</span><br><span class="line">    except AssertionError as err:</span><br><span class="line">        # 这里不是直接捕捉ShortInputException，而是将其作为assert的异常参数，</span><br><span class="line">        # 所以捕捉到的异常对象的属性应该是一个整体，作为err.args这个元组的一个参数</span><br><span class="line">        detail = err.args[0]</span><br><span class="line">        print(&#x27;ShortInputException: 输入的长度是 %d,长度至少应是 %d&#x27; % (detail.length, detail.atleast))</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;没有异常发生.&#x27;)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h4 id="8-with语句"><a href="#8-with语句" class="headerlink" title="8. with语句"></a>8. with语句</h4><ul>
<li><p><strong>上下文管理器</strong>：如果一个类实现了特殊方法<strong>__enter__()和__exit__()<strong>，就称这个类对象遵守了</strong>上下文管理协议</strong>，并称这个类对象的实例对象为<strong>上下文管理器</strong></p>
</li>
<li><p>with语句简介：</p>
<ol>
<li>with语句会让上下文管理器创建一个<strong>运行时上下文</strong></li>
<li>当进入<strong>运行时上下文</strong>时自动调用特殊方法__enter__()</li>
<li>当离开<strong>运行时上下文</strong>时自动调用特殊方法__exit__()</li>
</ol>
</li>
<li><p>with语句知识点：</p>
<ol>
<li><strong>特殊方法__exit__()总会被调用</strong>，与finally相似，所以通常在特殊方法__exit__()中释放资源</li>
<li>当with语句体中产生了异常，那么<strong>sys.exc_info()的返回值中三个元素会被自动传递给特殊方法__exit__()的形参exc_type、exc_val和exc_tb</strong></li>
</ol>
</li>
<li><p>with语句<strong>执行流程</strong>（中括号[]内容表示可选）：</p>
<ol>
<li><p>计算上下文表达式，返回一个上下文管理器，并创建一个运行时上下文</p>
</li>
<li><p>进入运行时上下文，自动调用上下文管理器的特殊方法__enter__()</p>
</li>
<li><p>[将特殊方法__enter__()的返回值赋值给变量，如果提供的话]</p>
</li>
<li><p>执行with语句体[，对变量进行操作]</p>
</li>
<li><p>判断with语句体是否产生异常，抛出异常则终止执行with语句体，未抛出异常则继续执行</p>
</li>
<li><p>无论是否抛出异常，都离开运行时上下文，自动调用上下文管理器的特殊方法__exit__()</p>
</li>
<li><p><strong>在__exit__()方法中，再次判断是否抛出异常，如果异常对象为None，则认为没有异常，返回值为True；如果有异常，则可以处理异常并返回一个布尔值，表示是否需要继续传播异常</strong></p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class FileManager:</span><br><span class="line">    def __init__(self, filename, mode):</span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.file = None</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&#x27;特殊方法__enter__()被调用&#x27;)</span><br><span class="line">        self.file = open(self.filename, self.mode)</span><br><span class="line">        return self.file</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_value, traceback):</span><br><span class="line">        print(&#x27;特殊方法__exit__()被调用&#x27;)</span><br><span class="line">        if exc_type is not None:  # 判断异常对象是否为None</span><br><span class="line">            # 发生异常时的处理</span><br><span class="line">            print(f&quot;异常的错误信息: &#123;exc_value&#125;&quot;)</span><br><span class="line">            print(f&quot;异常调用堆栈的跟踪信息: &#123;traceback&#125;&quot;)</span><br><span class="line">        self.file.close()</span><br><span class="line">        return True</span><br><span class="line">        # __exit__()方法的返回值为True时，将抑制异常的传播，而返回False或None时，将继续传播异常</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def do_sth():</span><br><span class="line">        print(&#x27;方法do_sth()被调用&#x27;)</span><br><span class="line">        print(1 / 0)</span><br><span class="line"></span><br><span class="line"># 此时with语句体中产生异常，若__exit__()方法返回True则正常执行，否则直接抛出异常</span><br><span class="line">with FileManager(&#x27;myfile.txt&#x27;, &#x27;w+&#x27;) as fm:</span><br><span class="line">    &quot;&quot;&quot;fm.do_sth()</span><br><span class="line">    注意：此处fm并不是类FileManager的实例，而是一个文件对象，</span><br><span class="line">    由于文件对象并没有do_sth这个方法，因此调用do_sth方法会导致错误</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    FileManager.do_sth()</span><br><span class="line">&quot;&quot;&quot;输出顺序与执行流程一致：</span><br><span class="line">特殊方法__enter__()被调用</span><br><span class="line">方法do_sth()被调用</span><br><span class="line">特殊方法__exit__()被调用</span><br><span class="line">异常的错误信息: division by zero</span><br><span class="line">异常调用堆栈的跟踪信息: &lt;traceback object at 0x102dd8580&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 当with语句体中产生异常，并且特殊方法__exit__()没有返回True时，</span><br><span class="line"># 为了让程序能够继续执行，可以使用try-except语句对抛出的异常实例对象进行捕获和处理</span><br><span class="line"># try:</span><br><span class="line">#     with FileManager(&#x27;myfile.txt&#x27;, &#x27;w+&#x27;) as fm:</span><br><span class="line">#         FileManager.do_sth()</span><br><span class="line"># except ZeroDivisionError as err:</span><br><span class="line">#     print(err)</span><br><span class="line"># 此时输出内容比上面多一行print(err)的内容：division by zero</span><br></pre></td></tr></table></figure>

<h2 id="七、文件读写"><a href="#七、文件读写" class="headerlink" title="七、文件读写"></a>七、文件读写</h2><blockquote>
<p><strong>文件读写：文件读写是一种常见的IO操作，把数据存储到文件中是数据存储的方式之一。</strong>由于操作I&#x2F;O的能力是由操作系统提供的，且现代操作系统不允许普通程序直接操作磁盘，所以读写文件时需要请求操作系统打开一个对象（通常被称为文件描述符， 简称fd），即为<strong>文件对象</strong></p>
<p><strong>文件对象</strong>：文件对象是迭代器对象，可以调用next()方法逐行读取文件内容。当达到文件的末尾时，将引发StopIteration异常，所以通常会使用for循环来迭代文件对象，它会自动处理StopIteration异常</p>
<p><strong>文件打开模式：</strong></p>
<ul>
<li>‘r’：以只读方式打开，只能读文件。不存在则抛出异常（<strong>默认打开模式</strong>）</li>
<li>‘w’：以只写方式打开，只能写文件。存在则清空文件，不存在则创建文件</li>
<li>‘a’：以追加方式打开，只能写文件。存在则从文件末尾开始写，不存在则创建文件</li>
<li>‘x’：以只写方式打开，只能写文件。存在则抛出异常，不存在则创建文件（独占创建）</li>
<li>‘+’：以读写方式打开，可以读写文件。不能单独使用，只能添加到其他方式的后面：’r+’、’w+’、’a+’、’x+’</li>
<li>‘t’：以文本方式打开（<strong>默认文本格式</strong>）通常省略，’rt’等价于’r’。不能单独使用，只能添加到其他方式的后面</li>
<li>‘b’：以二进制方式打开。例如：打开图片、视频等，不能单独使用，只能添加到其他方式的后面</li>
</ul>
</blockquote>
<h4 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1. 打开文件"></a>1. 打开文件</h4><ul>
<li>简介：<strong>内置函数open()用于打开文件，其返回值是一个文件对象，通过该对象即可操作文件</strong><ul>
<li><strong>参数1是文件的路径</strong>，必须指定，既可以指定绝对路径，也可以指定相对路径</li>
<li><strong>参数2是文件的打开方式</strong>，默认值是’r’，表示以只读方式打开</li>
<li>其余参数都是带默认值的，可参考官方文档，或直接转到open()函数声明处查看</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;myfile.text文件在与执行文件同级的目录中，其内容为：</span><br><span class="line">1234567890</span><br><span class="line">abcdefghijklmn</span><br><span class="line">opqrstuvwxyz</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 打开方式为&#x27;r&#x27;时，可以省略，即：file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file)  # `&lt;_io.TextIOWrapper name=&#x27;myfile.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;UTF-8&#x27;&gt;`</span><br></pre></td></tr></table></figure>

<h4 id="2-读文件"><a href="#2-读文件" class="headerlink" title="2. 读文件"></a>2. 读文件</h4><ul>
<li>简介：<strong>读写文件之前，必须先打开文件</strong>。可以调用内置函数open()并以只读或读写方式打开文件，返回的文件对象有三个用于读文件的方法，分别为read()、readline()、readlines()</li>
<li><strong>read()：不传入参数时读到文件尾，传入参数时size用于指定字节数</strong><ul>
<li>用法：当指定的字节数小于读到文件尾的字节数时，读到指定的字节数；当指定的字节数大于读到文件尾的字节数时，或当指定的字节数小于0时，读到文件尾</li>
<li><strong>注意：指定的size不要超过默认缓冲区的大小。</strong>如果文件很大，调用read()一次性读取整个文件会导致内存占用较大，因此最好可以多次调用，否则可能并取不到指定的字节数，<strong>通过标准库中模块io的属性DEFAULT_BUFFER_SIZE可以查看默认缓冲区的大小</strong></li>
</ul>
</li>
<li><strong>readline()：不传入参数时读到行尾，传入参数时size用于指定字节数</strong><ul>
<li>用法：当指定的字节数小于读到行尾的字节数时，读到指定的字节数；当指定的字节数大于读到行尾的字节数时，或当指定的字节数小于0时，读到行尾</li>
</ul>
</li>
<li><strong>readlines()：不传入参数时读到文件尾，并返回每一行组成的列表；传入参数时size用于指定字节数</strong><ul>
<li>用法：当指定的字节数小于读到文件尾的字节数时，一直读取到最后一个字符所在行的行尾；当指定的字节数大于读到文件尾的字节数时，或当指定的字节数小于0时，读到文件尾</li>
<li><strong>注意：同样指定的size不要超过默认缓冲区的大小</strong>。一次性读取整个文件会导致内存占用较大，而取不到指定的字节数</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;myfile.text文件在与执行文件同级的目录中，其内容为：</span><br><span class="line">1234567890</span><br><span class="line">abcdefghijklmn</span><br><span class="line">opqrstuvwxyz</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">print(io.DEFAULT_BUFFER_SIZE)  # 8192</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file.read())  # 1234567890 abcdefghijklmn opqrstuvwxyz</span><br><span class="line">file.close()  # 文件在使用完毕后必须要关闭</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">print(file.read(12))  # 1234567890 a</span><br><span class="line">print(file.read(3))  # 没有关闭文件，所以可以继续提取 bcd</span><br><span class="line">print(file.read(-5))  # 参数为负数时读到文件尾 efghijklmn opqrstuvwxyz</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">print(&#x27;-&#x27; * 18)</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file.readline())  # 1234567890\n</span><br><span class="line">print(file.readline(7))  # abcdefg</span><br><span class="line">print(file.readline(10))  # hijklmn\n</span><br><span class="line">print(file.readline(-5))  # opqrstuvwxyz</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">print(&#x27;-&#x27; * 18)</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)</span><br><span class="line">print(file.readlines())  # [&#x27;1234567890\n&#x27;, &#x27;abcdefghijklmn\n&#x27;, &#x27;opqrstuvwxyz&#x27;]</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">print(file.readlines(8))  # [&#x27;1234567890\n&#x27;]</span><br><span class="line">print(file.readlines(50))  # [&#x27;abcdefghijklmn\n&#x27;, &#x27;opqrstuvwxyz&#x27;]</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;)</span><br><span class="line">print(file.readlines(13))  # [&#x27;1234567890\n&#x27;, &#x27;abcdefghijklmn\n&#x27;]</span><br><span class="line">print(file.readlines(-5))  # [&#x27;opqrstuvwxyz&#x27;]</span><br><span class="line">print(file.readlines())  # []</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<h4 id="3-写文件"><a href="#3-写文件" class="headerlink" title="3. 写文件"></a>3. 写文件</h4><ul>
<li>简介：<strong>写文件之前，必须先打开文件</strong>。可以调用内置函数open()并以只写、追加或读写方式打开文件，返回的文件对象有两个用于写文件的方法，分别为<strong>write()、writelines()</strong></li>
<li>write(str)：<strong>用于将指定的字符串写入到文件中，返回写入的字符数，即指定的字符串的长度</strong></li>
<li>writelines(seq)：<strong>用于将指定的字符串序列依次写入到文件中，无返回值</strong><ul>
<li>原理：调用后，会先将指定的子符串写入到缓存中，手动调用方法flush()或close()之后，或者当写入的数据量大于等于缓存的容量时，缓存中的字符串才会被写入到文件中</li>
<li><strong>flush()方法：用于刷新内部缓冲区，即将缓冲区中的数据立刻写入文件（一般情况下，文件关闭后会自动刷新缓冲区）</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">print(file.write(&#x27;hello&#x27;))  # 5</span><br><span class="line">file.write(&#x27;python&#x27;)</span><br><span class="line">file.flush()</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;)</span><br><span class="line">file.write(&#x27;hello&#x27;)</span><br><span class="line">file.write(&#x27;python&#x27;)</span><br><span class="line">file.close()</span><br><span class="line"># 追加后，myfile.txt中内容更改为：hellopythonhellopython</span><br><span class="line"></span><br><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">file.writelines([&#x27;123\t&#x27;, &#x27;456\n&#x27;, &#x27;789&#x27;])</span><br><span class="line">file.close()</span><br><span class="line">&quot;&quot;&quot;myfile.txt中内容更改为：</span><br><span class="line">123 456</span><br><span class="line">789</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-关闭文件"><a href="#4-关闭文件" class="headerlink" title="4. 关闭文件"></a>4. 关闭文件</h4><ul>
<li><p>简介：<strong>文件在使用完毕后必须要关闭</strong>，这是因为文件对象会占用操作系统的资源，并且操作系统在某一时刻所能打开的文件数量也是有限的</p>
</li>
<li><p>注意：<strong>读文件或写文件时都有可能发生异常，从而导致方法close()不会被调用，文件没有关闭</strong>。为了保证方法close()总能被调用，可以把读文件或写文件的操作放在try语句块中，把方法close()的调用放在finally从句中</p>
</li>
<li><p><strong>重点：由于文件对象实现了特殊方法__enter__()和__exit__()，所以文件对象可以作为上下文管理器。其中特殊方法__enter__()用于返回打开的文件对象，特殊方法__exit__()用于关闭打开的文件，因此操作文件对象常用with语句来实现，因为其与try-finally语句相比更加简洁</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file = open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">try:</span><br><span class="line">    file.write(&#x27;hello&#x27;)</span><br><span class="line">finally:</span><br><span class="line">    file.close()</span><br><span class="line"># myfile.txt文件内容更改为：hello</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;) as file:</span><br><span class="line">    file.write(&#x27;python&#x27;)</span><br><span class="line"># myfile.txt文件内容更改为：hellopython</span><br></pre></td></tr></table></figure>

<h4 id="5-文件指针"><a href="#5-文件指针" class="headerlink" title="5. 文件指针"></a>5. 文件指针</h4><ul>
<li><p>简介：<strong>任何文件对象都有一个文件指针，指向文件中的某个位置</strong>。读写文件时，是从文件指针的当前位置开始读写的，在读写的过程中，文件指针会随之往后移动</p>
</li>
<li><p>打开文件后文件指针的位置：</p>
<ul>
<li>以追加方式打开文件后，文件指针指向文件的结尾位置</li>
<li>以其他方式打开文件后，文件指针指向文件的起始位置</li>
<li><strong>可以调用文件对象的方法tell()，返回文件指针的当前位置</strong></li>
</ul>
</li>
<li><p>自由移动文件指针：<strong>可以调用文件对象的方法seek(offset[, whence])<strong>，将文件指针自由移动到参数指定的位置，其中参数offset表示偏移量，可以为负数。</strong>参数whence是可选的</strong>，表示相对偏移量，有三种取值：</p>
<ul>
<li>os.SEEK_SET：相对文件的起始位置，值为0，默认值</li>
<li>os.SEEK_CUR：相对文件的当前位置，值为1</li>
<li>os.SEEK_END：相对文件的结尾位置，值为2</li>
<li><strong>注意：以文本方式打开的文件，不支持使用参数whence，只支持相对文件的起始位置</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def reset(data):</span><br><span class="line">    with open(&#x27;myfile.txt&#x27;, &#x27;w&#x27;) as file:</span><br><span class="line">        file.write(data)</span><br><span class="line"></span><br><span class="line">reset(&#x27;0123456789&#x27;)  # 创建或覆盖数据为 0123456789 的文本文件&#x27;myfile.txt&#x27;</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 10</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 0</span><br><span class="line">    file.read(3)</span><br><span class="line">    print(file.tell())  # 3</span><br><span class="line">    file.read()</span><br><span class="line">    print(file.tell())  # 10</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;a&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 10</span><br><span class="line">    file.write(&#x27;hello&#x27;)</span><br><span class="line">    print(file.tell())  # 15</span><br><span class="line"></span><br><span class="line">reset(&#x27;0123456789&#x27;)  # 将文件内数据复原到0123456789</span><br><span class="line"></span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;rb+&#x27;) as file:</span><br><span class="line">    print(file.tell())  # 0</span><br><span class="line"></span><br><span class="line">    # file.seek(3, os.SEEK_SET)</span><br><span class="line">    # file.seek(3, 0)</span><br><span class="line">    file.seek(3)</span><br><span class="line">    print(file.tell())  # 3</span><br><span class="line"></span><br><span class="line">    # os.SEEK_CUR表示相对于当前位置的寻址，</span><br><span class="line">    # 文本文件对象并不支持这种操作，所以一定要确保以二进制读写模式打开文件</span><br><span class="line">    file.seek(4, os.SEEK_CUR)</span><br><span class="line">    print(file.tell())  # 7</span><br><span class="line"></span><br><span class="line">    file.seek(-2, os.SEEK_END)</span><br><span class="line">    print(file.tell())  # 8，即此时指针移动到了数字7后面</span><br><span class="line"></span><br><span class="line">    file.write(b&#x27;Python&#x27;)  # 在二进制模式下打开的文件，写入数据也一定要是二进制数据</span><br><span class="line">    print(file.tell())  # 14，写入数据时将从数字7后面开始覆盖</span><br><span class="line"></span><br><span class="line"># 最终myfile.txt中的内容为：01234567Python</span><br><span class="line">with open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    print(file.read())  # 01234567Python</span><br></pre></td></tr></table></figure>

<h2 id="八、函数进阶"><a href="#八、函数进阶" class="headerlink" title="八、函数进阶"></a>八、函数进阶</h2><h4 id="1-函数的重要特性"><a href="#1-函数的重要特性" class="headerlink" title="1. 函数的重要特性"></a>1. 函数的重要特性</h4><ul>
<li><strong>在Python中，一切皆为对象</strong>。所以，<strong>函数也是对象</strong>，以下是函数的重要特性：<ol>
<li><strong>一个函数可以被赋值给一个变量</strong></li>
<li><strong>一个函数可以作为另一个函数的实参</strong></li>
<li><strong>一个函数可以作为另一个函数的返回值</strong></li>
<li><strong>一个函数可以嵌套定义在另一个函数中</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 1. 函数也是对象，可以被赋值给变量</span><br><span class="line">def add(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line">print(add)  # `&lt;function add at 0x100ccb2e0&gt;`</span><br><span class="line">f = add</span><br><span class="line">print(f(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 2. 一个函数可以作为另一个函数的实参</span><br><span class="line">def eval_square(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line">result = map(eval_square, [1, 2, 3, 4])</span><br><span class="line">print(list(result))  # [1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line"># 3. 一个函数可以作为另一个函数的返回值</span><br><span class="line">def do_sth():</span><br><span class="line">    return add</span><br><span class="line"></span><br><span class="line">print(do_sth()(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 4. 一个函数可以嵌套定义在另一个函数中</span><br><span class="line">def outer():</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;This is inner.&quot;)</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">outer()()  # This is inner.</span><br></pre></td></tr></table></figure>

<h4 id="2-Lambda匿名函数"><a href="#2-Lambda匿名函数" class="headerlink" title="2. Lambda匿名函数"></a>2. Lambda匿名函数</h4><ul>
<li><p>简介：当函数中只有一行return语句时，函数的定义可以用一个lambda表达式来代替</p>
</li>
<li><p><strong>语法：<code>lambda arguments: expression</code>（arguments是参数，expression是函数的返回值）</strong></p>
</li>
<li><p><strong>闭包：</strong> Lambda函数也涉及到闭包的概念，因为<strong>其可以捕获和引用定义在其周围作用域中的变量</strong>，形成闭包</p>
</li>
<li><p><strong>重点用法：将某个操作直接包装成一个可调用对象，即直接return某个函数并带有实参，这也是因为其可以捕获和引用定义在其周围作用域中的变量，例：<code>lambda: requests.get(url, headers=headers)</code></strong></p>
</li>
<li><p><strong>lambda表达式的特点：</strong></p>
<ol>
<li><strong>没有函数名</strong></li>
<li><strong>没有关键字def</strong></li>
<li><strong>没有小括号</strong></li>
<li><strong>关于形式参数的表达式相当于函数的返回值</strong></li>
</ol>
</li>
<li><p>在Python中，一切皆为对象，lambda表达式也是对象，又属于函数，所以也拥有函数的部分重要特性</p>
<ol>
<li><strong>lambda表达式可以被赋值给变量</strong></li>
<li><strong>lambda表达式可以作为函数的实参</strong></li>
<li><strong>lambda表达式可以作为函数的返回值</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># &gt; 函数与lambda表达式的区别</span><br><span class="line">def add(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line">print(add(1, 2))  # 3</span><br><span class="line">print((lambda num1, num2: num1 + num2)(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 1、lambda表达式可以被赋值给变量</span><br><span class="line">le = lambda num1, num2: num1 + num2</span><br><span class="line">print(le(1, 2))  # 3</span><br><span class="line"></span><br><span class="line"># 2、lambda表达式可以作为函数的实参</span><br><span class="line">result = map(lambda x: x * x, [1, 2, 3, 4])</span><br><span class="line">print(list(result))  # [1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line"># 3、lambda表达式可以作为函数的返回值</span><br><span class="line">def do_sth():</span><br><span class="line">    return lambda num1, num2: num1 + num2</span><br><span class="line"></span><br><span class="line">print(do_sth()(1, 2))  # 3</span><br></pre></td></tr></table></figure>

<h4 id="3-partial偏函数"><a href="#3-partial偏函数" class="headerlink" title="3. partial偏函数"></a>3. partial偏函数</h4><ul>
<li><p>简介：偏函数可以将某个已有的函数转换为一个新函数，在<strong>转换的过程中指定最前面的若干个位置实参以及关键字实参</strong>，这样，当调用新函数的时候，在其内部调用的仍然是转换前的函数，在<strong>传递实参时只需要传递剩余的位置实参和关键字实参</strong>即可，从而<strong>简化函数的调用</strong>。转换后的新函数被称为转换前的函数的<strong>偏函数</strong>。</p>
</li>
<li><p>应用：**可以调用标准库模块functools中的函数partial(func, *args, **kwargs)**，将某个已有的函数转换为其偏函数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line"># 案例1</span><br><span class="line">def f1(a, b=5, *args, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;args =&#x27;, args, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f1_new = partial(f1, 1, 3, 6, m=8)</span><br><span class="line">f1_new(2, 4, n=9)  # a = 1 b = 3 args = (6, 2, 4) kwargs = &#123;&#x27;m&#x27;: 8, &#x27;n&#x27;: 9&#125;</span><br><span class="line"></span><br><span class="line"># 案例2</span><br><span class="line">def f2(a, b=5, *, c, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line">f2_new = partial(f2, 1, m=8)</span><br><span class="line">f2_new(3, c=9)  # a = 1 b = 3 c = 9 kwargs = &#123;&#x27;m&#x27;: 8&#125;</span><br><span class="line"></span><br><span class="line"># 案例3</span><br><span class="line">def eval_sum(*args):</span><br><span class="line">    s = 0</span><br><span class="line">    for n in args:</span><br><span class="line">        s += n</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line">eval_sum_new = partial(eval_sum, 20, 30)</span><br><span class="line">print(eval_sum_new(1, 2, 3, 4, 5))  # 65</span><br></pre></td></tr></table></figure>

<h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h4><ul>
<li><p>简介：如果在一个函数的内部嵌套定义了另外一个函数（暂且将外部的函数和内部的函数分别称为外函数和内函数），同时满足<strong>内函数引用了外函数中的变量</strong>、<strong>外函数的返回值是内函数</strong>这两点，那么就构成了一个<strong>闭包</strong></p>
</li>
<li><p>应用：通常情况下，在函数调用结束后，函数内定义的变量将不再可用。但是，<strong>对于闭包而言，在外函数调用结束后，外函数中被内函数引用的变量仍然是可用的，因为此变量并没有被释放，而是被绑定到了内函数的特殊属性__closure__中，可以通过__closure__[i].cell_contents打印其值</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 一个简单典型的闭包结构</span><br><span class="line">def outer():</span><br><span class="line">    a = 10</span><br><span class="line">    def inner():  # 一个函数的内部嵌套定义了另外一个函数</span><br><span class="line">        print(a)  # 内函数引用了外函数中的变量</span><br><span class="line">    return inner  # 外函数的返回值是内函数</span><br><span class="line"></span><br><span class="line">outer()()  # 10</span><br><span class="line"></span><br><span class="line"># 此时打印内函数的特殊属性__closure__，返回了一个只包含一个元素的元组</span><br><span class="line">print(outer().__closure__)  # (`&lt;cell at 0x10107f430: int object at 0x100f20210&gt;`,)</span><br><span class="line">print(outer().__closure__[0].cell_contents)  # 10，即outer函数中的变量a</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>重点：默认情况下，在内函数中不能修改外函数中变量的引用（如果引用的对象是可变类型的，可以修改对象的值）</strong>。如果想在内函数中修改外函数中变量的引用，<strong>可以在内函数中使用关键字nonlocal对变量进行声明</strong>；声明即意味着在内函数中不会再重新定义一个新的同名变量，而是使用了外函数中该名称的变量</p>
</li>
<li><p><strong>注意：对于内函数中引用的外函数中的变量， 在调用内函数后对该变量的修改，在下一次调用内函数时仍然是有效的，因为该变量会被绑定到内函数的特殊属性__closure__中</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    a, b, c = 1, [2], [3]</span><br><span class="line">    print(f&quot;a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;, 调用内函数前id(c)=&#123;id(c)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def inner():</span><br><span class="line">        # 在内函数中不能修改外函数中变量的引用，如果在内函数直接给变量a重新赋值，相当于重新定义</span><br><span class="line">        # a += 1  # 抛出异常，直接使用 += 会导致等号右边的变量a还没赋值</span><br><span class="line">        # b = [8]  # 同理，这里是重新定义了一个变量b，把外函数中的变量b给屏蔽了</span><br><span class="line">        b[0] = 8  # 外函数中变量b的引用是列表为可变类型的，所以这里是内函数引用了外函数中的变量</span><br><span class="line"></span><br><span class="line">        nonlocal a, c</span><br><span class="line">        a += 1  # 声明后即操作的是外函数中变量</span><br><span class="line">        c = [9]  # 与b[0]=8不同，c是改变了外函数中变量c的引用，而b仅仅是改变了其值</span><br><span class="line">        print(f&quot;a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;, 调用内函数前id(c)=&#123;id(c)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"># 在调用内函数后对该变量的修改，在下一次调用内函数时仍然是有效的</span><br><span class="line">inner = outer()  # a=1, b=[2], c=[3], 调用内函数前id(c)=4333769536</span><br><span class="line">inner()  # a=2, b=[8], c=[9], 调用内函数前id(c)=4333774272</span><br><span class="line">inner()  # a=3, b=[8], c=[9], 调用内函数前id(c)=4333769536</span><br><span class="line"></span><br><span class="line">print(inner.__closure__)  # 此时特殊属性__closure__中存放了三个cell对象所组成的元组</span><br><span class="line">for i in range(3):</span><br><span class="line">    print(inner.__closure__[i].cell_contents)  # 3 [8] [9]</span><br></pre></td></tr></table></figure>

<h4 id="5-变量的作用域"><a href="#5-变量的作用域" class="headerlink" title="5. 变量的作用域"></a>5. 变量的作用域</h4><blockquote>
<p><strong>变量的作用域指的是变量起作用的范围，是由定义变量的位置决定的。</strong></p>
<p>变量的作用域有4种：</p>
<ol>
<li>局部作用域（Local）<ul>
<li>每次调用函数时都会创建一个<strong>局部作用域</strong>，局部作用域（函数）中定义的变量称为<strong>局部变量</strong></li>
<li>局部变量的作用域为：<strong>从定义变量处开始到函数结束</strong></li>
<li>函数调用结束后，其对应的<strong>局部作用域中的所有变量都会被销毁</strong></li>
</ul>
</li>
<li>嵌套作用域（Enclosing）<ul>
<li>每次调用嵌套函数中的外函数时都会创建一个<strong>嵌套作用域</strong></li>
<li>当在外函数内定义变量时，该变量的作用域为：<strong>从定义变量处开始到函数结束</strong></li>
<li>外函数调用结束后，其对应的<strong>嵌套作用域中的所有变量都会被销毁（闭包除外）</strong></li>
</ul>
</li>
<li>全局作用域（Global）<ul>
<li>每次运行模块时都会创建一个<strong>全局作用域</strong>，全局作用域（模块）中定义的变量称之为<strong>全局变量</strong></li>
<li>全局变量的作用域为：<strong>从定义变量处开始到模块结束</strong></li>
<li>程序运行结束后，<strong>全局作用域中的所有变量都会被销毁</strong></li>
</ul>
</li>
<li>内置作用域（Built-in）<ul>
<li>每次启动Python解释器都会自动加载内置模块，从而创建一个<strong>内置作用域</strong></li>
<li>内置模块中的函数（内置函数），<strong>可以在程序中直接使用</strong></li>
<li><strong>停止解释器后，内置作用域中的所有变量都会被销毁</strong></li>
</ul>
</li>
</ol>
</blockquote>
<ul>
<li><strong>重点1：当在某个作用域中访问变量时，会按照LEGB的顺序依次搜索该作用域及其后面的所有作用域</strong>，只要找到了则停止搜索，如果没找到则抛出NameError。因此，如果不同的作用域中定义了同名的变量，根据LEGB的搜索顺序，<strong>前面作用域中的变量会屏蔽掉后面作用域中定义的同名变量</strong></li>
<li><strong>重点2：与闭包原理类似，在局部作用域或嵌套作用域中不能修改全局变量的引用（如果引用的对象是可变类型的，可以修改对象的值）</strong>。如果想要修改，<strong>可以在局部作用域或嵌套作用域中使用关键字global对变量进行声明</strong>；声明即意味着在局部作用域或嵌套作用域中不会再重新定义一个新的同名变量，而是使用了该名称的全局变量</li>
<li><strong>注意：流程控制语句和异常处理语句不会创建对应的作用域。因此，对于流程控制语句和异常处理语句中定义的变量，在语句执行结束后仍然是可以用的</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">id = &quot;Global&quot;</span><br><span class="line"></span><br><span class="line">def outside():</span><br><span class="line">    id = &quot;Enclosing&quot;</span><br><span class="line"></span><br><span class="line">    def inside():</span><br><span class="line">        id = &quot;Local&quot;</span><br><span class="line">        # global id  # 使用global关键字声明后，打印id的值就为Global</span><br><span class="line">        print(id)</span><br><span class="line"></span><br><span class="line">    inside()</span><br><span class="line"></span><br><span class="line">outside()  # 按照LEGB的顺序依次注释掉函数中的属性id值，</span><br><span class="line"># 会依次输出：Local、Enclosing、Global、`&lt;built-in function id&gt;`</span><br><span class="line"></span><br><span class="line"># 重要问题：关于作用域的典型问题！</span><br><span class="line">def fun():</span><br><span class="line">    # 按照LEGB的顺序会先到局部作用域中搜索变量id，而局部变量id却定义在了访问print之后，</span><br><span class="line">    # 意味着局部变量id还没有赋值，这样就会抛出异常，而如果没有定义局部变量id，反而不会抛出异常</span><br><span class="line">    # 因为按照LEGB的搜索顺序，会在全局作用域中搜索到已赋值的全局变量id = &#x27;Global&#x27;</span><br><span class="line">    print(id)  # UnboundLocalError: ......</span><br><span class="line">    # id = 5</span><br><span class="line"></span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line"># 流程控制语句和异常处理语句不会创建对应的作用域</span><br><span class="line">if True:</span><br><span class="line">    temp = 18</span><br><span class="line">print(temp)  # 18</span><br><span class="line"></span><br><span class="line">for item in [1, 2, 3]:</span><br><span class="line">    print(item)  # 1 2 3</span><br><span class="line">print(item)  # 3</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    result = 5</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line">print(result)  # 5</span><br></pre></td></tr></table></figure>

<h4 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6. 命名空间"></a>6. 命名空间</h4><ul>
<li>简介：<strong>命名空间指的是某个作用域内所有名字和值的映射，用字典表示</strong><ul>
<li>内置函数locals()可以返回其所在局部作用域的命名空间</li>
<li>内置函数globals()可以返回其所在全局作用域的命名空间</li>
</ul>
</li>
<li><strong>重点：</strong><ul>
<li><strong>对于可变类型，使用locals()或者globals()返回的字典与实际命名空间是共享的，通过该字典修改可变类型的值会在实际命名空间中反映出来。需要注意的是，此时locals()返回的字典只能改变变量的值，而globals()返回的字典既可以改变变量的值，还可以改变其引用</strong></li>
<li><strong>对于不可变类型，是无法通过修改locals()返回的字典来改变实际的命名空间中的不可变类型的值的，但是globals()可以</strong></li>
</ul>
</li>
<li><strong>总结：locals() 和 globals() 都用于查看当前作用域内的命名空间，但是 locals() 返回的是一个只读的字典副本，而 globals() 返回的是实际命名空间的引用。</strong>在局部命名空间中，对于可变类型的变量，使用 locals() 返回的字典修改其值会影响实际的命名空间，但对于不可变类型的变量，使用 locals() 修改值是无效的。对于 globals()，无论变量的类型是可变还是不可变，修改都会影响实际的命名空间。</li>
<li>**内置函数vars()**：返回对象的属性和属性值的字典对象<ul>
<li>当函数不接收参数时，返回当前作用域内的局部变量，其功能和locals()函数类似</li>
<li>当函数接收一个参数时，参数可以是模块、类、类实例或者定义了__dict__属性的对象，其功能和object.__dict__属性类似</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># eg1：</span><br><span class="line">school_students = &#123;</span><br><span class="line">    &#x27;Alice&#x27;: 18,</span><br><span class="line">    &#x27;Bob&#x27;: 19,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def class_students(students):</span><br><span class="line">    print(f&quot;局部命名空间中的变量：&#123;locals()&#125;&quot;)  # &#123;&#x27;students&#x27;: &#123;&#x27;Alice&#x27;: 18, &#x27;Bob&#x27;: 19&#125;&#125;</span><br><span class="line"></span><br><span class="line">    # 在局部命名空间中，添加一个新的学生</span><br><span class="line">    locals()[&#x27;students&#x27;][&#x27;Emily&#x27;] = 20  # 添加</span><br><span class="line">    locals()[&#x27;students&#x27;][&#x27;Alice&#x27;] = 17  # 修改</span><br><span class="line"></span><br><span class="line">    print(f&quot;局部命名空间中的变量：&#123;locals()&#125;&quot;)  # &#123;&#x27;students&#x27;: &#123;&#x27;Alice&#x27;: 17, &#x27;Bob&#x27;: 19, &#x27;Emily&#x27;: 20&#125;&#125;</span><br><span class="line">    print(f&quot;当前作用域内的局部变量：&#123;vars()&#125;&quot;)  # &#123;&#x27;students&#x27;: &#123;&#x27;Alice&#x27;: 17, &#x27;Bob&#x27;: 19, &#x27;Emily&#x27;: 20&#125;&#125;</span><br><span class="line"></span><br><span class="line">class_students(school_students)</span><br><span class="line">print(&quot;全局命名空间中的变量students：&quot;, globals()[&#x27;school_students&#x27;])  # &#123;&#x27;Alice&#x27;: 17, &#x27;Bob&#x27;: 19, &#x27;Emily&#x27;: 20&#125;</span><br><span class="line"></span><br><span class="line"># eg2：</span><br><span class="line">def f():</span><br><span class="line">    x, y = [123], &#x27;hello&#x27;</span><br><span class="line">    print(locals())  # &#123;&#x27;x&#x27;: [123], &#x27;y&#x27;: &#x27;hello&#x27;&#125;</span><br><span class="line">    locals()[&#x27;x&#x27;][0] = 333  # 可变类型，locals()可以修改值，但不能修改其引用</span><br><span class="line">    # locals()[&#x27;x&#x27;] = 333  # 没有效果</span><br><span class="line">    locals()[&#x27;y&#x27;] = &#x27;xfblog&#x27;  # 不可变类型，locals()修改值无效</span><br><span class="line">    locals()[&#x27;z&#x27;] = &#x27;world&#x27;  # 可以添加值</span><br><span class="line">    print(x, y)  # [333] hello，z未定义所以不能访问，只能通过locals()访问</span><br><span class="line">    print(locals())  # &#123;&#x27;x&#x27;: [333], &#x27;y&#x27;: &#x27;hello&#x27;, &#x27;z&#x27;: &#x27;world&#x27;&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

<h4 id="7-函数装饰器"><a href="#7-函数装饰器" class="headerlink" title="7. 函数装饰器"></a>7. 函数装饰器</h4><ul>
<li><p>简介：对于某个函数，如果希望<strong>在不改变该函数代码的前提下，为该函数增加额外的功能</strong>，那么就可以使用装饰器来装饰该函数</p>
</li>
<li><p>原理：装饰器是一个函数，装饰器接收一个函数作为参数（传入的实参是被装饰的函数），装饰器的内部嵌套定义另一个函数，内函数中会引用装饰器的参数，并且装饰器的返回值是内函数，这样就<strong>构成了一个闭包</strong>。为了让内函数接收任意类型的参数，将内函数的形参定义为(*args, **kwargs)。 <strong>在内函数中，首先完成为被装饰函数添加的新功能，然后返回调用被装饰的函数</strong></p>
</li>
<li><p>把装饰器应用到被装饰函数的语法为：<strong>在被装饰函数的前面添加”@装饰器的函数名”<strong>。在被装饰函数add的前面添加@log后，相当于执行了语句：</strong>add &#x3D; log(add)<strong>， 首先被装饰的函数add会作为实参传递给装饰log，然后返回装饰器的内函数wrapper，最后将内函数wrapper赋值给add（被装饰函数的函数名），</strong>这样再调用被装饰的函数add时，其实调用的是装饰器的内函数wrapper</strong> <img  
                       lazyload
                       alt="image"
                       data-src="https://osswcf.oss-cn-shanghai.aliyuncs.com/2022/10/1667144165-4475f40809afcf1.jpg"
                       
                 ></p>
</li>
<li><p>知识点1：如果希望被装饰函数的特殊属性__name__的值为其函数名add， 而不是装饰器的内函数函数名wrapper，可以在装饰器的内函数前面添加另外一个装饰器：**@functools.wraps(装饰器的形参名)<strong>。</strong>其中functools.wraps指的是标准库模块functools中的函数wraps**</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&quot;函数%s被调用了&quot; % func.__name__)</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line">def add(sum1, sum2):</span><br><span class="line">    return sum1 + sum2</span><br><span class="line"></span><br><span class="line">print(add(1, 2))  # 函数add被调用了 3</span><br><span class="line"># print(add.__name__)  # 若注释掉&quot;@functools.wraps(func)&quot;，则打印wrapper</span><br><span class="line">print(add.__name__)  # add</span><br></pre></td></tr></table></figure>

<ul>
<li>知识点2：<strong>把装饰器应用到递归函数时，装饰器会执行多次。如果只想装饰器正常执行一次，可以在递归函数前都加上单下划线，并重新定义一个新函数调用此递归函数，最后再将装饰器应用到新函数上即可</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 汉诺塔问题</span><br><span class="line">def zhuangshiqi(func):</span><br><span class="line">    def wrapper(*a, **b):</span><br><span class="line">        print(&quot;移动开始&quot;)</span><br><span class="line">        func(*a, **b)</span><br><span class="line">        print(&quot;移动结束&quot;)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def _hanoi(n, a, b, c):</span><br><span class="line">    if n &gt; 0:</span><br><span class="line">        _hanoi(n - 1, a, c, b)</span><br><span class="line">        print(&quot;移动%s最上方的盘子至%s&quot; % (a, c))</span><br><span class="line">        _hanoi(n - 1, b, a, c)</span><br><span class="line"></span><br><span class="line">@zhuangshiqi</span><br><span class="line">def hanoi(n):</span><br><span class="line">    _hanoi(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br><span class="line"></span><br><span class="line">hanoi(3)</span><br><span class="line">&quot;&quot;&quot;如果递归函数特殊处理装饰器，则会打印多次移动开始和移动结束</span><br><span class="line">移动开始</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动A最上方的盘子至B</span><br><span class="line">移动C最上方的盘子至B</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动B最上方的盘子至A</span><br><span class="line">移动B最上方的盘子至C</span><br><span class="line">移动A最上方的盘子至C</span><br><span class="line">移动结束</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>知识点3：<strong>把装饰器应用到被装饰函数时，还可以传递额外的参数；此时，需要编写一个三层嵌套的装饰器</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def logs(year, month, day):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            print(&quot;%s年%s月%s日, 函数%s被调用了&quot; % (year, month, day, func.__name__))</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@logs(2099, 10, 30)  # 同理，对于@logs(2099, 10, 30)，相当于执行语句：adds = logs(2099, 10, 30)(adds)</span><br><span class="line">def adds(sum1, sum2):</span><br><span class="line">    return sum1 + sum2</span><br><span class="line"></span><br><span class="line">print(adds(1, 2))  # 2099年10月30日, 函数adds被调用了 3</span><br></pre></td></tr></table></figure>

<h4 id="8-内置函数property"><a href="#8-内置函数property" class="headerlink" title="8. 内置函数property"></a>8. 内置函数property</h4><ul>
<li>简介：在Python中定义类时，希望控制类的属性的访问和修改方式，property()函数可以<strong>将方法转化为静态的属性（变量）</strong>，使得属性的获取、设置和删除可以通过方法调用来实现，从而提供更多的控制。这样一来，当访问这个属性时，实际上是调用了这个方法</li>
<li>语法：<strong>property(getx, setx, delx, doc)，函数设有4个参数，即获取属性值的函数、设置属性值的函数、删除属性值的函数和属性描述信息</strong></li>
<li>应用1：<strong>定义一个可控属性值，即在类中定义值为property对象的类属性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Circle:</span><br><span class="line">    def __init__(self, radius):</span><br><span class="line">        self._radius = radius  # 使用下划线前缀表示这是一个受保护的属性</span><br><span class="line"></span><br><span class="line">    def get_radius(self):</span><br><span class="line">        print(&quot;获取半径&quot;)</span><br><span class="line">        return self._radius</span><br><span class="line"></span><br><span class="line">    def set_radius(self, value):</span><br><span class="line">        if value &lt; 0:</span><br><span class="line">            raise ValueError(&quot;半径不能为负数&quot;)</span><br><span class="line">        print(&quot;设置半径&quot;)</span><br><span class="line">        self._radius = value</span><br><span class="line"></span><br><span class="line">    def del_radius(self):</span><br><span class="line">        print(&quot;删除半径&quot;)</span><br><span class="line">        del self._radius</span><br><span class="line"></span><br><span class="line">    # 使用property()将get_radius方法转化为属性</span><br><span class="line">    radius = property(get_radius, set_radius, del_radius, &quot;圆的半径&quot;)</span><br><span class="line"></span><br><span class="line"># 创建一个Circle对象</span><br><span class="line">circle = Circle(5)</span><br><span class="line"></span><br><span class="line"># 访问属性（调用get_radius方法）</span><br><span class="line">print(circle.radius)  # 5</span><br><span class="line"></span><br><span class="line"># 设置属性（调用set_radius方法）</span><br><span class="line">circle.radius = 10</span><br><span class="line"></span><br><span class="line"># 获取属性的文档字符串</span><br><span class="line">print(Circle.radius.__doc__)  # 需要通过类名来获取，因为属性是属于类的</span><br><span class="line"></span><br><span class="line"># 删除属性（调用del_radius方法）</span><br><span class="line">del circle.radius</span><br></pre></td></tr></table></figure>

<ul>
<li>应用2：<strong>将property函数用作装饰器，可以直接创建只读属性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.__x = name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def myfun(self):</span><br><span class="line">        &quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span><br><span class="line">        return self.__x</span><br><span class="line"></span><br><span class="line">    @myfun.setter</span><br><span class="line">    def myfun(self, value):</span><br><span class="line">        self.__x = value</span><br><span class="line"></span><br><span class="line">    @myfun.deleter</span><br><span class="line">    def myfun(self):</span><br><span class="line">        del self.__x</span><br><span class="line"></span><br><span class="line">c = C(&#x27;wcf&#x27;)</span><br><span class="line">print(c.myfun)  # 自动执行@property修饰的myfun方法，并获取方法的返回值</span><br><span class="line">c.myfun = &#x27;zxc&#x27;  # 自动执行@myfun.setter修饰的myfun方法，并将&#x27;zxc&#x27;赋值给方法的参数</span><br><span class="line">print(C.myfun.__doc__)  # 自动获取@property修饰的myfun方法的__doc__属性：I&#x27;m the &#x27;x&#x27; property.</span><br><span class="line">del c.myfun  # 自动执行@myfun.deleter修饰的myfun方法</span><br></pre></td></tr></table></figure>
                    
                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                02_Python_高级语法
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2022/11/01/python-高级语法/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">xfblog</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2022-11-01 00:00</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Python/">Python</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                
                    

<div class="reward-author-container border-box flex-center">
    <div class="reward-btn border-box flex-center tooltip tooltip-img"
            data-tooltip-img-url="/images/zfb.webp"
            data-tooltip-img-trigger="click"
            data-tooltip-img-style="top: -6px;"
    >
        <i class="fa-solid fa-gift"></i>&nbsp;创作不易，打赏随意，您的支持是我更新的动力💪！
    </div>
</div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2023/01/01/python-%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"
                                   title="03_Python_线程、进程与协程"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">03_Python_线程、进程与协程</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2022/09/01/python-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"
                                   title="01_Python_基础语法"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">01_Python_基础语法</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-text">一、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="nav-text">1. 函数的定义与调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">2. 函数的多个返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E5%8F%82%E4%B8%8E%E4%BC%A0%E9%80%92"><span class="nav-text">3. 函数的两种实参与传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%BD%A2%E5%8F%82"><span class="nav-text">4. 函数的默认值形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%87%BD%E6%95%B0%E4%B8%AD-%E5%AF%B9%E5%8F%82%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">5. 函数中*对参数的用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-text">6. 递归函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-pass%E8%AF%AD%E5%8F%A5%E3%80%81%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3"><span class="nav-text">7. pass语句、文档字符串、函数注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">二、浅拷贝和深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">1. 浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">2. 深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">三、面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. 类和对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Python%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="nav-text">2. Python的动态性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">3. 访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E5%A4%9A%E6%80%81"><span class="nav-text">4. 封装、继承、重写、多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-MRO"><span class="nav-text">5. MRO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B9%8B%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-text">6. 获取对象的信息之内置函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B9%8B%E5%8F%8D%E5%B0%84"><span class="nav-text">7. 获取对象的信息之反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E5%92%8C%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="nav-text">8. 特殊属性和魔术方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">9. 对象的引用计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E5%92%8C%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%EF%BC%88%E7%BB%AD%EF%BC%89"><span class="nav-text">10. 特殊属性和魔术方法（续）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9D%97"><span class="nav-text">四、模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-text">1. 使用标准库中的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-text">2. 使用第三方库中的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEAnaconda"><span class="nav-text">3. 安装和配置Anaconda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="nav-text">4. 模块的使用规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-import%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">5. import语句的执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-dir%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-text">6. dir查看模块的所有属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7"><span class="nav-text">7. 模块的特殊属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">8. 模块的数据访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="nav-text">9. 动态加载模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">五、生成器与迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">1. 生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">2. 迭代器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">六、异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8D%95%E8%8E%B7%E5%92%8C%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-text">1. 捕获和处理异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8raise%E8%AF%AD%E5%8F%A5%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text">2. 使用raise语句手动抛出异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-text">3. 自定义异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BC%82%E5%B8%B8%E5%AE%9E%E4%BE%8Berr"><span class="nav-text">4. 异常实例err</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%BC%82%E5%B8%B8%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-text">5. 异常和函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF"><span class="nav-text">6. 获取异常信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-assert%E6%96%AD%E8%A8%80"><span class="nav-text">7. assert断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-with%E8%AF%AD%E5%8F%A5"><span class="nav-text">8. with语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="nav-text">七、文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-text">1. 打开文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-text">2. 读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-text">3. 写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="nav-text">4. 关闭文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="nav-text">5. 文件指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="nav-text">八、函数进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-text">1. 函数的重要特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-text">2. Lambda匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-partial%E5%81%8F%E5%87%BD%E6%95%B0"><span class="nav-text">3. partial偏函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%97%AD%E5%8C%85"><span class="nav-text">4. 闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5. 变量的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">6. 命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">7. 函数装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0property"><span class="nav-text">8. 内置函数property</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
    Copyright&nbsp;&copy;&nbsp;<span>2021</span>&nbsp;-&nbsp;2024&nbsp;<a href="https://xfblog.cn/" target="_self">小傅博客</a>&nbsp;-&nbsp;All&nbsp;rights&nbsp;reserved.&nbsp;&nbsp;&nbsp;&nbsp;
    
            <!-- &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">xfblog</a> -->
        
    </div>

    <!-- <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div> -->

    

    

    
        <div class="record-info info-item">
            
                
                    <div class="record-item border-box">
                        <a class=""
                           target="_blank"
                           href="https://beian.miit.gov.cn"
                        >
                            蜀ICP备2021021033号-1
                        </a>
                    </div>
                
            
                
                    <div class="record-item border-box">
                        <a class=""
                           target="_blank"
                           href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51138102000134"
                        >
                            川公网安备 51138102000134号
                        </a>
                    </div>
                
            
        </div>&nbsp;&nbsp;&nbsp;&nbsp;
    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-text">一、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="nav-text">1. 函数的定义与调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">2. 函数的多个返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E5%8F%82%E4%B8%8E%E4%BC%A0%E9%80%92"><span class="nav-text">3. 函数的两种实参与传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%BD%A2%E5%8F%82"><span class="nav-text">4. 函数的默认值形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%87%BD%E6%95%B0%E4%B8%AD-%E5%AF%B9%E5%8F%82%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">5. 函数中*对参数的用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-text">6. 递归函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-pass%E8%AF%AD%E5%8F%A5%E3%80%81%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3"><span class="nav-text">7. pass语句、文档字符串、函数注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">二、浅拷贝和深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">1. 浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">2. 深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">三、面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. 类和对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Python%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="nav-text">2. Python的动态性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">3. 访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E5%A4%9A%E6%80%81"><span class="nav-text">4. 封装、继承、重写、多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-MRO"><span class="nav-text">5. MRO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B9%8B%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-text">6. 获取对象的信息之内置函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B9%8B%E5%8F%8D%E5%B0%84"><span class="nav-text">7. 获取对象的信息之反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E5%92%8C%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="nav-text">8. 特殊属性和魔术方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">9. 对象的引用计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E5%92%8C%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%EF%BC%88%E7%BB%AD%EF%BC%89"><span class="nav-text">10. 特殊属性和魔术方法（续）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9D%97"><span class="nav-text">四、模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-text">1. 使用标准库中的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-text">2. 使用第三方库中的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEAnaconda"><span class="nav-text">3. 安装和配置Anaconda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="nav-text">4. 模块的使用规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-import%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">5. import语句的执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-dir%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-text">6. dir查看模块的所有属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7"><span class="nav-text">7. 模块的特殊属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">8. 模块的数据访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="nav-text">9. 动态加载模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">五、生成器与迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">1. 生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">2. 迭代器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">六、异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8D%95%E8%8E%B7%E5%92%8C%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-text">1. 捕获和处理异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8raise%E8%AF%AD%E5%8F%A5%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text">2. 使用raise语句手动抛出异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-text">3. 自定义异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BC%82%E5%B8%B8%E5%AE%9E%E4%BE%8Berr"><span class="nav-text">4. 异常实例err</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%BC%82%E5%B8%B8%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-text">5. 异常和函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF"><span class="nav-text">6. 获取异常信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-assert%E6%96%AD%E8%A8%80"><span class="nav-text">7. assert断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-with%E8%AF%AD%E5%8F%A5"><span class="nav-text">8. with语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="nav-text">七、文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-text">1. 打开文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-text">2. 读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-text">3. 写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="nav-text">4. 关闭文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="nav-text">5. 文件指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="nav-text">八、函数进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-text">1. 函数的重要特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-text">2. Lambda匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-partial%E5%81%8F%E5%87%BD%E6%95%B0"><span class="nav-text">3. partial偏函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%97%AD%E5%8C%85"><span class="nav-text">4. 闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5. 变量的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">6. 命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">7. 函数装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0property"><span class="nav-text">8. 内置函数property</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->
<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/toggle-theme.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/code-block.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/libs/anime.min.js"></script>

<!-- local search -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/local-search.js"></script>


<!-- lazyload -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/lazyload.js"></script>


<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/post-helper.js"></script>

        <!-- toc -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/toc.js"></script>
        

        <!-- copyright-info -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/copyright-info.js"></script>
        

        <!-- share -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/share.js"></script>
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




    
        
            
<script class="custom-inject-js" src="/js/run_time.js" data-pjax></script>

        
    
        
            
<script class="custom-inject-js" src="/js/code_click_copy.js" data-pjax></script>

        
    
        
            
<script class="custom-inject-js" src="/js/copyrightpro.js" data-pjax></script>

        
    

</body>
</html>
