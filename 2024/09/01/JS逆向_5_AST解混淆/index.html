<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="xfblog">
    
    <title>
        
            JS逆向_5_AST解混淆 |
        
        XFBLOG.CN
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/favicon.webp">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/font/css/brands.min.css">
    
        
            
                
<link rel="stylesheet" href="/css/custom-1.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"XFBLOG.CN","author":"xfblog","avatar":"/images/avatar.webp","logo":"/images/logo.webp","favicon":"/images/favicon.webp"},"menu":{"home":"/ || fa-solid fa-home","archives":"/archives || fa-solid fa-box-archive","categories":"/categories || fa-solid fa-layer-group","links":"/links || fa-solid fa-link","about":"/about || fa-solid fa-circle-info"},"first_screen":{"enable":true,"background_img":"/images/home_light.webp","background_img_dark":"/images/home_dark.webp","description":null,"hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/xfblogcn","weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":true,"hide_header":true},"home":{"announcement":"版权声明：本站所有文章均为 xfblog.cn 小傅原创，请遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。","category":true,"tag":true,"post_datetime":"created","post_datetime_format":"YYYY-MM-DD"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD","copyright_info":true,"share":true,"reward":{"enable":true,"img_link":"/images/zfb.webp","text":"创作不易，打赏随意，您的支持是我更新的动力💪！"}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":false,"site_pv":false,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":true},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"jsdelivr"},"pjax":{"enable":true},"footer":{"since":2021,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":true,"list":[{"code":"蜀ICP备2021021033号-1","link":"https://beian.miit.gov.cn"},{"code":"川公网安备 51138102000134号","link":"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51138102000134"}]}},"inject":{"enable":true,"css":["/css/custom-1.css"],"js":["/js/run_time.js","/js/code_click_copy.js","/js/copyrightpro.js"]},"root":"","source_data":{},"version":"4.2.5"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Keep" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.webp">
                </a>
            
            <a class="site-name border-box" href="/">
               XFBLOG.CN
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-home"></i>
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                
                                分类
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/links">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-link"></i>
                                
                                友链
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/about">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-circle-info"></i>
                                
                                关于
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-home"></i>
                                </span>
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                </span>
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                </span>
                            
                            分类
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/links">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-link"></i>
                                </span>
                            
                            友链
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/about">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-circle-info"></i>
                                </span>
                            
                            关于
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        JS逆向_5_AST解混淆
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.webp">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">xfblog</span>
                                
                                    <span class="author-badge">Lv3</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-09-01</span>
            </span>

            
                <span class="meta-info-item post-update-date">
                    <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                    <span class="datetime" data-updated="Tue Dec 03 2024 17:50:47 GMT+0800">2024-12-03</span>
                </span>
            
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/JS%E9%80%86%E5%90%91/">JS逆向</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E7%88%AC%E8%99%AB/">爬虫</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Python/">Python</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>36.9k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>187 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h2 id="一、AST技术专题"><a href="#一、AST技术专题" class="headerlink" title="一、AST技术专题"></a>一、AST技术专题</h2><blockquote>
<p><strong>AST 抽象语法树（Abstract Syntax Tree）：</strong>AST 是一种数据结构，是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构，如语句、表达式、变量声明等。语法树不是某一种编程语言独有的，几乎所有编程语言都有语法树，<strong>既然是一棵树，那一定存在节点，或遍历相关的概念</strong>。</p>
<ul>
<li><strong>安装 babel 库：</strong><code>npm install @babel/core --save-dev</code>（全局安装可能会有无法导入库的情况）</li>
<li><strong>将源代码解析为 AST 在线网站：</strong><a class="link"   href="https://astexplorer.net/"  target="_blank" rel="noopener">AST explorer<i class="fas fa-external-link-alt"></i></a>（解释器选择 @babel&#x2F;parser）</li>
<li><strong>小技巧：</strong>在 AST explorer 中，点击左侧某段代码的中间，对应右侧的 AST 树片段就会被标黄</li>
</ul>
<p><strong>在编译原理中，编译器转换代码要经过三个步骤：词法分析 &#x3D;&gt; 语法分析（构建 AST 语法树） &#x3D;&gt; 代码生成</strong></p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://xfblog.cn/images/1716090018-9dbb06e659303be.png"
                        
                 >
</blockquote>
<h3 id="0-AST-脱混淆思路"><a href="#0-AST-脱混淆思路" class="headerlink" title="0. AST -&gt; 脱混淆思路"></a>0. AST -&gt; 脱混淆思路</h3><blockquote>
<p><strong>匹配括号内全为字面量实参的正则表达式：</strong></p>
<ul>
<li>匹配多个：<code>\(\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\2)(\s*,\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\5))*\s*\)</code></li>
<li>匹配两个：<code>\(\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\2)\s*,\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\4)\s*\)</code></li>
<li>指定函数名匹配多个：<code>myFunction\s*\(\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\2)(\s*,\s*(\d+|([&#39;&quot;])[a-zA-Z0-9\s]+?\5))*\s*\)</code></li>
</ul>
</blockquote>
<ul>
<li><strong>数组还原思路：</strong>直接复制网页原始数组 <code>copy(_$UH.map(String))</code> 在本地通过 ast 遍历还原</li>
<li><strong>通用思路：</strong><ol>
<li><strong><span style="color:red;">拿到一段代码，先进行预处理，然后观察其整体结构，不要盲目还原，如果需要还原的函数调用，其里面还嵌套的有函数调用，那就应该先还原里面那层的</span></strong></li>
<li><strong>嵌套的节点还原，优先采用 exit 方式遍历：</strong><code>a = b = c = d;</code>、<code>(n = (n = (n = (n = n[]())</code>，如果此时插件中还要遍历其他类型节点进行处理，而这个处理结果又可以继续生成指定特征的还原，那么这个遍历<strong>也要用 exit 方式</strong>，因为<strong>要保证下面的遍历比上面的遍历晚退出</strong>（<strong>注意如果同时要在遍历过程中遍历处理其他类型节点，那么最好不要将其分开为多个插件，因为在同一个插件中，是会无限递归遍历此类型的节点，包括刚处理过的；而将插件分开写，就会导致每个插件分开作用，插件1遍历一次处理好了，然后插件2遍历插件1处理好的结果并再次处理，再然后就结束了</strong>，同时要注意配合 <code>scope.crawl()</code> 使用）</li>
<li><strong><span style="color:red;">在一个作用域内继续获取元素的 banding，就要使用当前 banding.path.scope.getBinding() 去获取</span></strong></li>
<li><strong>每一次调用插件还原后，都应该思考当前节点被还原后，其定义或其使用过的对象是否还有存在的必要</strong>，没有则应该立即删除，**<span style="color:red;">尽管删不干净同类型的，但至少应该清除与此次还原相关的垃圾代码</span><strong>，同类型的垃圾代码留给</strong>最后一次调用垃圾代码删除插件清除即可**，目的是为了此次还原不影响后续插件的调用</li>
<li><strong>在 obj 对象 value 实现之前，既要保证对象属性中的函数只有一条 return 语句，还要保证属性非函数的均为子面量，否则无法还原</strong>，所以需要调用一次折叠子面量或表达式的插件，并且在对象还原之后又会出现一些子面量，此时应该<strong>再次调用一次折叠子面量或表达式的插件</strong></li>
<li><strong><span style="color:red;">AST 删除的时候有个特点，就是其绑定相关的参数都要重新解析并删除一次后才会更新，即需要删除两次</span></strong></li>
</ol>
</li>
<li><strong>通用法则：</strong><ol>
<li><strong>一个插件中不允许同时遍历两种相同类型的节点，即使遍历内容不一样也不行，因为后者会覆盖前者</strong></li>
<li><strong>实参全部为字面量的函数才可还原</strong>，一定要判断实参是否全部为子面量，且还原后函数定义应该删除掉</li>
<li>在还原调用表达式时，<strong>需要先挑选一个还原</strong>，判断其需要哪些环境代码，将这些环境代码放入插件之前，再<strong>收集所有需要还原的调用表达式对应的函数定义</strong>，并加载执行代码，统一还原（另一种情况看下面）</li>
<li><strong>当插件无作用的时候，可以尝试重新解析一次 ast 树</strong></li>
<li><strong>在整个 ast 解混淆大致结束时，并且调用垃圾代码插件后，剩余的冗余代码，可自行判断手动删除更快</strong></li>
</ol>
</li>
<li><strong>注意细节：</strong><ol>
<li><strong><span style="color:red;">在 for 循环中，变量定义会被记录为改变一次；同时变量赋值的改变次数就等于循环次数</span></strong></li>
<li><strong><span style="color:red;">在 binding 中，对数组或对象进行元素赋值的操作也算引用 <code>arr[1] = 9</code>、<code>e[&#39;age&#39;]=18</code>、<code>++arr[1]</code></span></strong></li>
<li><strong><span style="color:red;">在一个作用域中，特别是函数中，若函数中存在与函数名同名的标识符（包括形参），则需要通过其父 path 获取当前节点的 binding，否则可能会获取错对象的绑定</span></strong></li>
<li>在编写插件中，<strong>需要通过 if 判断过滤出不需要的节点，这很重要</strong>，包括判读其父节点、子节点、参数等</li>
<li><strong>type.ExpressionStatement()：</strong>用于创建语句节点，通常用做<strong>包裹创建</strong>，目的是在语句结尾加上分号</li>
<li><strong>涉及节点、path 更改或赋值等操作时：</strong>被赋值的对象一定不能是最具体的那一层，而是其上一层或几层</li>
<li><strong>遍历赋值语句通常都需要过滤一下父 path 类型，因为不能改变在某些语句的判断条件中的赋值语句</strong></li>
<li><strong>object 对象合并：</strong>构造对象属性 <code>types.objectProperty(key, value)</code> ，插入 <code>properties.push()</code></li>
<li><strong>错误示范：</strong><code>let &#123; switchNode, breakNode &#125; = body.body;</code> 此时 body.body 是个<strong>数组</strong>，要中括号取</li>
<li><strong>在 for 循环中过滤节点应该使用 continue 或 break</strong>，不能使用 return，return 则直接结束遍历了</li>
</ol>
</li>
<li><strong>另一种还原方式（代码整体被自执行函数包裹，且无传参）：</strong><ol>
<li><strong>核心思想：想方设法拿到需要还原的函数的调用结果</strong></li>
<li><strong>核心步骤：</strong>复制一份 encode 文件为 change，<strong>去除外层自执行函数包裹并替换为 try-catch 语句</strong>，不仅可以让程序正常运行，还可以<strong>加大变量作用域的范围</strong>；如果此时可以拿到函数调用值，则表示可以还原了</li>
<li><strong>引入文件：</strong><code>let decodeObCode = files.readFileSync(&quot;change.js&quot;, &#123; encoding: &quot;utf-8&quot; &#125;);</code>，并通过 eval 执行文件</li>
</ol>
</li>
</ul>
<h3 id="1-代码混淆原理"><a href="#1-代码混淆原理" class="headerlink" title="1. 代码混淆原理"></a>1. 代码混淆原理</h3><ul>
<li><strong>为混淆做准备：</strong><ol>
<li>利用<strong>对象属性的两种访问方式</strong>，将<strong>打点调用方式</strong>转换成<strong>中括号调用方式</strong>，即 <code>p.name =&gt; p[&#39;name&#39;]</code></li>
<li>js 中很多内置对象都是 window 对象的属性，例 <code>Date() =&gt; window.Date() =&gt; window[&#39;Date&#39;]()</code></li>
</ol>
</li>
<li><strong>基本混淆处理：</strong><ol>
<li><strong>十六进制编码：</strong>将字符串循环拼接 <code>&quot;\\x&quot; + code.charCodeAt(i).toString(16)</code> 转换为十六进制形式，但是一般不大面积使用，因为还原简单，常用于变量名的转换，<strong>在 js 中变量名无法进行加密等操作</strong></li>
<li><strong>unicode 编码：</strong><code>&quot;\\u&quot; + (&quot;0000&quot; + code.charCodeAt(i).toString(16)).substr(-4)</code>，unicode 编码不仅仅适用于变量，<strong>还适用于 js 中的方法名等标识符</strong>，但也存在还原简单的问题</li>
<li><strong>转 ASCII 码数组：</strong>将字符串循环通过 str.charCodeAt(i) 方法转换为 ascii 数组，在使用时直接配合方法 String.fromCharCode(ascii_array) 代替字符串。这种方式还适用于<strong>混淆整句代码</strong>，配合 eval 执行代码</li>
<li><strong>字符串常量加密：</strong>先把字符串加密得到密文，然后在使用之前，调用对应的解密函数去解密，得到明文。例 Base64 编码后，通过 atob 解码，但在实际混淆应用中，atob 这种标识符一定要处理为没有语义的</li>
<li><strong>算法里的数值常量加密：</strong>在算法加密过程中，大致已经知道是什么算法加密，但是无法定位，则可以直接搜索算法中的常量，例如 md5 中的常量 0x67452301、0xefcdab89 等，达到定位代码关键位置的目的。而最常见的则是<strong>利用位异或的特性加密，例如 a^b&#x3D;c，那么 c^b&#x3D;a，此时 b 相当于加密密钥</strong>，网易常见</li>
</ol>
</li>
<li><strong>增加 js 逆向者的工作量：</strong><ol>
<li><strong>数组混淆：</strong>将所有的字符串都提取到一个数组中，然后在需要引用字符串的地方，全部都以数组下标的方式去访问数组成员。这归功于 js 语法的灵活，同一个数组可以存放任意类型的数据，包括函数。例如将 <code>&quot;&quot;[&#39;constructor&#39;][&#39;fromCharCode&#39;]</code> 放入数组，这里 <strong>“”[‘constructor’] 获取构造函数等同于 String</strong></li>
<li><strong>数组乱序：</strong>将数组成员顺序通过一定逻辑打乱，同时内置一段对应的还原顺序逻辑代码，确保引用正确</li>
<li><strong>花指令：</strong>添加一些没有意义却可以混淆视听的代码，瞬间膨胀代码量，是花指令的核心。常见的有二项式相加转函数的花指令、函数调用表达式的花指令等，并且都可以进行<strong>多级嵌套</strong></li>
<li><strong>jsfuck：</strong>基于 js 是弱类型语言，存在<strong>隐式转换</strong>的特点，将 js 代码转换成只用 6 个字符 ( ) + ! [ ] 就可以表示的代码，同时<strong>在 js 中只有 7 种值 false、undefined、null、0、-0、NaN、”” 为假</strong>，其余均为真。例 <code>(!+[]+!![]+[])</code> 等于 2，其中 +[] 会转换为字符串 +”” ，再由字符串转换为 0，则 !+[] 为 true（由于控制台可以直接还原，所以 jsfuck 应用较少）</li>
</ol>
</li>
<li><strong>代码执行流程的防护原理：</strong><ol>
<li><strong>流程平坦化：</strong>使用 switch case 语句实现，因为 case 块是平级的，调换 case 块的前后顺序，并不影响代码原先的执行逻辑。通过套入死循环，定义一个记录了真实执行顺序的文本字符串，将文本串分割为数组，作为 switch 语句的条件，并通过计数器每次递增，当索引越界时无匹配 case 则直接 break 跳出结束</li>
<li><strong>特点：</strong>case 的条件不仅仅是字符串，还可以是对象，数组等类型。同时 switch 混淆的执行顺序并不一定要通过文本串分割循环数组的方式实现，还可以通过在 case 块中修改 switch 条件，从而控制执行顺序</li>
<li><strong>逗号表达式：</strong>逗号表达式会执行都好前面所有的语句，但只返回最后一个逗号的表达式的值，这其中可以添加很多无用的花指令来混淆视听</li>
</ol>
</li>
<li><strong>其他代码防护方案：</strong><ol>
<li><strong>eval 加密：</strong>原理是通过一个自执行的匿名函数返回一段字符串，再用 eval 执行这段字符串，使其效果等同于原代码。匿名函数可以看作解密函数，eval 解密就是直接去掉 eval，执行剩余的代码，得到原代码</li>
<li><strong>内存爆破：</strong>在代码中加入死代码，正常情况下这段代码不执行，当检测到函数被格式化或者被 Hook 时，就跳转到这段代码执行，运行直到内存溢出。例如 for 循环使用数组长度为条件，无限往数组中添加成员</li>
<li><strong>检查代码是否格式化：</strong>通过正则表达式匹配某个函数的 toString() 来判断代码是否被格式化</li>
</ol>
</li>
</ul>
<h3 id="2-语法树节点名词"><a href="#2-语法树节点名词" class="headerlink" title="2. 语法树节点名词"></a>2. 语法树节点名词</h3><ul>
<li>Program（程序主体）：整段代码的主体</li>
<li>Identifier（标识符）：标识，例如声明变量时 var obj &#x3D; 5 中的 obj</li>
<li>VariableDeclarator（变量声明符）：对应一个具体变量的定义</li>
<li>Property（属性）</li>
<li>Literal（字面量）：<ul>
<li>BooleanLiteral（布尔型字面量）：布尔值，例如 true false</li>
<li>NumericLiteral（数字型字面量）：数字，例如 100</li>
<li>StringLiteral（字符型字面量）：字符串，例如 “vansenb”</li>
</ul>
</li>
<li>Declaration（声明）：<ul>
<li>VariableDeclaration（变量声明）：声明一个变量，例如 var let const</li>
<li>FunctionDeclaration（函数声明）：声明一个函数，例如 function</li>
</ul>
</li>
<li>Statement（语句）：<ul>
<li>ExpressionStatement（表达式语句）：通常是调用一个函数，例如 console.log()</li>
<li>BlockStatement（块语句）：包裹在 {} 块内的代码，例如 if (condition){var a &#x3D; 1;}</li>
<li>BreakStatement（中断语句）：通常指 break</li>
<li>ContinueStatement（持续语句）：通常指 continue</li>
<li>ReturnStatement（返回语句）：通常指 return</li>
<li>SwitchStatement（Switch 语句）通常指 Switch Case 语句中的 Switch</li>
<li><strong>SwitchCase（Case 语句）：</strong>通常指 Switch 语句中的 Case</li>
<li>IfStatement（If 控制流语句）：控制流语句，通常指 if(condition){}else{}</li>
</ul>
</li>
<li>Expression（表达式）：<ul>
<li>CallExpression（调用表达式）：通常指调用一个函数，例如 console.log()</li>
<li>BinaryExpression（二进制表达式）：通常指运算，例如 1+2</li>
<li>MemberExpression（成员表达式）：通常指调用对象的成员，例如 console 对象的 log 成员</li>
<li>ArrayExpression（数组表达式）：通常指一个数组，例如 [1, 3, 5]</li>
<li>NewExpression（New 表达式）：通常指使用 New 关键词</li>
<li>AssignmentExpression（赋值表达式）：通常指将函数的返回值赋值给变量</li>
<li>UpdateExpression（更新表达式）：通常指更新成员值，例如 i++</li>
</ul>
</li>
</ul>
<h3 id="3-bable"><a href="#3-bable" class="headerlink" title="3. bable"></a>3. bable</h3><blockquote>
<p><strong>JavaScirpt 的 Babel 编译器：</strong></p>
<ol>
<li><strong>@babel&#x2F;core：</strong>Babel 编译器本身，提供了 babel 的编译 API</li>
<li><strong>@babel&#x2F;parser：</strong>将 JavaScript 代码解析成 AST 语法树</li>
<li><strong>@babel&#x2F;traverse：</strong>用于遍历、修改 AST 语法树的各个节点</li>
<li><strong>@babel&#x2F;types：</strong>用于判断、验证节点的类型、构建新 AST 节点等</li>
<li><strong>@babel&#x2F;generator：</strong>将 AST 还原成 JavaScript 代码</li>
</ol>
</blockquote>
<ul>
<li><strong>Bable 中的组件：</strong><ol>
<li><strong>parser 组件：</strong>parser 的 parse 方法的第 2 个参数接受一个对象，默认值为 <code>&#123;sourceType: &quot;script&quot;&#125;</code><ul>
<li>当解析的 js 代码中含有 export 等 ES6 语法时，需要指定 sourceType 为 module 值，否则抛出异常</li>
</ul>
</li>
<li><strong>generator 组件：</strong>generator 方法的第 2 个参数接受一个对象，可以自定义设置输出结果的格式<ul>
<li><code>&#123;retainLines: false, comments: true, compact: true&#125;</code> 均为默认值</li>
<li>retainLines：表示是否使用与源代码相同的行号，即否是格式化</li>
<li>comments：表示是否保留注释</li>
<li>compact：表示是否压缩代码，压缩程度正常，minified 表示压缩程度高，concise表示压缩程度低</li>
</ul>
</li>
<li><strong>traverse 组件与 visitor 对象：</strong><ul>
<li><strong>visitor 对象：</strong>用于过滤节点的一个对象，配合 traverse 组件一起使用 <strong><code>traverse(ast, visitor);</code></strong></li>
<li><strong>enter、exit 函数：</strong>在遍历节点过程中，一个节点会有两次访问机会，即 enter 进入节点时（<strong>从整体到部分遍历，大 &#x3D;&gt; 小，默认</strong>）与 exit 退出节点时（<strong>从部分到整体遍历，小 &#x3D;&gt; 大</strong>）（<strong>深度优先</strong>）</li>
<li><strong>把一个函数应用到多个节点：</strong>使用 | 分隔，<code>&quot;FunctionExpression|BinaryExpression&quot;(path)</code></li>
<li><strong>把多个函数应用到一个节点：</strong>把多个函数的数组赋值给 enter 对象，<code>enter: [func1, func2]</code></li>
<li><strong>不一定从头，可以从任意节点向下开始遍历：</strong><code>path.traverse(visitor对象, 传入的参数对象)</code></li>
</ul>
</li>
<li><strong>types 组件：</strong><ul>
<li><strong>判断节点类型：</strong><code>t.isIdentifier(path.node, &#123;name: &#39;a&#39;&#125;)</code> 判断 node 的 type 是否是标识符，且名称是否为 a，等价于 <code>path.isIdentifier(&#123;name: &#39;a&#39;&#125;)</code>，但这判断的是 path 下的 type 类型</li>
<li><strong>断言式的判断节点类型：</strong>当节点不符合要求时，会抛出异常而不是返回布尔值 <code>t.assertIdentifier</code></li>
<li><strong>主要用于构建新的 AST 节点：</strong>树的结构对应代码的实现从下至上，代码的实现对应目标代码由外向内</li>
<li><strong>valueToNode 方法：</strong>生成各种类型对象，除了原始类型 undefined、null、string、number、boolean，还可以是对象类型 RegExp、ReadonlyArray、object，可以接受数组，传入什么生成什么</li>
</ul>
</li>
</ol>
</li>
<li><strong>定义 visitor 对象的三种方式（常用第 2 种）：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const visitor1 = &#123;</span><br><span class="line">    FunctionExpression: function (path) &#123;</span><br><span class="line">        console.log(&quot;xfblog&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const visitor2 = &#123;</span><br><span class="line">    &quot;FunctionExpression|BinaryExpression&quot;(path) &#123;</span><br><span class="line">        console.log(&quot;xfblog&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const visitor3 = &#123;</span><br><span class="line">    FunctionExpression: &#123;</span><br><span class="line">        // enter(path) &#123;</span><br><span class="line">        //     console.log(&quot;xfblog&quot;);</span><br><span class="line">        // &#125;</span><br><span class="line">        enter: [</span><br><span class="line">            function (path) &#123;</span><br><span class="line">                console.log(&quot;func1&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            function (path) &#123;</span><br><span class="line">                console.log(&quot;func2&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>利用 types 组件构建新的 AST 节点：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 目标代码：</span><br><span class="line">// let obj = &#123;</span><br><span class="line">//     name: &quot;hhhh&quot;,</span><br><span class="line">//     add: function (a, b) &#123;</span><br><span class="line">//         return a + b + 1000;</span><br><span class="line">//     &#125;,</span><br><span class="line">//     eee: function (a, b) &#123;</span><br><span class="line">//         return null</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const t = require(&quot;@babel/types&quot;);</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line"></span><br><span class="line">const jscode = fs.readFileSync(&quot;./demo.js&quot;, &#123;</span><br><span class="line">    encoding: &quot;utf-8&quot;</span><br><span class="line">&#125;);</span><br><span class="line">let ast = parser.parse(jscode);</span><br><span class="line"></span><br><span class="line">let a = t.identifier(&#x27;a&#x27;);</span><br><span class="line">let b = t.identifier(&#x27;b&#x27;);</span><br><span class="line">let binExpr2 = t.binaryExpression(&quot;+&quot;, a, b);</span><br><span class="line">let binExpr3 = t.binaryExpression(&quot;*&quot;, a, b);</span><br><span class="line">let retSta2 = t.returnStatement(t.binaryExpression(&quot;+&quot;, binExpr2, t.numericLiteral(1000)));</span><br><span class="line">let retSta3 = t.returnStatement(t.binaryExpression(&quot;+&quot;, binExpr3, t.numericLiteral(1000)));</span><br><span class="line">let bloSta2 = t.blockStatement([retSta2]);</span><br><span class="line">let bloSta3 = t.blockStatement([retSta3]);</span><br><span class="line">let funcExpr2 = t.functionExpression(null, [a, b], bloSta2);</span><br><span class="line">let funcExpr3 = t.functionExpression(null, [a, b], bloSta3);</span><br><span class="line">let objProp1 = t.objectProperty(t.identifier(&#x27;name&#x27;), t.stringLiteral(&#x27;xiaojianbang&#x27;));</span><br><span class="line">let objProp2 = t.objectProperty(t.identifier(&#x27;add&#x27;), funcExpr2);</span><br><span class="line">let objProp3 = t.objectProperty(t.identifier(&#x27;mul&#x27;), funcExpr3);</span><br><span class="line">let objExpr = t.objectExpression([objProp1, objProp2, objProp3]);</span><br><span class="line">let varDec = t.variableDeclarator(t.identifier(&#x27;obj&#x27;), objExpr);</span><br><span class="line">let loaclAst = t.variableDeclaration(&#x27;let&#x27;, [varDec]);</span><br><span class="line">let code = generator(loaclAst).code;</span><br><span class="line">console.log(code);</span><br><span class="line"></span><br><span class="line">// code = generator(ast).code;</span><br><span class="line">fs.writeFile(&#x27;./demoNew.js&#x27;, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-path"><a href="#4-path" class="headerlink" title="4. path"></a>4. path</h3><blockquote>
<p><strong>path 与 node 的区别：</strong>path 是在一开始 parser.parse 解析时就生成的，node 节点是被包含在 path 中的</p>
<p><strong>注意：在通过 type 组件构建新的 AST 节点时，生成的新 node 是没有 path 的。所以在对节点进行增删改后，需要先将 AST 转成代码，再重新 parser.parse 解析为 AST 语法树，此时 node 节点才会有 path 对象</strong></p>
<p><strong><span style="color:red;">重点：凡是涉及到节点的操作，都推荐使用 path 对象的方法，因为只有这样 Babel 才会更新 path 对象。但有时避免不了使用其他方法，所以最好的办法就是在修改之前，先将 AST 转成代码，再将代码解析为 AST</span></strong></p>
</blockquote>
<ul>
<li><strong>path.skip()：</strong>只跳过当前节点的子节点遍历，遍历器会继续处理当前节点之后的其他节点</li>
<li><strong>path.stop()：</strong>停止整个遍历过程，不再处理任何节点</li>
<li>**<span style="color:red;">path.evaluate()：</span>**用于评估一个表达式并返回其计算结果，返回一个对象，包含以下属性<ul>
<li><strong>confident：</strong>一个布尔值，表示 Babel 是否确信可以确定该表达式的值</li>
<li><strong>value：</strong>表达式的值（如果 confident 为 true），否则为 undefined</li>
</ul>
</li>
<li><strong><span style="color:red;">path.evaluateTruthy()：</span><strong>专门用于评估一个表达式的真假性，</strong>直接返回一个布尔值或 undefined 无法确定</strong></li>
<li><strong>判断 path 类型：</strong>path 的 type 属性通常与 node 中的 type 属性一致，用于判断自身类型，用法与 types 组件差不多，例 <code>path.get(&#39;left&#39;).isIdentifier()</code> 返回布尔值</li>
<li><strong>节点转代码：</strong>将 AST（部分）节点转成代码，<code>path.toString()</code>、<code>path + &#39;&#39;</code>，与 generator 组件作用相同</li>
<li><strong>替换节点属性：</strong>将标识符改为 x，<code>path.node.left = t.identifier(&quot;x&quot;)</code>（**这方式不会更新 path 对象，可以使用这种方式替换 <code>path.get(&#39;left&#39;).replaceWith(types.identifier(&#39;x&#39;))</code>**）</li>
<li><strong>path 的属性：</strong><ul>
<li>node：表示当前 path 下的 node 节点</li>
<li>parent：用于获取当前 path 下的父 node，多用于判断节点类型</li>
<li>parentPath：用于获取当前 path 下的父 path，多用于判断节点类型</li>
<li>scope：表示当前 path 下的作用域</li>
<li><strong>注意：</strong><code>path.parentPath.node</code> 等价于 <code>path.parent</code>，即 parent 是 parentPath 的一部分</li>
<li>type：用于获取当前path的节点类型</li>
<li>key：用于获取当前 path 的 key 值，key 通常用于 path.get 函数</li>
<li><strong>container：</strong>容器，用于获取当前path下的所有兄弟<strong>节点</strong>（<strong>包括自身</strong>），是一个 Array 类型</li>
<li>inList：判断是否有同级节点，即是否处于数组中（当数组只有一个成员时，也会返回 true）</li>
</ul>
</li>
<li><strong>container 容器内的属性：</strong><ul>
<li>key：表示当前节点在 container <strong>数组</strong>中的索引</li>
<li>listKey：表示 container 容器的名字</li>
</ul>
</li>
<li><strong>path 的方法：</strong><ul>
<li>toString：用来获取当前遍历 path 的 js 源代码，同样用法 <code>generator(path.node).code</code></li>
<li>get：获取子节点的 <strong>path</strong> 对象（区别于 path.node. 获取子节点的 node 对象）</li>
<li>findParent：向父节点搜寻节点，不包括当前节点，接受一个回调函数，根据回调函数的布尔值，从而返回找到节点的 path 或 null。例如 <code>path.findParent((p) =&gt; p.isObjectExpression())</code></li>
<li>find：向父节点搜寻节点，包括当前节点，用法与 findParent 一致</li>
<li>getFunctionParent：获取函数类型父节点的 path，存在则返回 path，不存在则返回 null</li>
<li>getStatementParent：获取 Statement 类型父节点的 path，这个基本上都会有返回值，如果当前遍历的是 Program 或者 File 节点，则会报错</li>
<li>getAncestry：获取所有的祖先节点的 path，没有实参，返回的是一个 Array 对象</li>
<li>isAncestor(someNode)：判断当前遍历的节点是否是传入节点的祖先节点</li>
<li>isDescendant(someNode)：判断当前遍历的节点是否是传入节点的子孙节点</li>
<li><strong>replaceWith：</strong>用 AST 节点替换该节点（<strong>严格一换一，替换新节点一般由 types 组件生成</strong>）</li>
<li><strong>replaceWithMultiple：</strong>用多个 AST 节点替换当前节点（<strong>多换一，实参为数组，或一换一单元素数组</strong>）</li>
<li><strong>replaceInline：</strong>整合 replaceWith 与 replaceWithMultiple（<strong>接受一个节点则一换一，数组则一换多</strong>）</li>
<li>replaceWithSourceString：直接使用字符串源码替换该节点（<strong>替换为表达式，而不是字符串</strong>）</li>
<li><strong>insertBefore：</strong>在当前节点之前插入一个或多个兄弟节点</li>
<li>insertAfter：在当前节点之后插入一个或多个兄弟节点</li>
<li><strong>remove：</strong>删除节点，直接调用即可将当前遍历的所有<strong>符合条件的路径</strong>全部删除</li>
<li>traverse：在当前节点下遍历其他的节点</li>
<li>getSibling：获取不同的同级 Path，接受容器数组中的索引为参数，通过传参 path.key 的增减定位</li>
<li>getPrevSibling：获取当前 path 的前一个兄弟节点，返回的是 path 类型</li>
<li>getAllPrevSiblings：获取当前 path 的所有前兄弟节点，返回的是 Array 类型，其元素都是 path 类型</li>
<li><strong>getNextSibling：</strong>获取当前 path 的后一个兄弟节点，返回的是 path 类型</li>
<li><strong>getAllNextSiblings：</strong>获取当前 path 的所有后兄弟节点，返回的是 Array 类型，其元素都是 path 类型</li>
<li><strong>path.evaluate：用于计算表达式的值</strong></li>
<li>unshiftContainer 和 pushContainer 方法：分别用于往容器的最前面和最后面加入节点，第一个参数为 listKey 容器名称，第二个参数为 Nodes 节点，<code>path.parentPath.unshiftContainer(body, [...])</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/** 测试代码：</span><br><span class="line"> * let obj = &#123;</span><br><span class="line"> *     name : &#x27;xiaofu&#x27;,</span><br><span class="line"> *     add: function(a, b)&#123;</span><br><span class="line"> *         return a + b + 1000;</span><br><span class="line"> *     &#125;,</span><br><span class="line"> *     mul: function(a, b)&#123;</span><br><span class="line"> *         return a * b + 1000;</span><br><span class="line"> *     &#125;,</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">    ReturnStatement(path) &#123;</span><br><span class="line">        console.log(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">/** 输出结果：</span><br><span class="line">NodePath &#123;</span><br><span class="line">  parentPath: NodePath &#123;......&#125;,</span><br><span class="line">  container: [</span><br><span class="line">    Node &#123;</span><br><span class="line">      type: &#x27;ReturnStatement&#x27;,</span><br><span class="line">      start: 272,</span><br><span class="line">      end: 292,</span><br><span class="line">      loc: [SourceLocation],</span><br><span class="line">      argument: [Node]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  listKey: &#x27;body&#x27;,</span><br><span class="line">  key: 0,</span><br><span class="line">  node: Node &#123;......&#125;,</span><br><span class="line">  type: &#x27;ReturnStatement&#x27;,</span><br><span class="line">  parent: Node &#123;......&#125;,</span><br><span class="line">  hub: undefined,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="5-scope"><a href="#5-scope" class="headerlink" title="5. scope"></a>5. scope</h3><blockquote>
<p><strong>path.scope：</strong>scope 提供了一些属性和方法，可以方便的查找标识符的作用域，获取标识符的所有引用，修改标识符的所有引用，以及识别标识符是否为参数、常量等，如果不是常量，也可以知道在哪里修改了它</p>
<p><strong><span style="color:red;">关于标识符在作用域中的引用次数与 scope.crawl() 的使用的重要解读：</span></strong></p>
<ol>
<li>在整个插件编写与调用遍历的过程中，可能会在某些插件中修改代码的 AST 结构或者创建新的节点，这将同时会影响到代码的作用域，<strong>但 scope 对象在某些情况下不会自动更新</strong>，从而导致其中的信息有误差</li>
<li><strong>scope.crawl()的使用：</strong>在涉及有关作用域的操作时，最好在其之前先调用 scope.crawl() 方法更新当前作用域信息，<strong>以确保获取对象的绑定信息正确，同时建议在每个插件的最后一行都调用此方法更新作用域（<span style="color:red;">已废弃，新解决思路是每个插件后重构 AST</span>）</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scope.crawl()</span><br><span class="line"></span><br><span class="line">let nameBin = scope.getBinding(left.name)</span><br><span class="line">if (nameBin.references == 0) &#123;</span><br><span class="line">    path.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>scope.block：</strong>返回<strong>当前作用域</strong>下的所有 node，可用 <code>generator(path.scope.block).code</code> 查看代码；在遍历函数获取作用域时，返回的是函数本身的 node，其真实作用域应该为 <code>path.scope.parent.block</code></p>
</li>
<li><p><strong>scope.dump()：</strong>输出当前每个变量的作用域信息。调用后直接打印，不需要加打印函数</p>
</li>
<li><p><strong><span style="color:red;">scope.crawl()：</span>更新作用域信息，并确保之后对作用域信息的访问是最新的</strong></p>
</li>
<li><p><strong>scope.getBinding(name)：</strong>获取某个变量的 binding，可理解为其生命周期，包含引用，修改之类的信息。参数必须是当前节点能够引用的到的标识符名，<strong>只有变量定义和函数定义拥有 binding</strong>，其他的获取 binding 都是 undefined。返回的作用域中有几个关键属性：</p>
<ul>
<li><p>path：用于定位初始拥有 binding 的 path，例如形参或新定义的变量</p>
</li>
<li><p>identifier：是参数的 node 对象</p>
</li>
<li><p>scope：是参数的 scope 对象，将其中 block 节点转为代码后，一样可以得到其作用域范围代码</p>
</li>
<li><p>kind：表示此标识符的生成，是定义 let 还是参数 params 等，但是它并不代表就是当前函数的参数</p>
</li>
<li><p><strong>constant：</strong>用于判断当前变量是否<strong>没有</strong>被更改，<strong>在定义时赋值不是更改，但是先定义后赋值就算被更改，同时函数中形参也是有绑定的，为形参赋值就是改变，在还原时应判断其改变是否只有一次且为本身</strong></p>
</li>
<li><p><strong>constantViolations：</strong>Array 类型，包含所有<strong>修改</strong>该标识符节点的 path 对象，多用于判断</p>
</li>
<li><p><strong>referenced：</strong>用于判断当前变量是否被引用，<strong>赋值不算引用，取值才算（例外 e[‘age’]&#x3D;18; 算引用）</strong></p>
</li>
<li><p><strong>referencePaths：</strong>Array 类型，包含所有引用该标识符的节点的 path 对象，多用于替换（<strong>注意：</strong>循环遍历时，通常 item 的父 path 才是调用表达式或成员表达式）（<strong>修改变量时解决重名问题</strong>）</p>
</li>
<li><p><strong>references：</strong>代表标识符被引用的次数</p>
</li>
</ul>
</li>
<li><p><strong>scope.getOwnBinding()：</strong>用于获取当前节点自己的绑定，也就是不包含父级作用域中定义的标识符的绑定，但是该函数会得到子函数中定义的标识符的绑定</p>
</li>
<li><p><strong>scope.rename(oldName, newName, [block])：</strong>修改当前作用域下指定的变量名，<strong>同时修改所有引用该标识符的地方</strong>，实参为字符串类型。注意，oldName 需要有 binding，否则无法重命名</p>
<ul>
<li><strong>生成新标识符名：</strong><code>path.scope.generateUidIdentifier(&quot;uid&quot;).name</code></li>
</ul>
</li>
<li><p><strong>scope.traverse()：</strong>遍历当前作用域下的某些(个)插件，使用 path.scope.traverse 则是当前节点的作用域，而使用 path.scope.getBinding(name).scope.traverse 则是遍历标识符 name 的作用域，推荐后者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FunctionDeclaration(path) &#123;</span><br><span class="line">    let binding = path.scope.getBinding(&#x27;a&#x27;);</span><br><span class="line">    binding.scope.traverse(binding.scope.block, &#123;</span><br><span class="line">        AssignmentExpression(p) &#123;</span><br><span class="line">            if (p.node.left.name == &#x27;a&#x27;) &#123;</span><br><span class="line">                p.node.right = t.numericLiteral(5000)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>scope 的其他方法：</strong></p>
<ul>
<li><strong>scope.hasBinding(‘a’)：</strong>查询是否有标识符 a 的绑定，返回 true 或 false</li>
<li><strong>scope.hasOwnBinding(‘a’)：</strong>查询是否有自己的绑定，不包含函数本身，返回 true 或 false</li>
<li><strong>scope.getAllBindings()：</strong>获取当前节点的所有绑定，是包含全局变量的，返回一个对象。该对象以标识符名为属性名，对应的 Binding 为属性值</li>
<li><strong>scope.hasReference(‘a’)：</strong>查询当前节点中是否有 a 标识符的引用，返回 true 或 false</li>
<li><strong>scope.getBindingIdentifier(‘a’)：</strong>获取当前节点中绑定的 a 标识符，返回的是 Identifier 的 Node 对象。同样地，这个方法也有 Own 版本，scope.getOwnBindingldentifier(‘a’)</li>
</ul>
</li>
</ul>
<h3 id="6-常见语法技巧"><a href="#6-常见语法技巧" class="headerlink" title="6. 常见语法技巧"></a>6. 常见语法技巧</h3><ul>
<li><p><strong>获取节点源代码：</strong></p>
<ul>
<li><strong>path：<code>path.toString()</code></strong></li>
<li><strong>node：<code>generator(node).code</code></strong></li>
</ul>
</li>
<li><p><strong>使用 template 构造节点：</strong></p>
<ol>
<li><pre><code>// 创建一个模板
let VAR_NODE = template(`var A = 1, B = A;`);

// 定义替换的标识符
let firstVar = types.identifier(&#39;a&#39;);
let secondVar = types.identifier(&#39;b&#39;);

// 生成新的节点
let newNode = VAR_NODE(&#123; A: firstVar, B: secondVar &#125;);
console.log(generator(newNode).code); // var a = 1, b = a;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   let newNode = template.ast(&quot;aaa = 666;&quot;);</span><br><span class="line">   console.log(generator(newNode).code); // aaa = 666;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p><strong>除了 path.remove() 的其他删除节点方式：</strong></p>
<ol>
<li><strong>delete path.node.extra：</strong>删除 <strong>StringLiteral</strong> 节点的 extra 属性，可以还原简单的进制混淆字面量</li>
<li><strong>body.pop()：</strong>需删除的节点存在多个兄弟节点，且存在 Array 中，则可通过遍历数组配合条件判断删除</li>
</ol>
</li>
</ul>
<h3 id="7-ast-必备-js-语法与特性"><a href="#7-ast-必备-js-语法与特性" class="headerlink" title="7. ast 必备 js 语法与特性"></a>7. ast 必备 js 语法与特性</h3><ol>
<li><strong>在 js 中只有 7 种值 false、undefined、null、0、-0、NaN、”” 为假</strong>，其余均为真</li>
<li>在 js 中对象的 key 可以不加引号，不同于 python</li>
<li><strong>在 js 中变量名和对象键无法直接进行加密，只能混淆</strong>，因为加密会导致 js 引擎无法正确解析和访问</li>
</ol>
<ul>
<li><p><strong>数组常用小方法：</strong></p>
<ol>
<li><strong>push(ele)：</strong>在数组末尾添加一个或多个元素，并返回数组的新长度</li>
<li><strong>pop()：</strong>从数组末尾移除最后一个元素，并返回该元素</li>
<li><strong>shift()：</strong>从数组开头移除第一个元素，并返回该元素</li>
<li><strong>unshift(ele)：</strong>在数组开头添加一个或多个元素，并返回数组的新长度</li>
<li><strong>concat(arr1, arr2)：</strong>合并两个或多个数组，并返回一个新数组</li>
<li><strong>sort()：</strong>就地对数组的元素进行排序，并返回此数组。默认排序顺序是根据字符串 Unicode 码点</li>
<li><strong>reverse()：</strong>就地颠倒数组中元素的顺序，并返回此数组</li>
<li><strong>join(separator)：</strong>将数组的所有元素连接成一个字符串，元素通过指定的分隔符 separator 分隔</li>
<li><strong>includes(ele)：</strong>如果数组包含某个元素，则返回 true，否则返回 false</li>
</ol>
</li>
<li><p><strong>数组常用遍历方法：</strong></p>
<ol>
<li><strong>forEach(callback)：</strong>对数组的每个元素执行一次提供的函数</li>
<li><strong>filter(callback)：</strong>创建一个新数组，其中包含所有通过所提供函数实现的测试的元素</li>
<li><strong>every(callback)：</strong>测试一个数组的所有元素是否都通过了指定函数的测试，返回布尔值</li>
<li><strong>some(callback)：</strong>测试数组中的某些元素是否至少有一个通过了提供的函数的测试，返回布尔值</li>
<li><strong>map(callback)：</strong>创建一个新数组，其结果是该数组中的每个元素调用一次提供的函数后的返回值</li>
<li><strong>slice(beginIndex, endIndex)：</strong>返回一个新数组，包含从开始到结束（左闭右开）选择的数组的一部分</li>
<li><strong>splice(startIndex, deleteCount[, item…])：</strong>通过删除或替换现有元素和&#x2F;或添加新元素来修改数组的内容，并返回被删除的元素</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.every(element =&gt; element.toString() == &#x27;xfblog.cn&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="二、判断节点通用函数"><a href="#二、判断节点通用函数" class="headerlink" title="二、判断节点通用函数"></a>二、判断节点通用函数</h2><h3 id="1-函数-–-节点字面量基础判断"><a href="#1-函数-–-节点字面量基础判断" class="headerlink" title="1. 函数 –&gt; 节点字面量基础判断"></a>1. 函数 –&gt; 节点字面量基础判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-函数-节点字面量递归判断"><a href="#2-函数-节点字面量递归判断" class="headerlink" title="2. 函数 -&gt; 节点字面量递归判断"></a>2. 函数 -&gt; 节点字面量递归判断</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">if (Array.isArray(node))</span><br><span class="line">    return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isThisExpression(node))</span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">if (types.isLiteral(node))</span><br><span class="line">    return node.value != null;</span><br><span class="line"></span><br><span class="line">if (types.isBinaryExpression(node))</span><br><span class="line">    return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">    return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">if (types.isObjectExpression(node))</span><br><span class="line">    return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isArrayExpression(node))</span><br><span class="line">    return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 用于检查一个给定的 AST 节点是否可以被视为字面量(Literal)</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    // node 是数组，函数会递归地检查数组中的每个元素是否都符合字面量的条件</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    // node 是一个 ThisExpression (例`this`关键字)，则返回true，因为this可以被视为字面量</span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    // node 是字面量，函数会进一步检查它的值。如果value为null，返回false，否则返回true</span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    // node 是二元表达式，函数会递归地检查表达式的左操作数和右操作数是否都为字面量</span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    // node 是一元表达式，且操作符是 + 或 -，函数会递归地检查表达式的参数是否为字面量</span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    // node 是对象表达式，例`&#123;a: 1, b: 2&#125;`，函数会检查对象的属性，属性为空则返回true，否则递归检查每个属性是否为字面量</span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    // node 是数组表达式，例`[1, 2, 3]`，函数会检查数组的元素，元素为空则返回true，否则递归检查每个元素是否为字面量</span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-函数优化-节点子面量判断"><a href="#3-函数优化-节点子面量判断" class="headerlink" title="3. 函数优化 -&gt; 节点子面量判断"></a>3. 函数优化 -&gt; 节点子面量判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-函数-判断节点是否纯函数"><a href="#3-函数-判断节点是否纯函数" class="headerlink" title="3. 函数 -&gt; 判断节点是否纯函数"></a>3. 函数 -&gt; 判断节点是否纯函数</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line"> let isPure = true;</span><br><span class="line"></span><br><span class="line"> // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line"> let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line"> let sourceCode = path.toString();</span><br><span class="line"> let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line"> if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line"> path.traverse(&#123;</span><br><span class="line">     MemberExpression(innerPath) &#123;</span><br><span class="line">         const &#123; object &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">             isPure = false;</span><br><span class="line">             innerPath.stop();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     AssignmentExpression(innerPath) &#123;</span><br><span class="line">         const &#123; left &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">             isPure = false;</span><br><span class="line">             innerPath.stop();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     CallExpression(innerPath) &#123;</span><br><span class="line">         const &#123; callee &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(callee)) &#123;</span><br><span class="line">             const binding = path.scope.getBinding(callee.name);</span><br><span class="line">             if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                 isPure = false;</span><br><span class="line">                 innerPath.stop();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     UpdateExpression(innerPath) &#123;</span><br><span class="line">         const &#123; argument &#125; = innerPath.node;</span><br><span class="line">         if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">             isPure = false;</span><br><span class="line">             innerPath.stop();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> return isPure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line">    </span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    // 访问函数内部的所有节点</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        // 检查是否有副作用</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            // 如果访问了外部变量</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 检查是否修改了外部状态</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 检查是否调用了非纯函数</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 其他可能的副作用</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 检查使用了全局对象</span><br><span class="line">        Identifier(innerPath) &#123;</span><br><span class="line">            if ([&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;Date&#x27;, &#x27;random&#x27;].includes(innerPath.node.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、解混淆通用插件"><a href="#三、解混淆通用插件" class="headerlink" title="三、解混淆通用插件"></a>三、解混淆通用插件</h2><h3 id="0-模版-通用解混淆模版"><a href="#0-模版-通用解混淆模版" class="headerlink" title="0. 模版 -&gt; 通用解混淆模版"></a>0. 模版 -&gt; 通用解混淆模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">const visitor = &#123;</span><br><span class="line">    /**  @param  &#123;NodePath&#125; path */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, visitor);</span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-插件-编码还原十进制"><a href="#1-插件-编码还原十进制" class="headerlink" title="1. 插件 -&gt; 编码还原十进制"></a>1. 插件 -&gt; 编码还原十进制</h3><ul>
<li>当代码中包含<strong>非ASCII字符</strong>时，要尽可能少地使用转义字符，以确保其被正确地保留和显示，而不是被转义<ul>
<li>配置：<code>let &#123; code &#125; = generator(ast, opts = &#123; jsescOption: &#123; &quot;minimal&quot;: true &#125; &#125;);</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 编码还原十进制</span><br><span class="line">const simplifyLiteral = &#123;</span><br><span class="line">    NumericLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /^0[obx]/i.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    StringLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /\\[ux]/gi.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, simplifyLiteral);</span><br></pre></td></tr></table></figure>

<h3 id="2-插件-字面量化成员表达式"><a href="#2-插件-字面量化成员表达式" class="headerlink" title="2. 插件 -&gt; 字面量化成员表达式"></a>2. 插件 -&gt; 字面量化成员表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 字面量化成员表达式 `b.length` ==&gt; `b[&#x27;length&#x27;]`</span><br><span class="line">const keyToLiteral = &#123;</span><br><span class="line">    MemberExpression: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const prop = node.property;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(prop)) &#123;</span><br><span class="line">                node.property = types.stringLiteral(prop.name)</span><br><span class="line">                node.computed = true; // 只有当使用中括号调用才为true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 对象的 key 也由标识符转为字面量</span><br><span class="line">    ObjectProperty: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const key = node.key;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(key)) &#123;</span><br><span class="line">                node.key = types.stringLiteral(key.name);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.computed &amp;&amp; types.isStringLiteral(key)) &#123;</span><br><span class="line">                node.computed = false; // 不是通过计算得来的，computed为false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, keyToLiteral);</span><br></pre></td></tr></table></figure>

<h3 id="3-插件-折叠字面量或表达式"><a href="#3-插件-折叠字面量或表达式" class="headerlink" title="3. 插件 -&gt; 折叠字面量或表达式"></a>3. 插件 -&gt; 折叠字面量或表达式</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// 折叠计算部分字面量或表达式</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">if (Array.isArray(node))</span><br><span class="line">  return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isThisExpression(node))</span><br><span class="line">  return true;</span><br><span class="line"></span><br><span class="line">if (types.isLiteral(node))</span><br><span class="line">  return node.value != null;</span><br><span class="line"></span><br><span class="line">if (types.isBinaryExpression(node))</span><br><span class="line">  return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">  return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">if (types.isObjectExpression(node))</span><br><span class="line">  return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">if (types.isArrayExpression(node))</span><br><span class="line">  return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">&quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">  exit(path) &#123;</span><br><span class="line">      let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">      let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">      if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">          path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">          path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">          path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">          const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">          if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">          if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">          try &#123;</span><br><span class="line">                 path.replaceWith(types.valueToNode(value));</span><br><span class="line">             &#125; catch &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     path.replaceWith(types.stringLiteral(value));</span><br><span class="line">                 &#125; catch (e) &#123;</span><br><span class="line">                     console.log(&quot;无法还原原因:&quot;, e.message);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 处理条件表达式（三目表达式）</span><br><span class="line">      if (path.isConditionalExpression()) &#123;</span><br><span class="line">          let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">          if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">              path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">          if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">          if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">          path.replaceWith(types.valueToNode(value));</span><br><span class="line">      &#125;</span><br><span class="line">      // 处理字符串相加</span><br><span class="line">      if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">          if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">              if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                  path.node.right.value += parent.right.value;</span><br><span class="line">                  parentPath.replaceWith(path.node);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/** 插件：折叠计算部分字面量或表达式</span><br><span class="line"> * var a = 1 + 2 + 3 + 4;                   ===&gt; var a = 10;</span><br><span class="line"> * var b = 3 - 5;                           ===&gt; var b = -2;</span><br><span class="line"> * var c = true ? 7 : 2;                    ===&gt; var c = 7;</span><br><span class="line"> * var d = !![];                            ===&gt; var d = true;</span><br><span class="line"> * var e = pw + 1 + 5 + 66;                 ===&gt; var e = pw + 72;</span><br><span class="line"> * var f = 3 + 100 - 30 + pw + 1 + 5 + 66;  ===&gt; var f = 145 + pw;</span><br><span class="line"> * var aaa = &quot;a&quot; + &quot;b&quot; + c;                 ===&gt; var aaa = &quot;ab&quot; + c;</span><br><span class="line"> * var bbb = c + &quot;d&quot; + &quot;e&quot;;                 ===&gt; var bbb = c + &quot;de&quot;;</span><br><span class="line"> * var ccc = &quot;a&quot; + &quot;b&quot; + c + &quot;d&quot; + &quot;e&quot;;     ===&gt; var ccc = &quot;ab&quot; + c + &quot;de&quot;;</span><br><span class="line"> * var ddd = &quot;111&quot;.toString().length        ===&gt; var ddd = 3</span><br><span class="line"> */</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression(&#123; operator: &#x27;!&#x27; &#125;) ||        // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isConditionalExpression() ||                   // 处理三目运算符</span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                // 评估当前路径（表达式）的值，confident表示评估结果是否确定，value表示评估的具体值</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return; // 排除value值为 1/0 无穷大的情况</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                // console.log(path + &#x27;&#x27;);</span><br><span class="line">                // console.log(parentPath + &#x27;&#x27;);</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果父节点是二元表达式，且父节点左侧操作数为当前节点          // 处理右侧字符串字面量相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                // 如果当前节点的左操作数不是字面量，操作符是加号，且右操作数是字面量</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    // 同时如果父节点的操作符也是加号，且右操作数也是字面量</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        // 合并当前节点和父节点的右侧字面量值，并替换父节点</span><br><span class="line">                        // console.log(path + &#x27;&#x27;);</span><br><span class="line">                        // console.log(parentPath + &#x27;&#x27;);</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 处理`var a = 73 + b + 72;`的情况</span><br><span class="line">                if (types.isNumericLiteral(left) &amp;&amp; types.isNumericLiteral(parent.right)) &#123;</span><br><span class="line">                    // console.log(path + &#x27;&#x27;);</span><br><span class="line">                    // console.log(parentPath + &#x27;&#x27;);   </span><br><span class="line">                    path.node.left.value += parent.right.value;</span><br><span class="line">                    parentPath.replaceWith(path.node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br></pre></td></tr></table></figure>

<h3 id="4-插件-简化循环和-If-语句"><a href="#4-插件-简化循环和-If-语句" class="headerlink" title="4. 插件 -&gt; 简化循环和 If 语句"></a>4. 插件 -&gt; 简化循环和 If 语句</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 美化循环语句和 if-else 语句，并简化逻辑</span><br><span class="line">const SimplifyLoopAndIf = &#123;</span><br><span class="line">    &quot;ForStatement|WhileStatement|ForInStatement|ForOfStatement&quot;(&#123; node &#125;) &#123;</span><br><span class="line">        if (!types.isBlockStatement(node.body)) &#123;</span><br><span class="line">            node.body = types.blockStatement([node.body]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IfStatement&quot;(path) &#123;</span><br><span class="line">        const test = path.get(&quot;test&quot;);</span><br><span class="line">        const consequent = path.get(&quot;consequent&quot;);</span><br><span class="line">        const alternate = path.get(&quot;alternate&quot;);</span><br><span class="line">        const evaluateTest = test.evaluateTruthy();</span><br><span class="line"></span><br><span class="line">     if (!consequent.isBlockStatement() &amp;&amp; !consequent.isEmptyStatement()) &#123;</span><br><span class="line">            consequent.replaceWith(types.blockStatement([consequent.node]));</span><br><span class="line">        &#125;</span><br><span class="line">        if (alternate.node !== null &amp;&amp; !alternate.isBlockStatement() &amp;&amp; !alternate.isEmptyStatement()) &#123;</span><br><span class="line">            alternate.replaceWith(types.blockStatement([alternate.node]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     if (consequent.isEmptyStatement() || consequent.node.body.length == 0) &#123;</span><br><span class="line">            if (alternate.node == null || alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                path.replaceWith(test.node);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent.replaceWith(alternate.node);</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">                test.replaceWith(types.unaryExpression(&quot;!&quot;, test.node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     if (alternate.node != null) &#123;</span><br><span class="line">            if (alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     if (evaluateTest === true) &#123;</span><br><span class="line">            path.replaceWithMultiple(consequent.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (evaluateTest === false) &#123;</span><br><span class="line">            (alternate.node === null || alternate.node.body.length == 0) ? path.remove() : path.replaceWithMultiple(alternate.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, SimplifyLoopAndIf);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/** 插件：美化循环语句和 if-else 语句，并简化逻辑</span><br><span class="line"> * if (a) b; else c;                ===&gt; if (a) &#123; b; &#125; else &#123; c; &#125;</span><br><span class="line"> * if (a);                          ===&gt; a;</span><br><span class="line"> * if (a) &#123; &#125;;                      ===&gt; a;</span><br><span class="line"> * if (a) &#123; &#125; else &#123; &#125;;             ===&gt; a;</span><br><span class="line"> * if (a) &#123; &#125; else &#123; b &#125;;           ===&gt; if (!a) &#123; b; &#125;</span><br><span class="line"> * if (a) &#123; &#125; else b;               ===&gt; if (!a) &#123; b; &#125;</span><br><span class="line"> * if (a) &#123; b &#125; else &#123; &#125;;           ===&gt; if (a) &#123; b; &#125;</span><br><span class="line"> * if (a) &#123; b &#125; else;               ===&gt; if (a) &#123; b; &#125;</span><br><span class="line"> * if (1 + 1) b; else c;            ===&gt; b;</span><br><span class="line"> * if (1 - 1) b; else c;            ===&gt; c;</span><br><span class="line"> */</span><br><span class="line">const SimplifyLoopAndIf = &#123;</span><br><span class="line">    &quot;ForStatement|WhileStatement|ForInStatement|ForOfStatement&quot;(&#123; node, scope &#125;) &#123;</span><br><span class="line">        if (!types.isBlockStatement(node.body)) &#123;</span><br><span class="line">            node.body = types.BlockStatement([node.body]);</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IfStatement&quot;(path) &#123;</span><br><span class="line">        const test = path.get(&quot;test&quot;);</span><br><span class="line">        const consequent = path.get(&quot;consequent&quot;);</span><br><span class="line">        const alternate = path.get(&quot;alternate&quot;);</span><br><span class="line">        const evaluateTest = test.evaluateTruthy(); // if的条件执行，返回布尔值</span><br><span class="line"></span><br><span class="line">        if (!consequent.isBlockStatement() &amp;&amp; !consequent.isEmptyStatement()) &#123;</span><br><span class="line">            consequent.replaceWith(types.BlockStatement([consequent.node]));</span><br><span class="line">        &#125;</span><br><span class="line">        if (alternate.node !== null &amp;&amp; !alternate.isBlockStatement() &amp;&amp; !alternate.isEmptyStatement()) &#123;</span><br><span class="line">            alternate.replaceWith(types.BlockStatement([alternate.node]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (consequent.isEmptyStatement() || consequent.node.body.length == 0) &#123; // `if(a);`或`if(a)&#123;&#125;;`</span><br><span class="line">            if (alternate.node == null || alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                path.replaceWith(test.node);</span><br><span class="line">            &#125; else &#123; // `if(a)&#123;&#125; else&#123;b&#125;;`</span><br><span class="line">                consequent.replaceWith(alternate.node);</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">                test.replaceWith(types.unaryExpression(&quot;!&quot;, test.node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `if(a)&#123;b&#125; else;`或`if(a)&#123;b&#125; else&#123;&#125;;`</span><br><span class="line">        if (alternate.node != null) &#123;</span><br><span class="line">            if (alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 能计算出条件真假值的情况</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            path.replaceWithMultiple(consequent.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (evaluateTest === false) &#123; // 也可能为undefined，此时不确定，则不处理</span><br><span class="line">            (alternate.node === null || alternate.node.body.length == 0) ? path.remove() : path.replaceWithMultiple(alternate.node.body);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, SimplifyLoopAndIf);</span><br></pre></td></tr></table></figure>

<h3 id="5-插件-简化逗号表达式"><a href="#5-插件-简化逗号表达式" class="headerlink" title="5. 插件 -&gt; 简化逗号表达式"></a>5. 插件 -&gt; 简化逗号表达式</h3><ul>
<li><strong>第 1 种（常用）：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 去除逗号表达式1</span><br><span class="line">const resolveSequence1 = &#123;</span><br><span class="line">    SequenceExpression(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, parent &#125; = path;</span><br><span class="line">        if (parentPath.parentPath.isLabeledStatement()) return; // 标签节点无法往前插入</span><br><span class="line">        let ancestorPath = parentPath.parentPath;</span><br><span class="line">        let expressions = node.expressions;</span><br><span class="line">        </span><br><span class="line">        // 把 (0, xxx) 的逗号表达式直接替换为本身</span><br><span class="line">        if (parentPath.isCallExpression(&#123; callee: node &#125;) &amp;&amp; expressions.length == 2 &amp;&amp; types.isNumericLiteral(expressions[0], &#123; value: 0 &#125;)) &#123;</span><br><span class="line">            path.replaceWith(expressions[1])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentPath.isReturnStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isThrowStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isIfStatement(&#123; &#x27;test&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isWhileStatement(&#123; &quot;test&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForInStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForOfStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isSwitchStatement(&#123; &quot;discriminant&quot;: node &#125;) ||</span><br><span class="line">            (parentPath.isConditionalExpression(&#123; &quot;test&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isUnaryExpression(&#123; &quot;argument&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isAssignmentExpression(&#123; &quot;right&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            ((parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;) || parentPath.isNewExpression(&#123; &quot;callee&quot;: node &#125;)) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            parentPath.isLogicalExpression(&#123; &#x27;left&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isExpressionStatement(&#123; &quot;expression&quot;: node &#125;)) &#123;</span><br><span class="line"></span><br><span class="line">            let lastExpression = expressions.pop(); // 取出最后一个表达式</span><br><span class="line">            // 将前面的每个表达式都插入到父节点之前，作为单独的 ExpressionStatement</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                parentPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 for 循环的init处的所有逗号表达式都提出来</span><br><span class="line">        else if (parentPath.isForStatement(&#123; &#x27;init&#x27;: node &#125;)) &#123;</span><br><span class="line">            node.expressions.forEach(express =&gt; &#123; parentPath.insertBefore(types.expressionStatement(express)); &#125;);</span><br><span class="line">            path.remove();;</span><br><span class="line">        &#125;</span><br><span class="line">        // 变量定义应该插入到声明之前，不然会有问题</span><br><span class="line">        else if (parentPath.isVariableDeclarator(&#123; &quot;init&quot;: node &#125;) &amp;&amp; ancestorPath.isVariableDeclaration() &amp;&amp; ancestorPath.parentPath.isBlock()) &#123;</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line"></span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ancestorPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 逻辑表达式中的处理，不管父节点符号是&amp;&amp;还是||，左边都可以直接还原，右边则需判断</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;&amp;&amp;&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement(ifBody), null)</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        // js中逻辑或运算符 || 使用了短路求值，如果 || 运算符的左操作数为 true，右操作数将不会被计算或执行</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;||&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement([]), types.blockStatement(ifBody))</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, resolveSequence1);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第 2 种：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 去除逗号表达式2</span><br><span class="line">const resolveSequence2 = &#123;</span><br><span class="line">    SequenceExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let statementPath = path.getStatementParent();</span><br><span class="line">            if (!statementPath) return;</span><br><span class="line"></span><br><span class="line">            let paths = [];</span><br><span class="line">            statementPath.traverse(&#123;</span><br><span class="line">                &quot;LogicalExpression|ConditionalExpression&quot;(_path) &#123;</span><br><span class="line">                    paths.push(_path); // 收集所有不确定会不会执行的表达式</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            let canVisitFlag = true;</span><br><span class="line"></span><br><span class="line">            for (let _path of paths) &#123;</span><br><span class="line">                if (_path.isAncestor(path)) &#123;</span><br><span class="line">                    canVisitFlag = false; // 过滤不能还原的情况</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (canVisitFlag) &#123;</span><br><span class="line">                if (statementPath.isLoop()) return; // 循环表达式内的test节点，不能随意插在该表达式前面</span><br><span class="line"></span><br><span class="line">                let expressions = path.node.expressions;</span><br><span class="line">                let lastNode = expressions.pop();</span><br><span class="line">                for (let expression of expressions) &#123;</span><br><span class="line">                    statementPath.insertBefore(types.ExpressionStatement(expression = expression));</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWith(lastNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, resolveSequence2);</span><br></pre></td></tr></table></figure>

<h3 id="6-插件-对象-val-值全为常量"><a href="#6-插件-对象-val-值全为常量" class="headerlink" title="6. 插件 -&gt; 对象 val 值全为常量"></a>6. 插件 -&gt; 对象 val 值全为常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// object对象的value值全部为字面量时的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObjectofValue = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, scope &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let properties = init.properties;</span><br><span class="line">        if (properties.length == 0 || !properties.every(property =&gt; isBaseLiteral(property.value))) return;</span><br><span class="line"></span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        for (const property of properties) &#123;</span><br><span class="line">            let &#123; key, value &#125; = property;</span><br><span class="line">            let KeyName = types.isIdentifier(key) ? key.name : key.value;</span><br><span class="line"></span><br><span class="line">            newMap.set(KeyName, value);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newMap.size != properties.length) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            let flag = false; // 用于标志当前对象是否可以删除</span><br><span class="line">            for (const referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isMemberExpression()) break;</span><br><span class="line"></span><br><span class="line">                let AncestorPath = parentPath.parentPath;</span><br><span class="line">                if (AncestorPath.isAssignmentExpression(&#123; &quot;left&quot;: parentPath.node &#125;)) &#123;</span><br><span class="line">                    break; // 特殊引用，其实是赋值 obj[&#x27;c&#x27;] = 789;，有赋值肯定直接取消还原</span><br><span class="line">                &#125;</span><br><span class="line">                if (AncestorPath.isUpdateExpression() &amp;&amp; [&#x27;++&#x27;, &#x27;--&#x27;].includes(AncestorPath.node.operator)) &#123;</span><br><span class="line">                    break; // 同理，有自增自减的操作，等同于赋值，也取消还原</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let &#123; property &#125; = parentPath.node;</span><br><span class="line">                let curKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">                if (!newMap.has(curKey)) break;</span><br><span class="line"></span><br><span class="line">                flag = true;</span><br><span class="line">                parentPath.replaceWith(newMap.get(curKey))</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                console.log(&quot;对象 val 值全为常量&quot;, &quot;删除 --&gt; 对象定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObjectofValue);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="7-插件-数组元素全为常量"><a href="#7-插件-数组元素全为常量" class="headerlink" title="7. 插件 -&gt; 数组元素全为常量"></a>7. 插件 -&gt; 数组元素全为常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// Array 数据类型还原，需要元素全部为 Literal</span><br><span class="line">// var a=[1,&#x27;xfblog&#x27;,window];  res=a[2](a[0]+a[1]);     ===&gt;     res = window(1 + &#x27;xfblog&#x27;);</span><br><span class="line">const replaceArrayElements = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, scope &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isArrayExpression(init) || init.elements.length == 0) return;</span><br><span class="line"></span><br><span class="line">        for (let ele of init.elements) &#123;</span><br><span class="line">            if (types.isArrayExpression(ele) || types.isObjectExpression(ele)) &#123;</span><br><span class="line">                return;  // 不处理数组中有嵌套数组或对象的情况</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            let flag = false;</span><br><span class="line">            for (let referPath of referencePaths) &#123;</span><br><span class="line">                let &#123; node, parent, parentPath &#125; = referPath;</span><br><span class="line">                if (!parentPath.isMemberExpression(&#123; object: node &#125;) || !types.isNumericLiteral(parent.property)) break;</span><br><span class="line"></span><br><span class="line">                if (parentPath.parentPath.isAssignmentExpression(&#123; &quot;left&quot;: parent &#125;)) break; // arr[1] = arr[0] + arr[2];</span><br><span class="line">                if (parentPath.parentPath.isUpdateExpression(&#123; &quot;argument&quot;: parent &#125;)) break; // ++arr[1];</span><br><span class="line"></span><br><span class="line">                flag = true;</span><br><span class="line">                let index = parent.property.value;</span><br><span class="line">                parentPath.replaceWith(init.elements[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                console.log(&quot;数组元素全为常量&quot;, &quot;删除 --&gt; 数组定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, replaceArrayElements);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="8-插件-垃圾代码删除"><a href="#8-插件-垃圾代码删除" class="headerlink" title="8. 插件 -&gt; 垃圾代码删除"></a>8. 插件 -&gt; 垃圾代码删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// 最后使用：垃圾代码删除</span><br><span class="line">function containsSequenceExpression(path) &#123;</span><br><span class="line">    let containsSequence = false;</span><br><span class="line">    // 深度优先遍历当前路径及其所有子路径</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        &quot;SequenceExpression|AssignmentExpression&quot;(_path) &#123;</span><br><span class="line">            containsSequence = true;</span><br><span class="line">            _path.stop(); // 找到逗号表达式后立即停止遍历</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    return containsSequence;</span><br><span class="line">&#125;</span><br><span class="line">const removeDeadCode = &#123;</span><br><span class="line">    &quot;IfStatement|ConditionalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; consequent, alternate &#125; = node;</span><br><span class="line">        let testPath = path.get(&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (testPath.isSequenceExpression() || testPath.isAssignmentExpression() || containsSequenceExpression(testPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateTest = testPath.evaluateTruthy();</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            if (types.isBlockStatement(consequent)) &#123;</span><br><span class="line">                consequent = consequent.body;</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceWithMultiple(consequent);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (evaluateTest === false) &#123;</span><br><span class="line">            if (alternate != null) &#123;</span><br><span class="line">                if (types.isBlockStatement(alternate)) &#123;</span><br><span class="line">                    alternate = alternate.body;</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWithMultiple(alternate);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;LogicalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let leftPath = path.get(&#x27;left&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (leftPath.isSequenceExpression() || leftPath.isAssignmentExpression() || containsSequenceExpression(leftPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateLeft = leftPath.evaluateTruthy();</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == true) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == false)) &#123;</span><br><span class="line">            path.replaceWith(left);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == false) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == true)) &#123;</span><br><span class="line">            path.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;EmptyStatement|DebuggerStatement&quot;(path) &#123;</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, parentPath, parent &#125; = path;</span><br><span class="line">        let ancestryPath = parentPath.parentPath;</span><br><span class="line"></span><br><span class="line">        // for循环中的变量定义不能删除</span><br><span class="line">        if (ancestryPath.isForOfStatement(&#123; left: parent &#125;) || ancestryPath.isForInStatement(&#123; left: parent &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        //目前只发现赋值语句和调用语句会有问题。后续待添加</span><br><span class="line">        if (!types.isIdentifier(id) || types.isCallExpression(init) || types.isAssignmentExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name); // 重新解析ast后，一定会有binding</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;AssignmentExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(path + &#x27;&#x27;, referenced, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 赋值语句:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ContinueStatement|BreakStatement|ReturnStatement|ThrowStatement&quot;(path) &#123;</span><br><span class="line">    		if (!path.parentPath.isSwitchCase()) return; // 只处理在 switch-case 语句中的</span><br><span class="line">        let AllNextSiblings = path.getAllNextSiblings(); // 获取所有的后续兄弟节点</span><br><span class="line">        for (let nextSibling of AllNextSiblings) &#123;</span><br><span class="line">            if (nextSibling.isFunctionDeclaration() || nextSibling.isVariableDeclaration(&#123; kind: &quot;var&quot; &#125;)) &#123; //变量提升.....</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params &#125; = node;</span><br><span class="line">        if (!params) return;</span><br><span class="line">        let flag = true;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            for (let i of params) &#123;</span><br><span class="line">                if (!types.isIdentifier(i)) continue;</span><br><span class="line">                let binding = scope.getBinding(i.name);</span><br><span class="line">                if (!binding) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; references, constantViolations &#125; = binding;</span><br><span class="line">                if (references === 0 &amp;&amp; constantViolations.length === 0) &#123;</span><br><span class="line">                    // 将未使用的参数标记为删除</span><br><span class="line">                    console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数形参:&quot;, i.name);</span><br><span class="line">                    params = params.filter(param =&gt; param !== i);</span><br><span class="line">                    console.log(params);</span><br><span class="line">                &#125;</span><br><span class="line">                path.node.params = params;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, removeDeadCode); // 删除不够彻底则再调用一次，以此类推</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、变量相关插件"><a href="#四、变量相关插件" class="headerlink" title="四、变量相关插件"></a>四、变量相关插件</h2><h3 id="1-插件-分离多个变量同定义"><a href="#1-插件-分离多个变量同定义" class="headerlink" title="1. 插件 -&gt; 分离多个变量同定义"></a>1. 插件 -&gt; 分离多个变量同定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 分离多个变量同定义</span><br><span class="line">// var a, b, c;     ===&gt;     var a; var b; var c;</span><br><span class="line">const DeclaratorToDeclaration = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 避免处理那些在非块级节点内的变量声明`if (true) let a, b;`</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length == 1) return;</span><br><span class="line"></span><br><span class="line">        let newNodes = [];</span><br><span class="line">        for (let varNode of declarations) &#123;</span><br><span class="line">            let newDeclarationNode = types.variableDeclaration(kind, [varNode]);</span><br><span class="line">            newNodes.push(newDeclarationNode);</span><br><span class="line">        &#125;</span><br><span class="line">        path.replaceWithMultiple(newNodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, DeclaratorToDeclaration);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="2-插件-合并变量声明与定义"><a href="#2-插件-合并变量声明与定义" class="headerlink" title="2. 插件 -&gt; 合并变量声明与定义"></a>2. 插件 -&gt; 合并变量声明与定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 合并变量声明与定义</span><br><span class="line">// var a, b, c; a = 1; b = 2; c = 3;    ===&gt;    var a = 1, b = 2, c = 3;</span><br><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const combinDefineAndNextAssgin = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (init != null) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line">        if (!constantViolations[0].isAssignmentExpression()) return;</span><br><span class="line">        if (constantViolations[0].parentPath.isConditionalExpression() || constantViolations[0].parentPath.isLogicalExpression()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = constantViolations[0].node</span><br><span class="line">        if (!types.isIdentifier(left, &#123; name: name &#125;) || operator != &#x27;=&#x27; || !isNodeLiteral(right)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.set(&quot;init&quot;, right);</span><br><span class="line">        constantViolations[0].remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="3-插件-变量定义函数转自定"><a href="#3-插件-变量定义函数转自定" class="headerlink" title="3. 插件 -&gt; 变量定义函数转自定"></a>3. 插件 -&gt; 变量定义函数转自定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 由变量定义的函数表达式，统一还原为函数定义</span><br><span class="line">// var a =function()&#123;&#125;     ===&gt;     function a()&#123;&#125;</span><br><span class="line">const varDeclarToFuncDeclar = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, scope &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 过滤掉部分特殊情况，例如for循环里的变量定义</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = declarations[0];</span><br><span class="line">        if (!types.isFunctionExpression(init, &#123; id: null &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; params, body &#125; = init;</span><br><span class="line">        let newNode = types.functionDeclaration(id, params, body);</span><br><span class="line">        path.replaceWith(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, varDeclarToFuncDeclar);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="4-插件-定义字面量未改还原"><a href="#4-插件-定义字面量未改还原" class="headerlink" title="4. 插件 -&gt; 定义字面量未改还原"></a>4. 插件 -&gt; 定义字面量未改还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 变量初始化为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数（只能用这个，因为不能还原容器）</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (parentPath.parentPath.isForStatement() || parentPath.find((p) =&gt; p.isSwitchCase())) return;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="5-插件-赋值字面量未改还原"><a href="#5-插件-赋值字面量未改还原" class="headerlink" title="5. 插件 -&gt; 赋值字面量未改还原"></a>5. 插件 -&gt; 赋值字面量未改还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 在函数中形参变量赋值为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数（只能用这个，因为不能还原容器）</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const restoreAssignment = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return; // 必须只处理单独的语句，不能是嵌套在其他语句里的赋值语句，涉及删除</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !isBaseLiteral(right)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(left.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // 如果绑定不是形参而是变量定义，那么就存在一种情况，改变只有一次，但是赋了两次值，所以要确保变量定义无赋值</span><br><span class="line">        if (constantViolations.length != 1 || !binding.path.isVariableDeclarator(&#123; init: null &#125;)) return;</span><br><span class="line"></span><br><span class="line">        for (let referencePath of referencePaths) &#123;</span><br><span class="line">            referencePath.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;赋值字面量未改还原&quot;, &quot;删除 --&gt; 变量赋值与定义:&quot;, path + &#x27;&#x27;, binding.path + &#x27;&#x27;);</span><br><span class="line">        path.remove(); // 顺便还把形参为常量，但没有使用过的形参赋值也删了</span><br><span class="line">        binding.path.remove(); // 删除函数形参</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, restoreAssignment);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h2 id="五、函数相关插件"><a href="#五、函数相关插件" class="headerlink" title="五、函数相关插件"></a>五、函数相关插件</h2><h3 id="1-插件-内置函数调用还原"><a href="#1-插件-内置函数调用还原" class="headerlink" title="1. 插件 -&gt; 内置函数调用还原"></a>1. 插件 -&gt; 内置函数调用还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 万能调用表达式替换计算值插件</span><br><span class="line">// var a = &quot;motnahp&quot;[&quot;split&quot;](&#x27;&#x27;)[&quot;reverse&quot;]()[&quot;join&quot;](&#x27;&#x27;);    ===&gt;    var a = &quot;phantom&quot;;</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const callToStringLiteral = &#123;</span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; arguments &#125; = path.node;</span><br><span class="line">            if (!isNodeLiteral(arguments)) return;</span><br><span class="line">            try &#123;</span><br><span class="line">                let arr = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">                let flag = arr.every(ele =&gt; !path.toString().includes(ele));</span><br><span class="line">                if (!flag) return;</span><br><span class="line"></span><br><span class="line">                let value = eval(path.toString());</span><br><span class="line">                // if (typeof value != &quot;string&quot;) return; // 有时也需要还原为数字</span><br><span class="line">                console.log(path.toString(), &quot;--&gt;&quot;, value);</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToStringLiteral);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="2-插件-假函数体内容还原"><a href="#2-插件-假函数体内容还原" class="headerlink" title="2. 插件 -&gt; 假函数体内容还原"></a>2. 插件 -&gt; 假函数体内容还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 假函数体内容还原</span><br><span class="line">const untruthFuncContent = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; id, params, body &#125; = path.node;</span><br><span class="line">        if (params.length != 0 || body.body.length != 1 || !types.isExpressionStatement(body.body[0])) return;</span><br><span class="line"></span><br><span class="line">        let binding = path.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1 || !constant || referencePaths.length != 1) return;</span><br><span class="line">        let referPath = referencePaths[0]</span><br><span class="line">        let &#123; node, parentPath &#125; = referPath;</span><br><span class="line">        if (!parentPath.isCallExpression(&#123; callee: node &#125;)) return;</span><br><span class="line">        if (!parentPath.parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;假函数体内容还原:&quot;, path + &#x27;&#x27;);</span><br><span class="line">        parentPath.parentPath.replaceWith(body.body[0]);</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, untruthFuncContent);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="3-插件-ob-典型花指令还原"><a href="#3-插件-ob-典型花指令还原" class="headerlink" title="3. 插件 -&gt; ob 典型花指令还原"></a>3. 插件 -&gt; ob 典型花指令还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">// ob 典型花指令还原</span><br><span class="line">const reStoreUnaryExpressionOfReturn = &#123;</span><br><span class="line">    FunctionDeclaration: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; scope, node &#125; = path;</span><br><span class="line">            let &#123; id, params, body &#125; = node;</span><br><span class="line">            if (params.length != 1 || body.body.length != 1 || !types.isReturnStatement(body.body[0]) ||</span><br><span class="line">                !types.isUnaryExpression(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">            let &#123; operator, argument &#125; = body.body[0].argument;</span><br><span class="line">            if (!types.isIdentifier(argument)) return;</span><br><span class="line"></span><br><span class="line">            let binding = scope.getBinding(id.name);</span><br><span class="line">            if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">            let canRemoved = true;</span><br><span class="line">            for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referPath;</span><br><span class="line"></span><br><span class="line">                if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">                if (arguments.length != 1) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(parentPath.toString());</span><br><span class="line">                parentPath.replaceWith(types.UnaryExpression(operator, arguments[0], prefix = true));</span><br><span class="line">            &#125;</span><br><span class="line">            canRemoved &amp;&amp; path.remove();</span><br><span class="line">            path.stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reStoreBinaryExpressionOfReturn = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1 || !types.isReturnStatement(body.body[0]) ||</span><br><span class="line">            !types.isBinaryExpression(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; operator, left, right &#125; = body.body[0].argument;</span><br><span class="line">        if (!types.isIdentifier(left) || !types.isIdentifier(right)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">        let canRemoved = true;</span><br><span class="line">        for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">            let &#123; parentPath, node &#125; = referPath;</span><br><span class="line"></span><br><span class="line">            if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">            if (arguments.length != 2) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(parentPath.toString());</span><br><span class="line">            // console.log(&#x27;------&#x27;, parentPath.parentPath.parentPath.toString());</span><br><span class="line">            parentPath.replaceWith(types.BinaryExpression(operator, arguments[0], arguments[1]));</span><br><span class="line">        &#125;</span><br><span class="line">        canRemoved &amp;&amp; path.remove();</span><br><span class="line">        path.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reStoreArrayExpressionOfReturn = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 0 || body.body.length != 1 || !types.isReturnStatement(body.body[0]) ||</span><br><span class="line">            !types.isArrayExpression(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">        let canRemoved = true;</span><br><span class="line">        for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">            let &#123; parentPath, node &#125; = referPath;</span><br><span class="line"></span><br><span class="line">            if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">            if (arguments.length != 0) &#123;</span><br><span class="line">                canRemoved = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(parentPath.toString());</span><br><span class="line">            // console.log(&#x27;------&#x27;, parentPath.parentPath.parentPath.toString());</span><br><span class="line">            parentPath.replaceWith(body.body[0].argument);</span><br><span class="line">        &#125;</span><br><span class="line">        canRemoved &amp;&amp; path.remove();</span><br><span class="line">        path.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, reStoreUnaryExpressionOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreBinaryExpressionOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreArrayExpressionOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、条件与逻辑表达式相关插件"><a href="#六、条件与逻辑表达式相关插件" class="headerlink" title="六、条件与逻辑表达式相关插件"></a>六、条件与逻辑表达式相关插件</h2><h3 id="1-嵌套在语句中的优化"><a href="#1-嵌套在语句中的优化" class="headerlink" title="1. 嵌套在语句中的优化"></a>1. 嵌套在语句中的优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 当条件表达式的父节点是赋值语句或者return语句时的优化</span><br><span class="line">// a = b ? c : d;   ===&gt;    b ? a = c : a = d;</span><br><span class="line">let retNODE = template(`if(A)&#123;return B;&#125;else&#123;return C;&#125;`);</span><br><span class="line">const TransConditionExpression = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isConditionalExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; test, consequent, alternate &#125; = right;</span><br><span class="line">        consequent = types.AssignmentExpression(operator, left, consequent);</span><br><span class="line">        alternate = types.AssignmentExpression(operator, left, alternate);</span><br><span class="line"></span><br><span class="line">        path.replaceWith(types.ConditionalExpression(test, consequent, alternate));</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;,</span><br><span class="line">    ReturnStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; argument &#125; = node;</span><br><span class="line">        if (!types.isConditionalExpression(argument)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; test, consequent, alternate &#125; = argument;</span><br><span class="line">        let retNode = retNODE(&#123; &quot;A&quot;: test, &quot;B&quot;: consequent, &quot;C&quot;: alternate &#125;)</span><br><span class="line">        path.replaceWith(retNode);</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, TransConditionExpression);</span><br></pre></td></tr></table></figure>

<h3 id="2-条件表达式转-if-语句"><a href="#2-条件表达式转-if-语句" class="headerlink" title="2. 条件表达式转 if 语句"></a>2. 条件表达式转 if 语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">// 条件表达式转 if 语句，支持嵌套的条件表达式，及子节点包含逗号表达式的情况</span><br><span class="line">const ConditionToIf = &#123;</span><br><span class="line">    ConditionalExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath, parent &#125; = path;</span><br><span class="line">        let &#123; test, consequent, alternate &#125; = node;</span><br><span class="line">        if (parentPath.isObjectProperty()) return;</span><br><span class="line"></span><br><span class="line">        if (parentPath.isAssignmentExpression(&#123; right: node &#125;)) &#123;</span><br><span class="line">            let &#123; left, operator, right &#125; = parent;</span><br><span class="line">            if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isConditionalExpression(right)) return;</span><br><span class="line">            let name = left.name;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(consequent)) &#123;</span><br><span class="line">                let lastExpression = consequent.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                consequent.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                retBody.push(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), lastExpression))</span><br><span class="line">                consequent = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent = types.ExpressionStatement(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), consequent));</span><br><span class="line">                consequent = types.BlockStatement([consequent]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(alternate)) &#123;</span><br><span class="line">                let lastExpression = alternate.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                alternate.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                retBody.push(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), lastExpression))</span><br><span class="line">                alternate = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternate = types.ExpressionStatement(types.assignmentExpression(&#x27;=&#x27;, types.identifier(name), alternate));</span><br><span class="line">                alternate = types.BlockStatement([alternate]);</span><br><span class="line">            &#125;</span><br><span class="line">            let ifStateNode = types.IfStatement(test, consequent, alternate);</span><br><span class="line">            parentPath.parentPath.replaceWith(ifStateNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (parentPath.isVariableDeclarator(&#123; init: node &#125;)) &#123;</span><br><span class="line">            let &#123; id, init &#125; = parent;</span><br><span class="line">            if (!types.isIdentifier(id) || !types.isConditionalExpression(init)) return;</span><br><span class="line">            let name = id.name;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(consequent)) &#123;</span><br><span class="line">                let lastExpression = consequent.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                consequent.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                let newNode = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), lastExpression)])</span><br><span class="line">                retBody.push(newNode)</span><br><span class="line">                consequent = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), consequent)]);</span><br><span class="line">                consequent = types.BlockStatement([consequent]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(alternate)) &#123;</span><br><span class="line">                let lastExpression = alternate.expressions.pop(); // 取出最后一个表达式</span><br><span class="line">                let retBody = [];</span><br><span class="line">                alternate.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)))</span><br><span class="line">                let newNode = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), lastExpression)])</span><br><span class="line">                retBody.push(newNode)</span><br><span class="line">                alternate = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternate = types.variableDeclaration(&#x27;var&#x27;, [types.variableDeclarator(types.identifier(name), alternate)]);</span><br><span class="line">                alternate = types.BlockStatement([alternate]);</span><br><span class="line">            &#125;</span><br><span class="line">            let ifStateNode = types.IfStatement(test, consequent, alternate);</span><br><span class="line">            parentPath.parentPath.replaceWith(ifStateNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (types.isSequenceExpression(consequent)) &#123;</span><br><span class="line">                let retBody = [];</span><br><span class="line">                consequent.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)));</span><br><span class="line">                consequent = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent = types.ExpressionStatement(consequent);</span><br><span class="line">                consequent = types.BlockStatement([consequent]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (types.isSequenceExpression(alternate)) &#123;</span><br><span class="line">                let retBody = [];</span><br><span class="line">                alternate.expressions.forEach(ele =&gt; retBody.push(types.ExpressionStatement(ele)));</span><br><span class="line">                alternate = types.BlockStatement(retBody);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alternate = types.ExpressionStatement(alternate);</span><br><span class="line">                alternate = types.BlockStatement([alternate]);</span><br><span class="line">            &#125;</span><br><span class="line">            let ifStateNode = types.IfStatement(test, consequent, alternate);</span><br><span class="line">            parentPath.replaceWith(ifStateNode);</span><br><span class="line">        &#125;</span><br><span class="line">        path.skip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, ConditionToIf);</span><br></pre></td></tr></table></figure>

<h2 id="七、5s盾解混淆专题"><a href="#七、5s盾解混淆专题" class="headerlink" title="七、5s盾解混淆专题"></a>七、5s盾解混淆专题</h2><blockquote>
<p><strong>注意：新版 5s 盾是新版 ob 混淆特征，存在大数组函数、移位自执行函数（push shift关键字）、解密函数</strong></p>
</blockquote>
<h3 id="1-插件-还原调用表达式"><a href="#1-插件-还原调用表达式" class="headerlink" title="1. 插件 -&gt; 还原调用表达式"></a>1. 插件 -&gt; 还原调用表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// ......代码环境</span><br><span class="line"></span><br><span class="line">// 执行需要的源代码</span><br><span class="line">const evalCode = &#123;</span><br><span class="line">    AssignmentExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; node &#125; = path;</span><br><span class="line">            let &#123; left, right, operator &#125; = node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; left.name.length == 2 &amp;&amp; operator == &#x27;=&#x27; &amp;&amp; types.isObjectExpression(right)) &#123;</span><br><span class="line">                eval(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; left.name.length == 2 &amp;&amp; operator == &#x27;=&#x27; &amp;&amp; types.isIdentifier(right, &#123; name: &#x27;b&#x27; &#125;)) &#123;</span><br><span class="line">                eval(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; left.name.length == 2 &amp;&amp; operator == &#x27;=&#x27; &amp;&amp; types.isIdentifier(right) &amp;&amp; right.name.length == 2) &#123;</span><br><span class="line">                eval(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, evalCode);</span><br><span class="line"></span><br><span class="line">const callToString = &#123;</span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parentPath, node, scope &#125; = path;</span><br><span class="line">            if (types.isIdentifier(node.callee) &amp;&amp; node.callee.name.length == 2 &amp;&amp; node.arguments.length == 1) &#123;</span><br><span class="line">                if (types.isNumericLiteral(node.arguments[0])) &#123;</span><br><span class="line">                    value = i9(node.arguments[0].value);</span><br><span class="line">                    console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                    path.replaceWith(types.valueToNode(value));</span><br><span class="line"></span><br><span class="line">                    // console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, eval(path.toString()));</span><br><span class="line">                    // path.replaceWith(types.StringLiteral(eval(path.toString())))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br></pre></td></tr></table></figure>

<h3 id="2-插件优化-插件1"><a href="#2-插件优化-插件1" class="headerlink" title="2. 插件优化 -&gt; 插件1"></a>2. 插件优化 -&gt; 插件1</h3><blockquote>
<p><strong>一个函数引用，通过多重的变量反复赋值，生成多个同引用不同函数名的调用，让需要被还原的函数超级多</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// ......代码环境</span><br><span class="line"></span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">var funcNameArr = [&#x27;b&#x27;]</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let &#123; name &#125; = left;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !funcNameArr.includes(right.name)) return;</span><br><span class="line">        funcNameArr.push(name)</span><br><span class="line"></span><br><span class="line">        let binding = path.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        const firstConstant = constantViolations[0];</span><br><span class="line">        let flag = constantViolations.every(constantPath =&gt; constantPath.toString() == firstConstant.toString());</span><br><span class="line">        if (!flag) return; // 在for循环中，函数执行两次，那么函数赋值就是两次，而这种情况也要还原，所以判断每次改变是否一样即可</span><br><span class="line"></span><br><span class="line">        let allCallFlag = 0;</span><br><span class="line">        let rebackFlag = 0;</span><br><span class="line">        referencePaths.forEach(element =&gt; &#123;</span><br><span class="line">            if (element.parentPath.isCallExpression()) &#123; ++allCallFlag; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 还原主要逻辑</span><br><span class="line">        for (let referencePath of referencePaths) &#123;</span><br><span class="line">            let &#123; parentPath &#125; = referencePath;</span><br><span class="line">            if (!parentPath.isCallExpression(&#123; callee: referencePath.node &#125;)) continue;</span><br><span class="line"></span><br><span class="line">            let &#123; arguments &#125; = parentPath.node;</span><br><span class="line">            if (!isNodeLiteral(arguments)) continue;</span><br><span class="line"></span><br><span class="line">            let newCallExpression = types.callExpression(types.identifier(&#x27;b&#x27;), arguments);</span><br><span class="line">            let value = eval(generator(newCallExpression).code);</span><br><span class="line">            console.log(parentPath + &#x27;&#x27;, &quot;--&gt;&quot;, value, ++rebackFlag);</span><br><span class="line">            parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">        &#125;</span><br><span class="line">        if (rebackFlag == allCallFlag) &#123; // 如果还原的次数等于引用数组里所有调用表达式的个数，那么说明还原完了</span><br><span class="line">            console.log(&quot;删除无用节点:&quot;, binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            binding.path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br></pre></td></tr></table></figure>

<h3 id="3-插件-object-对象合并"><a href="#3-插件-object-对象合并" class="headerlink" title="3. 插件 -&gt; object 对象合并"></a>3. 插件 -&gt; object 对象合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// object对象合并</span><br><span class="line">const preDecodeObject = &#123;</span><br><span class="line">    // 针对OB混淆，5秒盾中都是赋值的，ob混淆中都是定义的</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, parent, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isObjectExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let properties = right.properties;</span><br><span class="line">        if (right.properties.length != 0) return;</span><br><span class="line"></span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isExpressionStatement()) break;</span><br><span class="line"></span><br><span class="line">            let expression = nextSibling.get(&#x27;expression&#x27;);</span><br><span class="line">            if (!expression.isAssignmentExpression(&#123; operator: &quot;=&quot; &#125;)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; left, right &#125; = expression.node;</span><br><span class="line">            if (!types.isMemberExpression(left)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; object, property &#125; = left;</span><br><span class="line">            if (!types.isIdentifier(object, &#123; name: name &#125;) || !types.isStringLiteral(property)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.push(types.ObjectProperty(property, right));</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, preDecodeObject);</span><br></pre></td></tr></table></figure>

<h3 id="4-插件-深拷贝赋值引用"><a href="#4-插件-深拷贝赋值引用" class="headerlink" title="4. 插件 -&gt; 深拷贝赋值引用"></a>4. 插件 -&gt; 深拷贝赋值引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝赋值引用</span><br><span class="line">const deepCopy = &#123;</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isObjectExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let object = right;</span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isExpressionStatement()) break;</span><br><span class="line"></span><br><span class="line">            let expression = nextSibling.get(&#x27;expression&#x27;);</span><br><span class="line">            if (!expression.isAssignmentExpression(&#123; operator: &quot;=&quot; &#125;)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; left, right &#125; = expression.node;</span><br><span class="line">            if (!types.isIdentifier(left) || !types.isIdentifier(right, &#123; name: name &#125;)) break;</span><br><span class="line">            expression.node.right = object;</span><br><span class="line"></span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (references != 1 || constantViolations.length != 1) return;</span><br><span class="line">            if (constantViolations[0] == path) &#123;</span><br><span class="line">                console.log(&quot;深拷贝后删除无用节点与形参：&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, deepCopy);</span><br></pre></td></tr></table></figure>

<h3 id="5-插件-obj-对象-value-实现"><a href="#5-插件-obj-对象-value-实现" class="headerlink" title="5. 插件 -&gt; obj 对象 value 实现"></a>5. 插件 -&gt; obj 对象 value 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// object类型value字段的字面量和函数的还原</span><br><span class="line">// 保存对象中所有属性的特征到 Map 中</span><br><span class="line">function savePropertiesToObject(properties, newMap) &#123;</span><br><span class="line">    for (const property of properties) &#123;</span><br><span class="line">        if (!property.key) break; // ES6语法没有key</span><br><span class="line"></span><br><span class="line">        let propKey = property.key.value;</span><br><span class="line">        let propValue = property.value;</span><br><span class="line">        if (types.isStringLiteral(propValue)) &#123;</span><br><span class="line">            newMap.set(propKey, propValue.value); // 如果是字符串就直接存入字符串</span><br><span class="line">        &#125;</span><br><span class="line">        else if (types.isFunctionExpression(propValue)) &#123;</span><br><span class="line">            let retState = propValue.body.body; // 直接获取到 return 语句</span><br><span class="line">            if (retState.length == 1 &amp;&amp; types.isReturnStatement(retState[0])) &#123;</span><br><span class="line">                let argument = retState[0].argument;</span><br><span class="line">                if (types.isCallExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, &quot;Call&quot;); // 如果是调用表达式就存入 call 特证</span><br><span class="line">                &#125;</span><br><span class="line">                if (types.isBinaryExpression(argument) || types.isLogicalExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, argument.operator);</span><br><span class="line">                    // 如果是二项式表达式或者逻辑表达式，就存入 operator 操作符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历引用的地方，根据特征还原字符串或函数</span><br><span class="line">function replaceReferNode(newMap, referencePaths, scope) &#123;</span><br><span class="line">    for (const referPath of referencePaths.reverse()) &#123;</span><br><span class="line">        let &#123; node, parent, parentPath &#125; = referPath;</span><br><span class="line">        let ancestorPath = parentPath.parentPath; // 实参要通过祖先节点获取</span><br><span class="line">        if (!parentPath.isMemberExpression(&#123; object: node &#125;)) continue;</span><br><span class="line"></span><br><span class="line">        let property = parent.property;</span><br><span class="line">        let propKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">        let propValue = newMap.get(propKey);</span><br><span class="line">        if (!propValue) continue;</span><br><span class="line"></span><br><span class="line">        if (ancestorPath.isCallExpression(&#123; callee: parent &#125;)) &#123;</span><br><span class="line">            let &#123; arguments &#125; = ancestorPath.node;</span><br><span class="line">            switch (propValue) &#123;</span><br><span class="line">                case &quot;Call&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.CallExpression(arguments[0], arguments.slice(1)));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;||&quot;:</span><br><span class="line">                case &quot;&amp;&amp;&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.LogicalExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    ancestorPath.replaceWith(types.BinaryExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parentPath.replaceWith(types.valueToNode(propValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObject = &#123;</span><br><span class="line">    // AssignmentExpression对应5s盾，VariableDeclarator对应ob混淆</span><br><span class="line">    AssignmentExpression(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27; || !types.isObjectExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; properties &#125; = right;</span><br><span class="line">        if (properties.length == 0) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line"></span><br><span class="line">        // Map 对象用于存储键值对，其中键和值都可以是任意类型；</span><br><span class="line">        // Map 保持键值对的插入顺序，这意味着迭代键值对时的顺序与插入它们时的顺序相同</span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        savePropertiesToObject(properties, newMap);</span><br><span class="line"></span><br><span class="line">        if (newMap.size != properties.length) return; // 判断一个对象中是否处理完所有key</span><br><span class="line">        try &#123;</span><br><span class="line">            replaceReferNode(newMap, referencePaths, scope);</span><br><span class="line">        &#125; catch &#123; &#125;;</span><br><span class="line">        scope.crawl();</span><br><span class="line"></span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;深拷贝后删除无用节点与形参:&quot;, path.toString());</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObject);</span><br></pre></td></tr></table></figure>

<h3 id="6-插件-处理平坦控制流"><a href="#6-插件-处理平坦控制流" class="headerlink" title="6. 插件 -&gt; 处理平坦控制流"></a>6. 插件 -&gt; 处理平坦控制流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 平坦控制流处理，switch-case语句</span><br><span class="line">const decode5sForSwitch = &#123;</span><br><span class="line">    &quot;ForStatement&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, praent, praentPath &#125; = path;</span><br><span class="line">        let &#123; test, body &#125; = node;</span><br><span class="line">        if (!types.isBooleanLiteral(test) || body.body.length != 2) return;</span><br><span class="line"></span><br><span class="line">        let [switchNode, breakNode] = body.body;</span><br><span class="line">        if (!types.isSwitchStatement(switchNode) || !types.isBreakStatement(breakNode)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; discriminant, cases &#125; = switchNode;</span><br><span class="line">        if (!types.isMemberExpression(discriminant)) return;</span><br><span class="line"></span><br><span class="line">        let arrName = switchNode.discriminant.object.name;</span><br><span class="line">        let binding = scope.getBinding(arrName);</span><br><span class="line">        if (!binding || !binding.path) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(&quot;处理平坦控制流:&quot;, arrName, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return; // 改变有多次，就不还原了</span><br><span class="line"></span><br><span class="line">        let &#123; left, right &#125; = constantViolations[0].node;</span><br><span class="line">        if (!types.isIdentifier(left) || !types.isCallExpression(right)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; callee, arguments &#125; = right;</span><br><span class="line">        if (!types.isMemberExpression(callee) || arguments.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; object, property &#125; = callee;</span><br><span class="line">        if (!types.isStringLiteral(object) || !types.isStringLiteral(property, &#123; value: &#x27;split&#x27; &#125;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let disPatchArray = object.value.split(&#x27;|&#x27;);</span><br><span class="line">        let retBody = [];</span><br><span class="line">        disPatchArray.forEach(index =&gt; &#123;</span><br><span class="line">            let caseArr = cases[index].consequent;</span><br><span class="line">            if (types.isContinueStatement(caseArr[caseArr.length - 1])) &#123;</span><br><span class="line">                caseArr.pop() // 如果case中最后一条语句是continue语句，则删除最后一条</span><br><span class="line">            &#125;</span><br><span class="line">            retBody = retBody.concat(caseArr);</span><br><span class="line">        &#125;);</span><br><span class="line">        path.replaceWithMultiple(retBody);</span><br><span class="line">        if (references == 1) &#123;</span><br><span class="line">            constantViolations[0].remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decode5sForSwitch);</span><br><span class="line">ast = parser.parse(generator(ast).code);</span><br></pre></td></tr></table></figure>

<h2 id="八、OB解混淆专题"><a href="#八、OB解混淆专题" class="headerlink" title="八、OB解混淆专题"></a>八、OB解混淆专题</h2><blockquote>
<p><strong>ob混淆的注意事项（<a class="link"   href="https://obfuscator.io/"  target="_blank" rel="noopener">官方网址<i class="fas fa-external-link-alt"></i></a>）：</strong></p>
<ol>
<li><strong>代码格式化检测：</strong>通常在 <strong>大数组</strong>、<strong>移位自执行函数</strong> 或 <strong>解密函数</strong> 中，需要压缩为一行，否则运行会卡死</li>
<li><strong>解混淆数据值是乱码：</strong>通常是缺少了<strong>移位自执行函数</strong>对<strong>大数组</strong>元素进行正确排序，搜大数组名即可找到</li>
<li><strong>平坦控制流处理：</strong>在 ob 混淆的 switch-case 语句中，<strong>定位字符串分隔语句</strong>，可以通过 binding 绑定的 path 定位，因为 ob 的<strong>定义特性</strong>，在一个作用域中第一次出现的位置（定义），即是其绑定的 path</li>
</ol>
</blockquote>
<h3 id="1-插件-还原调用表达式-1"><a href="#1-插件-还原调用表达式-1" class="headerlink" title="1. 插件 -&gt; 还原调用表达式"></a>1. 插件 -&gt; 还原调用表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// 测试代码......</span><br><span class="line"></span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 收集所有需要还原的调用表达式对应的函数定义</span><br><span class="line">let decodeCode = &#x27;&#x27;;</span><br><span class="line">const collectObFuncs = &#123;</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; params, body &#125; = path.node;</span><br><span class="line">        if (params.length != 5 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isReturnStatement(body.body[0])) return;</span><br><span class="line">        decodeCode += path + &#x27;&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isVariableDeclaration()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isFunctionExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; params, body &#125; = init;</span><br><span class="line">        if (params.length != 5 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isReturnStatement(body.body[0])) return;</span><br><span class="line">        decodeCode += path + &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, collectObFuncs);</span><br><span class="line">eval(decodeCode); // 收集的函数为字符串，需要在这个 js 文件执行一次</span><br><span class="line">// 还原调用表达式</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    CallExpression(path) &#123;</span><br><span class="line">        let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">        if (!types.isIdentifier(callee) || arguments.length != 5 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">        value = eval(path + &#x27;&#x27;);</span><br><span class="line">        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">        path.replaceWith(types.valueToNode(value));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">// 删除没有调用的函数</span><br><span class="line">const removeNoCallFuncs = &#123;</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id &#125; = node;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;删除无用函数定义:&quot;, path.toString());</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isVariableDeclaration()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isFunctionExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;删除无用函数定义:&quot;, path.toString());</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ast = parser.parse(generator(ast).code);</span><br><span class="line">traverse(ast, removeNoCallFuncs); // 第一次是删除所有从未被调用的函数，此时刚刚还原的函数引用还存在</span><br><span class="line">ast = parser.parse(generator(ast).code);</span><br><span class="line">traverse(ast, removeNoCallFuncs); // 第二次删除的才是刚刚还原后，且没有地方再引用的函数</span><br></pre></td></tr></table></figure>

<h3 id="2-插件模版-插件1"><a href="#2-插件模版-插件1" class="headerlink" title="2. 插件模版 -&gt; 插件1"></a>2. 插件模版 -&gt; 插件1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 还原调用表达式</span><br><span class="line">const callToStringOb = &#123;</span><br><span class="line">    CallExpression(path) &#123;</span><br><span class="line">    		let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; callee, arguments &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(callee) || arguments.length != 2 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">        value = eval(path + &#x27;&#x27;);</span><br><span class="line">        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">        path.replaceWith(types.valueToNode(value));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToStringOb);</span><br></pre></td></tr></table></figure>

<h3 id="3-插件-object-对象合并-1"><a href="#3-插件-object-对象合并-1" class="headerlink" title="3. 插件 -&gt; object 对象合并"></a>3. 插件 -&gt; object 对象合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// object对象合并</span><br><span class="line">const preDecodeObject = &#123;</span><br><span class="line">    // 针对OB混淆，ob混淆中都是定义的，5秒盾中都是赋值的</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, parentPath, scope &#125;=path;</span><br><span class="line">        const &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let properties = init.properties;</span><br><span class="line">        if (properties.length != 0) return;</span><br><span class="line">        </span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isExpressionStatement()) continue;</span><br><span class="line"></span><br><span class="line">            let expression = nextSibling.get(&#x27;expression&#x27;);</span><br><span class="line">            if (!expression.isAssignmentExpression(&#123; operator: &quot;=&quot; &#125;)) break;</span><br><span class="line"></span><br><span class="line">            let &#123; left, right &#125; = expression.node;</span><br><span class="line">            if (!types.isMemberExpression(left)) break;</span><br><span class="line">            </span><br><span class="line">            let &#123; object, property &#125; = left;</span><br><span class="line">            if (!types.isIdentifier(object, &#123; name: name &#125;) || !types.isStringLiteral(property)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.push(types.ObjectProperty(property, right));</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, preDecodeObject);</span><br></pre></td></tr></table></figure>

<h3 id="4-插件-深拷贝赋值引用-1"><a href="#4-插件-深拷贝赋值引用-1" class="headerlink" title="4. 插件 -&gt; 深拷贝赋值引用"></a>4. 插件 -&gt; 深拷贝赋值引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝赋值引用</span><br><span class="line">const deepCopy = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let object = init;</span><br><span class="line">        let allNextSiblings = parentPath.getAllNextSiblings();</span><br><span class="line">        for (let nextSibling of allNextSiblings) &#123;</span><br><span class="line">            if (!nextSibling.isVariableDeclaration()) continue;</span><br><span class="line"></span><br><span class="line">            let declarations = nextSibling.get(&#x27;declarations&#x27;)[0];</span><br><span class="line">            if (!declarations.isVariableDeclarator()) break;</span><br><span class="line"></span><br><span class="line">            let &#123; id, init &#125; = declarations.node;</span><br><span class="line">            if (!types.isIdentifier(id) || !types.isIdentifier(init, &#123; name: name &#125;)) break;</span><br><span class="line">            declarations.node.init = object;</span><br><span class="line"></span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (references != 1 || !constant) return;</span><br><span class="line">            console.log(&quot;深拷贝赋值引用&quot;, &quot;删除 --&gt; 原对象:&quot;, id.name);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, deepCopy);</span><br></pre></td></tr></table></figure>

<h3 id="5-插件-obj-对象-value-实现-1"><a href="#5-插件-obj-对象-value-实现-1" class="headerlink" title="5. 插件 -&gt; obj 对象 value 实现"></a>5. 插件 -&gt; obj 对象 value 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// object类型value字段的字面量和函数的还原</span><br><span class="line">// 保存对象中所有属性的特征到 Map 中</span><br><span class="line">function savePropertiesToObject(properties, newMap) &#123;</span><br><span class="line">    for (const property of properties) &#123;</span><br><span class="line">        if (!property.key) break; // ES6语法没有key</span><br><span class="line"></span><br><span class="line">        let propKey = property.key.value;</span><br><span class="line">        let propValue = property.value;</span><br><span class="line">        if (types.isStringLiteral(propValue)) &#123;</span><br><span class="line">            newMap.set(propKey, propValue.value); // 如果是字符串就直接存入字符串</span><br><span class="line">        &#125;</span><br><span class="line">        else if (types.isFunctionExpression(propValue)) &#123;</span><br><span class="line">            let retState = propValue.body.body; // 直接获取到 return 语句</span><br><span class="line">            if (retState.length == 1 &amp;&amp; types.isReturnStatement(retState[0])) &#123;</span><br><span class="line">                let argument = retState[0].argument;</span><br><span class="line">                if (types.isCallExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, &quot;Call&quot;); // 如果是调用表达式就存入 call 特证</span><br><span class="line">                &#125;</span><br><span class="line">                if (types.isBinaryExpression(argument) || types.isLogicalExpression(argument)) &#123;</span><br><span class="line">                    newMap.set(propKey, argument.operator);</span><br><span class="line">                    // 如果是二项式表达式或者逻辑表达式，就存入 operator 操作符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历引用的地方，根据特征还原字符串或函数</span><br><span class="line">function replaceReferNode(newMap, referencePaths, scope) &#123;</span><br><span class="line">    for (const referPath of referencePaths.reverse()) &#123;</span><br><span class="line">        let &#123; node, parent, parentPath &#125; = referPath;</span><br><span class="line">        let ancestorPath = parentPath.parentPath; // 实参要通过祖先节点获取</span><br><span class="line">        if (!parentPath.isMemberExpression(&#123; object: node &#125;)) continue;</span><br><span class="line"></span><br><span class="line">        let property = parent.property;</span><br><span class="line">        let propKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">        let propValue = newMap.get(propKey);</span><br><span class="line">        if (!propValue) continue;</span><br><span class="line"></span><br><span class="line">        if (ancestorPath.isCallExpression(&#123; callee: parent &#125;)) &#123;</span><br><span class="line">            let &#123; arguments &#125; = ancestorPath.node;</span><br><span class="line">            switch (propValue) &#123;</span><br><span class="line">                case &quot;Call&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.CallExpression(arguments[0], arguments.slice(1)));</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;||&quot;:</span><br><span class="line">                case &quot;&amp;&amp;&quot;:</span><br><span class="line">                    ancestorPath.replaceWith(types.LogicalExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    ancestorPath.replaceWith(types.BinaryExpression(propValue, arguments[0], arguments[1]));</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parentPath.replaceWith(types.valueToNode(propValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObject = &#123;</span><br><span class="line">    // VariableDeclarator对应ob混淆，AssignmentExpression对应5s盾</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isVariableDeclaration()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || !types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; properties &#125; = init;</span><br><span class="line">        if (properties.length == 0) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (!constant) return;</span><br><span class="line"></span><br><span class="line">        // Map 对象用于存储键值对，其中键和值都可以是任意类型；</span><br><span class="line">        // Map 保持键值对的插入顺序，这意味着迭代键值对时的顺序与插入它们时的顺序相同</span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        savePropertiesToObject(properties, newMap);</span><br><span class="line"></span><br><span class="line">        if (newMap.size != properties.length) return; // 判断一个对象中是否处理完所有key</span><br><span class="line">        try &#123;</span><br><span class="line">            replaceReferNode(newMap, referencePaths, scope);</span><br><span class="line">            console.log(&quot;obj对象value实现&quot;, &quot;删除 --&gt; 已还原对象:&quot;, id.name);</span><br><span class="line">            path.remove(); // 上面遍历了所有引用，并且还原，那么就没有引用的地方了，直接删除即可</span><br><span class="line">        &#125; catch &#123; &#125;;</span><br><span class="line"></span><br><span class="line">        newMap.clear();</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObject);</span><br></pre></td></tr></table></figure>

<h3 id="6-插件-处理平坦控制流-1"><a href="#6-插件-处理平坦控制流-1" class="headerlink" title="6. 插件 -&gt; 处理平坦控制流"></a>6. 插件 -&gt; 处理平坦控制流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 平坦控制流处理，switch-case语句</span><br><span class="line">const decodeObWhileSwitch = &#123;</span><br><span class="line">    &quot;WhileStatement&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, praent, praentPath &#125; = path;</span><br><span class="line">        let &#123; test, body &#125; = node;</span><br><span class="line">        if (!types.isBooleanLiteral(test) || body.body.length != 2) return;</span><br><span class="line"></span><br><span class="line">        let [switchNode, breakNode] = body.body;</span><br><span class="line">        if (!types.isSwitchStatement(switchNode) || !types.isBreakStatement(breakNode)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; discriminant, cases &#125; = switchNode;</span><br><span class="line">        if (!types.isMemberExpression(discriminant)) return;</span><br><span class="line"></span><br><span class="line">        let arrName = switchNode.discriminant.object.name;</span><br><span class="line">        let binding = scope.getBinding(arrName);</span><br><span class="line">        if (!binding || !binding.path || !binding.path.isVariableDeclarator()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(&quot;处理平坦控制流:&quot;, arrName, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = binding.path.node; // 绑定的 path 就是在这个作用域中第一次出现（定义）的位置</span><br><span class="line">        if (!types.isIdentifier(id, &#123; name: arrName &#125;) || !types.isCallExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; callee, arguments &#125; = init;</span><br><span class="line">        if (!types.isMemberExpression(callee) || arguments.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; object, property &#125; = callee;</span><br><span class="line">        if (!types.isStringLiteral(object) || !types.isStringLiteral(property, &#123; value: &#x27;split&#x27; &#125;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let disPatchArray = object.value.split(&#x27;|&#x27;);</span><br><span class="line">        let retBody = [];</span><br><span class="line">        disPatchArray.forEach(index =&gt; &#123;</span><br><span class="line">            let caseArr = cases[index].consequent;</span><br><span class="line">            if (types.isContinueStatement(caseArr[caseArr.length - 1])) &#123;</span><br><span class="line">                caseArr.pop() // 如果case中最后一条语句是continue语句，则删除最后一条</span><br><span class="line">            &#125;</span><br><span class="line">            retBody = retBody.concat(caseArr);</span><br><span class="line">        &#125;);</span><br><span class="line">        path.replaceWithMultiple(retBody);</span><br><span class="line">        if (references == 1 &amp;&amp; (constant || constantViolations[0] == binding.path)) &#123;</span><br><span class="line">            // 在 for 循环中的变量定义，其绑定中会被记录为改变了一次</span><br><span class="line">            binding.path.remove()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObWhileSwitch);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h2 id="九、重点AST还原专题"><a href="#九、重点AST还原专题" class="headerlink" title="九、重点AST还原专题"></a>九、重点AST还原专题</h2><h3 id="0-模版-常用-banding-写法"><a href="#0-模版-常用-banding-写法" class="headerlink" title="0. 模版 -&gt; 常用 banding 写法"></a>0. 模版 -&gt; 常用 banding 写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let binding = scope.getBinding(name);</span><br><span class="line">if (!binding) return;</span><br><span class="line">let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">// console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">if (constantViolations.length &gt; 1) return;</span><br><span class="line">if (constant || constantViolations[0] == binding.path) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-案例-复杂控制流还原"><a href="#1-案例-复杂控制流还原" class="headerlink" title="1. 案例 -&gt; 复杂控制流还原"></a>1. 案例 -&gt; 复杂控制流还原</h3><blockquote>
<p><strong>encode.js 特征：</strong></p>
<ol>
<li>每一个 case 语句最后一段代码，都是 break 语句</li>
<li>没有 default 语句</li>
<li>每一个 case 语句的倒数第二段代码，是指向下一个 case 语句的 test、条件表达式、或者是 return 语句</li>
</ol>
<p><strong>还原思路：</strong></p>
<ol>
<li>给 return 语句的后面加上 break 语句，方便统一处理</li>
<li>先处理单线控制，即指向当前 case 的语句个数只有一个，则将当前语句与上一个 case 语句单线合并</li>
<li>再处理条件表达式，还原为 while 循环并删除 case 语句</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">function test(cU, cV) &#123;</span><br><span class="line">    var guagua = &quot;呱呱&quot;;</span><br><span class="line">    var cW = 1;</span><br><span class="line"></span><br><span class="line">    while (cW !== 0) &#123;</span><br><span class="line">        switch (cW) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                var cZ = [];</span><br><span class="line">                cW = 5;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 2:</span><br><span class="line">                cW = d0 &lt; cU ? 7 : 3;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 3:</span><br><span class="line">                cW = d1 &lt; cU ? 8 : 4;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 4:</span><br><span class="line">                return cZ;</span><br><span class="line"></span><br><span class="line">            case 5:</span><br><span class="line">                var d0 = 0;</span><br><span class="line">                cW = 6;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 6:</span><br><span class="line">                var d1 = 0;</span><br><span class="line">                cW = 2;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 7:</span><br><span class="line">                cZ[(d0 + cV) % cU] = [];</span><br><span class="line">                cW = 9;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 8:</span><br><span class="line">                var d2 = cU - 1;</span><br><span class="line">                cW = 10;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 9:</span><br><span class="line">                d0++;</span><br><span class="line">                cW = 2;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 10:</span><br><span class="line">                cW = d2 &gt;= 0 ? 12 : 11;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 11:</span><br><span class="line">                d1++;</span><br><span class="line">                cW = 3;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 12:</span><br><span class="line">                cZ[d1][(d2 + cV * d1) % cU] = cZ[d2];</span><br><span class="line">                cW = 13;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 13:</span><br><span class="line">                d2--;</span><br><span class="line">                cW = 10;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>手动还原：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function test(cU, cV) &#123;</span><br><span class="line">	var guagua = &quot;呱呱&quot;;</span><br><span class="line">	var cW = 1;</span><br><span class="line">	</span><br><span class="line">	var cZ = [];</span><br><span class="line">	var d0 = 0;</span><br><span class="line">	var d1 = 0;</span><br><span class="line">	while (d0 &lt; cU) &#123;</span><br><span class="line">		cZ[(d0 + cV) % cU] = [];</span><br><span class="line">		d0++;</span><br><span class="line">	&#125;</span><br><span class="line">	while (d1 &lt; cU) &#123;</span><br><span class="line">		var d2 = cU - 1;</span><br><span class="line">		while (d2 &gt;= 0) &#123;</span><br><span class="line">			cZ[d1][(d2 + cV * d1) % cU] = cZ[d2];</span><br><span class="line">			d2--;</span><br><span class="line">		&#125;</span><br><span class="line">		d1++;</span><br><span class="line">	&#125;</span><br><span class="line">	return cZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>AST 还原：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// 给case语句结尾统一加上 break 语句，有则不加</span><br><span class="line">const addBreakStatement = &#123;</span><br><span class="line">    SwitchCase(&#123; node &#125;) &#123;</span><br><span class="line">        let &#123; test, consequent &#125; = node;</span><br><span class="line">        if (types.isBreakStatement(consequent[consequent.length - 1])) return;</span><br><span class="line">        consequent.push(types.breakStatement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, addBreakStatement)</span><br><span class="line">// 函数：根据case的test条件，获取对应case的node节点，还可以判断是否删除节点</span><br><span class="line">function getItemFromTestValue(path, testValue, is_remove) &#123;</span><br><span class="line">    let &#123; cases &#125; = path.node;</span><br><span class="line">    for (let caseIndex in cases) &#123;</span><br><span class="line">        let caseItem = cases[caseIndex];</span><br><span class="line">        if (caseItem.test.value == testValue) &#123;</span><br><span class="line">            if (is_remove) &#123;</span><br><span class="line">                return cases.splice(caseIndex, 1)[0]; // 从当前索引开始删除一个元素，并返回被删除的元素数组</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return caseItem</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const dealWithSwitch = &#123;</span><br><span class="line">    SwitchStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; cases &#125; = node;</span><br><span class="line">        // 不管switch从哪里开始，先单线合并，再处理条件表达式并用while循环替换</span><br><span class="line">        for (let i = 0; i &lt; cases.length; i++) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = cases[i];</span><br><span class="line">            let jumpTo = consequent[consequent.length - 2].expression; // 控制case跳转的赋值语句</span><br><span class="line">            if (!types.isAssignmentExpression(jumpTo)) continue;</span><br><span class="line"></span><br><span class="line">            // 1. 当跳转语句的右节点是字面量时</span><br><span class="line">            if (types.isLiteral(jumpTo.right)) &#123;</span><br><span class="line">                // 数组的长度含义：代表指向下一个case块的赋值语句的数量，即被指向的csae块有几次引用</span><br><span class="line">                let newArr = cases.filter(element =&gt; &#123;</span><br><span class="line">                    let jumpto = element.consequent[element.consequent.length - 2].expression</span><br><span class="line">                    return generator(jumpto).code == generator(jumpTo).code;</span><br><span class="line">                &#125;);</span><br><span class="line">                // 如果只有一次，则可以合并</span><br><span class="line">                if (newArr.length == 1) &#123;</span><br><span class="line">                    let nextItem = getItemFromTestValue(path, jumpTo.right.value, true);</span><br><span class="line">                    let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                    consequent.splice(consequent.length - 2, 2, ...nextItemConsequent)</span><br><span class="line">                    i = -1; // 每合并一次又从头遍历，因为被合并过的语句块可能还需要再次合并</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 当跳转语句的右节点是条件表达式时</span><br><span class="line">            if (types.isConditionalExpression(jumpTo.right)) &#123;</span><br><span class="line">                let nextTest = jumpTo.right.test</span><br><span class="line">                let nextConsequent = jumpTo.right.consequent</span><br><span class="line">                let nextAlternate = jumpTo.right.alternate</span><br><span class="line"></span><br><span class="line">                let nextItem = getItemFromTestValue(path, nextConsequent.value, false);</span><br><span class="line">                let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                let nextJumpTo = nextItemConsequent[nextItemConsequent.length - 2].expression</span><br><span class="line">                if (!types.isAssignmentExpression(nextJumpTo) || !types.isLiteral(nextJumpTo.right)) continue;</span><br><span class="line"></span><br><span class="line">                if (nextJumpTo.right.value == test.value) &#123;</span><br><span class="line">                    let bodyNode = nextItemConsequent.slice(0, nextItemConsequent.length - 2);</span><br><span class="line">                    let whileNode = types.whileStatement(nextTest, types.blockStatement(bodyNode));</span><br><span class="line">                    consequent.splice(consequent.length - 2, 0, whileNode); // 删除0，则表示插入while语句</span><br><span class="line"></span><br><span class="line">                    getItemFromTestValue(path, nextConsequent.value, true);</span><br><span class="line">                    jumpTo.right = nextAlternate;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 还原到最后，只剩一层case语句，则可以将整段代码从switch中脱离出来</span><br><span class="line">        if (cases.length == 1) &#123;</span><br><span class="line">            let caseNode = cases[0].consequent;</span><br><span class="line">            if (types.isBreakStatement(caseNode[caseNode.length - 1])) &#123;</span><br><span class="line">                caseNode.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            parentPath.parentPath.replaceWithMultiple(caseNode);</span><br><span class="line">        &#125;</span><br><span class="line">        scope.crawl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, dealWithSwitch);</span><br></pre></td></tr></table></figure>

<h3 id="2-案例优化-复杂控制流还原"><a href="#2-案例优化-复杂控制流还原" class="headerlink" title="2. 案例优化 -&gt; 复杂控制流还原"></a>2. 案例优化 -&gt; 复杂控制流还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">// 函数：根据case的test条件，获取对应case的node节点，还可以判断是否删除节点</span><br><span class="line">function getItemFromTestValue(path, testValue, is_remove) &#123;</span><br><span class="line">    let &#123; cases &#125; = path.node;</span><br><span class="line">    for (let caseIndex in cases) &#123;</span><br><span class="line">        let caseItem = cases[caseIndex];</span><br><span class="line">        if (caseItem.test.value == testValue) &#123;</span><br><span class="line">            if (is_remove) &#123;</span><br><span class="line">                return cases.splice(caseIndex, 1)[0]; // 从当前索引开始删除一个元素，并返回被删除的元素数组</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return caseItem</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const dealWithSwitch = &#123;</span><br><span class="line">    SwitchStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; discriminant, cases &#125; = node;</span><br><span class="line">        let name = discriminant.name;</span><br><span class="line"></span><br><span class="line">        /* 获取 switch-case 的初始case条件，通常在外层 for 循环的init中定义</span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (!binding.path.isVariableDeclarator() &amp;&amp; !binding.path.isAssignmentExpression()) return;</span><br><span class="line">            if (binding.path.isVariableDeclarator() &amp;&amp; (startValue = binding.path.node.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">            if (binding.path.isAssignmentExpression() &amp;&amp; (startValue = binding.path.node.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        */</span><br><span class="line">        if (!parentPath.parentPath.isForStatement()) return;</span><br><span class="line">        let &#123; init &#125; = parentPath.parentPath.node;</span><br><span class="line">        init = types.isVariableDeclaration(init) ? init.declarations[init.declarations.length - 1] : init;</span><br><span class="line">        if (!types.isVariableDeclarator(init) &amp;&amp; !types.isAssignmentExpression(init)) return;</span><br><span class="line">        if (types.isVariableDeclarator(init) &amp;&amp; (startValue = init.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        if (types.isAssignmentExpression(init) &amp;&amp; (startValue = init.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line"></span><br><span class="line">        // 不管switch从哪里开始，先单线合并，再处理条件表达式并用while循环替换</span><br><span class="line">        for (let i = 0; i &lt; cases.length; i++) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = cases[i];</span><br><span class="line">            let jumpTo = consequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">            jumpTo = jumpTo[jumpTo.length - 1] ? jumpTo[jumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">            if (!types.isAssignmentExpression(jumpTo) || !types.isIdentifier(jumpTo.left, &#123; name: name &#125;)) continue;</span><br><span class="line"></span><br><span class="line">            // console.log(path + &#x27;&#x27;); // 打印出整个处理过程，用于调试</span><br><span class="line"></span><br><span class="line">            // 1. 当跳转语句的右节点是字面量时</span><br><span class="line">            if (types.isLiteral(jumpTo.right)) &#123;</span><br><span class="line">                // 数组的长度含义：代表指向下一个case块的赋值语句的数量，即被指向的csae块有几次引用</span><br><span class="line">                let newArr = cases.filter(ele =&gt; &#123;</span><br><span class="line">                    let jumpto = ele.consequent.filter(element =&gt; generator(element).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                    jumpto = jumpto[jumpto.length - 1] ? jumpto[jumpto.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                    return generator(jumpto).code == generator(jumpTo).code;</span><br><span class="line">                &#125;);</span><br><span class="line">                // 如果只有一次，则可以合并</span><br><span class="line">                if (newArr.length == 1) &#123;</span><br><span class="line">                    let nextItem = getItemFromTestValue(path, jumpTo.right.value, true);</span><br><span class="line">                    let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                    // --------******** 特别注意：每个case替换的行数由实际情况而定 ********--------</span><br><span class="line">                    // 经过测试：下一个case中只有一条语句 break; 时运行正常，但是如果是控制case跳转的赋值语句，就会还原错误</span><br><span class="line">                    consequent.splice(consequent.length - 2, 2, ...nextItemConsequent);</span><br><span class="line"></span><br><span class="line">                    i = -1; // 每合并一次又从头遍历，因为被合并过的语句块可能还需要再次合并</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 当跳转语句的右节点是条件表达式时</span><br><span class="line">            if (types.isConditionalExpression(jumpTo.right)) &#123;</span><br><span class="line">                let newTest = jumpTo.right.test</span><br><span class="line">                let newConsequent = jumpTo.right.consequent</span><br><span class="line">                let newAlternate = jumpTo.right.alternate</span><br><span class="line"></span><br><span class="line">                let nextItem = getItemFromTestValue(path, newConsequent.value, false);</span><br><span class="line">                let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                let nextJumpTo = nextItemConsequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                nextJumpTo = nextJumpTo[nextJumpTo.length - 1] ? nextJumpTo[nextJumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                if (!types.isAssignmentExpression(nextJumpTo) || !types.isLiteral(nextJumpTo.right)) continue;</span><br><span class="line"></span><br><span class="line">                if (nextJumpTo.right.value == test.value) &#123;</span><br><span class="line">                    let bodyNode = nextItemConsequent.slice(0, nextItemConsequent.length - 2); // 截取有效内容</span><br><span class="line">                    let whileNode = types.whileStatement(newTest, types.blockStatement(bodyNode));</span><br><span class="line">                    consequent.splice(consequent.length - 2, 0, whileNode); // 删除0，则表示插入while语句</span><br><span class="line"></span><br><span class="line">                    getItemFromTestValue(path, newConsequent.value, true);</span><br><span class="line">                    jumpTo.right = newAlternate;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 还原到最后，将有效代码从switch中脱离出来</span><br><span class="line">        for (let item of cases) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = item;</span><br><span class="line">            if (test.value == startValue.value) &#123;</span><br><span class="line">                let lastSta = consequent[consequent.length - 1];</span><br><span class="line">                if (types.isBreakStatement(lastSta) || types.isContinueStatement(lastSta)) &#123;</span><br><span class="line">                    consequent.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                parentPath.parentPath.replaceWithMultiple(consequent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, dealWithSwitch);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="3-模版-预处理解混淆模版"><a href="#3-模版-预处理解混淆模版" class="headerlink" title="3. 模版 -&gt; 预处理解混淆模版"></a>3. 模版 -&gt; 预处理解混淆模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">// 1. 编码还原十进制</span><br><span class="line">const simplifyLiteral = &#123;</span><br><span class="line">    NumericLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /^0[obx]/i.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    StringLiteral(&#123; node &#125;) &#123;</span><br><span class="line">        if (node.extra &amp;&amp; /\\[ux]/gi.test(node.extra.raw)) &#123;</span><br><span class="line">            node.extra = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, simplifyLiteral);</span><br><span class="line"></span><br><span class="line">// 2. 分离多个变量同定义</span><br><span class="line">// var a, b, c;     ===&gt;     var a; var b; var c;</span><br><span class="line">const DeclaratorToDeclaration = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 避免处理那些在非块级节点内的变量声明`if (true) let a, b;`</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length == 1) return;</span><br><span class="line"></span><br><span class="line">        let newNodes = [];</span><br><span class="line">        for (let varNode of declarations) &#123;</span><br><span class="line">            let newDeclarationNode = types.variableDeclaration(kind, [varNode]);</span><br><span class="line">            newNodes.push(newDeclarationNode);</span><br><span class="line">        &#125;</span><br><span class="line">        path.replaceWithMultiple(newNodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, DeclaratorToDeclaration);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 3. 由变量定义的函数表达式，统一还原为函数定义</span><br><span class="line">// var a =function()&#123;&#125;     ===&gt;     function a()&#123;&#125;</span><br><span class="line">const varDeclarToFuncDeclar = &#123;</span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, scope &#125; = path;</span><br><span class="line">        if (!parentPath.isBlock()) return; // 过滤掉部分特殊情况，例如for循环里的变量定义</span><br><span class="line"></span><br><span class="line">        let &#123; declarations, kind &#125; = node;</span><br><span class="line">        if (declarations.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = declarations[0];</span><br><span class="line">        if (!types.isFunctionExpression(init, &#123; id: null &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; params, body &#125; = init;</span><br><span class="line">        let newNode = types.functionDeclaration(id, params, body);</span><br><span class="line">        path.replaceWith(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, varDeclarToFuncDeclar);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 4. 美化循环语句和 if-else 语句，并简化逻辑</span><br><span class="line">const SimplifyLoopAndIf = &#123;</span><br><span class="line">    &quot;ForStatement|WhileStatement|ForInStatement|ForOfStatement&quot;(&#123; node &#125;) &#123;</span><br><span class="line">        if (!types.isBlockStatement(node.body)) &#123;</span><br><span class="line">            node.body = types.blockStatement([node.body]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IfStatement&quot;(path) &#123;</span><br><span class="line">        const test = path.get(&quot;test&quot;);</span><br><span class="line">        const consequent = path.get(&quot;consequent&quot;);</span><br><span class="line">        const alternate = path.get(&quot;alternate&quot;);</span><br><span class="line">        const evaluateTest = test.evaluateTruthy();</span><br><span class="line"></span><br><span class="line">        if (!consequent.isBlockStatement() &amp;&amp; !consequent.isEmptyStatement()) &#123;</span><br><span class="line">            consequent.replaceWith(types.blockStatement([consequent.node]));</span><br><span class="line">        &#125;</span><br><span class="line">        if (alternate.node !== null &amp;&amp; !alternate.isBlockStatement() &amp;&amp; !alternate.isEmptyStatement()) &#123;</span><br><span class="line">            alternate.replaceWith(types.blockStatement([alternate.node]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (consequent.isEmptyStatement() || consequent.node.body.length == 0) &#123;</span><br><span class="line">            if (alternate.node == null || alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                path.replaceWith(test.node);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consequent.replaceWith(alternate.node);</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">                test.replaceWith(types.unaryExpression(&quot;!&quot;, test.node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (alternate.node != null) &#123;</span><br><span class="line">            if (alternate.isEmptyStatement() || alternate.node.body.length == 0) &#123;</span><br><span class="line">                alternate.remove();</span><br><span class="line">                path.node.alternate = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            path.replaceWithMultiple(consequent.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (evaluateTest === false) &#123;</span><br><span class="line">            (alternate.node === null || alternate.node.body.length == 0) ? path.remove() : path.replaceWithMultiple(alternate.node.body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, SimplifyLoopAndIf);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 5. 去除逗号表达式1</span><br><span class="line">const resolveSequence1 = &#123;</span><br><span class="line">    SequenceExpression(path) &#123;</span><br><span class="line">        let &#123; parentPath, node, parent &#125; = path;</span><br><span class="line">        if (parentPath.parentPath.isLabeledStatement()) return; // 标签节点无法往前插入</span><br><span class="line">        let ancestorPath = parentPath.parentPath;</span><br><span class="line">        let expressions = node.expressions;</span><br><span class="line"></span><br><span class="line">        // 把 (0, xxx) 的逗号表达式直接替换为本身</span><br><span class="line">        if (parentPath.isCallExpression(&#123; callee: node &#125;) &amp;&amp; expressions.length == 2 &amp;&amp; types.isNumericLiteral(expressions[0], &#123; value: 0 &#125;)) &#123;</span><br><span class="line">            path.replaceWith(expressions[1])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentPath.isReturnStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isThrowStatement(&#123; &quot;argument&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isIfStatement(&#123; &#x27;test&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isWhileStatement(&#123; &quot;test&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForInStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isForOfStatement(&#123; &quot;right&quot;: node &#125;) ||</span><br><span class="line">            parentPath.isSwitchStatement(&#123; &quot;discriminant&quot;: node &#125;) ||</span><br><span class="line">            (parentPath.isConditionalExpression(&#123; &quot;test&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isUnaryExpression(&#123; &quot;argument&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            (parentPath.isAssignmentExpression(&#123; &quot;right&quot;: node &#125;) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            ((parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;) || parentPath.isNewExpression(&#123; &quot;callee&quot;: node &#125;)) &amp;&amp; ancestorPath.isExpressionStatement(&#123; &quot;expression&quot;: parent &#125;)) ||</span><br><span class="line">            parentPath.isLogicalExpression(&#123; &#x27;left&#x27;: node &#125;) ||</span><br><span class="line">            parentPath.isExpressionStatement(&#123; &quot;expression&quot;: node &#125;)) &#123;</span><br><span class="line"></span><br><span class="line">            let lastExpression = expressions.pop(); // 取出最后一个表达式</span><br><span class="line">            // 将前面的每个表达式都插入到父节点之前，作为单独的 ExpressionStatement</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                parentPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 for 循环的init处的所有逗号表达式都提出来</span><br><span class="line">        else if (parentPath.isForStatement(&#123; &#x27;init&#x27;: node &#125;)) &#123;</span><br><span class="line">            node.expressions.forEach(express =&gt; &#123; parentPath.insertBefore(types.expressionStatement(express)); &#125;);</span><br><span class="line">            path.remove();;</span><br><span class="line">        &#125;</span><br><span class="line">        // 变量定义应该插入到声明之前，不然会有问题</span><br><span class="line">        else if (parentPath.isVariableDeclarator(&#123; &quot;init&quot;: node &#125;) &amp;&amp; ancestorPath.isVariableDeclaration() &amp;&amp; ancestorPath.parentPath.isBlock()) &#123;</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line"></span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ancestorPath.insertBefore(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceInline(lastExpression); // 用最后一个表达式替换当前的 SequenceExpression</span><br><span class="line">        &#125;</span><br><span class="line">        // 逻辑表达式中的处理，不管父节点符号是&amp;&amp;还是||，左边都可以直接还原，右边则需判断</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;&amp;&amp;&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement(ifBody), null)</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        // js中逻辑或运算符 || 使用了短路求值，如果 || 运算符的左操作数为 true，右操作数将不会被计算或执行</span><br><span class="line">        else if (parentPath.isLogicalExpression(&#123; &#x27;right&#x27;: node &#125;) &amp;&amp; parent.operator == &#x27;||&#x27;) &#123;</span><br><span class="line">            let ifBody = [];</span><br><span class="line">            let lastExpression = expressions.pop();</span><br><span class="line">            for (let expression of expressions) &#123;</span><br><span class="line">                ifBody.push(types.expressionStatement(expression = expression));</span><br><span class="line">            &#125;</span><br><span class="line">            let ifNode = types.ifStatement(parent.left, types.blockStatement([]), types.blockStatement(ifBody))</span><br><span class="line"></span><br><span class="line">            path.replaceInline(lastExpression);</span><br><span class="line">            parentPath.insertBefore(ifNode);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, resolveSequence1);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 6. 字面量化成员表达式 `b.length` ==&gt; `b[&#x27;length&#x27;]`</span><br><span class="line">const keyToLiteral = &#123;</span><br><span class="line">    MemberExpression: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const prop = node.property;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(prop)) &#123;</span><br><span class="line">                node.property = types.stringLiteral(prop.name)</span><br><span class="line">                node.computed = true; // 只有当使用中括号调用才为true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 对象的 key 也由标识符转为字面量</span><br><span class="line">    ObjectProperty: &#123;</span><br><span class="line">        exit(&#123; node &#125;) &#123;</span><br><span class="line">            const key = node.key;</span><br><span class="line">            if (!node.computed &amp;&amp; types.isIdentifier(key)) &#123;</span><br><span class="line">                node.key = types.stringLiteral(key.name);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.computed &amp;&amp; types.isStringLiteral(key)) &#123;</span><br><span class="line">                node.computed = false; // 不是通过计算得来的，computed为false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, keyToLiteral);</span><br><span class="line"></span><br><span class="line">// 7. object对象的value值全部为字面量时的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const decodeObjectofValue = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; node, scope &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isObjectExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let properties = init.properties;</span><br><span class="line">        if (properties.length == 0 || !properties.every(property =&gt; isBaseLiteral(property.value))) return;</span><br><span class="line"></span><br><span class="line">        let newMap = new Map();</span><br><span class="line">        for (const property of properties) &#123;</span><br><span class="line">            let &#123; key, value &#125; = property;</span><br><span class="line">            let KeyName = types.isIdentifier(key) ? key.name : key.value;</span><br><span class="line"></span><br><span class="line">            newMap.set(KeyName, value);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newMap.size != properties.length) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            let flag = false; // 用于标志当前对象是否可以删除</span><br><span class="line">            for (const referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isMemberExpression()) break;</span><br><span class="line"></span><br><span class="line">                let AncestorPath = parentPath.parentPath;</span><br><span class="line">                if (AncestorPath.isAssignmentExpression(&#123; &quot;left&quot;: parentPath.node &#125;)) &#123;</span><br><span class="line">                    break; // 特殊引用，其实是赋值 obj[&#x27;c&#x27;] = 789;，有赋值肯定直接取消还原</span><br><span class="line">                &#125;</span><br><span class="line">                if (AncestorPath.isUpdateExpression() &amp;&amp; [&#x27;++&#x27;, &#x27;--&#x27;].includes(AncestorPath.node.operator)) &#123;</span><br><span class="line">                    break; // 同理，有自增自减的操作，等同于赋值，也取消还原</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let &#123; property &#125; = parentPath.node;</span><br><span class="line">                let curKey = types.isIdentifier(property) ? property.name : property.value;</span><br><span class="line">                if (!newMap.has(curKey)) break;</span><br><span class="line"></span><br><span class="line">                flag = true;</span><br><span class="line">                parentPath.replaceWith(newMap.get(curKey))</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                console.log(&quot;对象 val 值全为常量&quot;, &quot;删除 --&gt; 对象定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, decodeObjectofValue);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 8. 合并变量声明与定义</span><br><span class="line">// var a, b, c; a = 1; b = 2; c = 3;    ===&gt;    var a = 1, b = 2, c = 3;</span><br><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const combinDefineAndNextAssgin = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (init != null) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line">        if (!constantViolations[0].isAssignmentExpression()) return;</span><br><span class="line">        if (constantViolations[0].parentPath.isConditionalExpression() || constantViolations[0].parentPath.isLogicalExpression()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = constantViolations[0].node</span><br><span class="line">        if (!types.isIdentifier(left, &#123; name: name &#125;) || operator != &#x27;=&#x27; || !isNodeLiteral(right)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.set(&quot;init&quot;, right);</span><br><span class="line">        constantViolations[0].remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 9. 变量初始化为字面量，且没有修改的还原</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (parentPath.parentPath.isForStatement() || parentPath.find((p) =&gt; p.isSwitchCase())) return;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 10. 通用还原纯函数调用表达式</span><br><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line"></span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br><span class="line">// 节点子面量判断</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    const literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(node)) return node.every(isNodeLiteral);</span><br><span class="line">    if (types.isThisExpression(node)) return true;</span><br><span class="line">    if (types.isLiteral(node)) return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node)) &#123;</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27; || node.operator === &#x27;!&#x27;)) &#123;</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node)) &#123;</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node)) &#123;</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (types.isIdentifier(node)) &#123;</span><br><span class="line">        if (literalList.includes(node.name) || typeof globalThis[node.name] !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 主要还原逻辑</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    &quot;CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">            let &#123; name &#125; = callee;</span><br><span class="line">            if (!types.isIdentifier(callee) || arguments.length == 0 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">            let binding = path.scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line"></span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            // 1. 当 binding.path 为函数时，只能还原纯函数</span><br><span class="line">            try &#123;</span><br><span class="line">                if (binding.path.isFunctionDeclaration()) &#123;</span><br><span class="line">                    // console.log(binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                    // ******** 为解决下面在 binding.path 为赋值语句时的还原中，不还原其本身的调用表达式的问题 ******** </span><br><span class="line">                    if (decryptCode.includes(binding.path.toString().match(/function\s+\w+\s*\([^)]*\)/g)[0])) &#123;</span><br><span class="line"></span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!isPureFunction(binding.path)) return; // 判断函数是否是纯函数，不是则不处理</span><br><span class="line"></span><br><span class="line">                    let &#123; id, params, body &#125; = binding.path.node;</span><br><span class="line">                    if (params.length == 0 || body.body.length == 0) return;</span><br><span class="line">                    // ******** 专用插件配置限制：函数名、函数调用的实参个数、函数定义的函数体大小 ********</span><br><span class="line">                    if (id.name == &#x27;ln&#x27; || body.body.length &gt; 10) return;</span><br><span class="line">                    if (!types.isReturnStatement(body.body[body.body.length - 1])) return;</span><br><span class="line"></span><br><span class="line">                    eval(binding.path.toString());</span><br><span class="line"></span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || constantViolations[0] == binding.path) &#123; // 如果为常量，或更改的那一次为定义的那一次</span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">            // 2. 当 binding.path 为赋值语句或变量定义时，需要在 decode 中准备唯一被还原函数</span><br><span class="line">            try &#123;</span><br><span class="line">                var funcNameArr = [&#x27;n&#x27;] // 唯一被还原函数的函数名</span><br><span class="line">                if (binding.path.isVariableDeclarator()) &#123;</span><br><span class="line">                    // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || (constantViolations.length == 1 &amp;&amp; constantViolations[0].isAssignmentExpression())) &#123; // 变量定义只有一次改变，或没改变</span><br><span class="line">                        // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                        let &#123; id, init &#125; = binding.path.node;</span><br><span class="line">                        let &#123; name &#125; = id;</span><br><span class="line">                        if (init == null) &#123;</span><br><span class="line">                            init = types.identifier(constantViolations[0].node.right.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!types.isIdentifier(id) || !funcNameArr.includes(init.name)) return;</span><br><span class="line">                        funcNameArr.push(name);</span><br><span class="line"></span><br><span class="line">                        let newCallExpression = types.callExpression(types.identifier(&#x27;n&#x27;), arguments);</span><br><span class="line">                        let value = eval(generator(newCallExpression).code);</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">// console.log(decryptCode);</span><br><span class="line"></span><br><span class="line">// 11. 折叠计算部分字面量或表达式</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(value));</span><br><span class="line">                &#125; catch &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        path.replaceWith(types.stringLiteral(value));</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        console.log(&quot;无法还原原因:&quot;, e.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理条件表达式（三目表达式）</span><br><span class="line">            if (path.isConditionalExpression()) &#123;</span><br><span class="line">                let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">                if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理字符串相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-框架-通用纯函数还原"><a href="#4-框架-通用纯函数还原" class="headerlink" title="4. 框架 -&gt; 通用纯函数还原"></a>4. 框架 -&gt; 通用纯函数还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">// 框架 -&gt; 通用还原纯函数调用表达式</span><br><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line"></span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 主要还原逻辑</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    &quot;CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">            let &#123; name &#125; = callee;</span><br><span class="line">            if (!types.isIdentifier(callee) || arguments.length == 0 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">            let binding = path.scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line"></span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            // 1. 当 binding.path 为函数时，只能还原纯函数</span><br><span class="line">            try &#123;</span><br><span class="line">                if (binding.path.isFunctionDeclaration()) &#123;</span><br><span class="line">                    // console.log(binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                    // ******** 为解决下面在 binding.path 为赋值语句时的还原中，不还原其本身的调用表达式的问题 ******** </span><br><span class="line">                    if (decryptCode.includes(binding.path.toString().match(/function\s+\w+\s*\([^)]*\)/g)[0])) &#123;</span><br><span class="line"></span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!isPureFunction(binding.path)) return; // 判断函数是否是纯函数，不是则不处理</span><br><span class="line"></span><br><span class="line">                    let &#123; id, params, body &#125; = binding.path.node;</span><br><span class="line">                    if (params.length == 0 || body.body.length == 0) return;</span><br><span class="line">                    // ******** 专用插件配置限制：函数名、函数调用的实参个数、函数定义的函数体大小 ********</span><br><span class="line">                    if (id.name == &#x27;ln&#x27; || body.body.length &gt; 10) return;</span><br><span class="line">                    if (!types.isReturnStatement(body.body[body.body.length - 1])) return;</span><br><span class="line"></span><br><span class="line">                    eval(binding.path.toString());</span><br><span class="line"></span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || constantViolations[0] == binding.path) &#123; // 如果为常量，或更改的那一次为定义的那一次</span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">            // 2. 当 binding.path 为赋值语句或变量定义时，需要在 decode 中准备唯一被还原函数</span><br><span class="line">            try &#123;</span><br><span class="line">                var funcNameArr = [&#x27;n&#x27;] // 唯一被还原函数的函数名</span><br><span class="line">                if (binding.path.isVariableDeclarator()) &#123;</span><br><span class="line">                    // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || (constantViolations.length == 1 &amp;&amp; constantViolations[0].isAssignmentExpression())) &#123; // 变量定义只有一次改变，或没改变</span><br><span class="line">                        // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                        let &#123; id, init &#125; = binding.path.node;</span><br><span class="line">                        let &#123; name &#125; = id;</span><br><span class="line">                        if (init == null) &#123;</span><br><span class="line">                            init = types.identifier(constantViolations[0].node.right.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!types.isIdentifier(id) || !funcNameArr.includes(init.name)) return;</span><br><span class="line">                        funcNameArr.push(name);</span><br><span class="line"></span><br><span class="line">                        let newCallExpression = types.callExpression(types.identifier(&#x27;n&#x27;), arguments);</span><br><span class="line">                        let value = eval(generator(newCallExpression).code);</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">// console.log(decryptCode);</span><br></pre></td></tr></table></figure>

<h3 id="5-模版-专用函数还原模版"><a href="#5-模版-专用函数还原模版" class="headerlink" title="5. 模版 -&gt; 专用函数还原模版"></a>5. 模版 -&gt; 专用函数还原模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// 专用调用表达式还原插件模版</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const tsCallToString = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        var name = id.name;</span><br><span class="line">        // ******** 配置专用函数需要过滤的节点 ********</span><br><span class="line">        if (name != &#x27;ln&#x27;) return;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1) return;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        collectFuncCode.push(binding.path.toString());</span><br><span class="line"></span><br><span class="line">        // 收集所有需要的环境函数到 collectFuncCode 数组中，最终执行</span><br><span class="line"></span><br><span class="line">        eval(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line">        // console.log(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == binding.path) &#123;</span><br><span class="line">            let flag = true;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;;</span><br><span class="line">                // 不处理环境函数中的调用表达式，会有问题</span><br><span class="line">                if (parentPath.parentPath.isCallExpression() &amp;&amp; parentPath.parentPath.node.callee.name == &#x27;parseInt&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                // 不一定能删，根据具体情况而定</span><br><span class="line">                // path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="6-案例-datadome还原"><a href="#6-案例-datadome还原" class="headerlink" title="6. 案例 -&gt; datadome还原"></a>6. 案例 -&gt; datadome还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;ok_encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">// 专用调用表达式还原插件模版</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const tsCallToString = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; node, parentPath &#125; = path;</span><br><span class="line">        let name = node.id.name;</span><br><span class="line">        if (name != &#x27;ln&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        let preNodePath = path.getPrevSibling();</span><br><span class="line">        eval(preNodePath.toString() + path.toString());</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == binding.path) &#123;</span><br><span class="line">            let flag = true;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">                preNodePath.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString);</span><br><span class="line"></span><br><span class="line">// 变量初始化为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 折叠计算部分字面量或表达式</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理条件表达式（三目表达式）</span><br><span class="line">            if (path.isConditionalExpression()) &#123;</span><br><span class="line">                let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">                if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理字符串相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">const callToStringLiteral = &#123;</span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; arguments &#125; = path.node;</span><br><span class="line">            if (!isNodeLiteral(arguments)) return;</span><br><span class="line">            try &#123;</span><br><span class="line">                let arr = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">                let flag = arr.every(ele =&gt; !path.toString().includes(ele));</span><br><span class="line">                if (!flag) return;</span><br><span class="line"></span><br><span class="line">                let value = eval(path.toString());</span><br><span class="line">                // if (typeof value != &quot;string&quot;) return; // 有时也需要还原为数字</span><br><span class="line">                console.log(path.toString(), &quot;--&gt;&quot;, value);</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToStringLiteral);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 最后使用：垃圾代码删除</span><br><span class="line">function containsSequenceExpression(path) &#123;</span><br><span class="line">    let containsSequence = false;</span><br><span class="line">    // 深度优先遍历当前路径及其所有子路径</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        &quot;SequenceExpression|AssignmentExpression&quot;(_path) &#123;</span><br><span class="line">            containsSequence = true;</span><br><span class="line">            _path.stop(); // 找到逗号表达式后立即停止遍历</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    return containsSequence;</span><br><span class="line">&#125;</span><br><span class="line">const removeDeadCode = &#123;</span><br><span class="line">    &quot;IfStatement|ConditionalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; consequent, alternate &#125; = node;</span><br><span class="line">        let testPath = path.get(&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (testPath.isSequenceExpression() || testPath.isAssignmentExpression() || containsSequenceExpression(testPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateTest = testPath.evaluateTruthy();</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            if (types.isBlockStatement(consequent)) &#123;</span><br><span class="line">                consequent = consequent.body;</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceWithMultiple(consequent);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (evaluateTest === false) &#123;</span><br><span class="line">            if (alternate != null) &#123;</span><br><span class="line">                if (types.isBlockStatement(alternate)) &#123;</span><br><span class="line">                    alternate = alternate.body;</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWithMultiple(alternate);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;LogicalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let leftPath = path.get(&#x27;left&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (leftPath.isSequenceExpression() || leftPath.isAssignmentExpression() || containsSequenceExpression(leftPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateLeft = leftPath.evaluateTruthy();</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == true) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == false)) &#123;</span><br><span class="line">            path.replaceWith(left);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == false) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == true)) &#123;</span><br><span class="line">            path.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;EmptyStatement|DebuggerStatement&quot;(path) &#123;</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, parentPath, parent &#125; = path;</span><br><span class="line">        let ancestryPath = parentPath.parentPath;</span><br><span class="line"></span><br><span class="line">        // for循环中的变量定义不能删除</span><br><span class="line">        if (ancestryPath.isForOfStatement(&#123; left: parent &#125;) || ancestryPath.isForInStatement(&#123; left: parent &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        //目前只发现赋值语句和调用语句会有问题。后续待添加</span><br><span class="line">        if (!types.isIdentifier(id) || types.isCallExpression(init) || types.isAssignmentExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name); // 重新解析ast后，一定会有binding</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;AssignmentExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(path + &#x27;&#x27;, referenced, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 赋值语句:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ContinueStatement|BreakStatement|ReturnStatement|ThrowStatement&quot;(path) &#123;</span><br><span class="line">        if (!path.parentPath.isSwitchCase()) return; // 只处理在 switch-case 语句中的</span><br><span class="line">        let AllNextSiblings = path.getAllNextSiblings(); // 获取所有的后续兄弟节点</span><br><span class="line">        for (let nextSibling of AllNextSiblings) &#123;</span><br><span class="line">            if (nextSibling.isFunctionDeclaration() || nextSibling.isVariableDeclaration(&#123; kind: &quot;var&quot; &#125;)) &#123; //变量提升.....</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params &#125; = node;</span><br><span class="line">        if (!params) return;</span><br><span class="line">        let flag = true;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(id.name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            for (let i of params) &#123;</span><br><span class="line">                if (!types.isIdentifier(i)) continue;</span><br><span class="line">                let binding = scope.getBinding(i.name);</span><br><span class="line">                if (!binding) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; references, constantViolations &#125; = binding;</span><br><span class="line">                if (references === 0 &amp;&amp; constantViolations.length === 0) &#123;</span><br><span class="line">                    // 将未使用的参数标记为删除</span><br><span class="line">                    console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数形参:&quot;, i.name);</span><br><span class="line">                    params = params.filter(param =&gt; param !== i);</span><br><span class="line">                    console.log(params);</span><br><span class="line">                &#125;</span><br><span class="line">                path.node.params = params;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    traverse(ast, removeDeadCode); // 删除不够彻底则再调用一次，以此类推</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数：根据case的test条件，获取对应case的node节点，还可以判断是否删除节点</span><br><span class="line">function getItemFromTestValue(path, testValue, is_remove) &#123;</span><br><span class="line">    let &#123; cases &#125; = path.node;</span><br><span class="line">    for (let caseIndex in cases) &#123;</span><br><span class="line">        let caseItem = cases[caseIndex];</span><br><span class="line">        if (caseItem.test.value == testValue) &#123;</span><br><span class="line">            if (is_remove) &#123;</span><br><span class="line">                return cases.splice(caseIndex, 1)[0]; // 从当前索引开始删除一个元素，并返回被删除的元素数组</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return caseItem</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const dealWithSwitch = &#123;</span><br><span class="line">    SwitchStatement(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; discriminant, cases &#125; = node;</span><br><span class="line">        let name = discriminant.name;</span><br><span class="line"></span><br><span class="line">        /* 获取 switch-case 的初始case条件，通常在外层 for 循环的init中定义</span><br><span class="line">            let binding = scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            if (!binding.path.isVariableDeclarator() &amp;&amp; !binding.path.isAssignmentExpression()) return;</span><br><span class="line">            if (binding.path.isVariableDeclarator() &amp;&amp; (startValue = binding.path.node.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">            if (binding.path.isAssignmentExpression() &amp;&amp; (startValue = binding.path.node.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        */</span><br><span class="line">        if (!parentPath.parentPath.isForStatement()) return;</span><br><span class="line">        let &#123; init &#125; = parentPath.parentPath.node;</span><br><span class="line">        init = types.isVariableDeclaration(init) ? init.declarations[init.declarations.length - 1] : init;</span><br><span class="line">        if (!types.isVariableDeclarator(init) &amp;&amp; !types.isAssignmentExpression(init)) return;</span><br><span class="line">        if (types.isVariableDeclarator(init) &amp;&amp; (startValue = init.init) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line">        if (types.isAssignmentExpression(init) &amp;&amp; (startValue = init.right) &amp;&amp; !types.isLiteral(startValue)) return;</span><br><span class="line"></span><br><span class="line">        // 不管switch从哪里开始，先单线合并，再处理条件表达式并用while循环替换</span><br><span class="line">        for (let i = 0; i &lt; cases.length; i++) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = cases[i];</span><br><span class="line">            let jumpTo = consequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">            jumpTo = jumpTo[jumpTo.length - 1] ? jumpTo[jumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">            if (!types.isAssignmentExpression(jumpTo) || !types.isIdentifier(jumpTo.left, &#123; name: name &#125;)) continue;</span><br><span class="line"></span><br><span class="line">            // console.log(path + &#x27;&#x27;); // 打印出整个处理过程，用于调试</span><br><span class="line"></span><br><span class="line">            // 1. 当跳转语句的右节点是字面量时</span><br><span class="line">            if (types.isLiteral(jumpTo.right)) &#123;</span><br><span class="line">                // 数组的长度含义：代表指向下一个case块的赋值语句的数量，即被指向的csae块有几次引用</span><br><span class="line">                let newArr = cases.filter(ele =&gt; &#123;</span><br><span class="line">                    let jumpto = ele.consequent.filter(element =&gt; generator(element).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                    jumpto = jumpto[jumpto.length - 1] ? jumpto[jumpto.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                    return generator(jumpto).code == generator(jumpTo).code;</span><br><span class="line">                &#125;);</span><br><span class="line">                // 如果只有一次，则可以合并</span><br><span class="line">                if (newArr.length == 1) &#123;</span><br><span class="line">                    let nextItem = getItemFromTestValue(path, jumpTo.right.value, true);</span><br><span class="line">                    let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                    // --------******** 特别注意：每个case替换的行数由实际情况而定 ********--------</span><br><span class="line">                    // 经过测试：下一个case中只有一条语句 break; 时运行正常，但是如果是控制case跳转的赋值语句，就会还原错误</span><br><span class="line">                    consequent.splice(consequent.length - 2, 2, ...nextItemConsequent);</span><br><span class="line"></span><br><span class="line">                    i = -1; // 每合并一次又从头遍历，因为被合并过的语句块可能还需要再次合并</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 当跳转语句的右节点是条件表达式时</span><br><span class="line">            if (types.isConditionalExpression(jumpTo.right)) &#123;</span><br><span class="line">                let newTest = jumpTo.right.test</span><br><span class="line">                let newConsequent = jumpTo.right.consequent</span><br><span class="line">                let newAlternate = jumpTo.right.alternate</span><br><span class="line"></span><br><span class="line">                let nextItem = getItemFromTestValue(path, newConsequent.value, false);</span><br><span class="line">                let nextItemConsequent = nextItem.consequent;</span><br><span class="line">                let nextJumpTo = nextItemConsequent.filter(ele =&gt; generator(ele).code.includes(name + &#x27; =&#x27;));</span><br><span class="line">                nextJumpTo = nextJumpTo[nextJumpTo.length - 1] ? nextJumpTo[nextJumpTo.length - 1].expression : null; // 控制case跳转的赋值语句</span><br><span class="line">                if (!types.isAssignmentExpression(nextJumpTo) || !types.isLiteral(nextJumpTo.right)) continue;</span><br><span class="line"></span><br><span class="line">                if (nextJumpTo.right.value == test.value) &#123;</span><br><span class="line">                    let bodyNode = nextItemConsequent.slice(0, nextItemConsequent.length - 2); // 截取有效内容</span><br><span class="line">                    let whileNode = types.whileStatement(newTest, types.blockStatement(bodyNode));</span><br><span class="line">                    consequent.splice(consequent.length - 2, 0, whileNode); // 删除0，则表示插入while语句</span><br><span class="line"></span><br><span class="line">                    getItemFromTestValue(path, newConsequent.value, true);</span><br><span class="line">                    jumpTo.right = newAlternate;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 还原到最后，将有效代码从switch中脱离出来</span><br><span class="line">        for (let item of cases) &#123;</span><br><span class="line">            let &#123; test, consequent &#125; = item;</span><br><span class="line">            if (test.value == startValue.value) &#123;</span><br><span class="line">                let lastSta = consequent[consequent.length - 1];</span><br><span class="line">                if (types.isBreakStatement(lastSta) || types.isContinueStatement(lastSta)) &#123;</span><br><span class="line">                    consequent.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                parentPath.parentPath.replaceWithMultiple(consequent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, dealWithSwitch);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="7-案例-px3-还原"><a href="#7-案例-px3-还原" class="headerlink" title="7. 案例 -&gt; px3 还原"></a>7. 案例 -&gt; px3 还原</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode_ok.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;ok_encode_ok.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">const decryptFile = _path.resolve(__dirname, &#x27;decode.js&#x27;);</span><br><span class="line">let decryptCode = files.readFileSync(decryptFile, &#123; encoding: &quot;utf-8&quot; &#125;); // 读取解密代码</span><br><span class="line">let evalAst = parser.parse(decryptCode);</span><br><span class="line">decryptCode = generator(evalAst, opts = &#123; compact: true &#125;).code // 利用ast压缩代码</span><br><span class="line">eval(decryptCode);</span><br><span class="line"></span><br><span class="line">// 合并变量声明与定义</span><br><span class="line">// var a, b, c; a = 1; b = 2; c = 3;    ===&gt;    var a = 1, b = 2, c = 3;</span><br><span class="line">const combinDefineAndNextAssgin = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (init != null) return;</span><br><span class="line"></span><br><span class="line">        let name = id.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (constantViolations.length != 1) return;</span><br><span class="line">        if (!constantViolations[0].isAssignmentExpression()) return;</span><br><span class="line">        if (constantViolations[0].parentPath.isConditionalExpression() || constantViolations[0].parentPath.isLogicalExpression()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = constantViolations[0].node</span><br><span class="line">        if (!types.isIdentifier(left, &#123; name: name &#125;) || operator != &#x27;=&#x27; || !isBaseLiteral(right)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.set(&quot;init&quot;, right);</span><br><span class="line">        constantViolations[0].remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 变量初始化为字面量，且没有修改的还原</span><br><span class="line">// 节点字面量基础判断函数</span><br><span class="line">function isBaseLiteral(node) &#123;</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;];</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node) &amp;&amp; node.value != null) return true; // null可能有坑</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; literalList.includes(node.name)) return true;</span><br><span class="line">    if (types.isIdentifier(node) &amp;&amp; typeof globalThis[node.name] != &quot;undefined&quot;) return true;</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;!&quot;].includes(node.operator)) &#123;</span><br><span class="line">        if (types.isArrayExpression(node.argument) &amp;&amp; node.argument.elements.length == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return isBaseLiteral(node.argument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const rebackVarDeclarator = &#123;</span><br><span class="line">    VariableDeclarator(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        if (parentPath.parentPath.isForStatement()) return;</span><br><span class="line">        if (!types.isIdentifier(id) || init == null || !isBaseLiteral(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return; // 概率踩坑报错</span><br><span class="line">        let &#123; constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123; // 变量定义在 for 循环中是一次改变</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                referencePath.replaceWith(init);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;定义字面量未改还原&quot;, &quot;删除 --&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove(); // 顺便还把初始化为常量，但没有使用过的变量定义也删了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, rebackVarDeclarator);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 折叠计算部分字面量或表达式</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const calcPartBinaryExpression = &#123;</span><br><span class="line">    &quot;BinaryExpression|UnaryExpression|ConditionalExpression|MemberExpression|CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; parent, scope, parentPath, node &#125; = path;</span><br><span class="line">            let &#123; left, operator, right &#125; = node;</span><br><span class="line"></span><br><span class="line">            if ((isNodeLiteral(left) &amp;&amp; isNodeLiteral(right)) ||    // 处理数字字面量，简单字符串字面量</span><br><span class="line">                path.isUnaryExpression() ||                         // 处理jsfuck代码的`!![]` </span><br><span class="line">                path.isMemberExpression() ||                        // 处理成员表达式</span><br><span class="line">                path.isCallExpression()) &#123;                          // 处理调用表达式</span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();       // 这个计算是包含了二元表达式的</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理条件表达式（三目表达式）</span><br><span class="line">            if (path.isConditionalExpression()) &#123;</span><br><span class="line">                let &#123; test, consequent, alternate &#125; = path.node;</span><br><span class="line">                if (consequent.value != null &amp;&amp; alternate.value != null &amp;&amp; consequent.value == alternate.value) &#123;</span><br><span class="line">                    path.replaceWith(types.valueToNode(consequent.value));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const &#123; confident, value &#125; = path.evaluate();</span><br><span class="line">                if (!confident || value == &quot;Infinity&quot;) return;</span><br><span class="line">                if (path.isUnaryExpression(&#123; operator: &#x27;-&#x27; &#125;) || path.isUnaryExpression(&#123; operator: &#x27;void&#x27; &#125;)) return;</span><br><span class="line">                path.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理字符串相加</span><br><span class="line">            if (parentPath.isBinaryExpression(&#123; left: node &#125;)) &#123;</span><br><span class="line">                if (!types.isLiteral(left) &amp;&amp; operator == &quot;+&quot; &amp;&amp; types.isLiteral(right)) &#123;</span><br><span class="line">                    if (parent.operator == &quot;+&quot; &amp;&amp; types.isLiteral(parent.right)) &#123;</span><br><span class="line">                        path.node.right.value += parent.right.value;</span><br><span class="line">                        parentPath.replaceWith(path.node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, calcPartBinaryExpression);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 专用调用表达式还原插件模版</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">const tsCallToString = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isCallExpression(node.body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        var name = id.name;</span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        collectFuncCode.push(path.toString());</span><br><span class="line">        // console.log(binding.path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        function xxx(path) &#123;</span><br><span class="line">            let tempName = path.node.body.body[0].argument.callee.name;</span><br><span class="line">            let tempBinding = path.scope.getBinding(tempName);</span><br><span class="line">            if (!tempBinding) return;</span><br><span class="line">            // 处理收集的函数中存在同名的问题</span><br><span class="line">            if (name == tempName) &#123;</span><br><span class="line">                tempBinding.scope.rename(tempName, path.scope.generateUidIdentifier(tempName).name);</span><br><span class="line">                collectFuncCode.pop();</span><br><span class="line">                collectFuncCode.push(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            collectFuncCode.push(tempBinding.path.toString());</span><br><span class="line">            // console.log(&quot;-----------------&quot;, tempBinding.path + &#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">            if (tempBinding.path.node.body.body.length == 1) &#123;</span><br><span class="line">                let recursiveBinding = xxx(tempBinding.path);</span><br><span class="line">                if (recursiveBinding) return recursiveBinding;</span><br><span class="line">            &#125;</span><br><span class="line">            return tempBinding;</span><br><span class="line">        &#125;</span><br><span class="line">        callFuncBinding = xxx(path);</span><br><span class="line">        if (!callFuncBinding) return;</span><br><span class="line"></span><br><span class="line">        let bigArrFuncName = callFuncBinding.path.node.body.body[0].declarations[0].init.callee.name;</span><br><span class="line">        let bigArrFuncBinding = callFuncBinding.scope.getBinding(bigArrFuncName);</span><br><span class="line">        if (!bigArrFuncBinding) return;</span><br><span class="line">        collectFuncCode.push(bigArrFuncBinding.path.toString());</span><br><span class="line"></span><br><span class="line">        // 处理有些大数组存在的移位自执行函数</span><br><span class="line">        let referencePaths_3 = bigArrFuncBinding.referencePaths;</span><br><span class="line">        for (let reference of referencePaths_3) &#123;</span><br><span class="line">            if (!reference.parentPath.isCallExpression()) continue;</span><br><span class="line"></span><br><span class="line">            let &#123; callee, arguments &#125; = reference.parentPath.node;</span><br><span class="line">            if (!types.isFunctionExpression(callee) || arguments.length != 1 || arguments[0].name != bigArrFuncName) continue;</span><br><span class="line">            collectFuncCode.push(reference.parentPath.parentPath.toString());</span><br><span class="line">            // console.log(reference.parentPath.parentPath + &#x27;&#x27;, reference.parentPath.type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eval(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line">        // console.log(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == binding.path) &#123;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 不处理环境函数中的调用表达式，会有问题</span><br><span class="line">                if (parentPath.parentPath.isCallExpression() &amp;&amp; parentPath.parentPath.node.callee.name == &#x27;parseInt&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">const tsCallToString2 = &#123;</span><br><span class="line">    // 遍历函数定义是因为直接遍历调用表达式还原后不好删除</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length &lt; 2) return;</span><br><span class="line">        if (!types.isVariableDeclaration(node.body.body[0]) ||</span><br><span class="line">            !types.isCallExpression(node.body.body[0].declarations[0].init) ||</span><br><span class="line">            !types.isIdentifier(node.body.body[0].declarations[0].init.callee)) return;</span><br><span class="line"></span><br><span class="line">        var name = id.name;</span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        collectFuncCode.push(path.toString());</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        let bigArrFuncName = node.body.body[0].declarations[0].init.callee.name;</span><br><span class="line">        let bigArrFuncBinding = path.scope.getBinding(bigArrFuncName);</span><br><span class="line">        if (!bigArrFuncBinding) return;</span><br><span class="line">        collectFuncCode.push(bigArrFuncBinding.path.toString());</span><br><span class="line"></span><br><span class="line">        // 处理有些大数组存在的移位自执行函数</span><br><span class="line">        let referencePaths_3 = bigArrFuncBinding.referencePaths;</span><br><span class="line">        for (let reference of referencePaths_3) &#123;</span><br><span class="line">            if (!reference.parentPath.isCallExpression()) continue;</span><br><span class="line"></span><br><span class="line">            let &#123; callee, arguments &#125; = reference.parentPath.node;</span><br><span class="line">            if (!types.isFunctionExpression(callee) || arguments.length != 1 || arguments[0].name != bigArrFuncName) continue;</span><br><span class="line">            collectFuncCode.push(reference.parentPath.parentPath.toString());</span><br><span class="line">            // console.log(reference.parentPath.parentPath + &#x27;&#x27;, reference.parentPath.type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eval(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line">        // console.log(collectFuncCode.join(&#x27;;&#x27;));</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] != 1) &#123;</span><br><span class="line">            for (let referencePath of referencePaths) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referencePath;</span><br><span class="line">                // console.log(&quot;sdfewrew2342&quot;,parentPath+&#x27;&#x27;);</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; callee: node &#125;) || !isNodeLiteral(parentPath.node.arguments)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 不处理环境函数中的调用表达式，会有问题</span><br><span class="line">                if (parentPath.parentPath.isCallExpression() &amp;&amp; parentPath.parentPath.node.callee.name == &#x27;parseInt&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let value = eval(parentPath.toString());</span><br><span class="line">                console.log(&quot;第二种类型的还原:&quot;, parentPath + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                parentPath.replaceWith(types.valueToNode(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, tsCallToString2);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 判断函数是否为纯函数</span><br><span class="line">function isPureFunction(path) &#123;</span><br><span class="line">    let isPure = true;</span><br><span class="line"></span><br><span class="line">    // 检查 body.body 数组的每行代码是否包含全局属性，包含则不还原，同时返回值不唯一的也不是纯函数</span><br><span class="line">    let literalList = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;navigator&#x27;, &#x27;location&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;, &#x27;try&#x27;, &#x27;random&#x27;, &#x27;Date&#x27;];</span><br><span class="line">    let sourceCode = path.toString();</span><br><span class="line">    let allElementsValid = literalList.every(ele =&gt; !sourceCode.includes(ele)); // 为 true 则不包含，为 false 则说明包含</span><br><span class="line">    if (!allElementsValid) return false; // 包含则不是纯函数</span><br><span class="line"></span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        MemberExpression(innerPath) &#123;</span><br><span class="line">            const &#123; object &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(object) &amp;&amp; object.name !== &#x27;this&#x27; &amp;&amp; !path.scope.hasBinding(object.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        AssignmentExpression(innerPath) &#123;</span><br><span class="line">            const &#123; left &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(left) &amp;&amp; !path.scope.hasBinding(left.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        CallExpression(innerPath) &#123;</span><br><span class="line">            const &#123; callee &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(callee)) &#123;</span><br><span class="line">                const binding = path.scope.getBinding(callee.name);</span><br><span class="line">                if (!binding || !isPureFunction(binding.path)) &#123;</span><br><span class="line">                    isPure = false;</span><br><span class="line">                    innerPath.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateExpression(innerPath) &#123;</span><br><span class="line">            const &#123; argument &#125; = innerPath.node;</span><br><span class="line">            if (types.isIdentifier(argument) &amp;&amp; !path.scope.hasBinding(argument.name)) &#123;</span><br><span class="line">                isPure = false;</span><br><span class="line">                innerPath.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return isPure;</span><br><span class="line">&#125;</span><br><span class="line">// 节点字面量递归判断函数</span><br><span class="line">function isNodeLiteral(node) &#123;</span><br><span class="line">    if (Array.isArray(node))</span><br><span class="line">        return node.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isThisExpression(node))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (types.isLiteral(node))</span><br><span class="line">        return node.value != null;</span><br><span class="line"></span><br><span class="line">    if (types.isBinaryExpression(node))</span><br><span class="line">        return isNodeLiteral(node.left) &amp;&amp; isNodeLiteral(node.right);</span><br><span class="line"></span><br><span class="line">    if (types.isUnaryExpression(node) &amp;&amp; (node.operator === &#x27;-&#x27; || node.operator === &#x27;+&#x27;))</span><br><span class="line">        return isNodeLiteral(node.argument);</span><br><span class="line"></span><br><span class="line">    if (types.isObjectExpression(node))</span><br><span class="line">        return node.properties.length === 0 || node.properties.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    if (types.isArrayExpression(node))</span><br><span class="line">        return node.elements.length === 0 || node.elements.every(isNodeLiteral);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 主要还原逻辑</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    &quot;CallExpression&quot;: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; callee, arguments &#125; = path.node;</span><br><span class="line">            let &#123; name &#125; = callee;</span><br><span class="line">            if (!types.isIdentifier(callee) || arguments.length == 0 || !isNodeLiteral(arguments)) return;</span><br><span class="line"></span><br><span class="line">            let binding = path.scope.getBinding(name);</span><br><span class="line">            if (!binding) return;</span><br><span class="line"></span><br><span class="line">            let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">            // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line">            // 1. 当 binding.path 为函数时，只能还原纯函数</span><br><span class="line">            try &#123;</span><br><span class="line">                if (binding.path.isFunctionDeclaration()) &#123;</span><br><span class="line">                    // console.log(binding.path + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                    // ******** 为解决下面在 binding.path 为赋值语句时的还原中，不还原其本身的调用表达式的问题 ******** </span><br><span class="line">                    if (decryptCode.includes(binding.path.toString().match(/function\s+\w+\s*\([^)]*\)/g)[0])) &#123;</span><br><span class="line"></span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!isPureFunction(binding.path)) return; // 判断函数是否是纯函数，不是则不处理</span><br><span class="line"></span><br><span class="line">                    let &#123; id, params, body &#125; = binding.path.node;</span><br><span class="line">                    if (params.length == 0 || body.body.length == 0) return;</span><br><span class="line">                    // ******** 专用插件配置限制：函数名、函数调用的实参个数、函数定义的函数体大小 ********</span><br><span class="line">                    if (id.name == &#x27;ln&#x27; || body.body.length &gt; 10) return;</span><br><span class="line">                    if (!types.isReturnStatement(body.body[body.body.length - 1])) return;</span><br><span class="line"></span><br><span class="line">                    eval(binding.path.toString());</span><br><span class="line"></span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || constantViolations[0] == binding.path) &#123; // 如果为常量，或更改的那一次为定义的那一次</span><br><span class="line">                        let value = eval(path.toString());</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, value);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123; &#125;</span><br><span class="line">            // 2. 当 binding.path 为赋值语句或变量定义时，需要在 decode 中准备唯一被还原函数</span><br><span class="line">            try &#123;</span><br><span class="line">                var funcNameArr = [&#x27;n&#x27;] // 唯一被还原函数的函数名</span><br><span class="line">                if (binding.path.isVariableDeclarator()) &#123;</span><br><span class="line">                    // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;, referenced, references, constant, constantViolations.length);</span><br><span class="line">                    if (constantViolations.length &gt; 1) return;</span><br><span class="line">                    if (constant || (constantViolations.length == 1 &amp;&amp; constantViolations[0].isAssignmentExpression())) &#123; // 变量定义只有一次改变，或没改变</span><br><span class="line">                        // console.log(binding.path.parentPath + &#x27;&#x27;, path + &#x27;&#x27;);</span><br><span class="line">                        let &#123; id, init &#125; = binding.path.node;</span><br><span class="line">                        let &#123; name &#125; = id;</span><br><span class="line">                        if (init == null) &#123;</span><br><span class="line">                            init = types.identifier(constantViolations[0].node.right.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!types.isIdentifier(id) || !funcNameArr.includes(init.name)) return;</span><br><span class="line">                        funcNameArr.push(name);</span><br><span class="line"></span><br><span class="line">                        let newCallExpression = types.callExpression(types.identifier(&#x27;n&#x27;), arguments);</span><br><span class="line">                        let value = eval(generator(newCallExpression).code);</span><br><span class="line">                        console.log(path + &#x27;&#x27;, &quot;--&gt;&quot;, value,);</span><br><span class="line">                        path.replaceWith(types.valueToNode(value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">// 删除还原使用的环境函数，已无用</span><br><span class="line">const collectRemoveTsCallToString = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let collectFuncCode = [];</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        if (params.length != 2 || body.body.length != 1) return;</span><br><span class="line">        if (!types.isCallExpression(node.body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">        var name = id.name;</span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        collectFuncCode.push(path);</span><br><span class="line"></span><br><span class="line">        try &#123; // 使用 try 是因为明明节点存在，但依然会报错，实测捕获异常不影响删除功能</span><br><span class="line">            function xxx(path) &#123;</span><br><span class="line">                let tempName = path.node.body.body[0].argument.callee.name;</span><br><span class="line">                let tempBinding = path.scope.getBinding(tempName);</span><br><span class="line">                if (!tempBinding) return;</span><br><span class="line">                collectFuncCode.push(tempBinding.path);</span><br><span class="line"></span><br><span class="line">                if (tempBinding.path.node.body.body.length == 1) &#123;</span><br><span class="line">                    let recursiveBinding = xxx(tempBinding.path);</span><br><span class="line">                    if (recursiveBinding) return recursiveBinding;</span><br><span class="line">                &#125;</span><br><span class="line">                return tempBinding;</span><br><span class="line">            &#125;</span><br><span class="line">            callFuncBinding = xxx(path);</span><br><span class="line">            if (!callFuncBinding) return;</span><br><span class="line"></span><br><span class="line">            let bigArrFuncName = callFuncBinding.path.node.body.body[0].declarations[0].init.callee.name;</span><br><span class="line">            let bigArrFuncBinding = callFuncBinding.scope.getBinding(bigArrFuncName);</span><br><span class="line">            if (!bigArrFuncBinding) return;</span><br><span class="line">            collectFuncCode.push(bigArrFuncBinding.path);</span><br><span class="line"></span><br><span class="line">            // 处理有些大数组存在的移位自执行函数</span><br><span class="line">            let referencePaths_3 = bigArrFuncBinding.referencePaths;</span><br><span class="line">            for (let reference of referencePaths_3) &#123;</span><br><span class="line">                if (!reference.parentPath.isCallExpression()) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; callee, arguments &#125; = reference.parentPath.node;</span><br><span class="line">                if (!types.isFunctionExpression(callee) || arguments.length != 1 || arguments[0].name != bigArrFuncName) continue;</span><br><span class="line">                collectFuncCode.push(reference.parentPath.parentPath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let i of collectFuncCode) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, collectRemoveTsCallToString);</span><br><span class="line"></span><br><span class="line">// 最后使用：垃圾代码删除</span><br><span class="line">function containsSequenceExpression(path) &#123;</span><br><span class="line">    let containsSequence = false;</span><br><span class="line">    // 深度优先遍历当前路径及其所有子路径</span><br><span class="line">    path.traverse(&#123;</span><br><span class="line">        &quot;SequenceExpression|AssignmentExpression&quot;(_path) &#123;</span><br><span class="line">            containsSequence = true;</span><br><span class="line">            _path.stop(); // 找到逗号表达式后立即停止遍历</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    return containsSequence;</span><br><span class="line">&#125;</span><br><span class="line">const removeDeadCode = &#123;</span><br><span class="line">    &quot;IfStatement|ConditionalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; consequent, alternate &#125; = node;</span><br><span class="line">        let testPath = path.get(&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (testPath.isSequenceExpression() || testPath.isAssignmentExpression() || containsSequenceExpression(testPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateTest = testPath.evaluateTruthy();</span><br><span class="line">        if (evaluateTest === true) &#123;</span><br><span class="line">            if (types.isBlockStatement(consequent)) &#123;</span><br><span class="line">                consequent = consequent.body;</span><br><span class="line">            &#125;</span><br><span class="line">            path.replaceWithMultiple(consequent);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (evaluateTest === false) &#123;</span><br><span class="line">            if (alternate != null) &#123;</span><br><span class="line">                if (types.isBlockStatement(alternate)) &#123;</span><br><span class="line">                    alternate = alternate.body;</span><br><span class="line">                &#125;</span><br><span class="line">                path.replaceWithMultiple(alternate);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;LogicalExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; node &#125; = path;</span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        let leftPath = path.get(&#x27;left&#x27;);</span><br><span class="line"></span><br><span class="line">        //不处理逗号表达式，赋值语句防止误删</span><br><span class="line">        if (leftPath.isSequenceExpression() || leftPath.isAssignmentExpression() || containsSequenceExpression(leftPath)) return;</span><br><span class="line"></span><br><span class="line">        const evaluateLeft = leftPath.evaluateTruthy();</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == true) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == false)) &#123;</span><br><span class="line">            path.replaceWith(left);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((operator == &quot;||&quot; &amp;&amp; evaluateLeft == false) || (operator == &quot;&amp;&amp;&quot; &amp;&amp; evaluateLeft == true)) &#123;</span><br><span class="line">            path.replaceWith(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;EmptyStatement|DebuggerStatement&quot;(path) &#123;</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">        let &#123; node, scope, parentPath, parent &#125; = path;</span><br><span class="line">        let ancestryPath = parentPath.parentPath;</span><br><span class="line"></span><br><span class="line">        // for循环中的变量定义不能删除</span><br><span class="line">        if (ancestryPath.isForOfStatement(&#123; left: parent &#125;) || ancestryPath.isForInStatement(&#123; left: parent &#125;)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; id, init &#125; = node;</span><br><span class="line">        //目前只发现赋值语句和调用语句会有问题。后续待添加</span><br><span class="line">        if (!types.isIdentifier(id) || types.isCallExpression(init) || types.isAssignmentExpression(init)) return;</span><br><span class="line"></span><br><span class="line">        let binding = scope.getBinding(id.name); // 重新解析ast后，一定会有binding</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 变量定义:&quot;, path.parentPath + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;AssignmentExpression&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, parentPath, node &#125; = path;</span><br><span class="line">        if (!parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        let &#123; left, operator, right &#125; = node;</span><br><span class="line">        if (!types.isIdentifier(left) || operator != &#x27;=&#x27;) return;</span><br><span class="line"></span><br><span class="line">        let name = left.name;</span><br><span class="line">        let binding = scope.getBinding(name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line"></span><br><span class="line">        let &#123; referenced, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(path + &#x27;&#x27;, referenced, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 赋值语句:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            if (binding.path.parentPath.isFunctionExpression() || binding.path.parentPath.isFunctionDeclaration()) &#123;</span><br><span class="line">                binding.path.remove(); // 删除的函数形参</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ContinueStatement|BreakStatement|ReturnStatement|ThrowStatement&quot;(path) &#123;</span><br><span class="line">        if (!path.parentPath.isSwitchCase()) return; // 只处理在 switch-case 语句中的</span><br><span class="line">        let AllNextSiblings = path.getAllNextSiblings(); // 获取所有的后续兄弟节点</span><br><span class="line">        for (let nextSibling of AllNextSiblings) &#123;</span><br><span class="line">            if (nextSibling.isFunctionDeclaration() || nextSibling.isVariableDeclaration(&#123; kind: &quot;var&quot; &#125;)) &#123; //变量提升.....</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nextSibling.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">        let &#123; scope, node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params &#125; = node;</span><br><span class="line">        if (!params) return;</span><br><span class="line">        let flag = true;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations &#125; = binding;</span><br><span class="line">        // console.log(id.name, referenced, references, constant, constantViolations.length);</span><br><span class="line">        if (referenced || constantViolations.length &gt; 1) return;</span><br><span class="line">        if (constant || constantViolations[0] == path) &#123;</span><br><span class="line">            console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数定义:&quot;, path + &#x27;&#x27;);</span><br><span class="line">            path.remove();</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            for (let i of params) &#123;</span><br><span class="line">                if (!types.isIdentifier(i)) continue;</span><br><span class="line">                let binding = scope.getBinding(i.name);</span><br><span class="line">                if (!binding) continue;</span><br><span class="line"></span><br><span class="line">                let &#123; references, constantViolations &#125; = binding;</span><br><span class="line">                if (references === 0 &amp;&amp; constantViolations.length === 0) &#123;</span><br><span class="line">                    // 将未使用的参数标记为删除</span><br><span class="line">                    console.log(&quot;垃圾代码删除&quot;, &quot;--&gt; 函数形参:&quot;, i.name);</span><br><span class="line">                    params = params.filter(param =&gt; param !== i);</span><br><span class="line">                    console.log(params);</span><br><span class="line">                &#125;</span><br><span class="line">                path.node.params = params;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    traverse(ast, removeDeadCode); // 删除不够彻底则再调用一次，以此类推</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">let &#123; code &#125; = generator(ast, opts = &#123;</span><br><span class="line">    &quot;compact&quot;: false,  // 是否压缩代码</span><br><span class="line">    &quot;comments&quot;: false,  // 是否保留注释</span><br><span class="line">    &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125;,  // Unicode转义，确保非ASCII字符被正确地保留和显示，而不是被转义</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">files.writeFile(decodeFile, code, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="8-插件-px3-函数重命名"><a href="#8-插件-px3-函数重命名" class="headerlink" title="8. 插件 -&gt; px3 函数重命名"></a>8. 插件 -&gt; px3 函数重命名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">自执行函数外面有个Q函数，自执行函数里面又一个同名的Q函数，如果使用 ob混淆一键还原脚本里的思路，是会覆盖掉前一个 Q 函数的声明，对于它的调用，解密肯定会出错。</span><br><span class="line"></span><br><span class="line">因此，我的思路，是，将所有的这种 特征函数，将它的函数名重命名，并同时修改引用的位置，这样，就可以避免同名函数了。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">function getRandomName(length) &#123;</span><br><span class="line">    let initArr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;];</span><br><span class="line">    let puzzleArr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;];</span><br><span class="line">    let ranInx = Math.floor(Math.random() * initArr.length);</span><br><span class="line">    let randomName = initArr[ranInx];</span><br><span class="line"></span><br><span class="line">    for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">        ranInx = Math.floor(Math.random() * puzzleArr.length);</span><br><span class="line">        randomName += puzzleArr[ranInx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return randomName;</span><br><span class="line">&#125;</span><br><span class="line">let allNewNames = new Map(); //定义一个全局变量，保存需要处理的函数</span><br><span class="line"></span><br><span class="line">//获取未被使用的名称,返回 Identifier 类型。</span><br><span class="line">function getUnusedIdentifier() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        var newName = &quot;$C_&quot; + getRandomName(3);</span><br><span class="line">    &#125; while (allNewNames.has(newName))</span><br><span class="line"></span><br><span class="line">    allNewNames.set(newName, 1);</span><br><span class="line">    let UnusedIdentifier = types.Identifier(newName);</span><br><span class="line"></span><br><span class="line">    return UnusedIdentifier;</span><br><span class="line">&#125;</span><br><span class="line">const renameFunc = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; node, parentPath &#125; = path;</span><br><span class="line">        let &#123; id, params, body &#125; = node;</span><br><span class="line">        let name = id.name;</span><br><span class="line"></span><br><span class="line">        // PX3特征函数</span><br><span class="line">        if (params.length != 2 || body.body.length != 1 ||</span><br><span class="line">            !types.isReturnStatement(body.body[0]) || !types.isCallExpression(body.body[0].argument)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let binding = parentPath.scope.getBinding(name);</span><br><span class="line">        if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">        let newNameId = getUnusedIdentifier();</span><br><span class="line">        for (let referPath of binding.referencePaths) &#123;</span><br><span class="line">            referPath.replaceWith(newNameId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let newName = newNameId.name;</span><br><span class="line">        allNewNames.set(newName, name)</span><br><span class="line">        path.node.id.name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, renameFunc);</span><br><span class="line">allNewNames.clear();</span><br></pre></td></tr></table></figure>

<h2 id="十、Akamai-2-0-还原专题"><a href="#十、Akamai-2-0-还原专题" class="headerlink" title="十、Akamai 2.0 还原专题"></a>十、Akamai 2.0 还原专题</h2><blockquote>
<p><strong>有个坑，还原过后，有些代码的定义在最外层 return 下面导致替换无效，需要手动将其移上去</strong></p>
</blockquote>
<h3 id="0-技巧-过-toString-检测"><a href="#0-技巧-过-toString-检测" class="headerlink" title="0. 技巧 -&gt; 过 toString 检测"></a>0. 技巧 -&gt; 过 toString 检测</h3><ul>
<li><strong>实现步骤：</strong><ol>
<li>从网页上复制下来的源码不要格式化，压缩为一行，直接用于 AST 解析的 encode.js 文件</li>
<li>利用以下脚本对源码进行解析，得到用于过掉 toString 检测的脚本方法</li>
<li>最后将上一步得到的脚本方法，添加到最终经过 AST 还原（单独对源码进行解混淆）后的代码的最前面</li>
<li>最后通过浏览器映射技术，比如 Charles 的本地映射来实现替换网页文件并调试</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const _path = require(&#x27;path&#x27;);</span><br><span class="line">const files = require(&#x27;fs&#x27;);  // 导入文件库，防止与fs变量名冲突</span><br><span class="line">const types = require(&quot;@babel/types&quot;);</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">const template = require(&quot;@babel/template&quot;).default;</span><br><span class="line">const traverse = require(&quot;@babel/traverse&quot;).default;</span><br><span class="line">const generator = require(&quot;@babel/generator&quot;).default;</span><br><span class="line">const NodePath = require(&quot;@babel/traverse&quot;).NodePath; // 智能提示所需</span><br><span class="line"></span><br><span class="line">const encodeFile = _path.resolve(__dirname, &#x27;encode.js&#x27;);</span><br><span class="line">const decodeFile = _path.resolve(__dirname, &#x27;toStringResult.js&#x27;);</span><br><span class="line">let sourceCode = files.readFileSync(encodeFile, &#123; encoding: &quot;utf-8&quot; &#125;);</span><br><span class="line">let ast = parser.parse(sourceCode);</span><br><span class="line">console.time(&quot;处理完毕，耗时&quot;);</span><br><span class="line"></span><br><span class="line">let funStringPointArray = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 保存函数源代码，不使用 toString() 和 compact 压缩选项，非原始混淆代码</span><br><span class="line">const saveFuncString = &#123;</span><br><span class="line">	&quot;FunctionDeclaration&quot;(path) &#123;</span><br><span class="line">		let &#123; id, start, end &#125; = path.node;</span><br><span class="line">		funStringPointArray[id.name] = [start, end];</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;VariableDeclarator&quot;(path) &#123;</span><br><span class="line">		let &#123; id, init &#125; = path.node;</span><br><span class="line">		if (types.isFunctionExpression(init)) &#123;</span><br><span class="line">			let &#123; start, end &#125; = init;</span><br><span class="line">			funStringPointArray[id.name] = [start, end];</span><br><span class="line"></span><br><span class="line">			if (init.id != null) &#123;</span><br><span class="line">				funStringPointArray[init.id.name] = [start, end];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (types.isCallExpression(init) &amp;&amp; types.isFunctionExpression(init.callee)) &#123;</span><br><span class="line">			let &#123; start, end &#125; = init.callee;</span><br><span class="line">			funStringPointArray[id.name] = [start, end];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, saveFuncString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var funStringArray = &#123;&#125;;</span><br><span class="line">for (var funName in funStringPointArray) &#123;</span><br><span class="line">	funStringArray[funName] = sourceCode.substring(funStringPointArray[funName][0], funStringPointArray[funName][1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过重写 Function.prototype.toString，确保当调用 toString() 方法时，返回的是原始的未混淆代码片段</span><br><span class="line">let data = `var _old = Function.prototype.toString.call;</span><br><span class="line">var tostringData = ` + JSON.stringify(funStringArray) + `\n</span><br><span class="line">Function.prototype.toString.call = function (arg) &#123;</span><br><span class="line">    if(tostringData.hasOwnProperty(arg.name))&#123;</span><br><span class="line">        return tostringData[arg.name];</span><br><span class="line">    &#125;</span><br><span class="line">    return _old.call(this, arg);</span><br><span class="line">&#125;;</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">console.timeEnd(&quot;处理完毕，耗时&quot;);</span><br><span class="line">files.writeFile(decodeFile, data, (err) =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-思路-固定结果函数还原"><a href="#1-思路-固定结果函数还原" class="headerlink" title="1. 思路 -&gt; 固定结果函数还原"></a>1. 思路 -&gt; 固定结果函数还原</h3><ul>
<li><strong>特点：</strong>通过基本跟栈定位至 58 位大数组生成位置，可以发现其上面的类似 <code>Sx.zb.call(null, aa, bb)</code> 的函数调用，经过测试可以知道<strong>这类函数调用的结果与形参无关，无论传入什么形参都是一样的结果</strong></li>
<li><strong>还原思路：</strong>创建新对象 deObj，将主要调用对象 enObj 中的每个属性和方法的调用结果都存储在 deObj 中，再利用 AST 遍历对应函数，将其调用方法还原为这个 JSON 对象中的结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/* ******** 将 enObj 中的每个属性和方法的调用结果存储在 deObj 中 ********</span><br><span class="line">let enObj = Fn; // 这里的 Fn 即为调用的最外层的对象，需要修改</span><br><span class="line"></span><br><span class="line">let deObj = new Object();</span><br><span class="line">for (let key of Object.keys(enObj)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        deObj[key] = enObj[key].apply(null,);</span><br><span class="line">    &#125; catch &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy(JSON.stringify(deObj))</span><br><span class="line">*********************************************************************/</span><br><span class="line"></span><br><span class="line">let enObjName = &quot;T6&quot;; // 上面用到的 enObj 对象</span><br><span class="line">let deObj = &#123;&quot;H2&quot;:&quot;-103&quot;,&quot;Rh&quot;:&quot;ButtonHighlight&quot;,&quot;ph&quot;:&quot;CaptionText&quot;, ...&#125; // 存储所有调用结果的 JSON 对象</span><br><span class="line"></span><br><span class="line">// 主要还原 Fn.xx.call(null, aa, bb) 或 Fn.xx(aa, bb) 类型的调用表达式，且结果不受形参影响</span><br><span class="line">const callToString = &#123;</span><br><span class="line">    CallExpression(path) &#123;</span><br><span class="line">        let &#123; callee &#125; = path.node;</span><br><span class="line">        if (!types.isMemberExpression(callee)) return;</span><br><span class="line"></span><br><span class="line">        let &#123; object, property, computed &#125; = callee;</span><br><span class="line">        // 如果 object 是标识符，即 Fn.xx(aa, bb)</span><br><span class="line">        if (types.isIdentifier(object, &#123; name: enObjName &#125;)) &#123;</span><br><span class="line">            let proName = computed ? property.value : property.name;</span><br><span class="line"></span><br><span class="line">            if (deObj.hasOwnProperty(proName)) &#123;</span><br><span class="line">                console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, deObj[proName]);</span><br><span class="line">                path.replaceWith(types.valueToNode(deObj[proName]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 object 是成员表达式，即 Fn.xx.call(null, aa, bb)</span><br><span class="line">        if (types.isMemberExpression(object)) &#123;</span><br><span class="line">            let proName = computed ? property.value : property.name;</span><br><span class="line">            if (![&#x27;apply&#x27;, &#x27;call&#x27;].includes(proName)) return;</span><br><span class="line"></span><br><span class="line">            if (object.object.name == enObjName) &#123;</span><br><span class="line">                let proName = object.computed ? object.property.value : object.property.name;</span><br><span class="line"></span><br><span class="line">                if (deObj.hasOwnProperty(proName)) &#123;</span><br><span class="line">                    console.log(path + &#x27;&#x27;, &#x27;--&gt;&#x27;, deObj[proName]);</span><br><span class="line">                    path.replaceWith(types.valueToNode(deObj[proName]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, callToString);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="2-思路-假函数体内容还原"><a href="#2-思路-假函数体内容还原" class="headerlink" title="2. 思路 -&gt; 假函数体内容还原"></a>2. 思路 -&gt; 假函数体内容还原</h3><ul>
<li>Akamai 存在由函数体调用的形式来执行的代码，函数本身没有任何意义，所以使用<strong>假函数体内容还原</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 假函数体内容还原</span><br><span class="line">const untruthFuncContent = &#123;</span><br><span class="line">    FunctionDeclaration(path) &#123;</span><br><span class="line">        let &#123; id, params, body &#125; = path.node;</span><br><span class="line">        if (params.length != 0 || body.body.length != 1 || !types.isExpressionStatement(body.body[0])) return;</span><br><span class="line"></span><br><span class="line">        let binding = path.scope.getBinding(id.name);</span><br><span class="line">        if (!binding) return;</span><br><span class="line">        let &#123; referenced, references, constant, constantViolations, referencePaths &#125; = binding;</span><br><span class="line">        // console.log(name, referenced, references, constant, constantViolations.length);</span><br><span class="line"></span><br><span class="line">        if (constantViolations.length &gt; 1 || !constant || referencePaths.length != 1) return;</span><br><span class="line">        let referPath = referencePaths[0]</span><br><span class="line">        let &#123; node, parentPath &#125; = referPath;</span><br><span class="line">        if (!parentPath.isCallExpression(&#123; callee: node &#125;)) return;</span><br><span class="line">        if (!parentPath.parentPath.isExpressionStatement()) return;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;假函数体内容还原:&quot;, path + &#x27;&#x27;);</span><br><span class="line">        parentPath.parentPath.replaceWith(body.body[0]);</span><br><span class="line">        path.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, untruthFuncContent);</span><br><span class="line">ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br></pre></td></tr></table></figure>

<h3 id="3-思路-大量字面量还原"><a href="#3-思路-大量字面量还原" class="headerlink" title="3. 思路 -&gt; 大量字面量还原"></a>3. 思路 -&gt; 大量字面量还原</h3><ul>
<li>基于预处理解混淆模版，调用多次 <strong>合并变量声明与定义</strong>、<strong>定义字面量未改还原</strong>、<strong>折叠字面量或表达式</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, combinDefineAndNextAssgin);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, rebackVarDeclarator);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, calcPartBinaryExpression);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-思路-ob-典型花指令还原"><a href="#4-思路-ob-典型花指令还原" class="headerlink" title="4. 思路 -&gt; ob 典型花指令还原"></a>4. 思路 -&gt; ob 典型花指令还原</h3><ul>
<li>Akamai 存在大量典型的 OB 混淆函数花指令，AST 兼容 3 种表达式还原即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// OB 典型花指令还原，分别处理单元表达式、二元表达式、数组</span><br><span class="line">const replaceExpressionOfReturn = (typeCheck, createReplacement) =&gt; (&#123;</span><br><span class="line">    FunctionDeclaration: &#123;</span><br><span class="line">        exit(path) &#123;</span><br><span class="line">            let &#123; scope, node &#125; = path;</span><br><span class="line">            let &#123; id, params, body &#125; = node;</span><br><span class="line">            if (body.body.length != 1 || !types.isReturnStatement(body.body[0]) || !typeCheck(body.body[0].argument)) return;</span><br><span class="line"></span><br><span class="line">            let expression = body.body[0].argument;</span><br><span class="line">            let binding = scope.getBinding(id.name);</span><br><span class="line">            if (!binding || !binding.constant) return;</span><br><span class="line"></span><br><span class="line">            let canRemoved = true;</span><br><span class="line">            for (let referPath of binding.referencePaths.reverse()) &#123;</span><br><span class="line">                let &#123; parentPath, node &#125; = referPath;</span><br><span class="line">                if (!parentPath.isCallExpression(&#123; &quot;callee&quot;: node &#125;)) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let args = parentPath.node.arguments;</span><br><span class="line">                if (!createReplacement(args, expression)) &#123;</span><br><span class="line">                    canRemoved = false;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(parentPath.toString());</span><br><span class="line">                parentPath.replaceWith(createReplacement(args, expression));</span><br><span class="line">            &#125;</span><br><span class="line">            canRemoved &amp;&amp; path.remove();</span><br><span class="line">            path.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const reStoreUnaryOfReturn = replaceExpressionOfReturn(</span><br><span class="line">    expr =&gt; types.isUnaryExpression(expr) &amp;&amp; types.isIdentifier(expr.argument),</span><br><span class="line">    (args, expr) =&gt; args.length == 1 ? types.unaryExpression(expr.operator, args[0], true) : null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const reStoreBinaryOfReturn = replaceExpressionOfReturn(</span><br><span class="line">    expr =&gt; types.isBinaryExpression(expr) &amp;&amp; types.isIdentifier(expr.left) &amp;&amp; types.isIdentifier(expr.right),</span><br><span class="line">    (args, expr) =&gt; args.length == 2 ? types.binaryExpression(expr.operator, args[0], args[1]) : null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const reStoreArrayOfReturn = replaceExpressionOfReturn(</span><br><span class="line">    expr =&gt; types.isArrayExpression(expr),</span><br><span class="line">    (args, expr) =&gt; args.length == 0 ? expr : null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    traverse(ast, reStoreUnaryOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreBinaryOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line"></span><br><span class="line">    traverse(ast, reStoreArrayOfReturn);</span><br><span class="line">    ast = parser.parse(generator(ast, opts = &#123; &quot;jsescOption&quot;: &#123; &quot;minimal&quot;: true &#125; &#125;).code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                JS逆向_5_AST解混淆
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2024/09/01/JS逆向_5_AST解混淆/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">xfblog</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2024-09-01 00:00</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/JS%E9%80%86%E5%90%91/">JS逆向</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E7%88%AC%E8%99%AB/">爬虫</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Python/">Python</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                
                    

<div class="reward-author-container border-box flex-center">
    <div class="reward-btn border-box flex-center tooltip tooltip-img"
            data-tooltip-img-url="/images/zfb.webp"
            data-tooltip-img-trigger="click"
            data-tooltip-img-style="top: -6px;"
    >
        <i class="fa-solid fa-gift"></i>&nbsp;创作不易，打赏随意，您的支持是我更新的动力💪！
    </div>
</div>

                

                
                    <div class="post-nav border-box">
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/07/01/JS%E9%80%86%E5%90%91_4_%E8%A1%A5%E7%8E%AF%E5%A2%83%E4%B8%93%E9%A2%98/"
                                   title="JS逆向_4_补环境专题"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">JS逆向_4_补环境专题</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81AST%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98"><span class="nav-text">一、AST技术专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-AST-%E8%84%B1%E6%B7%B7%E6%B7%86%E6%80%9D%E8%B7%AF"><span class="nav-text">0. AST -&gt; 脱混淆思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%8E%9F%E7%90%86"><span class="nav-text">1. 代码混淆原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AF%AD%E6%B3%95%E6%A0%91%E8%8A%82%E7%82%B9%E5%90%8D%E8%AF%8D"><span class="nav-text">2. 语法树节点名词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-bable"><span class="nav-text">3. bable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-path"><span class="nav-text">4. path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-scope"><span class="nav-text">5. scope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E6%8A%80%E5%B7%A7"><span class="nav-text">6. 常见语法技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ast-%E5%BF%85%E5%A4%87-js-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="nav-text">7. ast 必备 js 语法与特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%88%A4%E6%96%AD%E8%8A%82%E7%82%B9%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">二、判断节点通用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0-%E2%80%93-%E8%8A%82%E7%82%B9%E5%AD%97%E9%9D%A2%E9%87%8F%E5%9F%BA%E7%A1%80%E5%88%A4%E6%96%AD"><span class="nav-text">1. 函数 –&gt; 节点字面量基础判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0-%E8%8A%82%E7%82%B9%E5%AD%97%E9%9D%A2%E9%87%8F%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD"><span class="nav-text">2. 函数 -&gt; 节点字面量递归判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96-%E8%8A%82%E7%82%B9%E5%AD%90%E9%9D%A2%E9%87%8F%E5%88%A4%E6%96%AD"><span class="nav-text">3. 函数优化 -&gt; 节点子面量判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0-%E5%88%A4%E6%96%AD%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-text">3. 函数 -&gt; 判断节点是否纯函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%A7%A3%E6%B7%B7%E6%B7%86%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="nav-text">三、解混淆通用插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%A8%A1%E7%89%88-%E9%80%9A%E7%94%A8%E8%A7%A3%E6%B7%B7%E6%B7%86%E6%A8%A1%E7%89%88"><span class="nav-text">0. 模版 -&gt; 通用解混淆模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E7%BC%96%E7%A0%81%E8%BF%98%E5%8E%9F%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="nav-text">1. 插件 -&gt; 编码还原十进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6-%E5%AD%97%E9%9D%A2%E9%87%8F%E5%8C%96%E6%88%90%E5%91%98%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">2. 插件 -&gt; 字面量化成员表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-%E6%8A%98%E5%8F%A0%E5%AD%97%E9%9D%A2%E9%87%8F%E6%88%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">3. 插件 -&gt; 折叠字面量或表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E7%AE%80%E5%8C%96%E5%BE%AA%E7%8E%AF%E5%92%8C-If-%E8%AF%AD%E5%8F%A5"><span class="nav-text">4. 插件 -&gt; 简化循环和 If 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-%E7%AE%80%E5%8C%96%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">5. 插件 -&gt; 简化逗号表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%92%E4%BB%B6-%E5%AF%B9%E8%B1%A1-val-%E5%80%BC%E5%85%A8%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="nav-text">6. 插件 -&gt; 对象 val 值全为常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%8F%92%E4%BB%B6-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="nav-text">7. 插件 -&gt; 数组元素全为常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%8F%92%E4%BB%B6-%E5%9E%83%E5%9C%BE%E4%BB%A3%E7%A0%81%E5%88%A0%E9%99%A4"><span class="nav-text">8. 插件 -&gt; 垃圾代码删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="nav-text">四、变量相关插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E5%88%86%E7%A6%BB%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 插件 -&gt; 分离多个变量同定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6-%E5%90%88%E5%B9%B6%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="nav-text">2. 插件 -&gt; 合并变量声明与定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E8%BD%AC%E8%87%AA%E5%AE%9A"><span class="nav-text">3. 插件 -&gt; 变量定义函数转自定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9C%AA%E6%94%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">4. 插件 -&gt; 定义字面量未改还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-%E8%B5%8B%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9C%AA%E6%94%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">5. 插件 -&gt; 赋值字面量未改还原</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="nav-text">五、函数相关插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%98%E5%8E%9F"><span class="nav-text">1. 插件 -&gt; 内置函数调用还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6-%E5%81%87%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E5%AE%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">2. 插件 -&gt; 假函数体内容还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-ob-%E5%85%B8%E5%9E%8B%E8%8A%B1%E6%8C%87%E4%BB%A4%E8%BF%98%E5%8E%9F"><span class="nav-text">3. 插件 -&gt; ob 典型花指令还原</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="nav-text">六、条件与逻辑表达式相关插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B5%8C%E5%A5%97%E5%9C%A8%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">1. 嵌套在语句中的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC-if-%E8%AF%AD%E5%8F%A5"><span class="nav-text">2. 条件表达式转 if 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%815s%E7%9B%BE%E8%A7%A3%E6%B7%B7%E6%B7%86%E4%B8%93%E9%A2%98"><span class="nav-text">七、5s盾解混淆专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E8%BF%98%E5%8E%9F%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">1. 插件 -&gt; 还原调用表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6%E4%BC%98%E5%8C%96-%E6%8F%92%E4%BB%B61"><span class="nav-text">2. 插件优化 -&gt; 插件1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-object-%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6"><span class="nav-text">3. 插件 -&gt; object 对象合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">4. 插件 -&gt; 深拷贝赋值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-obj-%E5%AF%B9%E8%B1%A1-value-%E5%AE%9E%E7%8E%B0"><span class="nav-text">5. 插件 -&gt; obj 对象 value 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%92%E4%BB%B6-%E5%A4%84%E7%90%86%E5%B9%B3%E5%9D%A6%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-text">6. 插件 -&gt; 处理平坦控制流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81OB%E8%A7%A3%E6%B7%B7%E6%B7%86%E4%B8%93%E9%A2%98"><span class="nav-text">八、OB解混淆专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E8%BF%98%E5%8E%9F%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="nav-text">1. 插件 -&gt; 还原调用表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6%E6%A8%A1%E7%89%88-%E6%8F%92%E4%BB%B61"><span class="nav-text">2. 插件模版 -&gt; 插件1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-object-%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6-1"><span class="nav-text">3. 插件 -&gt; object 对象合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8-1"><span class="nav-text">4. 插件 -&gt; 深拷贝赋值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-obj-%E5%AF%B9%E8%B1%A1-value-%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">5. 插件 -&gt; obj 对象 value 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%92%E4%BB%B6-%E5%A4%84%E7%90%86%E5%B9%B3%E5%9D%A6%E6%8E%A7%E5%88%B6%E6%B5%81-1"><span class="nav-text">6. 插件 -&gt; 处理平坦控制流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E9%87%8D%E7%82%B9AST%E8%BF%98%E5%8E%9F%E4%B8%93%E9%A2%98"><span class="nav-text">九、重点AST还原专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%A8%A1%E7%89%88-%E5%B8%B8%E7%94%A8-banding-%E5%86%99%E6%B3%95"><span class="nav-text">0. 模版 -&gt; 常用 banding 写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A1%88%E4%BE%8B-%E5%A4%8D%E6%9D%82%E6%8E%A7%E5%88%B6%E6%B5%81%E8%BF%98%E5%8E%9F"><span class="nav-text">1. 案例 -&gt; 复杂控制流还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A1%88%E4%BE%8B%E4%BC%98%E5%8C%96-%E5%A4%8D%E6%9D%82%E6%8E%A7%E5%88%B6%E6%B5%81%E8%BF%98%E5%8E%9F"><span class="nav-text">2. 案例优化 -&gt; 复杂控制流还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A8%A1%E7%89%88-%E9%A2%84%E5%A4%84%E7%90%86%E8%A7%A3%E6%B7%B7%E6%B7%86%E6%A8%A1%E7%89%88"><span class="nav-text">3. 模版 -&gt; 预处理解混淆模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A1%86%E6%9E%B6-%E9%80%9A%E7%94%A8%E7%BA%AF%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F"><span class="nav-text">4. 框架 -&gt; 通用纯函数还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A8%A1%E7%89%88-%E4%B8%93%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F%E6%A8%A1%E7%89%88"><span class="nav-text">5. 模版 -&gt; 专用函数还原模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A1%88%E4%BE%8B-datadome%E8%BF%98%E5%8E%9F"><span class="nav-text">6. 案例 -&gt; datadome还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%A1%88%E4%BE%8B-px3-%E8%BF%98%E5%8E%9F"><span class="nav-text">7. 案例 -&gt; px3 还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%8F%92%E4%BB%B6-px3-%E5%87%BD%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D"><span class="nav-text">8. 插件 -&gt; px3 函数重命名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81Akamai-2-0-%E8%BF%98%E5%8E%9F%E4%B8%93%E9%A2%98"><span class="nav-text">十、Akamai 2.0 还原专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%8A%80%E5%B7%A7-%E8%BF%87-toString-%E6%A3%80%E6%B5%8B"><span class="nav-text">0. 技巧 -&gt; 过 toString 检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%80%9D%E8%B7%AF-%E5%9B%BA%E5%AE%9A%E7%BB%93%E6%9E%9C%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F"><span class="nav-text">1. 思路 -&gt; 固定结果函数还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%80%9D%E8%B7%AF-%E5%81%87%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E5%AE%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">2. 思路 -&gt; 假函数体内容还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%80%9D%E8%B7%AF-%E5%A4%A7%E9%87%8F%E5%AD%97%E9%9D%A2%E9%87%8F%E8%BF%98%E5%8E%9F"><span class="nav-text">3. 思路 -&gt; 大量字面量还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%80%9D%E8%B7%AF-ob-%E5%85%B8%E5%9E%8B%E8%8A%B1%E6%8C%87%E4%BB%A4%E8%BF%98%E5%8E%9F"><span class="nav-text">4. 思路 -&gt; ob 典型花指令还原</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
    Copyright&nbsp;&copy;&nbsp;<span>2021</span>&nbsp;-&nbsp;2024&nbsp;<a href="https://xfblog.cn/" target="_self">小傅博客</a>&nbsp;-&nbsp;All&nbsp;rights&nbsp;reserved.&nbsp;&nbsp;&nbsp;&nbsp;
    
            <!-- &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">xfblog</a> -->
        
    </div>

    <!-- <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div> -->

    

    

    
        <div class="record-info info-item">
            
                
                    <div class="record-item border-box">
                        <a class=""
                           target="_blank"
                           href="https://beian.miit.gov.cn"
                        >
                        
                            蜀ICP备2021021033号-1
                        </a>
                    </div>
                
            
                
                    <div class="record-item border-box">
                        <a class=""
                           target="_blank"
                           href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51138102000134"
                        >
                        
                            <!-- 在第二个 <a> 标签前插入图片 -->
                            <img src="http://xfblog.cn/images/icon.webp" style="vertical-align: top;">
                        
                            川公网安备 51138102000134号
                        </a>
                    </div>
                
            
        </div>&nbsp;&nbsp;&nbsp;&nbsp;
        
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81AST%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98"><span class="nav-text">一、AST技术专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-AST-%E8%84%B1%E6%B7%B7%E6%B7%86%E6%80%9D%E8%B7%AF"><span class="nav-text">0. AST -&gt; 脱混淆思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%8E%9F%E7%90%86"><span class="nav-text">1. 代码混淆原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AF%AD%E6%B3%95%E6%A0%91%E8%8A%82%E7%82%B9%E5%90%8D%E8%AF%8D"><span class="nav-text">2. 语法树节点名词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-bable"><span class="nav-text">3. bable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-path"><span class="nav-text">4. path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-scope"><span class="nav-text">5. scope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E6%8A%80%E5%B7%A7"><span class="nav-text">6. 常见语法技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ast-%E5%BF%85%E5%A4%87-js-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="nav-text">7. ast 必备 js 语法与特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%88%A4%E6%96%AD%E8%8A%82%E7%82%B9%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-text">二、判断节点通用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0-%E2%80%93-%E8%8A%82%E7%82%B9%E5%AD%97%E9%9D%A2%E9%87%8F%E5%9F%BA%E7%A1%80%E5%88%A4%E6%96%AD"><span class="nav-text">1. 函数 –&gt; 节点字面量基础判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0-%E8%8A%82%E7%82%B9%E5%AD%97%E9%9D%A2%E9%87%8F%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD"><span class="nav-text">2. 函数 -&gt; 节点字面量递归判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96-%E8%8A%82%E7%82%B9%E5%AD%90%E9%9D%A2%E9%87%8F%E5%88%A4%E6%96%AD"><span class="nav-text">3. 函数优化 -&gt; 节点子面量判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0-%E5%88%A4%E6%96%AD%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-text">3. 函数 -&gt; 判断节点是否纯函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%A7%A3%E6%B7%B7%E6%B7%86%E9%80%9A%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="nav-text">三、解混淆通用插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%A8%A1%E7%89%88-%E9%80%9A%E7%94%A8%E8%A7%A3%E6%B7%B7%E6%B7%86%E6%A8%A1%E7%89%88"><span class="nav-text">0. 模版 -&gt; 通用解混淆模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E7%BC%96%E7%A0%81%E8%BF%98%E5%8E%9F%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="nav-text">1. 插件 -&gt; 编码还原十进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6-%E5%AD%97%E9%9D%A2%E9%87%8F%E5%8C%96%E6%88%90%E5%91%98%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">2. 插件 -&gt; 字面量化成员表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-%E6%8A%98%E5%8F%A0%E5%AD%97%E9%9D%A2%E9%87%8F%E6%88%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">3. 插件 -&gt; 折叠字面量或表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E7%AE%80%E5%8C%96%E5%BE%AA%E7%8E%AF%E5%92%8C-If-%E8%AF%AD%E5%8F%A5"><span class="nav-text">4. 插件 -&gt; 简化循环和 If 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-%E7%AE%80%E5%8C%96%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">5. 插件 -&gt; 简化逗号表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%92%E4%BB%B6-%E5%AF%B9%E8%B1%A1-val-%E5%80%BC%E5%85%A8%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="nav-text">6. 插件 -&gt; 对象 val 值全为常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%8F%92%E4%BB%B6-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="nav-text">7. 插件 -&gt; 数组元素全为常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%8F%92%E4%BB%B6-%E5%9E%83%E5%9C%BE%E4%BB%A3%E7%A0%81%E5%88%A0%E9%99%A4"><span class="nav-text">8. 插件 -&gt; 垃圾代码删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="nav-text">四、变量相关插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E5%88%86%E7%A6%BB%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 插件 -&gt; 分离多个变量同定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6-%E5%90%88%E5%B9%B6%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="nav-text">2. 插件 -&gt; 合并变量声明与定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E8%BD%AC%E8%87%AA%E5%AE%9A"><span class="nav-text">3. 插件 -&gt; 变量定义函数转自定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9C%AA%E6%94%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">4. 插件 -&gt; 定义字面量未改还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-%E8%B5%8B%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9C%AA%E6%94%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">5. 插件 -&gt; 赋值字面量未改还原</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="nav-text">五、函数相关插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%98%E5%8E%9F"><span class="nav-text">1. 插件 -&gt; 内置函数调用还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6-%E5%81%87%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E5%AE%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">2. 插件 -&gt; 假函数体内容还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-ob-%E5%85%B8%E5%9E%8B%E8%8A%B1%E6%8C%87%E4%BB%A4%E8%BF%98%E5%8E%9F"><span class="nav-text">3. 插件 -&gt; ob 典型花指令还原</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="nav-text">六、条件与逻辑表达式相关插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B5%8C%E5%A5%97%E5%9C%A8%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">1. 嵌套在语句中的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC-if-%E8%AF%AD%E5%8F%A5"><span class="nav-text">2. 条件表达式转 if 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%815s%E7%9B%BE%E8%A7%A3%E6%B7%B7%E6%B7%86%E4%B8%93%E9%A2%98"><span class="nav-text">七、5s盾解混淆专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E8%BF%98%E5%8E%9F%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">1. 插件 -&gt; 还原调用表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6%E4%BC%98%E5%8C%96-%E6%8F%92%E4%BB%B61"><span class="nav-text">2. 插件优化 -&gt; 插件1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-object-%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6"><span class="nav-text">3. 插件 -&gt; object 对象合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">4. 插件 -&gt; 深拷贝赋值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-obj-%E5%AF%B9%E8%B1%A1-value-%E5%AE%9E%E7%8E%B0"><span class="nav-text">5. 插件 -&gt; obj 对象 value 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%92%E4%BB%B6-%E5%A4%84%E7%90%86%E5%B9%B3%E5%9D%A6%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-text">6. 插件 -&gt; 处理平坦控制流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81OB%E8%A7%A3%E6%B7%B7%E6%B7%86%E4%B8%93%E9%A2%98"><span class="nav-text">八、OB解混淆专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E4%BB%B6-%E8%BF%98%E5%8E%9F%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="nav-text">1. 插件 -&gt; 还原调用表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8F%92%E4%BB%B6%E6%A8%A1%E7%89%88-%E6%8F%92%E4%BB%B61"><span class="nav-text">2. 插件模版 -&gt; 插件1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E4%BB%B6-object-%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6-1"><span class="nav-text">3. 插件 -&gt; object 对象合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8F%92%E4%BB%B6-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8-1"><span class="nav-text">4. 插件 -&gt; 深拷贝赋值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8F%92%E4%BB%B6-obj-%E5%AF%B9%E8%B1%A1-value-%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">5. 插件 -&gt; obj 对象 value 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%92%E4%BB%B6-%E5%A4%84%E7%90%86%E5%B9%B3%E5%9D%A6%E6%8E%A7%E5%88%B6%E6%B5%81-1"><span class="nav-text">6. 插件 -&gt; 处理平坦控制流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E9%87%8D%E7%82%B9AST%E8%BF%98%E5%8E%9F%E4%B8%93%E9%A2%98"><span class="nav-text">九、重点AST还原专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%A8%A1%E7%89%88-%E5%B8%B8%E7%94%A8-banding-%E5%86%99%E6%B3%95"><span class="nav-text">0. 模版 -&gt; 常用 banding 写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A1%88%E4%BE%8B-%E5%A4%8D%E6%9D%82%E6%8E%A7%E5%88%B6%E6%B5%81%E8%BF%98%E5%8E%9F"><span class="nav-text">1. 案例 -&gt; 复杂控制流还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A1%88%E4%BE%8B%E4%BC%98%E5%8C%96-%E5%A4%8D%E6%9D%82%E6%8E%A7%E5%88%B6%E6%B5%81%E8%BF%98%E5%8E%9F"><span class="nav-text">2. 案例优化 -&gt; 复杂控制流还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A8%A1%E7%89%88-%E9%A2%84%E5%A4%84%E7%90%86%E8%A7%A3%E6%B7%B7%E6%B7%86%E6%A8%A1%E7%89%88"><span class="nav-text">3. 模版 -&gt; 预处理解混淆模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A1%86%E6%9E%B6-%E9%80%9A%E7%94%A8%E7%BA%AF%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F"><span class="nav-text">4. 框架 -&gt; 通用纯函数还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A8%A1%E7%89%88-%E4%B8%93%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F%E6%A8%A1%E7%89%88"><span class="nav-text">5. 模版 -&gt; 专用函数还原模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A1%88%E4%BE%8B-datadome%E8%BF%98%E5%8E%9F"><span class="nav-text">6. 案例 -&gt; datadome还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%A1%88%E4%BE%8B-px3-%E8%BF%98%E5%8E%9F"><span class="nav-text">7. 案例 -&gt; px3 还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%8F%92%E4%BB%B6-px3-%E5%87%BD%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D"><span class="nav-text">8. 插件 -&gt; px3 函数重命名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81Akamai-2-0-%E8%BF%98%E5%8E%9F%E4%B8%93%E9%A2%98"><span class="nav-text">十、Akamai 2.0 还原专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%8A%80%E5%B7%A7-%E8%BF%87-toString-%E6%A3%80%E6%B5%8B"><span class="nav-text">0. 技巧 -&gt; 过 toString 检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%80%9D%E8%B7%AF-%E5%9B%BA%E5%AE%9A%E7%BB%93%E6%9E%9C%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F"><span class="nav-text">1. 思路 -&gt; 固定结果函数还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%80%9D%E8%B7%AF-%E5%81%87%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E5%AE%B9%E8%BF%98%E5%8E%9F"><span class="nav-text">2. 思路 -&gt; 假函数体内容还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%80%9D%E8%B7%AF-%E5%A4%A7%E9%87%8F%E5%AD%97%E9%9D%A2%E9%87%8F%E8%BF%98%E5%8E%9F"><span class="nav-text">3. 思路 -&gt; 大量字面量还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%80%9D%E8%B7%AF-ob-%E5%85%B8%E5%9E%8B%E8%8A%B1%E6%8C%87%E4%BB%A4%E8%BF%98%E5%8E%9F"><span class="nav-text">4. 思路 -&gt; ob 典型花指令还原</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->
<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/toggle-theme.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/code-block.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/libs/anime.min.js"></script>

<!-- local search -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/local-search.js"></script>


<!-- lazyload -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/lazyload.js"></script>


<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/post-helper.js"></script>

        <!-- toc -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/toc.js"></script>
        

        <!-- copyright-info -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/copyright-info.js"></script>
        

        <!-- share -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/post/share.js"></script>
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.2.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




    
        
            
<script class="custom-inject-js" src="/js/run_time.js" data-pjax></script>

        
    
        
            
<script class="custom-inject-js" src="/js/code_click_copy.js" data-pjax></script>

        
    
        
            
<script class="custom-inject-js" src="/js/copyrightpro.js" data-pjax></script>

        
    

</body>
</html>
